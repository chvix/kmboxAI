/* automatically generated by rust-bindgen 0.72.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
#[doc = r" If Bindgen could only determine the size and alignment of a"]
#[doc = r" type, it is represented like this."]
#[derive(PartialEq, Copy, Clone, Debug, Hash)]
#[repr(C)]
pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
    fn default() -> Self {
        Self([<T as Default>::default(); N])
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_ISOCXX11: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_XOPEN_EXTENDED: u32 = 1;
pub const __USE_UNIX98: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __USE_XOPEN2K8XSI: u32 = 1;
pub const __USE_XOPEN2KXSI: u32 = 1;
pub const __USE_LARGEFILE: u32 = 1;
pub const __USE_LARGEFILE64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 1;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 0;
pub const __GLIBC_USE_LIB_EXT2: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const CHAR_WIDTH: u32 = 8;
pub const SCHAR_WIDTH: u32 = 8;
pub const UCHAR_WIDTH: u32 = 8;
pub const SHRT_WIDTH: u32 = 16;
pub const USHRT_WIDTH: u32 = 16;
pub const INT_WIDTH: u32 = 32;
pub const UINT_WIDTH: u32 = 32;
pub const LONG_WIDTH: u32 = 64;
pub const ULONG_WIDTH: u32 = 64;
pub const LLONG_WIDTH: u32 = 64;
pub const ULLONG_WIDTH: u32 = 64;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_FD_SETSIZE: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_QLIMIT: u32 = 1;
pub const _POSIX_HIWAT: u32 = 512;
pub const _POSIX_UIO_MAXIOV: u32 = 16;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _XOPEN_LIM_H: u32 = 1;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const IOV_MAX: u32 = 1024;
pub const NL_ARGMAX: u32 = 4096;
pub const NL_LANGMAX: u32 = 2048;
pub const NZERO: u32 = 20;
pub const WORD_BIT: u32 = 32;
pub const LONG_BIT: u32 = 64;
pub const CV_HAL_ERROR_OK: u32 = 0;
pub const CV_HAL_ERROR_NOT_IMPLEMENTED: u32 = 1;
pub const CV_HAL_ERROR_UNKNOWN: i32 = -1;
pub const _GLIBCXX_CSTDDEF: u32 = 1;
pub const _GLIBCXX_CXX_CONFIG_H: u32 = 1;
pub const _GLIBCXX_RELEASE: u32 = 10;
pub const __GLIBCXX__: u32 = 20230707;
pub const _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY: u32 = 1;
pub const _GLIBCXX_USE_DEPRECATED: u32 = 1;
pub const _GLIBCXX_EXTERN_TEMPLATE: u32 = 1;
pub const _GLIBCXX_USE_DUAL_ABI: u32 = 1;
pub const _GLIBCXX_USE_CXX11_ABI: u32 = 1;
pub const _GLIBCXX_INLINE_VERSION: u32 = 0;
pub const _GLIBCXX_USE_ALLOCATOR_NEW: u32 = 1;
pub const _GLIBCXX_OS_DEFINES: u32 = 1;
pub const __NO_CTYPE: u32 = 1;
pub const _GLIBCXX_CPU_DEFINES: u32 = 1;
pub const _GLIBCXX_FAST_MATH: u32 = 0;
pub const _GLIBCXX_USE_FLOAT128: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_AGGREGATE: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_LAUNDER: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED: u32 = 1;
pub const _GLIBCXX_HAVE_ACOSF: u32 = 1;
pub const _GLIBCXX_HAVE_ACOSL: u32 = 1;
pub const _GLIBCXX_HAVE_ALIGNED_ALLOC: u32 = 1;
pub const _GLIBCXX_HAVE_ARPA_INET_H: u32 = 1;
pub const _GLIBCXX_HAVE_ASINF: u32 = 1;
pub const _GLIBCXX_HAVE_ASINL: u32 = 1;
pub const _GLIBCXX_HAVE_AS_SYMVER_DIRECTIVE: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2F: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2L: u32 = 1;
pub const _GLIBCXX_HAVE_ATANF: u32 = 1;
pub const _GLIBCXX_HAVE_ATANL: u32 = 1;
pub const _GLIBCXX_HAVE_ATOMIC_LOCK_POLICY: u32 = 1;
pub const _GLIBCXX_HAVE_AT_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_CEILF: u32 = 1;
pub const _GLIBCXX_HAVE_CEILL: u32 = 1;
pub const _GLIBCXX_HAVE_COMPLEX_H: u32 = 1;
pub const _GLIBCXX_HAVE_COSF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHL: u32 = 1;
pub const _GLIBCXX_HAVE_COSL: u32 = 1;
pub const _GLIBCXX_HAVE_DIRENT_H: u32 = 1;
pub const _GLIBCXX_HAVE_DLFCN_H: u32 = 1;
pub const _GLIBCXX_HAVE_ENDIAN_H: u32 = 1;
pub const _GLIBCXX_HAVE_EXCEPTION_PTR_SINCE_GCC46: u32 = 1;
pub const _GLIBCXX_HAVE_EXECINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_EXPF: u32 = 1;
pub const _GLIBCXX_HAVE_EXPL: u32 = 1;
pub const _GLIBCXX_HAVE_FABSF: u32 = 1;
pub const _GLIBCXX_HAVE_FABSL: u32 = 1;
pub const _GLIBCXX_HAVE_FCNTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_FENV_H: u32 = 1;
pub const _GLIBCXX_HAVE_FINITE: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEF: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEL: u32 = 1;
pub const _GLIBCXX_HAVE_FLOAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORF: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORL: u32 = 1;
pub const _GLIBCXX_HAVE_FMODF: u32 = 1;
pub const _GLIBCXX_HAVE_FMODL: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPF: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPL: u32 = 1;
pub const _GLIBCXX_HAVE_GETIPINFO: u32 = 1;
pub const _GLIBCXX_HAVE_GETS: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOT: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTF: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTL: u32 = 1;
pub const _GLIBCXX_HAVE_ICONV: u32 = 1;
pub const _GLIBCXX_HAVE_INT64_T: u32 = 1;
pub const _GLIBCXX_HAVE_INT64_T_LONG: u32 = 1;
pub const _GLIBCXX_HAVE_INTTYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFF: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFL: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANF: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANL: u32 = 1;
pub const _GLIBCXX_HAVE_ISWBLANK: u32 = 1;
pub const _GLIBCXX_HAVE_LC_MESSAGES: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPF: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPL: u32 = 1;
pub const _GLIBCXX_HAVE_LIBINTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_AS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_DATA: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_FSIZE: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_RSS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_VMEM: u32 = 0;
pub const _GLIBCXX_HAVE_LINK: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_FUTEX: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_RANDOM_H: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOCALE_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10F: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10L: u32 = 1;
pub const _GLIBCXX_HAVE_LOGF: u32 = 1;
pub const _GLIBCXX_HAVE_LOGL: u32 = 1;
pub const _GLIBCXX_HAVE_MBSTATE_T: u32 = 1;
pub const _GLIBCXX_HAVE_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_MEMORY_H: u32 = 1;
pub const _GLIBCXX_HAVE_MODF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFL: u32 = 1;
pub const _GLIBCXX_HAVE_NETDB_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_IN_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_TCP_H: u32 = 1;
pub const _GLIBCXX_HAVE_POLL: u32 = 1;
pub const _GLIBCXX_HAVE_POLL_H: u32 = 1;
pub const _GLIBCXX_HAVE_POSIX_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_POWF: u32 = 1;
pub const _GLIBCXX_HAVE_POWL: u32 = 1;
pub const _GLIBCXX_HAVE_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_READLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SETENV: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOS: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSF: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSL: u32 = 1;
pub const _GLIBCXX_HAVE_SINF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHL: u32 = 1;
pub const _GLIBCXX_HAVE_SINL: u32 = 1;
pub const _GLIBCXX_HAVE_SOCKATMARK: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTF: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTL: u32 = 1;
pub const _GLIBCXX_HAVE_STDALIGN_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDBOOL_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDINT_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDLIB_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_L: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_R: u32 = 1;
pub const _GLIBCXX_HAVE_STRINGS_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRING_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOF: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOLD: u32 = 1;
pub const _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE: u32 = 1;
pub const _GLIBCXX_HAVE_STRXFRM_L: u32 = 1;
pub const _GLIBCXX_HAVE_SYMLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IOCTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IPC_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_PARAM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_RESOURCE_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SDT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SEM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SOCKET_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STATVFS_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SYSINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_UIO_H: u32 = 1;
pub const _GLIBCXX_HAVE_S_ISREG: u32 = 1;
pub const _GLIBCXX_HAVE_TANF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHL: u32 = 1;
pub const _GLIBCXX_HAVE_TANL: u32 = 1;
pub const _GLIBCXX_HAVE_TGMATH_H: u32 = 1;
pub const _GLIBCXX_HAVE_TIMESPEC_GET: u32 = 1;
pub const _GLIBCXX_HAVE_TLS: u32 = 1;
pub const _GLIBCXX_HAVE_TRUNCATE: u32 = 1;
pub const _GLIBCXX_HAVE_UCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_UNISTD_H: u32 = 1;
pub const _GLIBCXX_HAVE_UTIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_VFWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VSWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_WCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_WCSTOF: u32 = 1;
pub const _GLIBCXX_HAVE_WCTYPE_H: u32 = 1;
pub const _GLIBCXX_HAVE_WRITEV: u32 = 1;
pub const _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL: u32 = 1;
pub const _GLIBCXX_LT_OBJDIR: &[u8; 7] = b".libs/\0";
pub const _GLIBCXX_PACKAGE_BUGREPORT: &[u8; 1] = b"\0";
pub const _GLIBCXX_PACKAGE_NAME: &[u8; 15] = b"package-unused\0";
pub const _GLIBCXX_PACKAGE_STRING: &[u8; 30] = b"package-unused version-unused\0";
pub const _GLIBCXX_PACKAGE_TARNAME: &[u8; 10] = b"libstdc++\0";
pub const _GLIBCXX_PACKAGE_URL: &[u8; 1] = b"\0";
pub const _GLIBCXX_PACKAGE__GLIBCXX_VERSION: &[u8; 15] = b"version-unused\0";
pub const _GLIBCXX_STDC_HEADERS: u32 = 1;
pub const _GLIBCXX_DARWIN_USE_64_BIT_INODE: u32 = 1;
pub const _GLIBCXX11_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX11_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX11_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX98_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX98_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX98_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX_ATOMIC_BUILTINS: u32 = 1;
pub const _GLIBCXX_FULLY_DYNAMIC_STRING: u32 = 0;
pub const _GLIBCXX_HAS_GTHREADS: u32 = 1;
pub const _GLIBCXX_HOSTED: u32 = 1;
pub const _GLIBCXX_RES_LIMITS: u32 = 1;
pub const _GLIBCXX_STDIO_EOF: i32 = -1;
pub const _GLIBCXX_STDIO_SEEK_CUR: u32 = 1;
pub const _GLIBCXX_STDIO_SEEK_END: u32 = 2;
pub const _GLIBCXX_SYMVER: u32 = 1;
pub const _GLIBCXX_SYMVER_GNU: u32 = 1;
pub const _GLIBCXX_USE_C11_UCHAR_CXX11: u32 = 1;
pub const _GLIBCXX_USE_C99: u32 = 1;
pub const _GLIBCXX_USE_C99_COMPLEX_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_CTYPE_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_FENV_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_MATH_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_STDINT_TR1: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_MONOTONIC: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_REALTIME: u32 = 1;
pub const _GLIBCXX_USE_DECIMAL_FLOAT: u32 = 1;
pub const _GLIBCXX_USE_DEV_RANDOM: u32 = 1;
pub const _GLIBCXX_USE_FCHMOD: u32 = 1;
pub const _GLIBCXX_USE_FCHMODAT: u32 = 1;
pub const _GLIBCXX_USE_GETTIMEOFDAY: u32 = 1;
pub const _GLIBCXX_USE_GET_NPROCS: u32 = 1;
pub const _GLIBCXX_USE_INT128: u32 = 1;
pub const _GLIBCXX_USE_LFS: u32 = 1;
pub const _GLIBCXX_USE_LONG_LONG: u32 = 1;
pub const _GLIBCXX_USE_LSTAT: u32 = 1;
pub const _GLIBCXX_USE_NANOSLEEP: u32 = 1;
pub const _GLIBCXX_USE_NLS: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_MUTEX_CLOCKLOCK: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_RWLOCK_CLOCKLOCK: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_RWLOCK_T: u32 = 1;
pub const _GLIBCXX_USE_RANDOM_TR1: u32 = 1;
pub const _GLIBCXX_USE_REALPATH: u32 = 1;
pub const _GLIBCXX_USE_SCHED_YIELD: u32 = 1;
pub const _GLIBCXX_USE_SC_NPROCESSORS_ONLN: u32 = 1;
pub const _GLIBCXX_USE_SENDFILE: u32 = 1;
pub const _GLIBCXX_USE_ST_MTIM: u32 = 1;
pub const _GLIBCXX_USE_TMPNAM: u32 = 1;
pub const _GLIBCXX_USE_UTIME: u32 = 1;
pub const _GLIBCXX_USE_UTIMENSAT: u32 = 1;
pub const _GLIBCXX_USE_WCHAR_T: u32 = 1;
pub const _GLIBCXX_VERBOSE: u32 = 1;
pub const _GLIBCXX_X86_RDRAND: u32 = 1;
pub const _GLIBCXX_X86_RDSEED: u32 = 1;
pub const _GTHREAD_USE_MUTEX_TIMEDLOCK: u32 = 1;
pub const _GLIBCXX_CSTDINT: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INT8_WIDTH: u32 = 8;
pub const UINT8_WIDTH: u32 = 8;
pub const INT16_WIDTH: u32 = 16;
pub const UINT16_WIDTH: u32 = 16;
pub const INT32_WIDTH: u32 = 32;
pub const UINT32_WIDTH: u32 = 32;
pub const INT64_WIDTH: u32 = 64;
pub const UINT64_WIDTH: u32 = 64;
pub const INT_LEAST8_WIDTH: u32 = 8;
pub const UINT_LEAST8_WIDTH: u32 = 8;
pub const INT_LEAST16_WIDTH: u32 = 16;
pub const UINT_LEAST16_WIDTH: u32 = 16;
pub const INT_LEAST32_WIDTH: u32 = 32;
pub const UINT_LEAST32_WIDTH: u32 = 32;
pub const INT_LEAST64_WIDTH: u32 = 64;
pub const UINT_LEAST64_WIDTH: u32 = 64;
pub const INT_FAST8_WIDTH: u32 = 8;
pub const UINT_FAST8_WIDTH: u32 = 8;
pub const INT_FAST16_WIDTH: u32 = 64;
pub const UINT_FAST16_WIDTH: u32 = 64;
pub const INT_FAST32_WIDTH: u32 = 64;
pub const UINT_FAST32_WIDTH: u32 = 64;
pub const INT_FAST64_WIDTH: u32 = 64;
pub const UINT_FAST64_WIDTH: u32 = 64;
pub const INTPTR_WIDTH: u32 = 64;
pub const UINTPTR_WIDTH: u32 = 64;
pub const INTMAX_WIDTH: u32 = 64;
pub const UINTMAX_WIDTH: u32 = 64;
pub const PTRDIFF_WIDTH: u32 = 64;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const SIZE_WIDTH: u32 = 64;
pub const WCHAR_WIDTH: u32 = 32;
pub const WINT_WIDTH: u32 = 32;
pub const CV_CN_MAX: u32 = 512;
pub const CV_CN_SHIFT: u32 = 3;
pub const CV_DEPTH_MAX: u32 = 8;
pub const CV_8U: u32 = 0;
pub const CV_8S: u32 = 1;
pub const CV_16U: u32 = 2;
pub const CV_16S: u32 = 3;
pub const CV_32S: u32 = 4;
pub const CV_32F: u32 = 5;
pub const CV_64F: u32 = 6;
pub const CV_16F: u32 = 7;
pub const CV_MAT_DEPTH_MASK: u32 = 7;
pub const CV_HAL_CMP_EQ: u32 = 0;
pub const CV_HAL_CMP_GT: u32 = 1;
pub const CV_HAL_CMP_GE: u32 = 2;
pub const CV_HAL_CMP_LT: u32 = 3;
pub const CV_HAL_CMP_LE: u32 = 4;
pub const CV_HAL_CMP_NE: u32 = 5;
pub const CV_HAL_BORDER_CONSTANT: u32 = 0;
pub const CV_HAL_BORDER_REPLICATE: u32 = 1;
pub const CV_HAL_BORDER_REFLECT: u32 = 2;
pub const CV_HAL_BORDER_WRAP: u32 = 3;
pub const CV_HAL_BORDER_REFLECT_101: u32 = 4;
pub const CV_HAL_BORDER_TRANSPARENT: u32 = 5;
pub const CV_HAL_BORDER_ISOLATED: u32 = 16;
pub const CV_HAL_DFT_INVERSE: u32 = 1;
pub const CV_HAL_DFT_SCALE: u32 = 2;
pub const CV_HAL_DFT_ROWS: u32 = 4;
pub const CV_HAL_DFT_COMPLEX_OUTPUT: u32 = 16;
pub const CV_HAL_DFT_REAL_OUTPUT: u32 = 32;
pub const CV_HAL_DFT_TWO_STAGE: u32 = 64;
pub const CV_HAL_DFT_STAGE_COLS: u32 = 128;
pub const CV_HAL_DFT_IS_CONTINUOUS: u32 = 512;
pub const CV_HAL_DFT_IS_INPLACE: u32 = 1024;
pub const CV_HAL_SVD_NO_UV: u32 = 1;
pub const CV_HAL_SVD_SHORT_UV: u32 = 2;
pub const CV_HAL_SVD_MODIFY_A: u32 = 4;
pub const CV_HAL_SVD_FULL_UV: u32 = 8;
pub const CV_HAL_GEMM_1_T: u32 = 1;
pub const CV_HAL_GEMM_2_T: u32 = 2;
pub const CV_HAL_GEMM_3_T: u32 = 4;
pub const CV_ENABLE_UNROLLED: u32 = 1;
pub const CV_CPU_NONE: u32 = 0;
pub const CV_CPU_MMX: u32 = 1;
pub const CV_CPU_SSE: u32 = 2;
pub const CV_CPU_SSE2: u32 = 3;
pub const CV_CPU_SSE3: u32 = 4;
pub const CV_CPU_SSSE3: u32 = 5;
pub const CV_CPU_SSE4_1: u32 = 6;
pub const CV_CPU_SSE4_2: u32 = 7;
pub const CV_CPU_POPCNT: u32 = 8;
pub const CV_CPU_FP16: u32 = 9;
pub const CV_CPU_AVX: u32 = 10;
pub const CV_CPU_AVX2: u32 = 11;
pub const CV_CPU_FMA3: u32 = 12;
pub const CV_CPU_AVX_512F: u32 = 13;
pub const CV_CPU_AVX_512BW: u32 = 14;
pub const CV_CPU_AVX_512CD: u32 = 15;
pub const CV_CPU_AVX_512DQ: u32 = 16;
pub const CV_CPU_AVX_512ER: u32 = 17;
pub const CV_CPU_AVX_512IFMA512: u32 = 18;
pub const CV_CPU_AVX_512IFMA: u32 = 18;
pub const CV_CPU_AVX_512PF: u32 = 19;
pub const CV_CPU_AVX_512VBMI: u32 = 20;
pub const CV_CPU_AVX_512VL: u32 = 21;
pub const CV_CPU_AVX_512VBMI2: u32 = 22;
pub const CV_CPU_AVX_512VNNI: u32 = 23;
pub const CV_CPU_AVX_512BITALG: u32 = 24;
pub const CV_CPU_AVX_512VPOPCNTDQ: u32 = 25;
pub const CV_CPU_AVX_5124VNNIW: u32 = 26;
pub const CV_CPU_AVX_5124FMAPS: u32 = 27;
pub const CV_CPU_NEON: u32 = 100;
pub const CV_CPU_MSA: u32 = 150;
pub const CV_CPU_VSX: u32 = 200;
pub const CV_CPU_VSX3: u32 = 201;
pub const CV_CPU_AVX512_SKX: u32 = 256;
pub const CV_CPU_AVX512_COMMON: u32 = 257;
pub const CV_CPU_AVX512_KNL: u32 = 258;
pub const CV_CPU_AVX512_KNM: u32 = 259;
pub const CV_CPU_AVX512_CNL: u32 = 260;
pub const CV_CPU_AVX512_CLX: u32 = 261;
pub const CV_CPU_AVX512_ICL: u32 = 262;
pub const CV_HARDWARE_MAX_FEATURE: u32 = 512;
pub const _GLIBCXX_STDLIB_H: u32 = 1;
pub const _GLIBCXX_CSTDLIB: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &[u8; 6] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const CV_MMX: u32 = 1;
pub const CV_SSE: u32 = 1;
pub const CV_SSE2: u32 = 1;
pub const CV_SSE3: u32 = 0;
pub const CV_SSSE3: u32 = 0;
pub const CV_SSE4_1: u32 = 0;
pub const CV_SSE4_2: u32 = 0;
pub const CV_POPCNT: u32 = 0;
pub const CV_AVX: u32 = 0;
pub const CV_FP16: u32 = 0;
pub const CV_AVX2: u32 = 0;
pub const CV_FMA3: u32 = 0;
pub const CV_AVX_512F: u32 = 0;
pub const CV_AVX_512BW: u32 = 0;
pub const CV_AVX_512CD: u32 = 0;
pub const CV_AVX_512DQ: u32 = 0;
pub const CV_AVX_512ER: u32 = 0;
pub const CV_AVX_512IFMA: u32 = 0;
pub const CV_AVX_512IFMA512: u32 = 0;
pub const CV_AVX_512PF: u32 = 0;
pub const CV_AVX_512VBMI: u32 = 0;
pub const CV_AVX_512VL: u32 = 0;
pub const CV_AVX_5124FMAPS: u32 = 0;
pub const CV_AVX_5124VNNIW: u32 = 0;
pub const CV_AVX_512VPOPCNTDQ: u32 = 0;
pub const CV_AVX_512VNNI: u32 = 0;
pub const CV_AVX_512VBMI2: u32 = 0;
pub const CV_AVX_512BITALG: u32 = 0;
pub const CV_AVX512_COMMON: u32 = 0;
pub const CV_AVX512_KNL: u32 = 0;
pub const CV_AVX512_KNM: u32 = 0;
pub const CV_AVX512_SKX: u32 = 0;
pub const CV_AVX512_CNL: u32 = 0;
pub const CV_AVX512_CLX: u32 = 0;
pub const CV_AVX512_ICL: u32 = 0;
pub const CV_NEON: u32 = 0;
pub const CV_VSX: u32 = 0;
pub const CV_VSX3: u32 = 0;
pub const CV_MSA: u32 = 0;
pub const CV_WASM_SIMD: u32 = 0;
pub const CV_PI: f64 = 3.141592653589793;
pub const CV_2PI: f64 = 6.283185307179586;
pub const CV_LOG2: f64 = 0.6931471805599453;
pub const CV_FP16_TYPE: u32 = 0;
pub const OPENCV_ABI_COMPATIBILITY: u32 = 400;
pub const CV_MAT_CN_MASK: u32 = 4088;
pub const CV_MAT_TYPE_MASK: u32 = 4095;
pub const CV_MAT_CONT_FLAG_SHIFT: u32 = 14;
pub const CV_MAT_CONT_FLAG: u32 = 16384;
pub const CV_SUBMAT_FLAG_SHIFT: u32 = 15;
pub const CV_SUBMAT_FLAG: u32 = 32768;
pub const CV_CXX11: u32 = 1;
pub const CV_CXX_MOVE_SEMANTICS: u32 = 1;
pub const CV_CXX_STD_ARRAY: u32 = 1;
pub const _GLIBCXX_ARRAY: u32 = 1;
pub const _GLIBCXX_UTILITY: u32 = 1;
pub const _STL_RELOPS_H: u32 = 1;
pub const _STL_PAIR_H: u32 = 1;
pub const _MOVE_H: u32 = 1;
pub const _GLIBCXX_TYPE_TRAITS: u32 = 1;
pub const __cpp_lib_is_null_pointer: u32 = 201309;
pub const __cpp_lib_result_of_sfinae: u32 = 201210;
pub const _GLIBCXX_USE_MAKE_INTEGER_SEQ: u32 = 1;
pub const _FUNCTEXCEPT_H: u32 = 1;
pub const _EXCEPTION_DEFINES_H: u32 = 1;
pub const _STL_ALGOBASE_H: u32 = 1;
pub const _CPP_TYPE_TRAITS_H: u32 = 1;
pub const _EXT_TYPE_TRAITS: u32 = 1;
pub const _EXT_NUMERIC_TRAITS: u32 = 1;
pub const _STL_ITERATOR_BASE_TYPES_H: u32 = 1;
pub const _STL_ITERATOR_BASE_FUNCS_H: u32 = 1;
pub const _CONCEPT_CHECK_H: u32 = 1;
pub const _GLIBCXX_DEBUG_ASSERTIONS_H: u32 = 1;
pub const _STL_ITERATOR_H: u32 = 1;
pub const _PTR_TRAITS_H: u32 = 1;
pub const _GLIBCXX_DEBUG_MACRO_SWITCH_H: u32 = 1;
pub const _GLIBCXX_PREDEFINED_OPS_H: u32 = 1;
pub const _GLIBCXX_RANGE_ACCESS_H: u32 = 1;
pub const _ITERATOR_CONCEPTS_H: u32 = 1;
pub const _GLIBCXX_CONCEPTS: u32 = 1;
pub const _RANGE_CMP_H: u32 = 1;
pub const CV_VERSION_MAJOR: u32 = 4;
pub const CV_VERSION_MINOR: u32 = 2;
pub const CV_VERSION_REVISION: u32 = 0;
pub const CV_VERSION_STATUS: &[u8; 1] = b"\0";
pub const CV_MAJOR_VERSION: u32 = 4;
pub const CV_MINOR_VERSION: u32 = 2;
pub const CV_SUBMINOR_VERSION: u32 = 0;
pub const _GLIBCXX_CLIMITS: u32 = 1;
pub const _GLIBCXX_ALGORITHM: u32 = 1;
pub const _STL_ALGO_H: u32 = 1;
pub const _GLIBCXX_ALGORITHMFWD_H: u32 = 1;
pub const _STL_HEAP_H: u32 = 1;
pub const _STL_TEMPBUF_H: u32 = 1;
pub const _STL_CONSTRUCT_H: u32 = 1;
pub const __EXCEPTION_H: u32 = 1;
pub const _CXXABI_INIT_EXCEPTION_H: u32 = 1;
pub const _GLIBCXX_HAVE_CDTOR_CALLABI: u32 = 0;
pub const _HASH_BYTES_H: u32 = 1;
pub const __GXX_MERGED_TYPEINFO_NAMES: u32 = 0;
pub const __GXX_TYPEINFO_EQUALITY_INLINE: u32 = 1;
pub const _GLIBCXX_NESTED_EXCEPTION_H: u32 = 1;
pub const _GLIBCXX_NUMERIC_LIMITS: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _GLIBCXX_CSTRING: u32 = 1;
pub const _CTYPE_H: u32 = 1;
pub const _GLIBCXX_CCTYPE: u32 = 1;
pub const _GLIBCXX_STRING: u32 = 1;
pub const _STRINGFWD_H: u32 = 1;
pub const _MEMORYFWD_H: u32 = 1;
pub const _CHAR_TRAITS_H: u32 = 1;
pub const _GLIBCXX_POSTYPES_H: u32 = 1;
pub const _WCHAR_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const __wint_t_defined: u32 = 1;
pub const _WINT_T: u32 = 1;
pub const __mbstate_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const WEOF: u32 = 4294967295;
pub const _GLIBCXX_CWCHAR: u32 = 1;
pub const _ALLOCATOR_H: u32 = 1;
pub const _GLIBCXX_CXX_ALLOCATOR_H: u32 = 1;
pub const _NEW_ALLOCATOR_H: u32 = 1;
pub const __cpp_lib_incomplete_container_elements: u32 = 201505;
pub const _LOCALE_FWD_H: u32 = 1;
pub const _GLIBCXX_CXX_LOCALE_H: u32 = 1;
pub const _LOCALE_H: u32 = 1;
pub const _BITS_LOCALE_H: u32 = 1;
pub const __LC_CTYPE: u32 = 0;
pub const __LC_NUMERIC: u32 = 1;
pub const __LC_TIME: u32 = 2;
pub const __LC_COLLATE: u32 = 3;
pub const __LC_MONETARY: u32 = 4;
pub const __LC_MESSAGES: u32 = 5;
pub const __LC_ALL: u32 = 6;
pub const __LC_PAPER: u32 = 7;
pub const __LC_NAME: u32 = 8;
pub const __LC_ADDRESS: u32 = 9;
pub const __LC_TELEPHONE: u32 = 10;
pub const __LC_MEASUREMENT: u32 = 11;
pub const __LC_IDENTIFICATION: u32 = 12;
pub const LC_CTYPE: u32 = 0;
pub const LC_NUMERIC: u32 = 1;
pub const LC_TIME: u32 = 2;
pub const LC_COLLATE: u32 = 3;
pub const LC_MONETARY: u32 = 4;
pub const LC_MESSAGES: u32 = 5;
pub const LC_ALL: u32 = 6;
pub const LC_PAPER: u32 = 7;
pub const LC_NAME: u32 = 8;
pub const LC_ADDRESS: u32 = 9;
pub const LC_TELEPHONE: u32 = 10;
pub const LC_MEASUREMENT: u32 = 11;
pub const LC_IDENTIFICATION: u32 = 12;
pub const LC_CTYPE_MASK: u32 = 1;
pub const LC_NUMERIC_MASK: u32 = 2;
pub const LC_TIME_MASK: u32 = 4;
pub const LC_COLLATE_MASK: u32 = 8;
pub const LC_MONETARY_MASK: u32 = 16;
pub const LC_MESSAGES_MASK: u32 = 32;
pub const LC_PAPER_MASK: u32 = 128;
pub const LC_NAME_MASK: u32 = 256;
pub const LC_ADDRESS_MASK: u32 = 512;
pub const LC_TELEPHONE_MASK: u32 = 1024;
pub const LC_MEASUREMENT_MASK: u32 = 2048;
pub const LC_IDENTIFICATION_MASK: u32 = 4096;
pub const LC_ALL_MASK: u32 = 8127;
pub const _GLIBCXX_CLOCALE: u32 = 1;
pub const _GLIBCXX_C_LOCALE_GNU: u32 = 1;
pub const _GLIBCXX_NUM_CATEGORIES: u32 = 6;
pub const _GLIBCXX_IOSFWD: u32 = 1;
pub const _OSTREAM_INSERT_H: u32 = 1;
pub const _CXXABI_FORCED_H: u32 = 1;
pub const _STL_FUNCTION_H: u32 = 1;
pub const _BACKWARD_BINDERS_H: u32 = 1;
pub const _BASIC_STRING_H: u32 = 1;
pub const _GLIBCXX_ATOMICITY_H: u32 = 1;
pub const _GLIBCXX_GTHREAD_USE_WEAK: u32 = 1;
pub const __GTHREADS: u32 = 1;
pub const __GTHREADS_CXX0X: u32 = 1;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const SCHED_BATCH: u32 = 3;
pub const SCHED_ISO: u32 = 4;
pub const SCHED_IDLE: u32 = 5;
pub const SCHED_DEADLINE: u32 = 6;
pub const SCHED_RESET_ON_FORK: u32 = 1073741824;
pub const CSIGNAL: u32 = 255;
pub const CLONE_VM: u32 = 256;
pub const CLONE_FS: u32 = 512;
pub const CLONE_FILES: u32 = 1024;
pub const CLONE_SIGHAND: u32 = 2048;
pub const CLONE_PIDFD: u32 = 4096;
pub const CLONE_PTRACE: u32 = 8192;
pub const CLONE_VFORK: u32 = 16384;
pub const CLONE_PARENT: u32 = 32768;
pub const CLONE_THREAD: u32 = 65536;
pub const CLONE_NEWNS: u32 = 131072;
pub const CLONE_SYSVSEM: u32 = 262144;
pub const CLONE_SETTLS: u32 = 524288;
pub const CLONE_PARENT_SETTID: u32 = 1048576;
pub const CLONE_CHILD_CLEARTID: u32 = 2097152;
pub const CLONE_DETACHED: u32 = 4194304;
pub const CLONE_UNTRACED: u32 = 8388608;
pub const CLONE_CHILD_SETTID: u32 = 16777216;
pub const CLONE_NEWCGROUP: u32 = 33554432;
pub const CLONE_NEWUTS: u32 = 67108864;
pub const CLONE_NEWIPC: u32 = 134217728;
pub const CLONE_NEWUSER: u32 = 268435456;
pub const CLONE_NEWPID: u32 = 536870912;
pub const CLONE_NEWNET: u32 = 1073741824;
pub const CLONE_IO: u32 = 2147483648;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const _BITS_TIMEX_H: u32 = 1;
pub const ADJ_OFFSET: u32 = 1;
pub const ADJ_FREQUENCY: u32 = 2;
pub const ADJ_MAXERROR: u32 = 4;
pub const ADJ_ESTERROR: u32 = 8;
pub const ADJ_STATUS: u32 = 16;
pub const ADJ_TIMECONST: u32 = 32;
pub const ADJ_TAI: u32 = 128;
pub const ADJ_SETOFFSET: u32 = 256;
pub const ADJ_MICRO: u32 = 4096;
pub const ADJ_NANO: u32 = 8192;
pub const ADJ_TICK: u32 = 16384;
pub const ADJ_OFFSET_SINGLESHOT: u32 = 32769;
pub const ADJ_OFFSET_SS_READ: u32 = 40961;
pub const MOD_OFFSET: u32 = 1;
pub const MOD_FREQUENCY: u32 = 2;
pub const MOD_MAXERROR: u32 = 4;
pub const MOD_ESTERROR: u32 = 8;
pub const MOD_STATUS: u32 = 16;
pub const MOD_TIMECONST: u32 = 32;
pub const MOD_CLKB: u32 = 16384;
pub const MOD_CLKA: u32 = 32769;
pub const MOD_TAI: u32 = 128;
pub const MOD_MICRO: u32 = 4096;
pub const MOD_NANO: u32 = 8192;
pub const STA_PLL: u32 = 1;
pub const STA_PPSFREQ: u32 = 2;
pub const STA_PPSTIME: u32 = 4;
pub const STA_FLL: u32 = 8;
pub const STA_INS: u32 = 16;
pub const STA_DEL: u32 = 32;
pub const STA_UNSYNC: u32 = 64;
pub const STA_FREQHOLD: u32 = 128;
pub const STA_PPSSIGNAL: u32 = 256;
pub const STA_PPSJITTER: u32 = 512;
pub const STA_PPSWANDER: u32 = 1024;
pub const STA_PPSERROR: u32 = 2048;
pub const STA_CLOCKERR: u32 = 4096;
pub const STA_NANO: u32 = 8192;
pub const STA_MODE: u32 = 16384;
pub const STA_CLK: u32 = 32768;
pub const STA_RONLY: u32 = 65280;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const __GTHREAD_HAS_COND: u32 = 1;
pub const __GTHREAD_ONCE_INIT: u32 = 0;
pub const _GLIBCXX_ATOMIC_WORD_H: u32 = 1;
pub const _EXT_ALLOC_TRAITS_H: u32 = 1;
pub const _ALLOC_TRAITS_H: u32 = 1;
pub const __cpp_lib_allocator_traits_is_always_equal: u32 = 201411;
pub const _STRING_CONVERSIONS_H: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_DATA: u32 = 3;
pub const SEEK_HOLE: u32 = 4;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const L_cuserid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const RENAME_NOREPLACE: u32 = 1;
pub const RENAME_EXCHANGE: u32 = 2;
pub const RENAME_WHITEOUT: u32 = 4;
pub const _GLIBCXX_CSTDIO: u32 = 1;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const __error_t_defined: u32 = 1;
pub const _GLIBCXX_CERRNO: u32 = 1;
pub const _GLIBCXX_CHARCONV_H: u32 = 1;
pub const _FUNCTIONAL_HASH_H: u32 = 1;
pub const _BASIC_STRING_TCC: u32 = 1;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __FP_LONG_MAX: u64 = 9223372036854775807;
pub const FP_LLOGB0: i64 = -9223372036854775808;
pub const FP_LLOGBNAN: i64 = -9223372036854775808;
pub const FP_INT_UPWARD: u32 = 0;
pub const FP_INT_DOWNWARD: u32 = 1;
pub const FP_INT_TOWARDZERO: u32 = 2;
pub const FP_INT_TONEARESTFROMZERO: u32 = 3;
pub const FP_INT_TONEAREST: u32 = 4;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const M_El: f64 = 2.718281828459045;
pub const M_LOG2El: f64 = 1.4426950408889634;
pub const M_LOG10El: f64 = 0.4342944819032518;
pub const M_LN2l: f64 = 0.6931471805599453;
pub const M_LN10l: f64 = 2.302585092994046;
pub const M_PIl: f64 = 3.141592653589793;
pub const M_PI_2l: f64 = 1.5707963267948966;
pub const M_PI_4l: f64 = 0.7853981633974483;
pub const M_1_PIl: f64 = 0.3183098861837907;
pub const M_2_PIl: f64 = 0.6366197723675814;
pub const M_2_SQRTPIl: f64 = 1.1283791670955126;
pub const M_SQRT2l: f64 = 1.4142135623730951;
pub const M_SQRT1_2l: f64 = 0.7071067811865476;
pub const _GLIBCXX_CMATH: u32 = 1;
pub const _GLIBCXX_MEMORY: u32 = 1;
pub const _STL_UNINITIALIZED_H: u32 = 1;
pub const _STL_RAW_STORAGE_ITERATOR_H: u32 = 1;
pub const _RANGES_UNINITIALIZED_H: u32 = 1;
pub const _CONCURRENCE_H: u32 = 1;
pub const _USES_ALLOCATOR_H: u32 = 1;
pub const _UNIQUE_PTR_H: u32 = 1;
pub const _GLIBCXX_TUPLE: u32 = 1;
pub const _GLIBCXX_INVOKE_H: u32 = 1;
pub const _SHARED_PTR_H: u32 = 1;
pub const _SHARED_PTR_BASE_H: u32 = 1;
pub const _ALLOCATED_PTR_H: u32 = 1;
pub const _GLIBCXX_REFWRAP_H: u32 = 1;
pub const _ALIGNED_BUFFER_H: u32 = 1;
pub const __cpp_lib_shared_ptr_arrays: u32 = 201611;
pub const _SHARED_PTR_ATOMIC_H: u32 = 1;
pub const _GLIBCXX_ATOMIC_BASE_H: u32 = 1;
pub const _GLIBCXX_ATOMIC_LOCK_FREE_H: u32 = 1;
pub const _BACKWARD_AUTO_PTR_H: u32 = 1;
pub const _ASSERT_H: u32 = 1;
pub const OPENCV_USE_FASTMATH_BUILTINS: u32 = 1;
pub const _GLIBCXX_CFLOAT: u32 = 1;
pub const _GLIBCXX_VECTOR: u32 = 1;
pub const _STL_VECTOR_H: u32 = 1;
pub const _STL_BVECTOR_H: u32 = 1;
pub const _VECTOR_TCC: u32 = 1;
pub const _GLIBCXX_COMPLEX: u32 = 1;
pub const _GLIBCXX_SSTREAM: u32 = 1;
pub const _GLIBCXX_ISTREAM: u32 = 1;
pub const _GLIBCXX_IOS: u32 = 1;
pub const _IOS_BASE_H: u32 = 1;
pub const _LOCALE_CLASSES_H: u32 = 1;
pub const _LOCALE_CLASSES_TCC: u32 = 1;
pub const _GLIBCXX_SYSTEM_ERROR: u32 = 1;
pub const _GLIBCXX_ERROR_CONSTANTS: u32 = 1;
pub const _GLIBCXX_STDEXCEPT: u32 = 1;
pub const _GLIBXX_STREAMBUF: u32 = 1;
pub const _STREAMBUF_TCC: u32 = 1;
pub const _BASIC_IOS_H: u32 = 1;
pub const _LOCALE_FACETS_H: u32 = 1;
pub const _WCTYPE_H: u32 = 1;
pub const _BITS_WCTYPE_WCHAR_H: u32 = 1;
pub const _GLIBCXX_CWCTYPE: u32 = 1;
pub const _STREAMBUF_ITERATOR_H: u32 = 1;
pub const _GLIBCXX_NUM_FACETS: u32 = 28;
pub const _GLIBCXX_NUM_CXX11_FACETS: u32 = 16;
pub const _GLIBCXX_NUM_UNICODE_FACETS: u32 = 2;
pub const _LOCALE_FACETS_TCC: u32 = 1;
pub const _BASIC_IOS_TCC: u32 = 1;
pub const _GLIBCXX_OSTREAM: u32 = 1;
pub const _OSTREAM_TCC: u32 = 1;
pub const _ISTREAM_TCC: u32 = 1;
pub const _SSTREAM_TCC: u32 = 1;
pub const _GLIBCXX_FUNCTIONAL: u32 = 1;
pub const _GLIBCXX_STD_FUNCTION_H: u32 = 1;
pub const _GLIBCXX_MUTEX: u32 = 1;
pub const _GLIBCXX_CHRONO: u32 = 1;
pub const _GLIBCXX_RATIO: u32 = 1;
pub const _GLIBCXX_CTIME: u32 = 1;
pub const _GLIBCXX_PARSE_NUMBERS_H: u32 = 1;
pub const _GLIBCXX_MUTEX_H: u32 = 1;
pub const _GLIBCXX_UNIQUE_LOCK_H: u32 = 1;
pub const FLANN_VERSION_: &[u8; 7] = b"1.6.10\0";
pub const OPENCV_DNN_API_VERSION: u32 = 20191202;
pub const _GLIBCXX_MAP: u32 = 1;
pub const _STL_TREE_H: u32 = 1;
pub const _STL_MAP_H: u32 = 1;
pub const _STL_MULTIMAP_H: u32 = 1;
pub const _GLIBCXX_ERASE_IF_H: u32 = 1;
pub const CV_DNN_BACKEND_INFERENCE_ENGINE_NN_BUILDER_API: &[u8; 11] = b"NN_BUILDER\0";
pub const CV_DNN_BACKEND_INFERENCE_ENGINE_NGRAPH: &[u8; 7] = b"NGRAPH\0";
pub const CV_DNN_INFERENCE_ENGINE_VPU_TYPE_UNSPECIFIED: &[u8; 1] = b"\0";
pub const CV_DNN_INFERENCE_ENGINE_VPU_TYPE_MYRIAD_2: &[u8; 8] = b"Myriad2\0";
pub const CV_DNN_INFERENCE_ENGINE_VPU_TYPE_MYRIAD_X: &[u8; 8] = b"MyriadX\0";
pub const _GLIBCXX_IOSTREAM: u32 = 1;
pub const _GLIBCXX_SET: u32 = 1;
pub const _STL_SET_H: u32 = 1;
pub const _STL_MULTISET_H: u32 = 1;
pub const FLANN_SIGNATURE_: &[u8; 12] = b"FLANN_INDEX\0";
pub const FLANN_USE_BOOST: u32 = 0;
pub const _GLIBCXX_IOMANIP: u32 = 1;
pub const _GLIBCXX_LOCALE: u32 = 1;
pub const _LOCALE_FACETS_NONIO_H: u32 = 1;
pub const _LIBINTL_H: u32 = 1;
pub const __USE_GNU_GETTEXT: u32 = 1;
pub const _CODECVT_H: u32 = 1;
pub const _LOCALE_FACETS_NONIO_TCC: u32 = 1;
pub const _LOCALE_CONV_H: u32 = 1;
pub const USE_UNORDERED_MAP: u32 = 1;
pub const _GLIBCXX_UNORDERED_MAP: u32 = 1;
pub const _HASHTABLE_H: u32 = 1;
pub const _HASHTABLE_POLICY_H: u32 = 1;
pub const _ENABLE_SPECIAL_MEMBERS_H: u32 = 1;
pub const _GLIBCXX_MATH_H: u32 = 1;
pub const _GLIBCXX_LIST: u32 = 1;
pub const _STL_LIST_H: u32 = 1;
pub const _LIST_TCC: u32 = 1;
pub const _GLIBCXX_QUEUE: u32 = 1;
pub const _GLIBCXX_DEQUE: u32 = 1;
pub const _STL_DEQUE_H: u32 = 1;
pub const _GLIBCXX_DEQUE_BUF_SIZE: u32 = 512;
pub const _DEQUE_TCC: u32 = 1;
pub const _STL_QUEUE_H: u32 = 1;
pub const _GLIBCXX_FSTREAM: u32 = 1;
pub const _GLIBCXX_BASIC_FILE_STDIO_H: u32 = 1;
pub const _GLIBCXX_CXX_IO_H: u32 = 1;
pub const _FSTREAM_TCC: u32 = 1;
pub const RKNN_FLAG_PRIOR_HIGH: u32 = 0;
pub const RKNN_FLAG_PRIOR_MEDIUM: u32 = 1;
pub const RKNN_FLAG_PRIOR_LOW: u32 = 2;
pub const RKNN_FLAG_ASYNC_MASK: u32 = 4;
pub const RKNN_FLAG_COLLECT_PERF_MASK: u32 = 8;
pub const RKNN_FLAG_MEM_ALLOC_OUTSIDE: u32 = 16;
pub const RKNN_FLAG_SHARE_WEIGHT_MEM: u32 = 32;
pub const RKNN_FLAG_FENCE_IN_OUTSIDE: u32 = 64;
pub const RKNN_FLAG_FENCE_OUT_OUTSIDE: u32 = 128;
pub const RKNN_FLAG_COLLECT_MODEL_INFO_ONLY: u32 = 256;
pub const RKNN_FLAG_INTERNAL_ALLOC_OUTSIDE: u32 = 512;
pub const RKNN_FLAG_EXECUTE_FALLBACK_PRIOR_DEVICE_GPU: u32 = 1024;
pub const RKNN_FLAG_ENABLE_SRAM: u32 = 2048;
pub const RKNN_FLAG_SHARE_SRAM: u32 = 4096;
pub const RKNN_FLAG_DISABLE_PROC_HIGH_PRIORITY: u32 = 8192;
pub const RKNN_FLAG_DISABLE_FLUSH_INPUT_MEM_CACHE: u32 = 16384;
pub const RKNN_FLAG_DISABLE_FLUSH_OUTPUT_MEM_CACHE: u32 = 32768;
pub const RKNN_FLAG_MODEL_BUFFER_ZERO_COPY: u32 = 65536;
pub const RKNN_MEM_FLAG_ALLOC_NO_CONTEXT: u32 = 131072;
pub const RKNN_SUCC: u32 = 0;
pub const RKNN_ERR_FAIL: i32 = -1;
pub const RKNN_ERR_TIMEOUT: i32 = -2;
pub const RKNN_ERR_DEVICE_UNAVAILABLE: i32 = -3;
pub const RKNN_ERR_MALLOC_FAIL: i32 = -4;
pub const RKNN_ERR_PARAM_INVALID: i32 = -5;
pub const RKNN_ERR_MODEL_INVALID: i32 = -6;
pub const RKNN_ERR_CTX_INVALID: i32 = -7;
pub const RKNN_ERR_INPUT_INVALID: i32 = -8;
pub const RKNN_ERR_OUTPUT_INVALID: i32 = -9;
pub const RKNN_ERR_DEVICE_UNMATCH: i32 = -10;
pub const RKNN_ERR_INCOMPATILE_PRE_COMPILE_MODEL: i32 = -11;
pub const RKNN_ERR_INCOMPATILE_OPTIMIZATION_LEVEL_VERSION: i32 = -12;
pub const RKNN_ERR_TARGET_PLATFORM_UNMATCH: i32 = -13;
pub const RKNN_MAX_DIMS: u32 = 16;
pub const RKNN_MAX_NUM_CHANNEL: u32 = 15;
pub const RKNN_MAX_NAME_LEN: u32 = 256;
pub const RKNN_MAX_DYNAMIC_SHAPE_NUM: u32 = 512;
pub const __bool_true_false_are_defined: u32 = 1;
pub const OBJ_NUMB_MAX_SIZE: u32 = 128;
pub type std_nullptr_t = *const ::std::os::raw::c_void;
#[repr(C)]
pub struct std_basic_string<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _M_dataplus: std_basic_string__Alloc_hider,
    pub _M_string_length: std_basic_string_size_type,
    pub __bindgen_anon_1: std_basic_string__bindgen_ty_2<_CharT>,
}
pub type std_basic_string__Char_alloc_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_string__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_value_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_string_allocator_type = std_basic_string__Char_alloc_type;
pub type std_basic_string_size_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_string_difference_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_string_reference = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_string_const_reference = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_string_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_string_const_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_string_iterator = __gnu_cxx___normal_iterator<std_basic_string_pointer>;
pub type std_basic_string_const_iterator =
    __gnu_cxx___normal_iterator<std_basic_string_const_pointer>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string___const_iterator = std_basic_string_const_iterator;
#[repr(C)]
pub struct std_basic_string__Alloc_hider {
    pub _M_p: std_basic_string_pointer,
}
pub const std_basic_string__S_local_capacity: std_basic_string__bindgen_ty_1 = 0;
pub type std_basic_string__bindgen_ty_1 = i32;
#[repr(C)]
pub struct std_basic_string__bindgen_ty_2<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _M_local_buf: __BindgenUnionField<*mut _CharT>,
    pub _M_allocated_capacity: __BindgenUnionField<std_basic_string_size_type>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_collate {
    pub _base: std_locale_facet,
    pub _M_c_locale_collate: std___c_locale,
}
pub type std_collate_char_type<_CharT> = _CharT;
pub type std_collate_string_type = std_basic_string<_CharT>;
#[repr(C)]
#[derive(Debug)]
pub struct std_collate_byname {
    pub _base: std_collate,
}
pub type std_collate_byname_char_type<_CharT> = _CharT;
pub type std_collate_byname_string_type = std_basic_string<_CharT>;
#[repr(C)]
#[derive(Debug)]
pub struct std_numpunct<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _base: std_locale_facet,
    pub _M_data: *mut std_numpunct___cache_type<_CharT>,
}
pub type std_numpunct_char_type<_CharT> = _CharT;
pub type std_numpunct_string_type = std_basic_string<_CharT>;
pub type std_numpunct___cache_type<_CharT> = std___numpunct_cache<_CharT>;
unsafe extern "C" {
    #[link_name = "\u{1}id"]
    pub static mut std_id: std_locale_id;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_numpunct_byname<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _base: std_numpunct<_CharT>,
}
pub type std_numpunct_byname_char_type<_CharT> = _CharT;
pub type std_numpunct_byname_string_type = std_basic_string<_CharT>;
#[repr(C)]
pub struct std_basic_stringbuf<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _base: std_basic_streambuf<_CharT>,
    pub _M_mode: std_ios_base_openmode,
    pub _M_string: std_basic_stringbuf___string_type<_CharT>,
}
pub type std_basic_stringbuf_char_type<_CharT> = _CharT;
pub type std_basic_stringbuf_traits_type<_Traits> = _Traits;
pub type std_basic_stringbuf_allocator_type<_Alloc> = _Alloc;
pub type std_basic_stringbuf_int_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_stringbuf_pos_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_stringbuf_off_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_stringbuf___streambuf_type<_CharT> =
    std_basic_streambuf<std_basic_stringbuf_char_type<_CharT>>;
pub type std_basic_stringbuf___string_type<_CharT> =
    std_basic_string<std_basic_stringbuf_char_type<_CharT>>;
pub type std_basic_stringbuf___size_type<_CharT> = std_basic_stringbuf___string_type<_CharT>;
#[repr(C)]
pub struct std_basic_stringbuf___xfer_bufptrs<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _M_to: *mut std_basic_stringbuf<_CharT>,
    pub _M_goff: [std_basic_stringbuf_off_type; 3usize],
    pub _M_poff: [std_basic_stringbuf_off_type; 3usize],
}
#[repr(C)]
pub struct std_basic_istringstream<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _base: std_basic_istream<_CharT>,
    pub _M_stringbuf: std_basic_istringstream___stringbuf_type<_CharT>,
}
pub type std_basic_istringstream_char_type<_CharT> = _CharT;
pub type std_basic_istringstream_traits_type<_Traits> = _Traits;
pub type std_basic_istringstream_allocator_type<_Alloc> = _Alloc;
pub type std_basic_istringstream_int_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_istringstream_pos_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_istringstream_off_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_istringstream___string_type<_CharT> = std_basic_string<_CharT>;
pub type std_basic_istringstream___stringbuf_type<_CharT> = std_basic_stringbuf<_CharT>;
pub type std_basic_istringstream___istream_type<_CharT> =
    std_basic_istream<std_basic_istringstream_char_type<_CharT>>;
#[repr(C)]
pub struct std_basic_ostringstream<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _base: std_basic_ostream<_CharT>,
    pub _M_stringbuf: std_basic_ostringstream___stringbuf_type<_CharT>,
}
pub type std_basic_ostringstream_char_type<_CharT> = _CharT;
pub type std_basic_ostringstream_traits_type<_Traits> = _Traits;
pub type std_basic_ostringstream_allocator_type<_Alloc> = _Alloc;
pub type std_basic_ostringstream_int_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_ostringstream_pos_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_ostringstream_off_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_ostringstream___string_type<_CharT> = std_basic_string<_CharT>;
pub type std_basic_ostringstream___stringbuf_type<_CharT> = std_basic_stringbuf<_CharT>;
pub type std_basic_ostringstream___ostream_type<_CharT> =
    std_basic_ostream<std_basic_ostringstream_char_type<_CharT>>;
#[repr(C)]
pub struct std_basic_stringstream<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _base: std_basic_iostream<_CharT>,
    pub _M_stringbuf: std_basic_stringstream___stringbuf_type<_CharT>,
}
pub type std_basic_stringstream_char_type<_CharT> = _CharT;
pub type std_basic_stringstream_traits_type<_Traits> = _Traits;
pub type std_basic_stringstream_allocator_type<_Alloc> = _Alloc;
pub type std_basic_stringstream_int_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_stringstream_pos_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_stringstream_off_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_stringstream___string_type<_CharT> = std_basic_string<_CharT>;
pub type std_basic_stringstream___stringbuf_type<_CharT> = std_basic_stringbuf<_CharT>;
pub type std_basic_stringstream___iostream_type<_CharT> =
    std_basic_iostream<std_basic_stringstream_char_type<_CharT>>;
#[repr(C)]
#[derive(Debug)]
pub struct std_time_get {
    pub _base: std_locale_facet,
}
pub type std_time_get_char_type<_CharT> = _CharT;
pub type std_time_get_iter_type<_InIter> = _InIter;
#[repr(C)]
#[derive(Debug)]
pub struct std_time_get_byname {
    pub _base: std_time_get,
}
pub type std_time_get_byname_char_type<_CharT> = _CharT;
pub type std_time_get_byname_iter_type<_InIter> = _InIter;
pub type std_moneypunct_char_type<_CharT> = _CharT;
pub type std_moneypunct_string_type = std_basic_string<_CharT>;
pub type std_moneypunct___cache_type = u8;
unsafe extern "C" {
    #[link_name = "\u{1}intl"]
    pub static std_intl: bool;
}
pub type std_moneypunct_byname_char_type<_CharT> = _CharT;
pub type std_moneypunct_byname_string_type = std_basic_string<_CharT>;
#[repr(C)]
#[derive(Debug)]
pub struct std_money_get {
    pub _base: std_locale_facet,
}
pub type std_money_get_char_type<_CharT> = _CharT;
pub type std_money_get_iter_type<_InIter> = _InIter;
pub type std_money_get_string_type = std_basic_string<_CharT>;
#[repr(C)]
#[derive(Debug)]
pub struct std_money_put {
    pub _base: std_locale_facet,
}
pub type std_money_put_char_type<_CharT> = _CharT;
pub type std_money_put_iter_type<_OutIter> = _OutIter;
pub type std_money_put_string_type = std_basic_string<_CharT>;
#[repr(C)]
#[derive(Debug)]
pub struct std_messages {
    pub _base: std_locale_facet,
    pub _M_c_locale_messages: std___c_locale,
    pub _M_name_messages: *const ::std::os::raw::c_char,
}
pub type std_messages_char_type<_CharT> = _CharT;
pub type std_messages_string_type = std_basic_string<_CharT>;
#[repr(C)]
#[derive(Debug)]
pub struct std_messages_byname {
    pub _base: std_messages,
}
pub type std_messages_byname_char_type<_CharT> = _CharT;
pub type std_messages_byname_string_type = std_basic_string<_CharT>;
#[repr(C)]
pub struct std_wstring_convert<_Elem> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Elem>>,
    pub _M_cvt: std_unique_ptr,
    pub _M_byte_err_string: std_wstring_convert_byte_string,
    pub _M_wide_err_string: std_wstring_convert_wide_string<_Elem>,
    pub _M_state: std_wstring_convert_state_type,
    pub _M_count: usize,
    pub _M_with_cvtstate: bool,
    pub _M_with_strings: bool,
}
pub type std_wstring_convert_byte_string = std_basic_string<_CharT>;
pub type std_wstring_convert_wide_string<_Elem> = std_basic_string<_Elem>;
pub type std_wstring_convert_state_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_wstring_convert_int_type<_Elem> = std_wstring_convert_wide_string<_Elem>;
#[repr(C)]
pub struct std__List_base {
    pub _M_impl: std__List_base__List_impl,
}
pub type std__List_base__Tp_alloc_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std__List_base__Tp_alloc_traits = __gnu_cxx___alloc_traits;
pub type std__List_base__Node_alloc_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std__List_base__Node_alloc_traits = __gnu_cxx___alloc_traits;
#[repr(C)]
pub struct std__List_base__List_impl {
    pub _M_node: std___detail__List_node_header,
}
pub type std__List_base_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
pub struct std_list {
    pub _base: std__List_base,
}
pub type std_list__Base = std__List_base;
pub type std_list__Tp_alloc_type = std_list__Base;
pub type std_list__Tp_alloc_traits = std_list__Base;
pub type std_list__Node_alloc_type = std_list__Base;
pub type std_list__Node_alloc_traits = std_list__Base;
pub type std_list_value_type<_Tp> = _Tp;
pub type std_list_pointer = std_list__Tp_alloc_traits;
pub type std_list_const_pointer = std_list__Tp_alloc_traits;
pub type std_list_reference = std_list__Tp_alloc_traits;
pub type std_list_const_reference = std_list__Tp_alloc_traits;
pub type std_list_iterator = std__List_iterator;
pub type std_list_const_iterator = std__List_const_iterator;
pub type std_list_const_reverse_iterator = std_reverse_iterator<std_list_const_iterator>;
pub type std_list_reverse_iterator = std_reverse_iterator<std_list_iterator>;
pub type std_list_size_type = usize;
pub type std_list_difference_type = isize;
pub type std_list_allocator_type<_Alloc> = _Alloc;
pub type std_list__Node = std__List_node;
pub type std_list___remove_return_type = ::std::os::raw::c_void;
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
unsafe extern "C" {
    #[link_name = "\u{1}value"]
    pub static std_value: _Tp;
}
pub type std_true_type = u8;
pub type std_false_type = u8;
pub type std___bool_constant = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_identity {
    pub _address: u8,
}
pub type std___type_identity_type<_Type> = _Type;
pub type std___type_identity_t = std___type_identity;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___or_ {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___or__open0_close0"]
        [::std::mem::size_of::<std___or_>() - 1usize];
    ["Align of template specialization: std___or__open0_close0"]
        [::std::mem::align_of::<std___or_>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___and_ {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___and__open0_close0"]
        [::std::mem::size_of::<std___and_>() - 1usize];
    ["Align of template specialization: std___and__open0_close0"]
        [::std::mem::align_of::<std___and_>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___not_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___success_type {
    pub _address: u8,
}
pub type std___success_type_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___failure_type {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___failure_type"][::std::mem::size_of::<std___failure_type>() - 1usize];
    ["Alignment of std___failure_type"][::std::mem::align_of::<std___failure_type>() - 1usize];
};
pub type std___remove_cv_t = std_remove_cv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_void_helper {
    pub _base: std_false_type,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_void_helper_open0_void_close0"]
        [::std::mem::size_of::<std___is_void_helper>() - 1usize];
    ["Align of template specialization: std___is_void_helper_open0_void_close0"]
        [::std::mem::align_of::<std___is_void_helper>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_void {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_integral_helper {
    pub _base: std_false_type,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integral_helper_open0_bool__close0"]
        [::std::mem::size_of::<std___is_integral_helper>() - 1usize];
    ["Align of template specialization: std___is_integral_helper_open0_bool__close0"]
        [::std::mem::align_of::<std___is_integral_helper>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integral_helper_open0_char_close0"]
        [::std::mem::size_of::<std___is_integral_helper>() - 1usize];
    ["Align of template specialization: std___is_integral_helper_open0_char_close0"]
        [::std::mem::align_of::<std___is_integral_helper>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integral_helper_open0_signed_char_close0"]
        [::std::mem::size_of::<std___is_integral_helper>() - 1usize];
    ["Align of template specialization: std___is_integral_helper_open0_signed_char_close0"]
        [::std::mem::align_of::<std___is_integral_helper>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integral_helper_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std___is_integral_helper>() - 1usize];
    ["Align of template specialization: std___is_integral_helper_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std___is_integral_helper>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integral_helper_open0_wchar_t_close0"]
        [::std::mem::size_of::<std___is_integral_helper>() - 1usize];
    ["Align of template specialization: std___is_integral_helper_open0_wchar_t_close0"]
        [::std::mem::align_of::<std___is_integral_helper>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integral_helper_open0_char16_t_close0"]
        [::std::mem::size_of::<std___is_integral_helper>() - 1usize];
    ["Align of template specialization: std___is_integral_helper_open0_char16_t_close0"]
        [::std::mem::align_of::<std___is_integral_helper>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integral_helper_open0_char32_t_close0"]
        [::std::mem::size_of::<std___is_integral_helper>() - 1usize];
    ["Align of template specialization: std___is_integral_helper_open0_char32_t_close0"]
        [::std::mem::align_of::<std___is_integral_helper>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integral_helper_open0_short_close0"]
        [::std::mem::size_of::<std___is_integral_helper>() - 1usize];
    ["Align of template specialization: std___is_integral_helper_open0_short_close0"]
        [::std::mem::align_of::<std___is_integral_helper>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integral_helper_open0_unsigned_short_close0"]
        [::std::mem::size_of::<std___is_integral_helper>() - 1usize];
    ["Align of template specialization: std___is_integral_helper_open0_unsigned_short_close0"]
        [::std::mem::align_of::<std___is_integral_helper>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integral_helper_open0_int_close0"]
        [::std::mem::size_of::<std___is_integral_helper>() - 1usize];
    ["Align of template specialization: std___is_integral_helper_open0_int_close0"]
        [::std::mem::align_of::<std___is_integral_helper>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integral_helper_open0_unsigned_int_close0"]
        [::std::mem::size_of::<std___is_integral_helper>() - 1usize];
    ["Align of template specialization: std___is_integral_helper_open0_unsigned_int_close0"]
        [::std::mem::align_of::<std___is_integral_helper>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integral_helper_open0_long_close0"]
        [::std::mem::size_of::<std___is_integral_helper>() - 1usize];
    ["Align of template specialization: std___is_integral_helper_open0_long_close0"]
        [::std::mem::align_of::<std___is_integral_helper>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integral_helper_open0_unsigned_long_close0"]
        [::std::mem::size_of::<std___is_integral_helper>() - 1usize];
    ["Align of template specialization: std___is_integral_helper_open0_unsigned_long_close0"]
        [::std::mem::align_of::<std___is_integral_helper>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integral_helper_open0_long_long_close0"]
        [::std::mem::size_of::<std___is_integral_helper>() - 1usize];
    ["Align of template specialization: std___is_integral_helper_open0_long_long_close0"]
        [::std::mem::align_of::<std___is_integral_helper>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integral_helper_open0_unsigned_long_long_close0"]
        [::std::mem::size_of::<std___is_integral_helper>() - 1usize];
    ["Align of template specialization: std___is_integral_helper_open0_unsigned_long_long_close0"]
        [::std::mem::align_of::<std___is_integral_helper>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_integral {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_floating_point_helper {
    pub _base: std_false_type,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_floating_point_helper_open0_float_close0"]
        [::std::mem::size_of::<std___is_floating_point_helper>() - 1usize];
    ["Align of template specialization: std___is_floating_point_helper_open0_float_close0"]
        [::std::mem::align_of::<std___is_floating_point_helper>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_floating_point_helper_open0_double_close0"]
        [::std::mem::size_of::<std___is_floating_point_helper>() - 1usize];
    ["Align of template specialization: std___is_floating_point_helper_open0_double_close0"]
        [::std::mem::align_of::<std___is_floating_point_helper>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_floating_point_helper_open0_long_double_close0"]
        [::std::mem::size_of::<std___is_floating_point_helper>() - 1usize];
    ["Align of template specialization: std___is_floating_point_helper_open0_long_double_close0"]
        [::std::mem::align_of::<std___is_floating_point_helper>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_floating_point {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_array {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_lvalue_reference {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_rvalue_reference {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_member_object_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_object_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_member_function_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_function_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_enum {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_union {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_class {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_null_pointer_helper {
    pub _base: std_false_type,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_null_pointer_helper_open0_nullptr_t_close0"]
        [::std::mem::size_of::<std___is_null_pointer_helper>() - 1usize];
    ["Align of template specialization: std___is_null_pointer_helper_open0_nullptr_t_close0"]
        [::std::mem::align_of::<std___is_null_pointer_helper>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_null_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nullptr_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_reference {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_arithmetic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_fundamental {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_object {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_scalar {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_compound {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_member_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_pointer {
    pub _address: u8,
}
pub type std___is_one_of = std___or_;
pub type std___is_signed_integer = std___is_one_of;
pub type std___is_unsigned_integer = std___is_one_of;
pub type std___is_standard_integer = std___or_;
pub type std___void_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_referenceable {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_const {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_volatile {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivial {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copyable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_standard_layout {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_pod {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_literal_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_empty {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_polymorphic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_abstract {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_signed {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_unsigned {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_array_known_bounds {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_array_unknown_bounds {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_is_destructible_impl {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___do_is_destructible_impl"]
        [::std::mem::size_of::<std___do_is_destructible_impl>() - 1usize];
    ["Alignment of std___do_is_destructible_impl"]
        [::std::mem::align_of::<std___do_is_destructible_impl>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_destructible_impl {
    pub _address: u8,
}
pub type std___is_destructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_is_nt_destructible_impl {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___do_is_nt_destructible_impl"]
        [::std::mem::size_of::<std___do_is_nt_destructible_impl>() - 1usize];
    ["Alignment of std___do_is_nt_destructible_impl"]
        [::std::mem::align_of::<std___do_is_nt_destructible_impl>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nt_destructible_impl {
    pub _address: u8,
}
pub type std___is_nt_destructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_constructible_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_move_constructible {
    pub _address: u8,
}
pub type std___is_nothrow_constructible_impl = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_move_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nt_assignable_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_assignable_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_is_implicitly_default_constructible_impl {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___do_is_implicitly_default_constructible_impl"]
        [::std::mem::size_of::<std___do_is_implicitly_default_constructible_impl>() - 1usize];
    ["Alignment of std___do_is_implicitly_default_constructible_impl"]
        [::std::mem::align_of::<std___do_is_implicitly_default_constructible_impl>() - 1usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt45__do_is_implicitly_default_constructible_impl6__testEz"]
    pub fn std___do_is_implicitly_default_constructible_impl___test() -> std_false_type;
}
impl std___do_is_implicitly_default_constructible_impl {
    #[inline]
    pub unsafe fn __test() -> std_false_type {
        std___do_is_implicitly_default_constructible_impl___test()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible_impl {
    pub _address: u8,
}
pub type std___is_implicitly_default_constructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible_safe {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_move_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_has_virtual_destructor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_alignment_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_rank {
    pub _base: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_same {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_base_of {
    pub _address: u8,
}
pub type std___is_convertible_helper_type = std_is_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_convertible {
    pub _address: u8,
}
pub type std___is_array_convertible = std_is_convertible;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_convertible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_const {
    pub _address: u8,
}
pub type std_remove_const_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_volatile {
    pub _address: u8,
}
pub type std_remove_volatile_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_cv {
    pub _address: u8,
}
pub type std_remove_cv_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_const {
    pub _address: u8,
}
pub type std_add_const_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_volatile {
    pub _address: u8,
}
pub type std_add_volatile_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_cv {
    pub _address: u8,
}
pub type std_add_cv_type = std_add_const;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_reference {
    pub _address: u8,
}
pub type std_remove_reference_type<_Tp> = _Tp;
pub type std___add_lvalue_reference_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_lvalue_reference {
    pub _address: u8,
}
pub type std___add_rvalue_reference_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_rvalue_reference {
    pub _address: u8,
}
pub type std___match_cv_qualifiers___match = u8;
pub type std___match_cv_qualifiers___type = std___match_cv_qualifiers___match;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_unsigned {
    pub _address: u8,
}
pub type std___make_unsigned___type<_Tp> = _Tp;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___make_unsigned_open0_char_close0"]
        [::std::mem::size_of::<std___make_unsigned>() - 1usize];
    ["Align of template specialization: std___make_unsigned_open0_char_close0"]
        [::std::mem::align_of::<std___make_unsigned>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___make_unsigned_open0_signed_char_close0"]
        [::std::mem::size_of::<std___make_unsigned>() - 1usize];
    ["Align of template specialization: std___make_unsigned_open0_signed_char_close0"]
        [::std::mem::align_of::<std___make_unsigned>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___make_unsigned_open0_short_close0"]
        [::std::mem::size_of::<std___make_unsigned>() - 1usize];
    ["Align of template specialization: std___make_unsigned_open0_short_close0"]
        [::std::mem::align_of::<std___make_unsigned>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___make_unsigned_open0_int_close0"]
        [::std::mem::size_of::<std___make_unsigned>() - 1usize];
    ["Align of template specialization: std___make_unsigned_open0_int_close0"]
        [::std::mem::align_of::<std___make_unsigned>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___make_unsigned_open0_long_close0"]
        [::std::mem::size_of::<std___make_unsigned>() - 1usize];
    ["Align of template specialization: std___make_unsigned_open0_long_close0"]
        [::std::mem::align_of::<std___make_unsigned>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___make_unsigned_open0_long_long_close0"]
        [::std::mem::size_of::<std___make_unsigned>() - 1usize];
    ["Align of template specialization: std___make_unsigned_open0_long_long_close0"]
        [::std::mem::align_of::<std___make_unsigned>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_unsigned_selector_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_unsigned_selector_base__List {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___make_unsigned_selector_base"]
        [::std::mem::size_of::<std___make_unsigned_selector_base>() - 1usize];
    ["Alignment of std___make_unsigned_selector_base"]
        [::std::mem::align_of::<std___make_unsigned_selector_base>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___make_unsigned_open0_wchar_t_close0"]
        [::std::mem::size_of::<std___make_unsigned>() - 1usize];
    ["Align of template specialization: std___make_unsigned_open0_wchar_t_close0"]
        [::std::mem::align_of::<std___make_unsigned>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___make_unsigned_open0_char16_t_close0"]
        [::std::mem::size_of::<std___make_unsigned>() - 1usize];
    ["Align of template specialization: std___make_unsigned_open0_char16_t_close0"]
        [::std::mem::align_of::<std___make_unsigned>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___make_unsigned_open0_char32_t_close0"]
        [::std::mem::size_of::<std___make_unsigned>() - 1usize];
    ["Align of template specialization: std___make_unsigned_open0_char32_t_close0"]
        [::std::mem::align_of::<std___make_unsigned>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_signed {
    pub _address: u8,
}
pub type std___make_signed___type<_Tp> = _Tp;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___make_signed_open0_char_close0"]
        [::std::mem::size_of::<std___make_signed>() - 1usize];
    ["Align of template specialization: std___make_signed_open0_char_close0"]
        [::std::mem::align_of::<std___make_signed>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___make_signed_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std___make_signed>() - 1usize];
    ["Align of template specialization: std___make_signed_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std___make_signed>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___make_signed_open0_unsigned_short_close0"]
        [::std::mem::size_of::<std___make_signed>() - 1usize];
    ["Align of template specialization: std___make_signed_open0_unsigned_short_close0"]
        [::std::mem::align_of::<std___make_signed>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___make_signed_open0_unsigned_int_close0"]
        [::std::mem::size_of::<std___make_signed>() - 1usize];
    ["Align of template specialization: std___make_signed_open0_unsigned_int_close0"]
        [::std::mem::align_of::<std___make_signed>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___make_signed_open0_unsigned_long_close0"]
        [::std::mem::size_of::<std___make_signed>() - 1usize];
    ["Align of template specialization: std___make_signed_open0_unsigned_long_close0"]
        [::std::mem::align_of::<std___make_signed>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___make_signed_open0_unsigned_long_long_close0"]
        [::std::mem::size_of::<std___make_signed>() - 1usize];
    ["Align of template specialization: std___make_signed_open0_unsigned_long_long_close0"]
        [::std::mem::align_of::<std___make_signed>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___make_signed_open0_wchar_t_close0"]
        [::std::mem::size_of::<std___make_signed>() - 1usize];
    ["Align of template specialization: std___make_signed_open0_wchar_t_close0"]
        [::std::mem::align_of::<std___make_signed>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___make_signed_open0_char16_t_close0"]
        [::std::mem::size_of::<std___make_signed>() - 1usize];
    ["Align of template specialization: std___make_signed_open0_char16_t_close0"]
        [::std::mem::align_of::<std___make_signed>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___make_signed_open0_char32_t_close0"]
        [::std::mem::size_of::<std___make_signed>() - 1usize];
    ["Align of template specialization: std___make_signed_open0_char32_t_close0"]
        [::std::mem::align_of::<std___make_signed>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_signed {
    pub _address: u8,
}
pub type std_make_signed_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_extent {
    pub _address: u8,
}
pub type std_remove_extent_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_all_extents {
    pub _address: u8,
}
pub type std_remove_all_extents_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___remove_pointer_helper {
    pub _address: u8,
}
pub type std___remove_pointer_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_pointer {
    pub _address: u8,
}
pub type std___add_pointer_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union std___aligned_storage_msa___type {
    pub __data: *mut ::std::os::raw::c_uchar,
    pub __align: std___aligned_storage_msa___type__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___aligned_storage_msa___type__bindgen_ty_1 {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___aligned_storage_msa___type"]
        [::std::mem::size_of::<std___aligned_storage_msa___type>() - 8usize];
    ["Alignment of std___aligned_storage_msa___type"]
        [::std::mem::align_of::<std___aligned_storage_msa___type>() - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union std_aligned_storage_type {
    pub __data: *mut ::std::os::raw::c_uchar,
    pub __align: std_aligned_storage_type__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_aligned_storage_type__bindgen_ty_1 {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_aligned_storage_type"]
        [::std::mem::size_of::<std_aligned_storage_type>() - 8usize];
    ["Alignment of std_aligned_storage_type"]
        [::std::mem::align_of::<std_aligned_storage_type>() - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___strictest_alignment {
    pub _address: u8,
}
pub type std_aligned_union___strictest = std___strictest_alignment;
pub type std_aligned_union_type = u8;
unsafe extern "C" {
    #[link_name = "\u{1}alignment_value"]
    pub static std_alignment_value: usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_decay {
    pub _address: u8,
}
pub type std_decay___remove_type = std_remove_reference;
pub type std_decay_type = u8;
pub type std___decay_t = std_decay;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___strip_reference_wrapper {
    pub _address: u8,
}
pub type std___strip_reference_wrapper___type<_Tp> = _Tp;
pub type std___decay_and_strip = std___strip_reference_wrapper;
pub type std___enable_if_t = u8;
pub type std__Require = std___enable_if_t;
pub type std_conditional_type<_Iftrue> = _Iftrue;
pub type std___remove_cvref_t = std_remove_cv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_common_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_common_type_impl {
    pub _address: u8,
}
pub type std___do_common_type_impl___cond_t<_Tp> = _Tp;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___do_common_type_impl"]
        [::std::mem::size_of::<std___do_common_type_impl>() - 1usize];
    ["Alignment of std___do_common_type_impl"]
        [::std::mem::align_of::<std___do_common_type_impl>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_common_type_open0_close0"]
        [::std::mem::size_of::<std_common_type>() - 1usize];
    ["Align of template specialization: std_common_type_open0_close0"]
        [::std::mem::align_of::<std_common_type>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_impl {
    pub _address: u8,
}
pub type std___common_type_impl_type = std_common_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_pack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_fold {
    pub _address: u8,
}
pub type std___underlying_type_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_underlying_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___declval_protector {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_result_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memfun_ref {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___invoke_memfun_ref"][::std::mem::size_of::<std___invoke_memfun_ref>() - 1usize];
    ["Alignment of std___invoke_memfun_ref"]
        [::std::mem::align_of::<std___invoke_memfun_ref>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memfun_deref {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___invoke_memfun_deref"]
        [::std::mem::size_of::<std___invoke_memfun_deref>() - 1usize];
    ["Alignment of std___invoke_memfun_deref"]
        [::std::mem::align_of::<std___invoke_memfun_deref>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memobj_ref {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___invoke_memobj_ref"][::std::mem::size_of::<std___invoke_memobj_ref>() - 1usize];
    ["Alignment of std___invoke_memobj_ref"]
        [::std::mem::align_of::<std___invoke_memobj_ref>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memobj_deref {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___invoke_memobj_deref"]
        [::std::mem::size_of::<std___invoke_memobj_deref>() - 1usize];
    ["Alignment of std___invoke_memobj_deref"]
        [::std::mem::align_of::<std___invoke_memobj_deref>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_other {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___invoke_other"][::std::mem::size_of::<std___invoke_other>() - 1usize];
    ["Alignment of std___invoke_other"][::std::mem::align_of::<std___invoke_other>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_success {
    pub _address: u8,
}
pub type std___result_of_success___invoke_type<_Tag> = _Tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_ref_impl {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___result_of_memfun_ref_impl"]
        [::std::mem::size_of::<std___result_of_memfun_ref_impl>() - 1usize];
    ["Alignment of std___result_of_memfun_ref_impl"]
        [::std::mem::align_of::<std___result_of_memfun_ref_impl>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_ref {
    pub _address: u8,
}
pub type std___result_of_memfun_ref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_deref_impl {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___result_of_memfun_deref_impl"]
        [::std::mem::size_of::<std___result_of_memfun_deref_impl>() - 1usize];
    ["Alignment of std___result_of_memfun_deref_impl"]
        [::std::mem::align_of::<std___result_of_memfun_deref_impl>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_deref {
    pub _address: u8,
}
pub type std___result_of_memfun_deref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_ref_impl {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___result_of_memobj_ref_impl"]
        [::std::mem::size_of::<std___result_of_memobj_ref_impl>() - 1usize];
    ["Alignment of std___result_of_memobj_ref_impl"]
        [::std::mem::align_of::<std___result_of_memobj_ref_impl>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_ref {
    pub _address: u8,
}
pub type std___result_of_memobj_ref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_deref_impl {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___result_of_memobj_deref_impl"]
        [::std::mem::size_of::<std___result_of_memobj_deref_impl>() - 1usize];
    ["Alignment of std___result_of_memobj_deref_impl"]
        [::std::mem::align_of::<std___result_of_memobj_deref_impl>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_deref {
    pub _address: u8,
}
pub type std___result_of_memobj_deref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___inv_unwrap {
    pub _address: u8,
}
pub type std___inv_unwrap_type<_Tp> = _Tp;
pub type std___result_of_impl_type = std___failure_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_other_impl {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___result_of_other_impl"]
        [::std::mem::size_of::<std___result_of_other_impl>() - 1usize];
    ["Alignment of std___result_of_other_impl"]
        [::std::mem::align_of::<std___result_of_other_impl>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_result {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detector {
    pub _address: u8,
}
pub type std___detector_value_t = std_false_type;
pub type std___detector_type<_Default> = _Default;
pub type std___detected_or = std___detector;
pub type std___detected_or_t = std___detected_or;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_tuple_like_impl {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_tuple_like {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_details___do_is_swappable_impl {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___swappable_details___do_is_swappable_impl"]
        [::std::mem::size_of::<std___swappable_details___do_is_swappable_impl>() - 1usize];
    ["Alignment of std___swappable_details___do_is_swappable_impl"]
        [::std::mem::align_of::<std___swappable_details___do_is_swappable_impl>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_details___do_is_nothrow_swappable_impl {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___swappable_details___do_is_nothrow_swappable_impl"]
        [::std::mem::size_of::<std___swappable_details___do_is_nothrow_swappable_impl>() - 1usize];
    ["Alignment of std___swappable_details___do_is_nothrow_swappable_impl"]
        [::std::mem::align_of::<std___swappable_details___do_is_nothrow_swappable_impl>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable_impl {
    pub _address: u8,
}
pub type std___is_swappable_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable_impl {
    pub _address: u8,
}
pub type std___is_nothrow_swappable_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_invocable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___call_is_nothrow {
    pub _address: u8,
}
pub type std___call_is_nothrow_ = std___call_is_nothrow;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_invocable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___nonesuchbase {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___nonesuchbase"][::std::mem::size_of::<std___nonesuchbase>() - 1usize];
    ["Alignment of std___nonesuchbase"][::std::mem::align_of::<std___nonesuchbase>() - 1usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct std___nonesuch {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___nonesuch"][::std::mem::size_of::<std___nonesuch>() - 1usize];
    ["Alignment of std___nonesuch"][::std::mem::align_of::<std___nonesuch>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___move_if_noexcept_cond {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_piecewise_construct_t {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_piecewise_construct_t"]
        [::std::mem::size_of::<std_piecewise_construct_t>() - 1usize];
    ["Alignment of std_piecewise_construct_t"]
        [::std::mem::align_of::<std_piecewise_construct_t>() - 1usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZStL19piecewise_construct"]
    pub static std_piecewise_construct: std_piecewise_construct_t;
}
#[repr(C)]
#[derive(Debug)]
pub struct std___pair_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_pair<_T1, _T2> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T1>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T2>>,
    pub first: _T1,
    pub second: _T2,
}
pub type std_pair_first_type<_T1> = _T1;
pub type std_pair_second_type<_T2> = _T2;
pub type std_pair__PCCP = u8;
pub type std_pair__PCCFP = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_initializer_list<_E> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_E>>,
    pub _M_array: std_initializer_list_iterator<_E>,
    pub _M_len: std_initializer_list_size_type,
}
pub type std_initializer_list_value_type<_E> = _E;
pub type std_initializer_list_reference<_E> = *const _E;
pub type std_initializer_list_const_reference<_E> = *const _E;
pub type std_initializer_list_size_type = usize;
pub type std_initializer_list_iterator<_E> = *const _E;
pub type std_initializer_list_const_iterator<_E> = *const _E;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple_size {
    pub _address: u8,
}
pub type std___enable_if_has_tuple_size<_Tp> = _Tp;
pub type std___tuple_element_t = u8;
pub type std__Build_index_tuple__IdxTuple = u8;
pub type std__Build_index_tuple___type = u8;
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt21__throw_bad_exceptionv"]
    pub fn std___throw_bad_exception() -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt17__throw_bad_allocv"]
    pub fn std___throw_bad_alloc() -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt16__throw_bad_castv"]
    pub fn std___throw_bad_cast() -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt18__throw_bad_typeidv"]
    pub fn std___throw_bad_typeid() -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_logic_errorPKc"]
    pub fn std___throw_logic_error(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_domain_errorPKc"]
    pub fn std___throw_domain_error(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt24__throw_invalid_argumentPKc"]
    pub fn std___throw_invalid_argument(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_length_errorPKc"]
    pub fn std___throw_length_error(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_out_of_rangePKc"]
    pub fn std___throw_out_of_range(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt24__throw_out_of_range_fmtPKcz"]
    pub fn std___throw_out_of_range_fmt(arg1: *const ::std::os::raw::c_char, ...) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt21__throw_runtime_errorPKc"]
    pub fn std___throw_runtime_error(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_range_errorPKc"]
    pub fn std___throw_range_error(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt22__throw_overflow_errorPKc"]
    pub fn std___throw_overflow_error(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt23__throw_underflow_errorPKc"]
    pub fn std___throw_underflow_error(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_ios_failurePKc"]
    pub fn std___throw_ios_failure(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_ios_failurePKci"]
    pub fn std___throw_ios_failure1(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_system_errori"]
    pub fn std___throw_system_error(arg1: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_future_errori"]
    pub fn std___throw_future_error(arg1: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt25__throw_bad_function_callv"]
    pub fn std___throw_bad_function_call() -> !;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___true_type {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___true_type"][::std::mem::size_of::<std___true_type>() - 1usize];
    ["Alignment of std___true_type"][::std::mem::align_of::<std___true_type>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___false_type {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___false_type"][::std::mem::size_of::<std___false_type>() - 1usize];
    ["Alignment of std___false_type"][::std::mem::align_of::<std___false_type>() - 1usize];
};
pub type std___truth_type___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___traitor {
    pub _address: u8,
}
pub const std___traitor___value: std___traitor__bindgen_ty_1 = 0;
pub type std___traitor__bindgen_ty_1 = i32;
pub type std___traitor___type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___are_same {
    pub _address: u8,
}
pub const std___are_same___value: std___are_same__bindgen_ty_1 = 0;
pub type std___are_same__bindgen_ty_1 = i32;
pub type std___are_same___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_void {
    pub _address: u8,
}
pub const std___is_void___value: std___is_void__bindgen_ty_1 = 0;
pub type std___is_void__bindgen_ty_1 = i32;
pub type std___is_void___type = std___false_type;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_void_open0_void_close0"]
        [::std::mem::size_of::<std___is_void>() - 1usize];
    ["Align of template specialization: std___is_void_open0_void_close0"]
        [::std::mem::align_of::<std___is_void>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_integer {
    pub _address: u8,
}
pub const std___is_integer___value: std___is_integer__bindgen_ty_1 = 0;
pub type std___is_integer__bindgen_ty_1 = i32;
pub type std___is_integer___type = std___false_type;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integer_open0_bool__close0"]
        [::std::mem::size_of::<std___is_integer>() - 1usize];
    ["Align of template specialization: std___is_integer_open0_bool__close0"]
        [::std::mem::align_of::<std___is_integer>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integer_open0_char_close0"]
        [::std::mem::size_of::<std___is_integer>() - 1usize];
    ["Align of template specialization: std___is_integer_open0_char_close0"]
        [::std::mem::align_of::<std___is_integer>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integer_open0_signed_char_close0"]
        [::std::mem::size_of::<std___is_integer>() - 1usize];
    ["Align of template specialization: std___is_integer_open0_signed_char_close0"]
        [::std::mem::align_of::<std___is_integer>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integer_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std___is_integer>() - 1usize];
    ["Align of template specialization: std___is_integer_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std___is_integer>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integer_open0_wchar_t_close0"]
        [::std::mem::size_of::<std___is_integer>() - 1usize];
    ["Align of template specialization: std___is_integer_open0_wchar_t_close0"]
        [::std::mem::align_of::<std___is_integer>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integer_open0_char16_t_close0"]
        [::std::mem::size_of::<std___is_integer>() - 1usize];
    ["Align of template specialization: std___is_integer_open0_char16_t_close0"]
        [::std::mem::align_of::<std___is_integer>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integer_open0_char32_t_close0"]
        [::std::mem::size_of::<std___is_integer>() - 1usize];
    ["Align of template specialization: std___is_integer_open0_char32_t_close0"]
        [::std::mem::align_of::<std___is_integer>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integer_open0_short_close0"]
        [::std::mem::size_of::<std___is_integer>() - 1usize];
    ["Align of template specialization: std___is_integer_open0_short_close0"]
        [::std::mem::align_of::<std___is_integer>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integer_open0_unsigned_short_close0"]
        [::std::mem::size_of::<std___is_integer>() - 1usize];
    ["Align of template specialization: std___is_integer_open0_unsigned_short_close0"]
        [::std::mem::align_of::<std___is_integer>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integer_open0_int_close0"]
        [::std::mem::size_of::<std___is_integer>() - 1usize];
    ["Align of template specialization: std___is_integer_open0_int_close0"]
        [::std::mem::align_of::<std___is_integer>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integer_open0_unsigned_int_close0"]
        [::std::mem::size_of::<std___is_integer>() - 1usize];
    ["Align of template specialization: std___is_integer_open0_unsigned_int_close0"]
        [::std::mem::align_of::<std___is_integer>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integer_open0_long_close0"]
        [::std::mem::size_of::<std___is_integer>() - 1usize];
    ["Align of template specialization: std___is_integer_open0_long_close0"]
        [::std::mem::align_of::<std___is_integer>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integer_open0_unsigned_long_close0"]
        [::std::mem::size_of::<std___is_integer>() - 1usize];
    ["Align of template specialization: std___is_integer_open0_unsigned_long_close0"]
        [::std::mem::align_of::<std___is_integer>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integer_open0_long_long_close0"]
        [::std::mem::size_of::<std___is_integer>() - 1usize];
    ["Align of template specialization: std___is_integer_open0_long_long_close0"]
        [::std::mem::align_of::<std___is_integer>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_integer_open0_unsigned_long_long_close0"]
        [::std::mem::size_of::<std___is_integer>() - 1usize];
    ["Align of template specialization: std___is_integer_open0_unsigned_long_long_close0"]
        [::std::mem::align_of::<std___is_integer>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_floating {
    pub _address: u8,
}
pub const std___is_floating___value: std___is_floating__bindgen_ty_1 = 0;
pub type std___is_floating__bindgen_ty_1 = i32;
pub type std___is_floating___type = std___false_type;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_floating_open0_float_close0"]
        [::std::mem::size_of::<std___is_floating>() - 1usize];
    ["Align of template specialization: std___is_floating_open0_float_close0"]
        [::std::mem::align_of::<std___is_floating>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_floating_open0_double_close0"]
        [::std::mem::size_of::<std___is_floating>() - 1usize];
    ["Align of template specialization: std___is_floating_open0_double_close0"]
        [::std::mem::align_of::<std___is_floating>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_floating_open0_long_double_close0"]
        [::std::mem::size_of::<std___is_floating>() - 1usize];
    ["Align of template specialization: std___is_floating_open0_long_double_close0"]
        [::std::mem::align_of::<std___is_floating>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_pointer {
    pub _address: u8,
}
pub const std___is_pointer___value: std___is_pointer__bindgen_ty_1 = 0;
pub type std___is_pointer__bindgen_ty_1 = i32;
pub type std___is_pointer___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_arithmetic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_scalar {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_char {
    pub _address: u8,
}
pub const std___is_char___value: std___is_char__bindgen_ty_1 = 0;
pub type std___is_char__bindgen_ty_1 = i32;
pub type std___is_char___type = std___false_type;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_char_open0_char_close0"]
        [::std::mem::size_of::<std___is_char>() - 1usize];
    ["Align of template specialization: std___is_char_open0_char_close0"]
        [::std::mem::align_of::<std___is_char>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_char_open0_wchar_t_close0"]
        [::std::mem::size_of::<std___is_char>() - 1usize];
    ["Align of template specialization: std___is_char_open0_wchar_t_close0"]
        [::std::mem::align_of::<std___is_char>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_byte {
    pub _address: u8,
}
pub const std___is_byte___value: std___is_byte__bindgen_ty_1 = 0;
pub type std___is_byte__bindgen_ty_1 = i32;
pub type std___is_byte___type = std___false_type;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_byte_open0_char_close0"]
        [::std::mem::size_of::<std___is_byte>() - 1usize];
    ["Align of template specialization: std___is_byte_open0_char_close0"]
        [::std::mem::align_of::<std___is_byte>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_byte_open0_signed_char_close0"]
        [::std::mem::size_of::<std___is_byte>() - 1usize];
    ["Align of template specialization: std___is_byte_open0_signed_char_close0"]
        [::std::mem::align_of::<std___is_byte>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___is_byte_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std___is_byte>() - 1usize];
    ["Align of template specialization: std___is_byte_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std___is_byte>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nonvolatile_trivially_copyable {
    pub _address: u8,
}
pub const std___is_nonvolatile_trivially_copyable___value:
    std___is_nonvolatile_trivially_copyable__bindgen_ty_1 = 0;
pub type std___is_nonvolatile_trivially_copyable__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___memcpyable {
    pub _address: u8,
}
pub const std___memcpyable___value: std___memcpyable__bindgen_ty_1 = 0;
pub type std___memcpyable__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___memcmpable {
    pub _address: u8,
}
pub const std___memcmpable___value: std___memcmpable__bindgen_ty_1 = 0;
pub type std___memcmpable__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_move_iterator {
    pub _address: u8,
}
pub const std___is_move_iterator___value: std___is_move_iterator__bindgen_ty_1 = 0;
pub type std___is_move_iterator__bindgen_ty_1 = i32;
pub type std___is_move_iterator___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_input_iterator_tag {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_input_iterator_tag"][::std::mem::size_of::<std_input_iterator_tag>() - 1usize];
    ["Alignment of std_input_iterator_tag"]
        [::std::mem::align_of::<std_input_iterator_tag>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_output_iterator_tag {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_output_iterator_tag"][::std::mem::size_of::<std_output_iterator_tag>() - 1usize];
    ["Alignment of std_output_iterator_tag"]
        [::std::mem::align_of::<std_output_iterator_tag>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_forward_iterator_tag"]
        [::std::mem::size_of::<std_forward_iterator_tag>() - 1usize];
    ["Alignment of std_forward_iterator_tag"]
        [::std::mem::align_of::<std_forward_iterator_tag>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bidirectional_iterator_tag {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_bidirectional_iterator_tag"]
        [::std::mem::size_of::<std_bidirectional_iterator_tag>() - 1usize];
    ["Alignment of std_bidirectional_iterator_tag"]
        [::std::mem::align_of::<std_bidirectional_iterator_tag>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_random_access_iterator_tag {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_random_access_iterator_tag"]
        [::std::mem::size_of::<std_random_access_iterator_tag>() - 1usize];
    ["Alignment of std_random_access_iterator_tag"]
        [::std::mem::align_of::<std_random_access_iterator_tag>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_iterator_category<_Category> = _Category;
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
pub type std___iterator_category_t = std_iterator_traits;
pub type std__RequireInputIter = std___enable_if_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_random_access_iter {
    pub _address: u8,
}
pub type std___is_random_access_iter__Base = std_is_base_of;
pub const std___is_random_access_iter___value: std___is_random_access_iter__bindgen_ty_1 = 0;
pub type std___is_random_access_iter__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___undefined {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___get_first_arg {
    pub _address: u8,
}
pub type std___get_first_arg_type = std___undefined;
pub type std___get_first_arg_t = std___get_first_arg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___replace_first_arg {
    pub _address: u8,
}
pub type std___replace_first_arg_t = std___replace_first_arg;
pub type std___make_not_void = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
pub type std_pointer_traits___element_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_pointer_traits___difference_type = __BindgenOpaqueArray<u8, 0usize>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits___rebind {
    pub _address: u8,
}
pub type std_pointer_traits_pointer<_Ptr> = _Ptr;
pub type std_pointer_traits_element_type = std___detected_or_t;
pub type std_pointer_traits_difference_type = std___detected_or_t;
pub type std_pointer_traits_rebind = std_pointer_traits___rebind;
pub type std___ptr_rebind = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iterator> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
    pub current: _Iterator,
}
pub type std_reverse_iterator___traits_type = std_iterator_traits;
pub type std_reverse_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_reverse_iterator_pointer = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_difference_type = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_reference = std_reverse_iterator___traits_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_back_insert_iterator<_Container> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Container>>,
    pub container: *mut _Container,
}
pub type std_back_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_front_insert_iterator<_Container> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Container>>,
    pub container: *mut _Container,
}
pub type std_front_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
pub struct std_insert_iterator<_Container> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Container>>,
    pub container: *mut _Container,
    pub iter: std_insert_iterator__Iter,
}
pub type std_insert_iterator__Iter = __BindgenOpaqueArray<u8, 0usize>;
pub type std_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Identity {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___detail__Identity"][::std::mem::size_of::<std___detail__Identity>() - 1usize];
    ["Alignment of std___detail__Identity"]
        [::std::mem::align_of::<std___detail__Identity>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Select1st {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___detail__Select1st"][::std::mem::size_of::<std___detail__Select1st>() - 1usize];
    ["Alignment of std___detail__Select1st"]
        [::std::mem::align_of::<std___detail__Select1st>() - 1usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct std___detail__ReuseOrAllocNode {
    pub _M_nodes: *mut std___detail__ReuseOrAllocNode___node_type,
    pub _M_h: *mut std___detail__ReuseOrAllocNode___hashtable_alloc,
}
pub type std___detail__ReuseOrAllocNode___node_alloc_type<_NodeAlloc> = _NodeAlloc;
pub type std___detail__ReuseOrAllocNode___hashtable_alloc = std___detail__Hashtable_alloc;
pub type std___detail__ReuseOrAllocNode___node_alloc_traits =
    std___detail__ReuseOrAllocNode___hashtable_alloc;
pub type std___detail__ReuseOrAllocNode___node_type =
    std___detail__ReuseOrAllocNode___hashtable_alloc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__AllocNode {
    pub _M_h: *mut std___detail__AllocNode___hashtable_alloc,
}
pub type std___detail__AllocNode___hashtable_alloc = std___detail__Hashtable_alloc;
pub type std___detail__AllocNode___node_type = std___detail__AllocNode___hashtable_alloc;
pub type std___detail__Hashtable_traits___hash_cached = std___bool_constant;
pub type std___detail__Hashtable_traits___constant_iterators = std___bool_constant;
pub type std___detail__Hashtable_traits___unique_keys = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Hash_node_base {
    pub _M_nxt: *mut std___detail__Hash_node_base,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___detail__Hash_node_base"]
        [::std::mem::size_of::<std___detail__Hash_node_base>() - 8usize];
    ["Alignment of std___detail__Hash_node_base"]
        [::std::mem::align_of::<std___detail__Hash_node_base>() - 8usize];
    ["Offset of field: std___detail__Hash_node_base::_M_nxt"]
        [::std::mem::offset_of!(std___detail__Hash_node_base, _M_nxt) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Hash_node_value_base {
    pub _base: std___detail__Hash_node_base,
    pub _M_storage: __gnu_cxx___aligned_buffer,
}
pub type std___detail__Hash_node_value_base_value_type<_Value> = _Value;
pub type std___detail__Node_iterator_base___node_type = u8;
pub type std___detail__Node_iterator___base_type = u8;
pub type std___detail__Node_iterator___node_type = std___detail__Node_iterator___base_type;
pub type std___detail__Node_iterator_value_type<_Value> = _Value;
pub type std___detail__Node_iterator_difference_type = isize;
pub type std___detail__Node_iterator_iterator_category = std_forward_iterator_tag;
pub type std___detail__Node_iterator_pointer = u8;
pub type std___detail__Node_iterator_reference = u8;
pub type std___detail__Node_const_iterator___base_type = u8;
pub type std___detail__Node_const_iterator___node_type =
    std___detail__Node_const_iterator___base_type;
pub type std___detail__Node_const_iterator_value_type<_Value> = _Value;
pub type std___detail__Node_const_iterator_difference_type = isize;
pub type std___detail__Node_const_iterator_iterator_category = std_forward_iterator_tag;
pub type std___detail__Node_const_iterator_pointer<_Value> = *const _Value;
pub type std___detail__Node_const_iterator_reference<_Value> = *const _Value;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Mod_range_hashing {
    pub _address: u8,
}
pub type std___detail__Mod_range_hashing_first_argument_type = usize;
pub type std___detail__Mod_range_hashing_second_argument_type = usize;
pub type std___detail__Mod_range_hashing_result_type = usize;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___detail__Mod_range_hashing"]
        [::std::mem::size_of::<std___detail__Mod_range_hashing>() - 1usize];
    ["Alignment of std___detail__Mod_range_hashing"]
        [::std::mem::align_of::<std___detail__Mod_range_hashing>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Default_ranged_hash {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___detail__Default_ranged_hash"]
        [::std::mem::size_of::<std___detail__Default_ranged_hash>() - 1usize];
    ["Alignment of std___detail__Default_ranged_hash"]
        [::std::mem::align_of::<std___detail__Default_ranged_hash>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Prime_rehash_policy {
    pub _M_max_load_factor: f32,
    pub _M_next_resize: usize,
}
pub type std___detail__Prime_rehash_policy___has_load_factor = std_true_type;
pub type std___detail__Prime_rehash_policy__State = usize;
pub const std___detail__Prime_rehash_policy__S_growth_factor: usize = 2;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___detail__Prime_rehash_policy"]
        [::std::mem::size_of::<std___detail__Prime_rehash_policy>() - 16usize];
    ["Alignment of std___detail__Prime_rehash_policy"]
        [::std::mem::align_of::<std___detail__Prime_rehash_policy>() - 8usize];
    ["Offset of field: std___detail__Prime_rehash_policy::_M_max_load_factor"]
        [::std::mem::offset_of!(std___detail__Prime_rehash_policy, _M_max_load_factor) - 0usize];
    ["Offset of field: std___detail__Prime_rehash_policy::_M_next_resize"]
        [::std::mem::offset_of!(std___detail__Prime_rehash_policy, _M_next_resize) - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt8__detail20_Prime_rehash_policy11_M_next_bktEm"]
    pub fn std___detail__Prime_rehash_policy__M_next_bkt(
        this: *const std___detail__Prime_rehash_policy,
        __n: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt8__detail20_Prime_rehash_policy14_M_need_rehashEmmm"]
    pub fn std___detail__Prime_rehash_policy__M_need_rehash(
        this: *const std___detail__Prime_rehash_policy,
        __n_bkt: usize,
        __n_elt: usize,
        __n_ins: usize,
    ) -> std_pair<bool, usize>;
}
impl std___detail__Prime_rehash_policy {
    #[inline]
    pub unsafe fn _M_next_bkt(&self, __n: usize) -> usize {
        std___detail__Prime_rehash_policy__M_next_bkt(self, __n)
    }
    #[inline]
    pub unsafe fn _M_need_rehash(
        &self,
        __n_bkt: usize,
        __n_elt: usize,
        __n_ins: usize,
    ) -> std_pair<bool, usize> {
        std___detail__Prime_rehash_policy__M_need_rehash(self, __n_bkt, __n_elt, __n_ins)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Mask_range_hashing {
    pub _address: u8,
}
pub type std___detail__Mask_range_hashing_first_argument_type = usize;
pub type std___detail__Mask_range_hashing_second_argument_type = usize;
pub type std___detail__Mask_range_hashing_result_type = usize;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___detail__Mask_range_hashing"]
        [::std::mem::size_of::<std___detail__Mask_range_hashing>() - 1usize];
    ["Alignment of std___detail__Mask_range_hashing"]
        [::std::mem::align_of::<std___detail__Mask_range_hashing>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Power2_rehash_policy {
    pub _M_max_load_factor: f32,
    pub _M_next_resize: usize,
}
pub type std___detail__Power2_rehash_policy___has_load_factor = std_true_type;
pub type std___detail__Power2_rehash_policy__State = usize;
pub const std___detail__Power2_rehash_policy__S_growth_factor: usize = 2;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___detail__Power2_rehash_policy"]
        [::std::mem::size_of::<std___detail__Power2_rehash_policy>() - 16usize];
    ["Alignment of std___detail__Power2_rehash_policy"]
        [::std::mem::align_of::<std___detail__Power2_rehash_policy>() - 8usize];
    ["Offset of field: std___detail__Power2_rehash_policy::_M_max_load_factor"]
        [::std::mem::offset_of!(std___detail__Power2_rehash_policy, _M_max_load_factor) - 0usize];
    ["Offset of field: std___detail__Power2_rehash_policy::_M_next_resize"]
        [::std::mem::offset_of!(std___detail__Power2_rehash_policy, _M_next_resize) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Insert_base {
    pub _address: u8,
}
pub type std___detail__Insert_base___hashtable<_RehashPolicy> = std__Hashtable<_RehashPolicy>;
pub type std___detail__Insert_base___hashtable_base = std___detail__Hashtable_base;
pub type std___detail__Insert_base_value_type = std___detail__Insert_base___hashtable_base;
pub type std___detail__Insert_base_iterator = std___detail__Insert_base___hashtable_base;
pub type std___detail__Insert_base_const_iterator = std___detail__Insert_base___hashtable_base;
pub type std___detail__Insert_base_size_type = std___detail__Insert_base___hashtable_base;
pub type std___detail__Insert_base___unique_keys = std___detail__Insert_base___hashtable_base;
pub type std___detail__Insert_base___ireturn_type = std___detail__Insert_base___hashtable_base;
pub type std___detail__Insert_base___node_type = u8;
pub type std___detail__Insert_base___node_alloc_type = std___alloc_rebind;
pub type std___detail__Insert_base___node_gen_type = std___detail__AllocNode;
pub type std___detail___has_load_factor = __BindgenOpaqueArray<u8, 0usize>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Rehash_base {
    pub _address: u8,
}
pub type std___detail___hash_code_for_local_iter = u8;
pub type std___detail__Local_iterator___base_type = u8;
pub type std___detail__Local_iterator___hash_code_base = std___detail__Local_iterator___base_type;
pub type std___detail__Local_iterator_value_type<_Value> = _Value;
pub type std___detail__Local_iterator_pointer = u8;
pub type std___detail__Local_iterator_reference = u8;
pub type std___detail__Local_iterator_difference_type = isize;
pub type std___detail__Local_iterator_iterator_category = std_forward_iterator_tag;
pub type std___detail__Local_const_iterator___base_type = u8;
pub type std___detail__Local_const_iterator___hash_code_base =
    std___detail__Local_const_iterator___base_type;
pub type std___detail__Local_const_iterator_value_type<_Value> = _Value;
pub type std___detail__Local_const_iterator_pointer<_Value> = *const _Value;
pub type std___detail__Local_const_iterator_reference<_Value> = *const _Value;
pub type std___detail__Local_const_iterator_difference_type = isize;
pub type std___detail__Local_const_iterator_iterator_category = std_forward_iterator_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Hashtable_base {
    pub _address: u8,
}
pub type std___detail__Hashtable_base_key_type<_Key> = _Key;
pub type std___detail__Hashtable_base_value_type<_Value> = _Value;
pub type std___detail__Hashtable_base_key_equal<_Equal> = _Equal;
pub type std___detail__Hashtable_base_size_type = usize;
pub type std___detail__Hashtable_base_difference_type = isize;
pub type std___detail__Hashtable_base___traits_type<_Traits> = _Traits;
pub type std___detail__Hashtable_base___hash_cached = __BindgenOpaqueArray<u8, 0usize>;
pub type std___detail__Hashtable_base___constant_iterators = __BindgenOpaqueArray<u8, 0usize>;
pub type std___detail__Hashtable_base___unique_keys = __BindgenOpaqueArray<u8, 0usize>;
pub type std___detail__Hashtable_base___hash_code_base = u8;
pub type std___detail__Hashtable_base___hash_code = std___detail__Hashtable_base___hash_code_base;
pub type std___detail__Hashtable_base___node_type = std___detail__Hashtable_base___hash_code_base;
pub type std___detail__Hashtable_base_iterator = u8;
pub type std___detail__Hashtable_base_const_iterator = u8;
pub type std___detail__Hashtable_base_local_iterator = u8;
pub type std___detail__Hashtable_base_const_local_iterator = u8;
pub type std___detail__Hashtable_base___ireturn_type = u8;
pub type std___detail__Hashtable_base__EqualEBO = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Hashtable_base__Equal_hash_code {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Hashtable_alloc {
    pub _address: u8,
}
pub type std___detail__Hashtable_alloc___ebo_node_alloc = u8;
pub type std___detail__Hashtable_alloc___node_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std___detail__Hashtable_alloc___node_alloc_type<_NodeAlloc> = _NodeAlloc;
pub type std___detail__Hashtable_alloc___node_alloc_traits = __gnu_cxx___alloc_traits;
pub type std___detail__Hashtable_alloc___value_alloc_traits = __BindgenOpaqueArray<u8, 0usize>;
pub type std___detail__Hashtable_alloc___node_base = std___detail__Hash_node_base;
pub type std___detail__Hashtable_alloc___bucket_type =
    *mut std___detail__Hashtable_alloc___node_base;
pub type std___detail__Hashtable_alloc___bucket_alloc_type = std___alloc_rebind;
pub type std___detail__Hashtable_alloc___bucket_alloc_traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__List_node_base {
    pub _M_next: *mut std___detail__List_node_base,
    pub _M_prev: *mut std___detail__List_node_base,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___detail__List_node_base"]
        [::std::mem::size_of::<std___detail__List_node_base>() - 16usize];
    ["Alignment of std___detail__List_node_base"]
        [::std::mem::align_of::<std___detail__List_node_base>() - 8usize];
    ["Offset of field: std___detail__List_node_base::_M_next"]
        [::std::mem::offset_of!(std___detail__List_node_base, _M_next) - 0usize];
    ["Offset of field: std___detail__List_node_base::_M_prev"]
        [::std::mem::offset_of!(std___detail__List_node_base, _M_prev) - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8__detail15_List_node_base4swapERS0_S1_"]
    pub fn std___detail__List_node_base_swap(
        __x: *mut std___detail__List_node_base,
        __y: *mut std___detail__List_node_base,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8__detail15_List_node_base11_M_transferEPS0_S1_"]
    pub fn std___detail__List_node_base__M_transfer(
        this: *mut std___detail__List_node_base,
        __first: *mut std___detail__List_node_base,
        __last: *mut std___detail__List_node_base,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8__detail15_List_node_base10_M_reverseEv"]
    pub fn std___detail__List_node_base__M_reverse(this: *mut std___detail__List_node_base);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8__detail15_List_node_base7_M_hookEPS0_"]
    pub fn std___detail__List_node_base__M_hook(
        this: *mut std___detail__List_node_base,
        __position: *mut std___detail__List_node_base,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8__detail15_List_node_base9_M_unhookEv"]
    pub fn std___detail__List_node_base__M_unhook(this: *mut std___detail__List_node_base);
}
impl std___detail__List_node_base {
    #[inline]
    pub unsafe fn swap(
        __x: *mut std___detail__List_node_base,
        __y: *mut std___detail__List_node_base,
    ) {
        std___detail__List_node_base_swap(__x, __y)
    }
    #[inline]
    pub unsafe fn _M_transfer(
        &mut self,
        __first: *mut std___detail__List_node_base,
        __last: *mut std___detail__List_node_base,
    ) {
        std___detail__List_node_base__M_transfer(self, __first, __last)
    }
    #[inline]
    pub unsafe fn _M_reverse(&mut self) {
        std___detail__List_node_base__M_reverse(self)
    }
    #[inline]
    pub unsafe fn _M_hook(&mut self, __position: *mut std___detail__List_node_base) {
        std___detail__List_node_base__M_hook(self, __position)
    }
    #[inline]
    pub unsafe fn _M_unhook(&mut self) {
        std___detail__List_node_base__M_unhook(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__List_node_header {
    pub _base: std___detail__List_node_base,
    pub _M_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___detail__List_node_header"]
        [::std::mem::size_of::<std___detail__List_node_header>() - 24usize];
    ["Alignment of std___detail__List_node_header"]
        [::std::mem::align_of::<std___detail__List_node_header>() - 8usize];
    ["Offset of field: std___detail__List_node_header::_M_size"]
        [::std::mem::offset_of!(std___detail__List_node_header, _M_size) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_move_iterator<_Iterator> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
    pub _M_current: _Iterator,
}
pub type std_move_iterator___traits_type = std_iterator_traits;
pub type std_move_iterator___base_ref = std_move_iterator___traits_type;
pub type std_move_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_move_iterator_iterator_category = std_move_iterator___traits_type;
pub type std_move_iterator_value_type = std_move_iterator___traits_type;
pub type std_move_iterator_difference_type = std_move_iterator___traits_type;
pub type std_move_iterator_pointer<_Iterator> = _Iterator;
pub type std_move_iterator_reference = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___lc_rai {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std___lc_rai_open0_std_random_access_iterator_tag_std_random_access_iterator_tag_close0",
    ][::std::mem::size_of::<std___lc_rai>() - 1usize];
    [
        "Align of template specialization: std___lc_rai_open0_std_random_access_iterator_tag_std_random_access_iterator_tag_close0",
    ][::std::mem::align_of::<std___lc_rai>() - 1usize];
};
pub type std___array_traits__Type<_Tp> = *mut _Tp;
pub type std___array_traits__Is_swappable = std___is_swappable;
pub type std___array_traits__Is_nothrow_swappable = std___is_nothrow_swappable;
pub type std_array_value_type<_Tp> = _Tp;
pub type std_array_pointer<_Tp> = *mut std_array_value_type<_Tp>;
pub type std_array_const_pointer<_Tp> = *const std_array_value_type<_Tp>;
pub type std_array_reference<_Tp> = *mut std_array_value_type<_Tp>;
pub type std_array_const_reference<_Tp> = *const std_array_value_type<_Tp>;
pub type std_array_iterator<_Tp> = *mut std_array_value_type<_Tp>;
pub type std_array_const_iterator<_Tp> = *const std_array_value_type<_Tp>;
pub type std_array_size_type = usize;
pub type std_array_difference_type = isize;
pub type std_array_reverse_iterator<_Tp> = std_reverse_iterator<std_array_iterator<_Tp>>;
pub type std_array_const_reverse_iterator<_Tp> =
    std_reverse_iterator<std_array_const_iterator<_Tp>>;
pub type std_array__AT_Type = u8;
#[repr(C)]
pub struct std_error_category__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_error_category {
    pub vtable_: *const std_error_category__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_error_category"][::std::mem::size_of::<std_error_category>() - 8usize];
    ["Alignment of std_error_category"][::std::mem::align_of::<std_error_category>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt3_V214error_categoryD1Ev"]
    pub fn std_error_category_error_category_destructor(this: *mut std_error_category);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt3_V214error_category23default_error_conditionEi"]
    pub fn std_error_category_default_error_condition(
        this: *mut ::std::os::raw::c_void,
        __i: ::std::os::raw::c_int,
    ) -> std_error_condition;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt3_V214error_category10equivalentEiRKSt15error_condition"]
    pub fn std_error_category_equivalent(
        this: *mut ::std::os::raw::c_void,
        __i: ::std::os::raw::c_int,
        __cond: *const std_error_condition,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt3_V214error_category10equivalentERKSt10error_codei"]
    pub fn std_error_category_equivalent1(
        this: *mut ::std::os::raw::c_void,
        __code: *const std_error_code,
        __i: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt3_V216generic_categoryEv"]
    pub fn std_generic_category() -> *const std_error_category;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt3_V215system_categoryEv"]
    pub fn std_system_category() -> *const std_error_category;
}
#[repr(C)]
pub struct std_exception__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_exception {
    pub vtable_: *const std_exception__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_exception"][::std::mem::size_of::<std_exception>() - 8usize];
    ["Alignment of std_exception"][::std::mem::align_of::<std_exception>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt9exceptionD1Ev"]
    pub fn std_exception_exception_destructor(this: *mut std_exception);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt9exception4whatEv"]
    pub fn std_exception_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_exception {
    pub _base: std_exception,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_bad_exception"][::std::mem::size_of::<std_bad_exception>() - 8usize];
    ["Alignment of std_bad_exception"][::std::mem::align_of::<std_bad_exception>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt13bad_exceptionD1Ev"]
    pub fn std_bad_exception_bad_exception_destructor(this: *mut std_bad_exception);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt13bad_exception4whatEv"]
    pub fn std_bad_exception_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
pub type std_terminate_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type std_unexpected_handler = ::std::option::Option<unsafe extern "C" fn()>;
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt13set_terminatePFvvE"]
    pub fn std_set_terminate(arg1: std_terminate_handler) -> std_terminate_handler;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt13get_terminatev"]
    pub fn std_get_terminate() -> std_terminate_handler;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt9terminatev"]
    pub fn std_terminate() -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt14set_unexpectedPFvvE"]
    pub fn std_set_unexpected(arg1: std_unexpected_handler) -> std_unexpected_handler;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt14get_unexpectedv"]
    pub fn std_get_unexpected() -> std_unexpected_handler;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt10unexpectedv"]
    pub fn std_unexpected() -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt18uncaught_exceptionv"]
    pub fn std_uncaught_exception() -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt11_Hash_bytesPKvmm"]
    pub fn std__Hash_bytes(
        __ptr: *const ::std::os::raw::c_void,
        __len: usize,
        __seed: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt15_Fnv_hash_bytesPKvmm"]
    pub fn std__Fnv_hash_bytes(
        __ptr: *const ::std::os::raw::c_void,
        __len: usize,
        __seed: usize,
    ) -> usize;
}
#[repr(C)]
pub struct std_type_info__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_type_info {
    pub vtable_: *const std_type_info__bindgen_vtable,
    pub __name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_type_info"][::std::mem::size_of::<std_type_info>() - 16usize];
    ["Alignment of std_type_info"][::std::mem::align_of::<std_type_info>() - 8usize];
    ["Offset of field: std_type_info::__name"]
        [::std::mem::offset_of!(std_type_info, __name) - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt9type_infoD1Ev"]
    pub fn std_type_info_type_info_destructor(this: *mut std_type_info);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info14__is_pointer_pEv"]
    pub fn std_type_info___is_pointer_p(this: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info15__is_function_pEv"]
    pub fn std_type_info___is_function_p(this: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info10__do_catchEPKS_PPvj"]
    pub fn std_type_info___do_catch(
        this: *mut ::std::os::raw::c_void,
        __thr_type: *const std_type_info,
        __thr_obj: *mut *mut ::std::os::raw::c_void,
        __outer: ::std::os::raw::c_uint,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info11__do_upcastEPKN10__cxxabiv117__class_type_infoEPPv"]
    pub fn std_type_info___do_upcast(
        this: *mut ::std::os::raw::c_void,
        __target: *const __cxxabiv1___class_type_info,
        __obj_ptr: *mut *mut ::std::os::raw::c_void,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_cast {
    pub _base: std_exception,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_bad_cast"][::std::mem::size_of::<std_bad_cast>() - 8usize];
    ["Alignment of std_bad_cast"][::std::mem::align_of::<std_bad_cast>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8bad_castD1Ev"]
    pub fn std_bad_cast_bad_cast_destructor(this: *mut std_bad_cast);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt8bad_cast4whatEv"]
    pub fn std_bad_cast_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_typeid {
    pub _base: std_exception,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_bad_typeid"][::std::mem::size_of::<std_bad_typeid>() - 8usize];
    ["Alignment of std_bad_typeid"][::std::mem::align_of::<std_bad_typeid>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10bad_typeidD1Ev"]
    pub fn std_bad_typeid_bad_typeid_destructor(this: *mut std_bad_typeid);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10bad_typeid4whatEv"]
    pub fn std_bad_typeid_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std___exception_ptr_exception_ptr {
    pub _M_exception_object: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___exception_ptr_exception_ptr"]
        [::std::mem::size_of::<std___exception_ptr_exception_ptr>() - 8usize];
    ["Alignment of std___exception_ptr_exception_ptr"]
        [::std::mem::align_of::<std___exception_ptr_exception_ptr>() - 8usize];
    ["Offset of field: std___exception_ptr_exception_ptr::_M_exception_object"]
        [::std::mem::offset_of!(std___exception_ptr_exception_ptr, _M_exception_object) - 0usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt15__exception_ptr13exception_ptr4swapERS0_"]
    pub fn std___exception_ptr_exception_ptr_swap(
        this: *mut std___exception_ptr_exception_ptr,
        arg1: *mut std___exception_ptr_exception_ptr,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt15__exception_ptr13exception_ptr20__cxa_exception_typeEv"]
    pub fn std___exception_ptr_exception_ptr___cxa_exception_type(
        this: *const std___exception_ptr_exception_ptr,
    ) -> *const std_type_info;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt15__exception_ptr13exception_ptrC1Ev"]
    pub fn std___exception_ptr_exception_ptr_exception_ptr(
        this: *mut std___exception_ptr_exception_ptr,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt15__exception_ptr13exception_ptrC1ERKS0_"]
    pub fn std___exception_ptr_exception_ptr_exception_ptr1(
        this: *mut std___exception_ptr_exception_ptr,
        arg1: *const std___exception_ptr_exception_ptr,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt15__exception_ptr13exception_ptrD1Ev"]
    pub fn std___exception_ptr_exception_ptr_exception_ptr_destructor(
        this: *mut std___exception_ptr_exception_ptr,
    );
}
impl std___exception_ptr_exception_ptr {
    #[inline]
    pub unsafe fn swap(&mut self, arg1: *mut std___exception_ptr_exception_ptr) {
        std___exception_ptr_exception_ptr_swap(self, arg1)
    }
    #[inline]
    pub unsafe fn __cxa_exception_type(&self) -> *const std_type_info {
        std___exception_ptr_exception_ptr___cxa_exception_type(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___exception_ptr_exception_ptr_exception_ptr(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const std___exception_ptr_exception_ptr) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___exception_ptr_exception_ptr_exception_ptr1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std___exception_ptr_exception_ptr_exception_ptr_destructor(self)
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt17current_exceptionv"]
    pub fn std_current_exception() -> std___exception_ptr_exception_ptr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt17rethrow_exceptionNSt15__exception_ptr13exception_ptrE"]
    pub fn std_rethrow_exception(arg1: std___exception_ptr_exception_ptr) -> !;
}
#[repr(C)]
pub struct std_nested_exception__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_nested_exception {
    pub vtable_: *const std_nested_exception__bindgen_vtable,
    pub _M_ptr: std___exception_ptr_exception_ptr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_nested_exception"][::std::mem::size_of::<std_nested_exception>() - 16usize];
    ["Alignment of std_nested_exception"][::std::mem::align_of::<std_nested_exception>() - 8usize];
    ["Offset of field: std_nested_exception::_M_ptr"]
        [::std::mem::offset_of!(std_nested_exception, _M_ptr) - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt16nested_exceptionD1Ev"]
    pub fn std_nested_exception_nested_exception_destructor(this: *mut std_nested_exception);
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Nested_exception<_Except> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Except>>,
    pub _base: _Except,
    pub _base_1: std_nested_exception,
}
pub type std___rethrow_if_nested_cond = u8;
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_alloc {
    pub _base: std_exception,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_bad_alloc"][::std::mem::size_of::<std_bad_alloc>() - 8usize];
    ["Alignment of std_bad_alloc"][::std::mem::align_of::<std_bad_alloc>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt9bad_allocD1Ev"]
    pub fn std_bad_alloc_bad_alloc_destructor(this: *mut std_bad_alloc);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt9bad_alloc4whatEv"]
    pub fn std_bad_alloc_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_array_new_length {
    pub _base: std_bad_alloc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_bad_array_new_length"]
        [::std::mem::size_of::<std_bad_array_new_length>() - 8usize];
    ["Alignment of std_bad_array_new_length"]
        [::std::mem::align_of::<std_bad_array_new_length>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt20bad_array_new_lengthD1Ev"]
    pub fn std_bad_array_new_length_bad_array_new_length_destructor(
        this: *mut std_bad_array_new_length,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt20bad_array_new_length4whatEv"]
    pub fn std_bad_array_new_length_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_nothrow_t {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_nothrow_t"][::std::mem::size_of::<std_nothrow_t>() - 1usize];
    ["Alignment of std_nothrow_t"][::std::mem::align_of::<std_nothrow_t>() - 1usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt7nothrow"]
    pub static std_nothrow: std_nothrow_t;
}
pub type std_new_handler = ::std::option::Option<unsafe extern "C" fn()>;
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt15set_new_handlerPFvvE"]
    pub fn std_set_new_handler(arg1: std_new_handler) -> std_new_handler;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt15get_new_handlerv"]
    pub fn std_get_new_handler() -> std_new_handler;
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Temporary_buffer<_Tp> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
    pub _M_original_len: std__Temporary_buffer_size_type,
    pub _M_len: std__Temporary_buffer_size_type,
    pub _M_buffer: std__Temporary_buffer_pointer<_Tp>,
}
pub type std__Temporary_buffer_value_type<_Tp> = _Tp;
pub type std__Temporary_buffer_pointer<_Tp> = *mut std__Temporary_buffer_value_type<_Tp>;
pub type std__Temporary_buffer_iterator<_Tp> = std__Temporary_buffer_pointer<_Tp>;
pub type std__Temporary_buffer_size_type = isize;
pub const std_float_round_style_round_indeterminate: std_float_round_style = -1;
pub const std_float_round_style_round_toward_zero: std_float_round_style = 0;
pub const std_float_round_style_round_to_nearest: std_float_round_style = 1;
pub const std_float_round_style_round_toward_infinity: std_float_round_style = 2;
pub const std_float_round_style_round_toward_neg_infinity: std_float_round_style = 3;
pub type std_float_round_style = ::std::os::raw::c_int;
pub const std_float_denorm_style_denorm_indeterminate: std_float_denorm_style = -1;
pub const std_float_denorm_style_denorm_absent: std_float_denorm_style = 0;
pub const std_float_denorm_style_denorm_present: std_float_denorm_style = 1;
pub type std_float_denorm_style = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___numeric_limits_base {
    pub _address: u8,
}
pub const std___numeric_limits_base_is_specialized: bool = false;
pub const std___numeric_limits_base_digits: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_digits10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_max_digits10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_is_signed: bool = false;
pub const std___numeric_limits_base_is_integer: bool = false;
pub const std___numeric_limits_base_is_exact: bool = false;
pub const std___numeric_limits_base_radix: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_min_exponent: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_min_exponent10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_max_exponent: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_max_exponent10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_has_infinity: bool = false;
pub const std___numeric_limits_base_has_quiet_NaN: bool = false;
pub const std___numeric_limits_base_has_signaling_NaN: bool = false;
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt21__numeric_limits_base10has_denormE"]
    pub static std___numeric_limits_base_has_denorm: std_float_denorm_style;
}
pub const std___numeric_limits_base_has_denorm_loss: bool = false;
pub const std___numeric_limits_base_is_iec559: bool = false;
pub const std___numeric_limits_base_is_bounded: bool = false;
pub const std___numeric_limits_base_is_modulo: bool = false;
pub const std___numeric_limits_base_traps: bool = false;
pub const std___numeric_limits_base_tinyness_before: bool = false;
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt21__numeric_limits_base11round_styleE"]
    pub static std___numeric_limits_base_round_style: std_float_round_style;
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___numeric_limits_base"]
        [::std::mem::size_of::<std___numeric_limits_base>() - 1usize];
    ["Alignment of std___numeric_limits_base"]
        [::std::mem::align_of::<std___numeric_limits_base>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_numeric_limits {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numeric_limits_open0_bool__close0"]
        [::std::mem::size_of::<std_numeric_limits>() - 1usize];
    ["Align of template specialization: std_numeric_limits_open0_bool__close0"]
        [::std::mem::align_of::<std_numeric_limits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numeric_limits_open0_char_close0"]
        [::std::mem::size_of::<std_numeric_limits>() - 1usize];
    ["Align of template specialization: std_numeric_limits_open0_char_close0"]
        [::std::mem::align_of::<std_numeric_limits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numeric_limits_open0_signed_char_close0"]
        [::std::mem::size_of::<std_numeric_limits>() - 1usize];
    ["Align of template specialization: std_numeric_limits_open0_signed_char_close0"]
        [::std::mem::align_of::<std_numeric_limits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numeric_limits_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_numeric_limits>() - 1usize];
    ["Align of template specialization: std_numeric_limits_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_numeric_limits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numeric_limits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_numeric_limits>() - 1usize];
    ["Align of template specialization: std_numeric_limits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_numeric_limits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numeric_limits_open0_char16_t_close0"]
        [::std::mem::size_of::<std_numeric_limits>() - 1usize];
    ["Align of template specialization: std_numeric_limits_open0_char16_t_close0"]
        [::std::mem::align_of::<std_numeric_limits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numeric_limits_open0_char32_t_close0"]
        [::std::mem::size_of::<std_numeric_limits>() - 1usize];
    ["Align of template specialization: std_numeric_limits_open0_char32_t_close0"]
        [::std::mem::align_of::<std_numeric_limits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numeric_limits_open0_short_close0"]
        [::std::mem::size_of::<std_numeric_limits>() - 1usize];
    ["Align of template specialization: std_numeric_limits_open0_short_close0"]
        [::std::mem::align_of::<std_numeric_limits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numeric_limits_open0_unsigned_short_close0"]
        [::std::mem::size_of::<std_numeric_limits>() - 1usize];
    ["Align of template specialization: std_numeric_limits_open0_unsigned_short_close0"]
        [::std::mem::align_of::<std_numeric_limits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numeric_limits_open0_int_close0"]
        [::std::mem::size_of::<std_numeric_limits>() - 1usize];
    ["Align of template specialization: std_numeric_limits_open0_int_close0"]
        [::std::mem::align_of::<std_numeric_limits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numeric_limits_open0_unsigned_int_close0"]
        [::std::mem::size_of::<std_numeric_limits>() - 1usize];
    ["Align of template specialization: std_numeric_limits_open0_unsigned_int_close0"]
        [::std::mem::align_of::<std_numeric_limits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numeric_limits_open0_long_close0"]
        [::std::mem::size_of::<std_numeric_limits>() - 1usize];
    ["Align of template specialization: std_numeric_limits_open0_long_close0"]
        [::std::mem::align_of::<std_numeric_limits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numeric_limits_open0_unsigned_long_close0"]
        [::std::mem::size_of::<std_numeric_limits>() - 1usize];
    ["Align of template specialization: std_numeric_limits_open0_unsigned_long_close0"]
        [::std::mem::align_of::<std_numeric_limits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numeric_limits_open0_long_long_close0"]
        [::std::mem::size_of::<std_numeric_limits>() - 1usize];
    ["Align of template specialization: std_numeric_limits_open0_long_long_close0"]
        [::std::mem::align_of::<std_numeric_limits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numeric_limits_open0_unsigned_long_long_close0"]
        [::std::mem::size_of::<std_numeric_limits>() - 1usize];
    ["Align of template specialization: std_numeric_limits_open0_unsigned_long_long_close0"]
        [::std::mem::align_of::<std_numeric_limits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numeric_limits_open0___int128_close0"]
        [::std::mem::size_of::<std_numeric_limits>() - 1usize];
    ["Align of template specialization: std_numeric_limits_open0___int128_close0"]
        [::std::mem::align_of::<std_numeric_limits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numeric_limits_open0_unsigned___int128_close0"]
        [::std::mem::size_of::<std_numeric_limits>() - 1usize];
    ["Align of template specialization: std_numeric_limits_open0_unsigned___int128_close0"]
        [::std::mem::align_of::<std_numeric_limits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numeric_limits_open0_float_close0"]
        [::std::mem::size_of::<std_numeric_limits>() - 1usize];
    ["Align of template specialization: std_numeric_limits_open0_float_close0"]
        [::std::mem::align_of::<std_numeric_limits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numeric_limits_open0_double_close0"]
        [::std::mem::size_of::<std_numeric_limits>() - 1usize];
    ["Align of template specialization: std_numeric_limits_open0_double_close0"]
        [::std::mem::align_of::<std_numeric_limits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numeric_limits_open0_long_double_close0"]
        [::std::mem::size_of::<std_numeric_limits>() - 1usize];
    ["Align of template specialization: std_numeric_limits_open0_long_double_close0"]
        [::std::mem::align_of::<std_numeric_limits>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uniform_int_distribution<_IntType> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_IntType>>,
    pub _M_param: std_uniform_int_distribution_param_type<_IntType>,
}
pub type std_uniform_int_distribution_result_type<_IntType> = _IntType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uniform_int_distribution_param_type<_IntType> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_IntType>>,
    pub _M_a: _IntType,
    pub _M_b: _IntType,
}
pub type std_uniform_int_distribution_param_type_distribution_type<_IntType> =
    std_uniform_int_distribution<_IntType>;
pub const _S_threshold: std__bindgen_ty_1 = 16;
pub type std__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const _S_chunk_size: std__bindgen_ty_2 = 7;
pub type std__bindgen_ty_2 = ::std::os::raw::c_uint;
pub type std_string = std_basic_string<::std::os::raw::c_char>;
pub type std_wstring = std_basic_string<u32>;
pub type std_u16string = std_basic_string<u16>;
pub type std_u32string = std_basic_string<u32>;
pub type std_streamoff = ::std::os::raw::c_long;
pub type std_streamsize = isize;
#[repr(C)]
#[derive(Debug)]
pub struct std_fpos<_StateT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
    pub _M_off: std_streamoff,
    pub _M_state: _StateT,
}
pub type std_streampos = std_fpos<mbstate_t>;
pub type std_wstreampos = std_fpos<mbstate_t>;
pub type std_u16streampos = std_fpos<mbstate_t>;
pub type std_u32streampos = std_fpos<mbstate_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char16_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char16_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char32_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char32_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
pub type std___allocator_base = __gnu_cxx_new_allocator;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_void_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_void_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_value_type<_Tp> = _Tp;
pub type std_allocator_size_type = usize;
pub type std_allocator_difference_type = isize;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *const _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
pub type std___c_locale = __locale_t;
pub type std_ios = std_basic_ios<::std::os::raw::c_char>;
pub type std_streambuf = std_basic_streambuf<::std::os::raw::c_char>;
pub type std_istream = std_basic_istream<::std::os::raw::c_char>;
pub type std_ostream = std_basic_ostream<::std::os::raw::c_char>;
pub type std_iostream = std_basic_iostream<::std::os::raw::c_char>;
pub type std_stringbuf = std_basic_stringbuf<::std::os::raw::c_char>;
pub type std_istringstream = std_basic_istringstream<::std::os::raw::c_char>;
pub type std_ostringstream = std_basic_ostringstream<::std::os::raw::c_char>;
pub type std_stringstream = std_basic_stringstream<::std::os::raw::c_char>;
pub type std_filebuf = std_basic_filebuf<::std::os::raw::c_char>;
pub type std_ifstream = std_basic_ifstream<::std::os::raw::c_char>;
pub type std_ofstream = std_basic_ofstream<::std::os::raw::c_char>;
pub type std_fstream = std_basic_fstream<::std::os::raw::c_char>;
pub type std_wios = std_basic_ios<u32>;
pub type std_wstreambuf = std_basic_streambuf<u32>;
pub type std_wistream = std_basic_istream<u32>;
pub type std_wostream = std_basic_ostream<u32>;
pub type std_wiostream = std_basic_iostream<u32>;
pub type std_wstringbuf = std_basic_stringbuf<u32>;
pub type std_wistringstream = std_basic_istringstream<u32>;
pub type std_wostringstream = std_basic_ostringstream<u32>;
pub type std_wstringstream = std_basic_stringstream<u32>;
pub type std_wfilebuf = std_basic_filebuf<u32>;
pub type std_wifstream = std_basic_ifstream<u32>;
pub type std_wofstream = std_basic_ofstream<u32>;
pub type std_wfstream = std_basic_fstream<u32>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unary_function {
    pub _address: u8,
}
pub type std_unary_function_argument_type<_Arg> = _Arg;
pub type std_unary_function_result_type<_Result> = _Result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binary_function {
    pub _address: u8,
}
pub type std_binary_function_first_argument_type<_Arg1> = _Arg1;
pub type std_binary_function_second_argument_type<_Arg2> = _Arg2;
pub type std_binary_function_result_type<_Result> = _Result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_plus {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_minus {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_multiplies {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_divides {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_modulus {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_negate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_equal_to {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_not_equal_to {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_greater {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_greater_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_and {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_or {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_not {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_and {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_or {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_xor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_not {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unary_negate<_Predicate> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
    pub _M_pred: _Predicate,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binary_negate<_Predicate> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
    pub _M_pred: _Predicate,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_to_unary_function<_Arg, _Result> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Result>>,
    pub _M_ptr: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Result>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_to_binary_function<_Arg1, _Arg2, _Result> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg1>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg2>>,
    pub _phantom_2: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Result>>,
    pub _M_ptr: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg1, arg2: _Arg2) -> _Result>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Identity {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Select1st {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Select2nd {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun_t<_Ret> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _M_f: ::std::option::Option<unsafe extern "C" fn() -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun_t<_Ret> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _M_f: ::std::option::Option<unsafe extern "C" fn() -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun_ref_t<_Ret> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _M_f: ::std::option::Option<unsafe extern "C" fn() -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun_ref_t<_Ret> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _M_f: ::std::option::Option<unsafe extern "C" fn() -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun1_t<_Ret, _Arg> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
    pub _M_f: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun1_t<_Ret, _Arg> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
    pub _M_f: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun1_ref_t<_Ret, _Arg> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
    pub _M_f: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun1_ref_t<_Ret, _Arg> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
    pub _M_f: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Ret>,
}
#[repr(C)]
pub struct std_binder1st<_Operation> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Operation>>,
    pub op: _Operation,
    pub value: __BindgenOpaqueArray<u8, 0usize>,
}
#[repr(C)]
pub struct std_binder2nd<_Operation> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Operation>>,
    pub op: _Operation,
    pub value: __BindgenOpaqueArray<u8, 0usize>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base___rebind {
    pub _address: u8,
}
pub type std___allocator_traits_base___pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std___allocator_traits_base___c_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std___allocator_traits_base___v_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std___allocator_traits_base___cv_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std___allocator_traits_base___pocca = __BindgenOpaqueArray<u8, 0usize>;
pub type std___allocator_traits_base___pocma = __BindgenOpaqueArray<u8, 0usize>;
pub type std___allocator_traits_base___pocs = __BindgenOpaqueArray<u8, 0usize>;
pub type std___allocator_traits_base___equal = __BindgenOpaqueArray<u8, 0usize>;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___allocator_traits_base"]
        [::std::mem::size_of::<std___allocator_traits_base>() - 1usize];
    ["Alignment of std___allocator_traits_base"]
        [::std::mem::align_of::<std___allocator_traits_base>() - 1usize];
};
pub type std___alloc_rebind = std___allocator_traits_base;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_allocator_traits_pointer = std___detected_or_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Ptr {
    pub _address: u8,
}
pub type std_allocator_traits__Ptr_type = __BindgenOpaqueArray<u8, 0usize>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Diff {
    pub _address: u8,
}
pub type std_allocator_traits__Diff_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Size {
    pub _address: u8,
}
pub type std_allocator_traits_const_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std_allocator_traits_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_const_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_difference_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_allocator_traits_size_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_allocator_traits_propagate_on_container_copy_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_move_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_swap = std___detected_or_t;
pub type std_allocator_traits_is_always_equal = std___detected_or_t;
pub type std_allocator_traits_rebind_alloc = std___alloc_rebind;
pub type std_allocator_traits_rebind_traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits___construct_helper {
    pub _address: u8,
}
pub type std_allocator_traits___construct_helper_type<_Alloc> = _Alloc;
pub type std_allocator_traits___has_construct = std_allocator_traits___construct_helper;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_traits_open0_std_allocator_open1_void_close1_close0",
    ][::std::mem::size_of::<std_allocator_traits>() - 1usize];
    [
        "Align of template specialization: std_allocator_traits_open0_std_allocator_open1_void_close1_close0",
    ][::std::mem::align_of::<std_allocator_traits>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_alloc_insertable_impl {
    pub _base: std_false_type,
}
#[repr(C)]
pub struct std___is_copy_insertable {
    pub _address: u8,
}
#[repr(C)]
pub struct std___is_move_insertable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_allocator {
    pub _base: std_false_type,
}
pub type std__RequireAllocator = u8;
pub type std__RequireNotAllocator = u8;
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt7getlineIcSt11char_traitsIcESaIcEERSt13basic_istreamIT_T0_ES7_RNSt7__cxx1112basic_stringIS4_S5_T1_EES4_"]
    pub fn std_getline(
        __in: *mut std_basic_istream<::std::os::raw::c_char>,
        __str: *mut std_basic_string<::std::os::raw::c_char>,
        __delim: ::std::os::raw::c_char,
    ) -> *mut std_basic_istream<::std::os::raw::c_char>;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt7getlineIwSt11char_traitsIwESaIwEERSt13basic_istreamIT_T0_ES7_RNSt7__cxx1112basic_stringIS4_S5_T1_EES4_"]
    pub fn std_getline1(
        __in: *mut std_basic_istream<u32>,
        __str: *mut std_basic_string<u32>,
        __delim: u32,
    ) -> *mut std_basic_istream<u32>;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___hash_base {
    pub _address: u8,
}
pub type std___hash_base_result_type<_Result> = _Result;
pub type std___hash_base_argument_type<_Arg> = _Arg;
#[repr(C)]
#[derive(Debug)]
pub struct std___poison_hash {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_hash {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_hash_open0_bool__close0"]
        [::std::mem::size_of::<std_hash>() - 1usize];
    ["Align of template specialization: std_hash_open0_bool__close0"]
        [::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_hash_open0_char_close0"]
        [::std::mem::size_of::<std_hash>() - 1usize];
    ["Align of template specialization: std_hash_open0_char_close0"]
        [::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_hash_open0_signed_char_close0"]
        [::std::mem::size_of::<std_hash>() - 1usize];
    ["Align of template specialization: std_hash_open0_signed_char_close0"]
        [::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_hash_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_hash>() - 1usize];
    ["Align of template specialization: std_hash_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_hash_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_hash>() - 1usize];
    ["Align of template specialization: std_hash_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_hash_open0_char16_t_close0"]
        [::std::mem::size_of::<std_hash>() - 1usize];
    ["Align of template specialization: std_hash_open0_char16_t_close0"]
        [::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_hash_open0_char32_t_close0"]
        [::std::mem::size_of::<std_hash>() - 1usize];
    ["Align of template specialization: std_hash_open0_char32_t_close0"]
        [::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_hash_open0_short_close0"]
        [::std::mem::size_of::<std_hash>() - 1usize];
    ["Align of template specialization: std_hash_open0_short_close0"]
        [::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_hash_open0_int_close0"]
        [::std::mem::size_of::<std_hash>() - 1usize];
    ["Align of template specialization: std_hash_open0_int_close0"]
        [::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_hash_open0_long_close0"]
        [::std::mem::size_of::<std_hash>() - 1usize];
    ["Align of template specialization: std_hash_open0_long_close0"]
        [::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_hash_open0_long_long_close0"]
        [::std::mem::size_of::<std_hash>() - 1usize];
    ["Align of template specialization: std_hash_open0_long_long_close0"]
        [::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_hash_open0_unsigned_short_close0"]
        [::std::mem::size_of::<std_hash>() - 1usize];
    ["Align of template specialization: std_hash_open0_unsigned_short_close0"]
        [::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_hash_open0_unsigned_int_close0"]
        [::std::mem::size_of::<std_hash>() - 1usize];
    ["Align of template specialization: std_hash_open0_unsigned_int_close0"]
        [::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_hash_open0_unsigned_long_close0"]
        [::std::mem::size_of::<std_hash>() - 1usize];
    ["Align of template specialization: std_hash_open0_unsigned_long_close0"]
        [::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_hash_open0_unsigned_long_long_close0"]
        [::std::mem::size_of::<std_hash>() - 1usize];
    ["Align of template specialization: std_hash_open0_unsigned_long_long_close0"]
        [::std::mem::align_of::<std_hash>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Hash_impl {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std__Hash_impl"][::std::mem::size_of::<std__Hash_impl>() - 1usize];
    ["Alignment of std__Hash_impl"][::std::mem::align_of::<std__Hash_impl>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Fnv_hash_impl {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std__Fnv_hash_impl"][::std::mem::size_of::<std__Fnv_hash_impl>() - 1usize];
    ["Alignment of std__Fnv_hash_impl"][::std::mem::align_of::<std__Fnv_hash_impl>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_hash_open0_float_close0"]
        [::std::mem::size_of::<std_hash>() - 1usize];
    ["Align of template specialization: std_hash_open0_float_close0"]
        [::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_hash_open0_double_close0"]
        [::std::mem::size_of::<std_hash>() - 1usize];
    ["Align of template specialization: std_hash_open0_double_close0"]
        [::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_hash_open0_long_double_close0"]
        [::std::mem::size_of::<std_hash>() - 1usize];
    ["Align of template specialization: std_hash_open0_long_double_close0"]
        [::std::mem::align_of::<std_hash>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_fast_hash {
    pub _base: std_true_type,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std___is_fast_hash_open0_std_hash_open1_long_double_close1_close0",
    ][::std::mem::size_of::<std___is_fast_hash>() - 1usize];
    [
        "Align of template specialization: std___is_fast_hash_open0_std_hash_open1_long_double_close1_close0",
    ][::std::mem::align_of::<std___is_fast_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_hash_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_hash>() - 1usize];
    [
        "Align of template specialization: std_hash_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std___is_fast_hash_open0_std_hash_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::size_of::<std___is_fast_hash>() - 1usize];
    [
        "Align of template specialization: std___is_fast_hash_open0_std_hash_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::align_of::<std___is_fast_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_hash_open0_std_basic_string_open1_wchar_t_std_char_traits_open2_wchar_t_close2_std_allocator_open2_wchar_t_close2_close1_close0",
    ][::std::mem::size_of::<std_hash>() - 1usize];
    [
        "Align of template specialization: std_hash_open0_std_basic_string_open1_wchar_t_std_char_traits_open2_wchar_t_close2_std_allocator_open2_wchar_t_close2_close1_close0",
    ][::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std___is_fast_hash_open0_std_hash_open1_std_basic_string_open2_wchar_t_std_char_traits_open3_wchar_t_close3_std_allocator_open3_wchar_t_close3_close2_close1_close0",
    ][::std::mem::size_of::<std___is_fast_hash>() - 1usize];
    [
        "Align of template specialization: std___is_fast_hash_open0_std_hash_open1_std_basic_string_open2_wchar_t_std_char_traits_open3_wchar_t_close3_std_allocator_open3_wchar_t_close3_close2_close1_close0",
    ][::std::mem::align_of::<std___is_fast_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_hash_open0_std_basic_string_open1_char16_t_std_char_traits_open2_char16_t_close2_std_allocator_open2_char16_t_close2_close1_close0",
    ][::std::mem::size_of::<std_hash>() - 1usize];
    [
        "Align of template specialization: std_hash_open0_std_basic_string_open1_char16_t_std_char_traits_open2_char16_t_close2_std_allocator_open2_char16_t_close2_close1_close0",
    ][::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std___is_fast_hash_open0_std_hash_open1_std_basic_string_open2_char16_t_std_char_traits_open3_char16_t_close3_std_allocator_open3_char16_t_close3_close2_close1_close0",
    ][::std::mem::size_of::<std___is_fast_hash>() - 1usize];
    [
        "Align of template specialization: std___is_fast_hash_open0_std_hash_open1_std_basic_string_open2_char16_t_std_char_traits_open3_char16_t_close3_std_allocator_open3_char16_t_close3_close2_close1_close0",
    ][::std::mem::align_of::<std___is_fast_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_hash_open0_std_basic_string_open1_char32_t_std_char_traits_open2_char32_t_close2_std_allocator_open2_char32_t_close2_close1_close0",
    ][::std::mem::size_of::<std_hash>() - 1usize];
    [
        "Align of template specialization: std_hash_open0_std_basic_string_open1_char32_t_std_char_traits_open2_char32_t_close2_std_allocator_open2_char32_t_close2_close1_close0",
    ][::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std___is_fast_hash_open0_std_hash_open1_std_basic_string_open2_char32_t_std_char_traits_open3_char32_t_close3_std_allocator_open3_char32_t_close3_close2_close1_close0",
    ][::std::mem::size_of::<std___is_fast_hash>() - 1usize];
    [
        "Align of template specialization: std___is_fast_hash_open0_std_hash_open1_std_basic_string_open2_char32_t_std_char_traits_open3_char32_t_close3_std_allocator_open3_char32_t_close3_close2_close1_close0",
    ][::std::mem::align_of::<std___is_fast_hash>() - 1usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}npos"]
    pub static std_npos: std_basic_string_size_type;
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_string<u32>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_string<u32>>() - 8usize];
};
pub type std_size_type = size_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_bitwise_relocatable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_raw_storage_iterator<_OutputIterator> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_OutputIterator>>,
    pub _M_iter: _OutputIterator,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___erased_type {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___erased_type"][::std::mem::size_of::<std___erased_type>() - 1usize];
    ["Alignment of std___erased_type"][::std::mem::align_of::<std___erased_type>() - 1usize];
};
pub type std___is_erased_or_convertible = std___or_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_arg_t {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_allocator_arg_t"][::std::mem::size_of::<std_allocator_arg_t>() - 1usize];
    ["Alignment of std_allocator_arg_t"][::std::mem::align_of::<std_allocator_arg_t>() - 1usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZStL13allocator_arg"]
    pub static std_allocator_arg: std_allocator_arg_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_allocator_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uses_allocator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc_base {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___uses_alloc_base"][::std::mem::size_of::<std___uses_alloc_base>() - 1usize];
    ["Alignment of std___uses_alloc_base"]
        [::std::mem::align_of::<std___uses_alloc_base>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc0 {
    pub _M_a: std___uses_alloc0__Sink,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc0__Sink {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___uses_alloc0__Sink"][::std::mem::size_of::<std___uses_alloc0__Sink>() - 1usize];
    ["Alignment of std___uses_alloc0__Sink"]
        [::std::mem::align_of::<std___uses_alloc0__Sink>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___uses_alloc0"][::std::mem::size_of::<std___uses_alloc0>() - 1usize];
    ["Alignment of std___uses_alloc0"][::std::mem::align_of::<std___uses_alloc0>() - 1usize];
    ["Offset of field: std___uses_alloc0::_M_a"]
        [::std::mem::offset_of!(std___uses_alloc0, _M_a) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc1<_Alloc> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
    pub _M_a: *const _Alloc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc2<_Alloc> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
    pub _M_a: *const _Alloc,
}
pub type std___uses_alloc_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_uses_allocator_predicate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_uses_allocator_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_uses_allocator_constructible {
    pub _address: u8,
}
pub type std___can_invoke_as_void = std___enable_if_t;
pub type std___can_invoke_as_nonvoid = std___enable_if_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_empty_non_tuple {
    pub _address: u8,
}
pub type std___empty_not_final = u8;
pub type std__TupleConstraints_is_constructible = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple {
    pub _address: u8,
}
pub type std_tuple__Inherited = u8;
pub type std_tuple__TCC = u8;
pub type std_tuple__ImplicitDefaultCtor = std___enable_if_t;
pub type std_tuple__ExplicitDefaultCtor = std___enable_if_t;
pub type std_tuple__ImplicitCtor = std___enable_if_t;
pub type std_tuple__ExplicitCtor = std___enable_if_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__UseOtherCtor {
    pub _base: std_false_type,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_tuple_open0_close0"]
        [::std::mem::size_of::<std_tuple>() - 1usize];
    ["Align of template specialization: std_tuple_open0_close0"]
        [::std::mem::align_of::<std_tuple>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_make_tuple {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_tuple {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___combine_tuples {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___combine_tuples_open0_close0"]
        [::std::mem::size_of::<std___combine_tuples>() - 1usize];
    ["Align of template specialization: std___combine_tuples_open0_close0"]
        [::std::mem::align_of::<std___combine_tuples>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tuple_cat_result {
    pub _address: u8,
}
pub type std___tuple_cat_result___type = std___combine_tuples;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_1st_indices {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___make_1st_indices_open0_close0"]
        [::std::mem::size_of::<std___make_1st_indices>() - 1usize];
    ["Align of template specialization: std___make_1st_indices_open0_close0"]
        [::std::mem::align_of::<std___make_1st_indices>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tuple_concater {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Swallow_assign {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std__Swallow_assign"][::std::mem::size_of::<std__Swallow_assign>() - 1usize];
    ["Alignment of std__Swallow_assign"][::std::mem::align_of::<std__Swallow_assign>() - 1usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZStL6ignore"]
    pub static std_ignore: std__Swallow_assign;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uniq_ptr_impl {
    pub _M_t: std_tuple,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uniq_ptr_impl__Ptr {
    pub _address: u8,
}
pub type std___uniq_ptr_impl__Ptr_type<_Up> = *mut _Up;
pub type std___uniq_ptr_impl__DeleterConstraint = u8;
pub type std___uniq_ptr_impl_pointer = std___uniq_ptr_impl__Ptr;
#[repr(C)]
#[derive(Debug)]
pub struct std_unique_ptr {
    pub _M_t: u8,
}
pub type std_unique_ptr__DeleterConstraint = std___uniq_ptr_impl;
pub type std_unique_ptr_pointer = std___uniq_ptr_impl;
pub type std_unique_ptr_element_type<_Tp> = _Tp;
pub type std_unique_ptr_deleter_type<_Dp> = _Dp;
pub type std_unique_ptr___safe_conversion_up = std___and_;
#[repr(C)]
#[derive(Debug)]
pub struct std___allocated_ptr<_Alloc> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
    pub _M_alloc: *mut _Alloc,
    pub _M_ptr: std___allocated_ptr_pointer,
}
pub type std___allocated_ptr_pointer = std_allocator_traits;
pub type std___allocated_ptr_value_type = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Maybe_unary_or_binary_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Mem_fn_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Mem_fn_traits_base {
    pub _address: u8,
}
pub type std__Mem_fn_traits_base___result_type<_Res> = _Res;
pub type std__Mem_fn_traits_base___maybe_type = std__Maybe_unary_or_binary_function;
pub type std__Mem_fn_traits_base___arity = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Maybe_get_result_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Weak_result_type_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Weak_result_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Refwrap_base_arg1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Refwrap_base_arg2 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Reference_wrapper_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reference_wrapper<_Tp> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
    pub _M_data: *mut _Tp,
}
pub type std_reference_wrapper___not_same = u8;
pub type std_reference_wrapper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_weak_ptr {
    pub _base: std_exception,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_bad_weak_ptr"][::std::mem::size_of::<std_bad_weak_ptr>() - 8usize];
    ["Alignment of std_bad_weak_ptr"][::std::mem::align_of::<std_bad_weak_ptr>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt12bad_weak_ptr4whatEv"]
    pub fn std_bad_weak_ptr_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12bad_weak_ptrD1Ev"]
    pub fn std_bad_weak_ptr_bad_weak_ptr_destructor(this: *mut std_bad_weak_ptr);
}
pub const std__Mutex_base__S_need_barriers: std__Mutex_base__bindgen_ty_1 = 0;
pub type std__Mutex_base__bindgen_ty_1 = i32;
unsafe extern "C" {
    #[link_name = "\u{1}_M_add_ref_lock"]
    pub fn std__Sp_counted_base__M_add_ref_lock(this: *mut u8);
}
unsafe extern "C" {
    #[link_name = "\u{1}_M_add_ref_lock_nothrow"]
    pub fn std__Sp_counted_base__M_add_ref_lock_nothrow(this: *mut u8) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_owner_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_counted_deleter__Impl<_Ptr> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ptr>>,
    pub _M_ptr: _Ptr,
}
pub type std__Sp_counted_deleter__Impl__Del_base = u8;
pub type std__Sp_counted_deleter__Impl__Alloc_base = u8;
pub type std__Sp_counted_deleter___allocator_type = std___alloc_rebind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_make_shared_tag {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std__Sp_make_shared_tag"][::std::mem::size_of::<std__Sp_make_shared_tag>() - 1usize];
    ["Alignment of std__Sp_make_shared_tag"]
        [::std::mem::align_of::<std__Sp_make_shared_tag>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_alloc_shared_tag<_Alloc> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
    pub _M_a: *const _Alloc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_counted_ptr_inplace__Impl {
    pub _M_storage: __gnu_cxx___aligned_buffer,
}
pub type std__Sp_counted_ptr_inplace__Impl__A_base = u8;
pub type std__Sp_counted_ptr_inplace___allocator_type = std___alloc_rebind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___sp_array_delete {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___sp_array_delete"][::std::mem::size_of::<std___sp_array_delete>() - 1usize];
    ["Alignment of std___sp_array_delete"]
        [::std::mem::align_of::<std___sp_array_delete>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___shared_count___not_alloc_shared_tag {
    pub _address: u8,
}
pub type std___shared_count___not_alloc_shared_tag_type = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___sp_compatible_with {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___sp_is_constructible_arr {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___sp_is_constructible {
    pub _address: u8,
}
pub type std___shared_ptr_access_element_type<_Tp> = _Tp;
pub type std___shared_ptr_element_type = std_remove_extent;
pub type std___shared_ptr__SafeConv = u8;
pub type std___shared_ptr__Compatible = u8;
pub type std___shared_ptr__Assignable = std___shared_ptr__Compatible;
pub type std___shared_ptr__UniqCompatible = std___enable_if_t;
pub type std___shared_ptr__UniqAssignable = std___shared_ptr__UniqCompatible;
pub type std___shared_ptr___esft_base_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___shared_ptr___has_esft_base {
    pub _base: std_false_type,
}
pub type std___weak_ptr__Compatible = u8;
pub type std___weak_ptr__Assignable = std___weak_ptr__Compatible;
pub type std___weak_ptr_element_type = std_remove_extent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_owner_less {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std__Sp_owner_less_open0_void_void_close0"]
        [::std::mem::size_of::<std__Sp_owner_less>() - 1usize];
    ["Align of template specialization: std__Sp_owner_less_open0_void_void_close0"]
        [::std::mem::align_of::<std__Sp_owner_less>() - 1usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct std_shared_ptr {
    pub _address: u8,
}
pub type std_shared_ptr__Constructible = u8;
pub type std_shared_ptr__Assignable = u8;
pub type std_shared_ptr_element_type = u8;
#[repr(C)]
#[derive(Debug)]
pub struct std_weak_ptr {
    pub _address: u8,
}
pub type std_weak_ptr__Constructible = u8;
pub type std_weak_ptr__Assignable = u8;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_owner_less_open0_void_close0"]
        [::std::mem::size_of::<std_owner_less>() - 1usize];
    ["Align of template specialization: std_owner_less_open0_void_close0"]
        [::std::mem::align_of::<std_owner_less>() - 1usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct std_enable_shared_from_this {
    pub _M_weak_this: std_weak_ptr,
}
pub const std_memory_order_memory_order_relaxed: std_memory_order = 0;
pub const std_memory_order_memory_order_consume: std_memory_order = 1;
pub const std_memory_order_memory_order_acquire: std_memory_order = 2;
pub const std_memory_order_memory_order_release: std_memory_order = 3;
pub const std_memory_order_memory_order_acq_rel: std_memory_order = 4;
pub const std_memory_order_memory_order_seq_cst: std_memory_order = 5;
pub type std_memory_order = ::std::os::raw::c_uint;
pub const std___memory_order_modifier___memory_order_mask: std___memory_order_modifier = 65535;
pub const std___memory_order_modifier___memory_order_modifier_mask: std___memory_order_modifier =
    4294901760;
pub const std___memory_order_modifier___memory_order_hle_acquire: std___memory_order_modifier =
    65536;
pub const std___memory_order_modifier___memory_order_hle_release: std___memory_order_modifier =
    131072;
pub type std___memory_order_modifier = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_atomic {
    pub _address: u8,
}
pub type std___atomic_flag_data_type = bool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___atomic_flag_base {
    pub _M_i: std___atomic_flag_data_type,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___atomic_flag_base"][::std::mem::size_of::<std___atomic_flag_base>() - 1usize];
    ["Alignment of std___atomic_flag_base"]
        [::std::mem::align_of::<std___atomic_flag_base>() - 1usize];
    ["Offset of field: std___atomic_flag_base::_M_i"]
        [::std::mem::offset_of!(std___atomic_flag_base, _M_i) - 0usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct std_atomic_flag {
    pub _base: std___atomic_flag_base,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_atomic_flag"][::std::mem::size_of::<std_atomic_flag>() - 1usize];
    ["Alignment of std_atomic_flag"][::std::mem::align_of::<std_atomic_flag>() - 1usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct std___atomic_base<_ITp> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_ITp>>,
    pub _M_i: std___atomic_base___int_type<_ITp>,
}
pub type std___atomic_base_value_type<_ITp> = _ITp;
pub type std___atomic_base_difference_type<_ITp> = std___atomic_base_value_type<_ITp>;
pub type std___atomic_base___int_type<_ITp> = _ITp;
#[repr(C)]
#[derive(Debug)]
pub struct std__Sp_locker {
    pub _M_key1: ::std::os::raw::c_uchar,
    pub _M_key2: ::std::os::raw::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std__Sp_locker"][::std::mem::size_of::<std__Sp_locker>() - 2usize];
    ["Alignment of std__Sp_locker"][::std::mem::align_of::<std__Sp_locker>() - 1usize];
    ["Offset of field: std__Sp_locker::_M_key1"]
        [::std::mem::offset_of!(std__Sp_locker, _M_key1) - 0usize];
    ["Offset of field: std__Sp_locker::_M_key2"]
        [::std::mem::offset_of!(std__Sp_locker, _M_key2) - 1usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10_Sp_lockerC1EPKv"]
    pub fn std__Sp_locker__Sp_locker(
        this: *mut std__Sp_locker,
        arg1: *const ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10_Sp_lockerC1EPKvS1_"]
    pub fn std__Sp_locker__Sp_locker1(
        this: *mut std__Sp_locker,
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10_Sp_lockerD1Ev"]
    pub fn std__Sp_locker__Sp_locker_destructor(this: *mut std__Sp_locker);
}
impl std__Sp_locker {
    #[inline]
    pub unsafe fn new(arg1: *const ::std::os::raw::c_void) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std__Sp_locker__Sp_locker(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std__Sp_locker__Sp_locker1(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std__Sp_locker__Sp_locker_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_auto_ptr_ref<_Tp1> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp1>>,
    pub _M_ptr: *mut _Tp1,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_auto_ptr<_Tp> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
    pub _M_ptr: *mut _Tp,
}
pub type std_auto_ptr_element_type<_Tp> = _Tp;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_auto_ptr_open0_void_close0"]
        [::std::mem::size_of::<std_auto_ptr<::std::os::raw::c_void>>() - 1usize];
    ["Align of template specialization: std_auto_ptr_open0_void_close0"]
        [::std::mem::align_of::<std_auto_ptr<::std::os::raw::c_void>>() - 1usize];
};
pub const std_pointer_safety_relaxed: std_pointer_safety = 0;
pub const std_pointer_safety_preferred: std_pointer_safety = 1;
pub const std_pointer_safety_strict: std_pointer_safety = 2;
pub type std_pointer_safety = ::std::os::raw::c_int;
#[repr(C)]
pub struct std__Vector_base {
    pub _M_impl: std__Vector_base__Vector_impl,
}
pub type std__Vector_base__Tp_alloc_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Vector_base_pointer = __BindgenOpaqueArray<u8, 0usize>;
#[repr(C)]
pub struct std__Vector_base__Vector_impl_data {
    pub _M_start: std__Vector_base_pointer,
    pub _M_finish: std__Vector_base_pointer,
    pub _M_end_of_storage: std__Vector_base_pointer,
}
#[repr(C)]
pub struct std__Vector_base__Vector_impl {
    pub _base_1: std__Vector_base__Vector_impl_data,
}
pub type std__Vector_base_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
pub struct std_vector {
    pub _base: std__Vector_base,
}
pub type std_vector__Base = std__Vector_base;
pub type std_vector__Tp_alloc_type = std_vector__Base;
pub type std_vector__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_vector_value_type<_Tp> = _Tp;
pub type std_vector_pointer = std_vector__Base;
pub type std_vector_const_pointer = std_vector__Alloc_traits;
pub type std_vector_reference = std_vector__Alloc_traits;
pub type std_vector_const_reference = std_vector__Alloc_traits;
pub type std_vector_iterator = __gnu_cxx___normal_iterator<std_vector_pointer>;
pub type std_vector_const_iterator = __gnu_cxx___normal_iterator<std_vector_const_pointer>;
pub type std_vector_const_reverse_iterator = std_reverse_iterator<std_vector_const_iterator>;
pub type std_vector_reverse_iterator = std_reverse_iterator<std_vector_iterator>;
pub type std_vector_size_type = usize;
pub type std_vector_difference_type = isize;
pub type std_vector_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
#[derive(Debug)]
pub struct std_vector__Temporary_value {
    pub _M_this: *mut std_vector,
    pub __buf: u8,
}
pub type std__Bit_type = ::std::os::raw::c_ulong;
pub const _S_word_bit: std__bindgen_ty_3 = 64;
pub type std__bindgen_ty_3 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bit_reference {
    pub _M_p: *mut std__Bit_type,
    pub _M_mask: std__Bit_type,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std__Bit_reference"][::std::mem::size_of::<std__Bit_reference>() - 16usize];
    ["Alignment of std__Bit_reference"][::std::mem::align_of::<std__Bit_reference>() - 8usize];
    ["Offset of field: std__Bit_reference::_M_p"]
        [::std::mem::offset_of!(std__Bit_reference, _M_p) - 0usize];
    ["Offset of field: std__Bit_reference::_M_mask"]
        [::std::mem::offset_of!(std__Bit_reference, _M_mask) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bit_iterator_base {
    pub _M_p: *mut std__Bit_type,
    pub _M_offset: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std__Bit_iterator_base"][::std::mem::size_of::<std__Bit_iterator_base>() - 16usize];
    ["Alignment of std__Bit_iterator_base"]
        [::std::mem::align_of::<std__Bit_iterator_base>() - 8usize];
    ["Offset of field: std__Bit_iterator_base::_M_p"]
        [::std::mem::offset_of!(std__Bit_iterator_base, _M_p) - 0usize];
    ["Offset of field: std__Bit_iterator_base::_M_offset"]
        [::std::mem::offset_of!(std__Bit_iterator_base, _M_offset) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bit_iterator {
    pub _base: std__Bit_iterator_base,
}
pub type std__Bit_iterator_reference = std__Bit_reference;
pub type std__Bit_iterator_pointer = *mut std__Bit_reference;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std__Bit_iterator"][::std::mem::size_of::<std__Bit_iterator>() - 16usize];
    ["Alignment of std__Bit_iterator"][::std::mem::align_of::<std__Bit_iterator>() - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bit_const_iterator {
    pub _base: std__Bit_iterator_base,
}
pub type std__Bit_const_iterator_reference = bool;
pub type std__Bit_const_iterator_const_reference = bool;
pub type std__Bit_const_iterator_pointer = *const bool;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std__Bit_const_iterator"][::std::mem::size_of::<std__Bit_const_iterator>() - 16usize];
    ["Alignment of std__Bit_const_iterator"]
        [::std::mem::align_of::<std__Bit_const_iterator>() - 8usize];
};
#[repr(C)]
pub struct std__Bvector_base {
    pub _M_impl: std__Bvector_base__Bvector_impl,
}
pub type std__Bvector_base__Bit_alloc_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Bvector_base__Bit_alloc_traits = __gnu_cxx___alloc_traits;
pub type std__Bvector_base__Bit_pointer = __BindgenOpaqueArray<u8, 0usize>;
#[repr(C)]
pub struct std__Bvector_base__Bvector_impl_data {
    pub _M_start: std__Bit_iterator,
    pub _M_finish: std__Bit_iterator,
    pub _M_end_of_storage: std__Bvector_base__Bit_pointer,
}
#[repr(C)]
pub struct std__Bvector_base__Bvector_impl {
    pub _base_1: std__Bvector_base__Bvector_impl_data,
}
pub type std__Bvector_base_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
#[derive(Debug)]
pub struct std_locale {
    pub _M_impl: *mut std_locale__Impl,
}
pub type std_locale_category = ::std::os::raw::c_int;
pub const std_locale__S_categories_size: std_locale__bindgen_ty_1 = 12;
pub type std_locale__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const std_locale_none: std_locale_category = 0;
pub const std_locale_ctype: std_locale_category = 1;
pub const std_locale_numeric: std_locale_category = 2;
pub const std_locale_collate: std_locale_category = 4;
pub const std_locale_time: std_locale_category = 8;
pub const std_locale_monetary: std_locale_category = 16;
pub const std_locale_messages: std_locale_category = 32;
pub const std_locale_all: std_locale_category = 63;
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale10_S_classicE"]
    pub static mut std_locale__S_classic: *mut std_locale__Impl;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale9_S_globalE"]
    pub static mut std_locale__S_global: *mut std_locale__Impl;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale13_S_categoriesE"]
    pub static std_locale__S_categories: *const *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale7_S_onceE"]
    pub static mut std_locale__S_once: __gthread_once_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale17_S_twinned_facetsE"]
    pub static std_locale__S_twinned_facets: [*const std_locale_id; 0usize];
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_locale"][::std::mem::size_of::<std_locale>() - 8usize];
    ["Alignment of std_locale"][::std::mem::align_of::<std_locale>() - 8usize];
    ["Offset of field: std_locale::_M_impl"][::std::mem::offset_of!(std_locale, _M_impl) - 0usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt6locale4nameB5cxx11Ev"]
    pub fn std_locale_name(this: *const std_locale) -> std_string;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale6globalERKS_"]
    pub fn std_locale_global(__loc: *const std_locale) -> std_locale;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale7classicEv"]
    pub fn std_locale_classic() -> *const std_locale;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6localeC1Ev"]
    pub fn std_locale_locale(this: *mut std_locale);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6localeC1ERKS_"]
    pub fn std_locale_locale1(this: *mut std_locale, __other: *const std_locale);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6localeC1EPKc"]
    pub fn std_locale_locale2(this: *mut std_locale, __s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6localeC1ERKS_PKci"]
    pub fn std_locale_locale3(
        this: *mut std_locale,
        __base: *const std_locale,
        __s: *const ::std::os::raw::c_char,
        __cat: std_locale_category,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6localeC1ERKS_S1_i"]
    pub fn std_locale_locale4(
        this: *mut std_locale,
        __base: *const std_locale,
        __add: *const std_locale,
        __cat: std_locale_category,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6localeD1Ev"]
    pub fn std_locale_locale_destructor(this: *mut std_locale);
}
impl std_locale {
    #[inline]
    pub unsafe fn name(&self) -> std_string {
        std_locale_name(self)
    }
    #[inline]
    pub unsafe fn global(__loc: *const std_locale) -> std_locale {
        std_locale_global(__loc)
    }
    #[inline]
    pub unsafe fn classic() -> *const std_locale {
        std_locale_classic()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(__other: *const std_locale) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale1(__bindgen_tmp.as_mut_ptr(), __other);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(__s: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale2(__bindgen_tmp.as_mut_ptr(), __s);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(
        __base: *const std_locale,
        __s: *const ::std::os::raw::c_char,
        __cat: std_locale_category,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale3(__bindgen_tmp.as_mut_ptr(), __base, __s, __cat);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(
        __base: *const std_locale,
        __add: *const std_locale,
        __cat: std_locale_category,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale4(__bindgen_tmp.as_mut_ptr(), __base, __add, __cat);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_locale_locale_destructor(self)
    }
}
#[repr(C)]
pub struct std_locale_facet__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_locale_facet {
    pub vtable_: *const std_locale_facet__bindgen_vtable,
    pub _M_refcount: _Atomic_word,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_locale_facet___shim {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet11_S_c_localeE"]
    pub static mut std_locale_facet__S_c_locale: std___c_locale;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet9_S_c_nameE"]
    pub static std_locale_facet__S_c_name: [::std::os::raw::c_char; 2usize];
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet7_S_onceE"]
    pub static mut std_locale_facet__S_once: __gthread_once_t;
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_locale_facet"][::std::mem::size_of::<std_locale_facet>() - 16usize];
    ["Alignment of std_locale_facet"][::std::mem::align_of::<std_locale_facet>() - 8usize];
    ["Offset of field: std_locale_facet::_M_refcount"]
        [::std::mem::offset_of!(std_locale_facet, _M_refcount) - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet18_S_create_c_localeERP15__locale_structPKcS2_"]
    pub fn std_locale_facet__S_create_c_locale(
        __cloc: *mut std___c_locale,
        __s: *const ::std::os::raw::c_char,
        __old: std___c_locale,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet17_S_clone_c_localeERP15__locale_struct"]
    pub fn std_locale_facet__S_clone_c_locale(__cloc: *mut std___c_locale) -> std___c_locale;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet19_S_destroy_c_localeERP15__locale_struct"]
    pub fn std_locale_facet__S_destroy_c_locale(__cloc: *mut std___c_locale);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet20_S_lc_ctype_c_localeEP15__locale_structPKc"]
    pub fn std_locale_facet__S_lc_ctype_c_locale(
        __cloc: std___c_locale,
        __s: *const ::std::os::raw::c_char,
    ) -> std___c_locale;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet15_S_get_c_localeEv"]
    pub fn std_locale_facet__S_get_c_locale() -> std___c_locale;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet13_S_get_c_nameEv"]
    pub fn std_locale_facet__S_get_c_name() -> *const ::std::os::raw::c_char;
}
impl std_locale_facet {
    #[inline]
    pub unsafe fn _S_create_c_locale(
        __cloc: *mut std___c_locale,
        __s: *const ::std::os::raw::c_char,
        __old: std___c_locale,
    ) {
        std_locale_facet__S_create_c_locale(__cloc, __s, __old)
    }
    #[inline]
    pub unsafe fn _S_clone_c_locale(__cloc: *mut std___c_locale) -> std___c_locale {
        std_locale_facet__S_clone_c_locale(__cloc)
    }
    #[inline]
    pub unsafe fn _S_destroy_c_locale(__cloc: *mut std___c_locale) {
        std_locale_facet__S_destroy_c_locale(__cloc)
    }
    #[inline]
    pub unsafe fn _S_lc_ctype_c_locale(
        __cloc: std___c_locale,
        __s: *const ::std::os::raw::c_char,
    ) -> std___c_locale {
        std_locale_facet__S_lc_ctype_c_locale(__cloc, __s)
    }
    #[inline]
    pub unsafe fn _S_get_c_locale() -> std___c_locale {
        std_locale_facet__S_get_c_locale()
    }
    #[inline]
    pub unsafe fn _S_get_c_name() -> *const ::std::os::raw::c_char {
        std_locale_facet__S_get_c_name()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facetD1Ev"]
    pub fn std_locale_facet_facet_destructor(this: *mut std_locale_facet);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_locale_id {
    pub _M_index: usize,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale2id11_S_refcountE"]
    pub static mut std_locale_id__S_refcount: _Atomic_word;
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_locale_id"][::std::mem::size_of::<std_locale_id>() - 8usize];
    ["Alignment of std_locale_id"][::std::mem::align_of::<std_locale_id>() - 8usize];
    ["Offset of field: std_locale_id::_M_index"]
        [::std::mem::offset_of!(std_locale_id, _M_index) - 0usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt6locale2id5_M_idEv"]
    pub fn std_locale_id__M_id(this: *const std_locale_id) -> usize;
}
impl std_locale_id {
    #[inline]
    pub unsafe fn _M_id(&self) -> usize {
        std_locale_id__M_id(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_locale__Impl {
    pub _M_refcount: _Atomic_word,
    pub _M_facets: *mut *const std_locale_facet,
    pub _M_facets_size: usize,
    pub _M_caches: *mut *const std_locale_facet,
    pub _M_names: *mut *mut ::std::os::raw::c_char,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl11_S_id_ctypeE"]
    pub static std_locale__Impl__S_id_ctype: [*const std_locale_id; 0usize];
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl13_S_id_numericE"]
    pub static std_locale__Impl__S_id_numeric: [*const std_locale_id; 0usize];
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl13_S_id_collateE"]
    pub static std_locale__Impl__S_id_collate: [*const std_locale_id; 0usize];
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl10_S_id_timeE"]
    pub static std_locale__Impl__S_id_time: [*const std_locale_id; 0usize];
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl14_S_id_monetaryE"]
    pub static std_locale__Impl__S_id_monetary: [*const std_locale_id; 0usize];
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl14_S_id_messagesE"]
    pub static std_locale__Impl__S_id_messages: [*const std_locale_id; 0usize];
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl19_S_facet_categoriesE"]
    pub static std_locale__Impl__S_facet_categories: [*const *const std_locale_id; 0usize];
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_locale__Impl"][::std::mem::size_of::<std_locale__Impl>() - 40usize];
    ["Alignment of std_locale__Impl"][::std::mem::align_of::<std_locale__Impl>() - 8usize];
    ["Offset of field: std_locale__Impl::_M_refcount"]
        [::std::mem::offset_of!(std_locale__Impl, _M_refcount) - 0usize];
    ["Offset of field: std_locale__Impl::_M_facets"]
        [::std::mem::offset_of!(std_locale__Impl, _M_facets) - 8usize];
    ["Offset of field: std_locale__Impl::_M_facets_size"]
        [::std::mem::offset_of!(std_locale__Impl, _M_facets_size) - 16usize];
    ["Offset of field: std_locale__Impl::_M_caches"]
        [::std::mem::offset_of!(std_locale__Impl, _M_caches) - 24usize];
    ["Offset of field: std_locale__Impl::_M_names"]
        [::std::mem::offset_of!(std_locale__Impl, _M_names) - 32usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_collate_open0_char_close0"]
        [::std::mem::size_of::<std_collate>() - 24usize];
    ["Align of template specialization: std_collate_open0_char_close0"]
        [::std::mem::align_of::<std_collate>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_collate_byname_open0_char_close0"]
        [::std::mem::size_of::<std_collate_byname>() - 24usize];
    ["Align of template specialization: std_collate_byname_open0_char_close0"]
        [::std::mem::align_of::<std_collate_byname>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_collate_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_collate>() - 24usize];
    ["Align of template specialization: std_collate_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_collate>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_collate_byname_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_collate_byname>() - 24usize];
    ["Align of template specialization: std_collate_byname_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_collate_byname>() - 8usize];
};
pub const std_errc_address_family_not_supported: std_errc = 97;
pub const std_errc_address_in_use: std_errc = 98;
pub const std_errc_address_not_available: std_errc = 99;
pub const std_errc_already_connected: std_errc = 106;
pub const std_errc_argument_list_too_long: std_errc = 7;
pub const std_errc_argument_out_of_domain: std_errc = 33;
pub const std_errc_bad_address: std_errc = 14;
pub const std_errc_bad_file_descriptor: std_errc = 9;
pub const std_errc_bad_message: std_errc = 74;
pub const std_errc_broken_pipe: std_errc = 32;
pub const std_errc_connection_aborted: std_errc = 103;
pub const std_errc_connection_already_in_progress: std_errc = 114;
pub const std_errc_connection_refused: std_errc = 111;
pub const std_errc_connection_reset: std_errc = 104;
pub const std_errc_cross_device_link: std_errc = 18;
pub const std_errc_destination_address_required: std_errc = 89;
pub const std_errc_device_or_resource_busy: std_errc = 16;
pub const std_errc_directory_not_empty: std_errc = 39;
pub const std_errc_executable_format_error: std_errc = 8;
pub const std_errc_file_exists: std_errc = 17;
pub const std_errc_file_too_large: std_errc = 27;
pub const std_errc_filename_too_long: std_errc = 36;
pub const std_errc_function_not_supported: std_errc = 38;
pub const std_errc_host_unreachable: std_errc = 113;
pub const std_errc_identifier_removed: std_errc = 43;
pub const std_errc_illegal_byte_sequence: std_errc = 84;
pub const std_errc_inappropriate_io_control_operation: std_errc = 25;
pub const std_errc_interrupted: std_errc = 4;
pub const std_errc_invalid_argument: std_errc = 22;
pub const std_errc_invalid_seek: std_errc = 29;
pub const std_errc_io_error: std_errc = 5;
pub const std_errc_is_a_directory: std_errc = 21;
pub const std_errc_message_size: std_errc = 90;
pub const std_errc_network_down: std_errc = 100;
pub const std_errc_network_reset: std_errc = 102;
pub const std_errc_network_unreachable: std_errc = 101;
pub const std_errc_no_buffer_space: std_errc = 105;
pub const std_errc_no_child_process: std_errc = 10;
pub const std_errc_no_link: std_errc = 67;
pub const std_errc_no_lock_available: std_errc = 37;
pub const std_errc_no_message_available: std_errc = 61;
pub const std_errc_no_message: std_errc = 42;
pub const std_errc_no_protocol_option: std_errc = 92;
pub const std_errc_no_space_on_device: std_errc = 28;
pub const std_errc_no_stream_resources: std_errc = 63;
pub const std_errc_no_such_device_or_address: std_errc = 6;
pub const std_errc_no_such_device: std_errc = 19;
pub const std_errc_no_such_file_or_directory: std_errc = 2;
pub const std_errc_no_such_process: std_errc = 3;
pub const std_errc_not_a_directory: std_errc = 20;
pub const std_errc_not_a_socket: std_errc = 88;
pub const std_errc_not_a_stream: std_errc = 60;
pub const std_errc_not_connected: std_errc = 107;
pub const std_errc_not_enough_memory: std_errc = 12;
pub const std_errc_not_supported: std_errc = 95;
pub const std_errc_operation_canceled: std_errc = 125;
pub const std_errc_operation_in_progress: std_errc = 115;
pub const std_errc_operation_not_permitted: std_errc = 1;
pub const std_errc_operation_not_supported: std_errc = 95;
pub const std_errc_operation_would_block: std_errc = 11;
pub const std_errc_owner_dead: std_errc = 130;
pub const std_errc_permission_denied: std_errc = 13;
pub const std_errc_protocol_error: std_errc = 71;
pub const std_errc_protocol_not_supported: std_errc = 93;
pub const std_errc_read_only_file_system: std_errc = 30;
pub const std_errc_resource_deadlock_would_occur: std_errc = 35;
pub const std_errc_resource_unavailable_try_again: std_errc = 11;
pub const std_errc_result_out_of_range: std_errc = 34;
pub const std_errc_state_not_recoverable: std_errc = 131;
pub const std_errc_stream_timeout: std_errc = 62;
pub const std_errc_text_file_busy: std_errc = 26;
pub const std_errc_timed_out: std_errc = 110;
pub const std_errc_too_many_files_open_in_system: std_errc = 23;
pub const std_errc_too_many_files_open: std_errc = 24;
pub const std_errc_too_many_links: std_errc = 31;
pub const std_errc_too_many_symbolic_link_levels: std_errc = 40;
pub const std_errc_value_too_large: std_errc = 75;
pub const std_errc_wrong_protocol_type: std_errc = 91;
pub type std_errc = ::std::os::raw::c_int;
#[repr(C)]
pub struct std___cow_string {
    pub __bindgen_anon_1: std___cow_string__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union std___cow_string__bindgen_ty_1 {
    pub _M_p: *const ::std::os::raw::c_char,
    pub _M_bytes: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___cow_string__bindgen_ty_1"]
        [::std::mem::size_of::<std___cow_string__bindgen_ty_1>() - 8usize];
    ["Alignment of std___cow_string__bindgen_ty_1"]
        [::std::mem::align_of::<std___cow_string__bindgen_ty_1>() - 8usize];
    ["Offset of field: std___cow_string__bindgen_ty_1::_M_p"]
        [::std::mem::offset_of!(std___cow_string__bindgen_ty_1, _M_p) - 0usize];
    ["Offset of field: std___cow_string__bindgen_ty_1::_M_bytes"]
        [::std::mem::offset_of!(std___cow_string__bindgen_ty_1, _M_bytes) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___cow_string"][::std::mem::size_of::<std___cow_string>() - 8usize];
    ["Alignment of std___cow_string"][::std::mem::align_of::<std___cow_string>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1Ev"]
    pub fn std___cow_string___cow_string(this: *mut std___cow_string);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std___cow_string___cow_string1(this: *mut std___cow_string, arg1: *const std_string);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1EPKcm"]
    pub fn std___cow_string___cow_string2(
        this: *mut std___cow_string,
        arg1: *const ::std::os::raw::c_char,
        arg2: usize,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1ERKS_"]
    pub fn std___cow_string___cow_string3(
        this: *mut std___cow_string,
        arg1: *const std___cow_string,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1EOS_"]
    pub fn std___cow_string___cow_string4(this: *mut std___cow_string, arg1: *mut std___cow_string);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringD1Ev"]
    pub fn std___cow_string___cow_string_destructor(this: *mut std___cow_string);
}
impl std___cow_string {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const ::std::os::raw::c_char, arg2: usize) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string2(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *const std___cow_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(arg1: *mut std___cow_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string4(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std___cow_string___cow_string_destructor(self)
    }
}
pub type std___sso_string = std_basic_string<::std::os::raw::c_char>;
#[repr(C)]
pub struct std_logic_error {
    pub _base: std_exception,
    pub _M_msg: std___cow_string,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_logic_error"][::std::mem::size_of::<std_logic_error>() - 16usize];
    ["Alignment of std_logic_error"][::std::mem::align_of::<std_logic_error>() - 8usize];
    ["Offset of field: std_logic_error::_M_msg"]
        [::std::mem::offset_of!(std_logic_error, _M_msg) - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_logic_error_logic_error(this: *mut std_logic_error, __arg: *const std_string);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorC1EPKc"]
    pub fn std_logic_error_logic_error1(
        this: *mut std_logic_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorC1EOS_"]
    pub fn std_logic_error_logic_error2(this: *mut std_logic_error, arg1: *mut std_logic_error);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorC1ERKS_"]
    pub fn std_logic_error_logic_error3(this: *mut std_logic_error, arg1: *const std_logic_error);
}
impl std_logic_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *mut std_logic_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *const std_logic_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorD1Ev"]
    pub fn std_logic_error_logic_error_destructor(this: *mut std_logic_error);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt11logic_error4whatEv"]
    pub fn std_logic_error_what(this: *mut ::std::os::raw::c_void)
    -> *const ::std::os::raw::c_char;
}
#[repr(C)]
pub struct std_domain_error {
    pub _base: std_logic_error,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_domain_error"][::std::mem::size_of::<std_domain_error>() - 16usize];
    ["Alignment of std_domain_error"][::std::mem::align_of::<std_domain_error>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12domain_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_domain_error_domain_error(this: *mut std_domain_error, __arg: *const std_string);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12domain_errorC1EPKc"]
    pub fn std_domain_error_domain_error1(
        this: *mut std_domain_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_domain_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_domain_error_domain_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_domain_error_domain_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12domain_errorD1Ev"]
    pub fn std_domain_error_domain_error_destructor(this: *mut std_domain_error);
}
#[repr(C)]
pub struct std_invalid_argument {
    pub _base: std_logic_error,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_invalid_argument"][::std::mem::size_of::<std_invalid_argument>() - 16usize];
    ["Alignment of std_invalid_argument"][::std::mem::align_of::<std_invalid_argument>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt16invalid_argumentC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_invalid_argument_invalid_argument(
        this: *mut std_invalid_argument,
        __arg: *const std_string,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt16invalid_argumentC1EPKc"]
    pub fn std_invalid_argument_invalid_argument1(
        this: *mut std_invalid_argument,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_invalid_argument {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_invalid_argument_invalid_argument(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_invalid_argument_invalid_argument1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt16invalid_argumentD1Ev"]
    pub fn std_invalid_argument_invalid_argument_destructor(this: *mut std_invalid_argument);
}
#[repr(C)]
pub struct std_length_error {
    pub _base: std_logic_error,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_length_error"][::std::mem::size_of::<std_length_error>() - 16usize];
    ["Alignment of std_length_error"][::std::mem::align_of::<std_length_error>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12length_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_length_error_length_error(this: *mut std_length_error, __arg: *const std_string);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12length_errorC1EPKc"]
    pub fn std_length_error_length_error1(
        this: *mut std_length_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_length_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_length_error_length_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_length_error_length_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12length_errorD1Ev"]
    pub fn std_length_error_length_error_destructor(this: *mut std_length_error);
}
#[repr(C)]
pub struct std_out_of_range {
    pub _base: std_logic_error,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_out_of_range"][::std::mem::size_of::<std_out_of_range>() - 16usize];
    ["Alignment of std_out_of_range"][::std::mem::align_of::<std_out_of_range>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12out_of_rangeC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_out_of_range_out_of_range(this: *mut std_out_of_range, __arg: *const std_string);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12out_of_rangeC1EPKc"]
    pub fn std_out_of_range_out_of_range1(
        this: *mut std_out_of_range,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_out_of_range {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_out_of_range_out_of_range(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_out_of_range_out_of_range1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12out_of_rangeD1Ev"]
    pub fn std_out_of_range_out_of_range_destructor(this: *mut std_out_of_range);
}
#[repr(C)]
pub struct std_runtime_error {
    pub _base: std_exception,
    pub _M_msg: std___cow_string,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_runtime_error"][::std::mem::size_of::<std_runtime_error>() - 16usize];
    ["Alignment of std_runtime_error"][::std::mem::align_of::<std_runtime_error>() - 8usize];
    ["Offset of field: std_runtime_error::_M_msg"]
        [::std::mem::offset_of!(std_runtime_error, _M_msg) - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_runtime_error_runtime_error(this: *mut std_runtime_error, __arg: *const std_string);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorC1EPKc"]
    pub fn std_runtime_error_runtime_error1(
        this: *mut std_runtime_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorC1EOS_"]
    pub fn std_runtime_error_runtime_error2(
        this: *mut std_runtime_error,
        arg1: *mut std_runtime_error,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorC1ERKS_"]
    pub fn std_runtime_error_runtime_error3(
        this: *mut std_runtime_error,
        arg1: *const std_runtime_error,
    );
}
impl std_runtime_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *mut std_runtime_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *const std_runtime_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorD1Ev"]
    pub fn std_runtime_error_runtime_error_destructor(this: *mut std_runtime_error);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt13runtime_error4whatEv"]
    pub fn std_runtime_error_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
pub struct std_range_error {
    pub _base: std_runtime_error,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_range_error"][::std::mem::size_of::<std_range_error>() - 16usize];
    ["Alignment of std_range_error"][::std::mem::align_of::<std_range_error>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt11range_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_range_error_range_error(this: *mut std_range_error, __arg: *const std_string);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt11range_errorC1EPKc"]
    pub fn std_range_error_range_error1(
        this: *mut std_range_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_range_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_range_error_range_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_range_error_range_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt11range_errorD1Ev"]
    pub fn std_range_error_range_error_destructor(this: *mut std_range_error);
}
#[repr(C)]
pub struct std_overflow_error {
    pub _base: std_runtime_error,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_overflow_error"][::std::mem::size_of::<std_overflow_error>() - 16usize];
    ["Alignment of std_overflow_error"][::std::mem::align_of::<std_overflow_error>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt14overflow_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_overflow_error_overflow_error(
        this: *mut std_overflow_error,
        __arg: *const std_string,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt14overflow_errorC1EPKc"]
    pub fn std_overflow_error_overflow_error1(
        this: *mut std_overflow_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_overflow_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_overflow_error_overflow_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_overflow_error_overflow_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt14overflow_errorD1Ev"]
    pub fn std_overflow_error_overflow_error_destructor(this: *mut std_overflow_error);
}
#[repr(C)]
pub struct std_underflow_error {
    pub _base: std_runtime_error,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_underflow_error"][::std::mem::size_of::<std_underflow_error>() - 16usize];
    ["Alignment of std_underflow_error"][::std::mem::align_of::<std_underflow_error>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt15underflow_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_underflow_error_underflow_error(
        this: *mut std_underflow_error,
        __arg: *const std_string,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt15underflow_errorC1EPKc"]
    pub fn std_underflow_error_underflow_error1(
        this: *mut std_underflow_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_underflow_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_underflow_error_underflow_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_underflow_error_underflow_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt15underflow_errorD1Ev"]
    pub fn std_underflow_error_underflow_error_destructor(this: *mut std_underflow_error);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_error_code_enum {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_error_condition_enum {
    pub _base: std_false_type,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_is_error_condition_enum_open0_std_errc_close0"]
        [::std::mem::size_of::<std_is_error_condition_enum>() - 1usize];
    ["Align of template specialization: std_is_error_condition_enum_open0_std_errc_close0"]
        [::std::mem::align_of::<std_is_error_condition_enum>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_error_code {
    pub _M_value: ::std::os::raw::c_int,
    pub _M_cat: *const std_error_category,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_error_code"][::std::mem::size_of::<std_error_code>() - 16usize];
    ["Alignment of std_error_code"][::std::mem::align_of::<std_error_code>() - 8usize];
    ["Offset of field: std_error_code::_M_value"]
        [::std::mem::offset_of!(std_error_code, _M_value) - 0usize];
    ["Offset of field: std_error_code::_M_cat"]
        [::std::mem::offset_of!(std_error_code, _M_cat) - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt10error_code23default_error_conditionEv"]
    pub fn std_error_code_default_error_condition(
        this: *const std_error_code,
    ) -> std_error_condition;
}
impl std_error_code {
    #[inline]
    pub unsafe fn default_error_condition(&self) -> std_error_condition {
        std_error_code_default_error_condition(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_error_condition {
    pub _M_value: ::std::os::raw::c_int,
    pub _M_cat: *const std_error_category,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_error_condition"][::std::mem::size_of::<std_error_condition>() - 16usize];
    ["Alignment of std_error_condition"][::std::mem::align_of::<std_error_condition>() - 8usize];
    ["Offset of field: std_error_condition::_M_value"]
        [::std::mem::offset_of!(std_error_condition, _M_value) - 0usize];
    ["Offset of field: std_error_condition::_M_cat"]
        [::std::mem::offset_of!(std_error_condition, _M_cat) - 8usize];
};
#[repr(C)]
pub struct std_system_error {
    pub _base: std_runtime_error,
    pub _M_code: std_error_code,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_system_error"][::std::mem::size_of::<std_system_error>() - 32usize];
    ["Alignment of std_system_error"][::std::mem::align_of::<std_system_error>() - 8usize];
    ["Offset of field: std_system_error::_M_code"]
        [::std::mem::offset_of!(std_system_error, _M_code) - 16usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12system_errorD1Ev"]
    pub fn std_system_error_system_error_destructor(this: *mut std_system_error);
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_hash_open0_std_error_code_close0"]
        [::std::mem::size_of::<std_hash>() - 1usize];
    ["Align of template specialization: std_hash_open0_std_error_code_close0"]
        [::std::mem::align_of::<std_hash>() - 1usize];
};
pub const std__Ios_Fmtflags__S_boolalpha: std__Ios_Fmtflags = 1;
pub const std__Ios_Fmtflags__S_dec: std__Ios_Fmtflags = 2;
pub const std__Ios_Fmtflags__S_fixed: std__Ios_Fmtflags = 4;
pub const std__Ios_Fmtflags__S_hex: std__Ios_Fmtflags = 8;
pub const std__Ios_Fmtflags__S_internal: std__Ios_Fmtflags = 16;
pub const std__Ios_Fmtflags__S_left: std__Ios_Fmtflags = 32;
pub const std__Ios_Fmtflags__S_oct: std__Ios_Fmtflags = 64;
pub const std__Ios_Fmtflags__S_right: std__Ios_Fmtflags = 128;
pub const std__Ios_Fmtflags__S_scientific: std__Ios_Fmtflags = 256;
pub const std__Ios_Fmtflags__S_showbase: std__Ios_Fmtflags = 512;
pub const std__Ios_Fmtflags__S_showpoint: std__Ios_Fmtflags = 1024;
pub const std__Ios_Fmtflags__S_showpos: std__Ios_Fmtflags = 2048;
pub const std__Ios_Fmtflags__S_skipws: std__Ios_Fmtflags = 4096;
pub const std__Ios_Fmtflags__S_unitbuf: std__Ios_Fmtflags = 8192;
pub const std__Ios_Fmtflags__S_uppercase: std__Ios_Fmtflags = 16384;
pub const std__Ios_Fmtflags__S_adjustfield: std__Ios_Fmtflags = 176;
pub const std__Ios_Fmtflags__S_basefield: std__Ios_Fmtflags = 74;
pub const std__Ios_Fmtflags__S_floatfield: std__Ios_Fmtflags = 260;
pub const std__Ios_Fmtflags__S_ios_fmtflags_end: std__Ios_Fmtflags = 65536;
pub const std__Ios_Fmtflags__S_ios_fmtflags_max: std__Ios_Fmtflags = 2147483647;
pub const std__Ios_Fmtflags__S_ios_fmtflags_min: std__Ios_Fmtflags = -2147483648;
pub type std__Ios_Fmtflags = ::std::os::raw::c_int;
pub const std__Ios_Openmode__S_app: std__Ios_Openmode = 1;
pub const std__Ios_Openmode__S_ate: std__Ios_Openmode = 2;
pub const std__Ios_Openmode__S_bin: std__Ios_Openmode = 4;
pub const std__Ios_Openmode__S_in: std__Ios_Openmode = 8;
pub const std__Ios_Openmode__S_out: std__Ios_Openmode = 16;
pub const std__Ios_Openmode__S_trunc: std__Ios_Openmode = 32;
pub const std__Ios_Openmode__S_ios_openmode_end: std__Ios_Openmode = 65536;
pub const std__Ios_Openmode__S_ios_openmode_max: std__Ios_Openmode = 2147483647;
pub const std__Ios_Openmode__S_ios_openmode_min: std__Ios_Openmode = -2147483648;
pub type std__Ios_Openmode = ::std::os::raw::c_int;
pub const std__Ios_Iostate__S_goodbit: std__Ios_Iostate = 0;
pub const std__Ios_Iostate__S_badbit: std__Ios_Iostate = 1;
pub const std__Ios_Iostate__S_eofbit: std__Ios_Iostate = 2;
pub const std__Ios_Iostate__S_failbit: std__Ios_Iostate = 4;
pub const std__Ios_Iostate__S_ios_iostate_end: std__Ios_Iostate = 65536;
pub const std__Ios_Iostate__S_ios_iostate_max: std__Ios_Iostate = 2147483647;
pub const std__Ios_Iostate__S_ios_iostate_min: std__Ios_Iostate = -2147483648;
pub type std__Ios_Iostate = ::std::os::raw::c_int;
pub const std__Ios_Seekdir__S_beg: std__Ios_Seekdir = 0;
pub const std__Ios_Seekdir__S_cur: std__Ios_Seekdir = 1;
pub const std__Ios_Seekdir__S_end: std__Ios_Seekdir = 2;
pub const std__Ios_Seekdir__S_ios_seekdir_end: std__Ios_Seekdir = 65536;
pub type std__Ios_Seekdir = ::std::os::raw::c_uint;
pub const std_io_errc_stream: std_io_errc = 1;
pub type std_io_errc = ::std::os::raw::c_int;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_is_error_code_enum_open0_std_io_errc_close0"]
        [::std::mem::size_of::<std_is_error_code_enum>() - 1usize];
    ["Align of template specialization: std_is_error_code_enum_open0_std_io_errc_close0"]
        [::std::mem::align_of::<std_is_error_code_enum>() - 1usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt17iostream_categoryv"]
    pub fn std_iostream_category() -> *const std_error_category;
}
#[repr(C)]
pub struct std_ios_base__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_ios_base {
    pub vtable_: *const std_ios_base__bindgen_vtable,
    pub _M_precision: std_streamsize,
    pub _M_width: std_streamsize,
    pub _M_flags: std_ios_base_fmtflags,
    pub _M_exception: std_ios_base_iostate,
    pub _M_streambuf_state: std_ios_base_iostate,
    pub _M_callbacks: *mut std_ios_base__Callback_list,
    pub _M_word_zero: std_ios_base__Words,
    pub _M_local_word: [std_ios_base__Words; 8usize],
    pub _M_word_size: ::std::os::raw::c_int,
    pub _M_word: *mut std_ios_base__Words,
    pub _M_ios_locale: std_locale,
}
#[repr(C)]
pub struct std_ios_base_failure {
    pub _base: std_system_error,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_ios_base_failure"][::std::mem::size_of::<std_ios_base_failure>() - 32usize];
    ["Alignment of std_ios_base_failure"][::std::mem::align_of::<std_ios_base_failure>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11C1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_ios_base_failure_failure(this: *mut std_ios_base_failure, __str: *const std_string);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11C1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt10error_code"]
    pub fn std_ios_base_failure_failure1(
        this: *mut std_ios_base_failure,
        arg1: *const std_string,
        arg2: *const std_error_code,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11C1EPKcRKSt10error_code"]
    pub fn std_ios_base_failure_failure2(
        this: *mut std_ios_base_failure,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const std_error_code,
    );
}
impl std_ios_base_failure {
    #[inline]
    pub unsafe fn new(__str: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_failure_failure(__bindgen_tmp.as_mut_ptr(), __str);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const std_string, arg2: *const std_error_code) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_failure_failure1(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const ::std::os::raw::c_char, arg2: *const std_error_code) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_failure_failure2(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
}
pub use self::std__Ios_Fmtflags as std_ios_base_fmtflags;
pub use self::std__Ios_Iostate as std_ios_base_iostate;
pub use self::std__Ios_Openmode as std_ios_base_openmode;
pub use self::std__Ios_Seekdir as std_ios_base_seekdir;
pub type std_ios_base_io_state = ::std::os::raw::c_int;
pub type std_ios_base_open_mode = ::std::os::raw::c_int;
pub type std_ios_base_seek_dir = ::std::os::raw::c_int;
pub type std_ios_base_streampos = std_streampos;
pub type std_ios_base_streamoff = std_streamoff;
pub const std_ios_base_event_erase_event: std_ios_base_event = 0;
pub const std_ios_base_event_imbue_event: std_ios_base_event = 1;
pub const std_ios_base_event_copyfmt_event: std_ios_base_event = 2;
pub type std_ios_base_event = ::std::os::raw::c_uint;
pub type std_ios_base_event_callback = ::std::option::Option<
    unsafe extern "C" fn(
        __e: std_ios_base_event,
        __b: *mut std_ios_base,
        __i: ::std::os::raw::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ios_base__Callback_list {
    pub _M_next: *mut std_ios_base__Callback_list,
    pub _M_fn: std_ios_base_event_callback,
    pub _M_index: ::std::os::raw::c_int,
    pub _M_refcount: _Atomic_word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_ios_base__Callback_list"]
        [::std::mem::size_of::<std_ios_base__Callback_list>() - 24usize];
    ["Alignment of std_ios_base__Callback_list"]
        [::std::mem::align_of::<std_ios_base__Callback_list>() - 8usize];
    ["Offset of field: std_ios_base__Callback_list::_M_next"]
        [::std::mem::offset_of!(std_ios_base__Callback_list, _M_next) - 0usize];
    ["Offset of field: std_ios_base__Callback_list::_M_fn"]
        [::std::mem::offset_of!(std_ios_base__Callback_list, _M_fn) - 8usize];
    ["Offset of field: std_ios_base__Callback_list::_M_index"]
        [::std::mem::offset_of!(std_ios_base__Callback_list, _M_index) - 16usize];
    ["Offset of field: std_ios_base__Callback_list::_M_refcount"]
        [::std::mem::offset_of!(std_ios_base__Callback_list, _M_refcount) - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ios_base__Words {
    pub _M_pword: *mut ::std::os::raw::c_void,
    pub _M_iword: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_ios_base__Words"][::std::mem::size_of::<std_ios_base__Words>() - 16usize];
    ["Alignment of std_ios_base__Words"][::std::mem::align_of::<std_ios_base__Words>() - 8usize];
    ["Offset of field: std_ios_base__Words::_M_pword"]
        [::std::mem::offset_of!(std_ios_base__Words, _M_pword) - 0usize];
    ["Offset of field: std_ios_base__Words::_M_iword"]
        [::std::mem::offset_of!(std_ios_base__Words, _M_iword) - 8usize];
};
pub const std_ios_base__S_local_word_size: std_ios_base__bindgen_ty_1 = 8;
pub type std_ios_base__bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct std_ios_base_Init {
    pub _address: u8,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base4Init11_S_refcountE"]
    pub static mut std_ios_base_Init__S_refcount: _Atomic_word;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base4Init20_S_synced_with_stdioE"]
    pub static mut std_ios_base_Init__S_synced_with_stdio: bool;
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_ios_base_Init"][::std::mem::size_of::<std_ios_base_Init>() - 1usize];
    ["Alignment of std_ios_base_Init"][::std::mem::align_of::<std_ios_base_Init>() - 1usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base4InitC1Ev"]
    pub fn std_ios_base_Init_Init(this: *mut std_ios_base_Init);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base4InitD1Ev"]
    pub fn std_ios_base_Init_Init_destructor(this: *mut std_ios_base_Init);
}
impl std_ios_base_Init {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_Init_Init(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_ios_base_Init_Init_destructor(self)
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base9boolalphaE"]
    pub static std_ios_base_boolalpha: std_ios_base_fmtflags;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3decE"]
    pub static std_ios_base_dec: std_ios_base_fmtflags;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base5fixedE"]
    pub static std_ios_base_fixed: std_ios_base_fmtflags;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3hexE"]
    pub static std_ios_base_hex: std_ios_base_fmtflags;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base8internalE"]
    pub static std_ios_base_internal: std_ios_base_fmtflags;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base4leftE"]
    pub static std_ios_base_left: std_ios_base_fmtflags;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3octE"]
    pub static std_ios_base_oct: std_ios_base_fmtflags;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base5rightE"]
    pub static std_ios_base_right: std_ios_base_fmtflags;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base10scientificE"]
    pub static std_ios_base_scientific: std_ios_base_fmtflags;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base8showbaseE"]
    pub static std_ios_base_showbase: std_ios_base_fmtflags;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base9showpointE"]
    pub static std_ios_base_showpoint: std_ios_base_fmtflags;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7showposE"]
    pub static std_ios_base_showpos: std_ios_base_fmtflags;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base6skipwsE"]
    pub static std_ios_base_skipws: std_ios_base_fmtflags;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7unitbufE"]
    pub static std_ios_base_unitbuf: std_ios_base_fmtflags;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base9uppercaseE"]
    pub static std_ios_base_uppercase: std_ios_base_fmtflags;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base11adjustfieldE"]
    pub static std_ios_base_adjustfield: std_ios_base_fmtflags;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base9basefieldE"]
    pub static std_ios_base_basefield: std_ios_base_fmtflags;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base10floatfieldE"]
    pub static std_ios_base_floatfield: std_ios_base_fmtflags;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base6badbitE"]
    pub static std_ios_base_badbit: std_ios_base_iostate;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base6eofbitE"]
    pub static std_ios_base_eofbit: std_ios_base_iostate;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7failbitE"]
    pub static std_ios_base_failbit: std_ios_base_iostate;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7goodbitE"]
    pub static std_ios_base_goodbit: std_ios_base_iostate;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3appE"]
    pub static std_ios_base_app: std_ios_base_openmode;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3ateE"]
    pub static std_ios_base_ate: std_ios_base_openmode;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base6binaryE"]
    pub static std_ios_base_binary: std_ios_base_openmode;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base2inE"]
    pub static std_ios_base_in: std_ios_base_openmode;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3outE"]
    pub static std_ios_base_out: std_ios_base_openmode;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base5truncE"]
    pub static std_ios_base_trunc: std_ios_base_openmode;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3begE"]
    pub static std_ios_base_beg: std_ios_base_seekdir;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3curE"]
    pub static std_ios_base_cur: std_ios_base_seekdir;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3endE"]
    pub static std_ios_base_end: std_ios_base_seekdir;
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_ios_base"][::std::mem::size_of::<std_ios_base>() - 216usize];
    ["Alignment of std_ios_base"][::std::mem::align_of::<std_ios_base>() - 8usize];
    ["Offset of field: std_ios_base::_M_precision"]
        [::std::mem::offset_of!(std_ios_base, _M_precision) - 8usize];
    ["Offset of field: std_ios_base::_M_width"]
        [::std::mem::offset_of!(std_ios_base, _M_width) - 16usize];
    ["Offset of field: std_ios_base::_M_flags"]
        [::std::mem::offset_of!(std_ios_base, _M_flags) - 24usize];
    ["Offset of field: std_ios_base::_M_exception"]
        [::std::mem::offset_of!(std_ios_base, _M_exception) - 28usize];
    ["Offset of field: std_ios_base::_M_streambuf_state"]
        [::std::mem::offset_of!(std_ios_base, _M_streambuf_state) - 32usize];
    ["Offset of field: std_ios_base::_M_callbacks"]
        [::std::mem::offset_of!(std_ios_base, _M_callbacks) - 40usize];
    ["Offset of field: std_ios_base::_M_word_zero"]
        [::std::mem::offset_of!(std_ios_base, _M_word_zero) - 48usize];
    ["Offset of field: std_ios_base::_M_local_word"]
        [::std::mem::offset_of!(std_ios_base, _M_local_word) - 64usize];
    ["Offset of field: std_ios_base::_M_word_size"]
        [::std::mem::offset_of!(std_ios_base, _M_word_size) - 192usize];
    ["Offset of field: std_ios_base::_M_word"]
        [::std::mem::offset_of!(std_ios_base, _M_word) - 200usize];
    ["Offset of field: std_ios_base::_M_ios_locale"]
        [::std::mem::offset_of!(std_ios_base, _M_ios_locale) - 208usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base17register_callbackEPFvNS_5eventERS_iEi"]
    pub fn std_ios_base_register_callback(
        this: *mut std_ios_base,
        __fn: std_ios_base_event_callback,
        __index: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base17_M_call_callbacksENS_5eventE"]
    pub fn std_ios_base__M_call_callbacks(this: *mut std_ios_base, __ev: std_ios_base_event);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base20_M_dispose_callbacksEv"]
    pub fn std_ios_base__M_dispose_callbacks(this: *mut std_ios_base);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base13_M_grow_wordsEib"]
    pub fn std_ios_base__M_grow_words(
        this: *mut std_ios_base,
        __index: ::std::os::raw::c_int,
        __iword: bool,
    ) -> *mut std_ios_base__Words;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7_M_initEv"]
    pub fn std_ios_base__M_init(this: *mut std_ios_base);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base15sync_with_stdioEb"]
    pub fn std_ios_base_sync_with_stdio(__sync: bool) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base5imbueERKSt6locale"]
    pub fn std_ios_base_imbue(this: *mut std_ios_base, __loc: *const std_locale) -> std_locale;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base6xallocEv"]
    pub fn std_ios_base_xalloc() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7_M_moveERS_"]
    pub fn std_ios_base__M_move(this: *mut std_ios_base, arg1: *mut std_ios_base);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7_M_swapERS_"]
    pub fn std_ios_base__M_swap(this: *mut std_ios_base, __rhs: *mut std_ios_base);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_baseC1Ev"]
    pub fn std_ios_base_ios_base(this: *mut std_ios_base);
}
impl std_ios_base {
    #[inline]
    pub unsafe fn register_callback(
        &mut self,
        __fn: std_ios_base_event_callback,
        __index: ::std::os::raw::c_int,
    ) {
        std_ios_base_register_callback(self, __fn, __index)
    }
    #[inline]
    pub unsafe fn _M_call_callbacks(&mut self, __ev: std_ios_base_event) {
        std_ios_base__M_call_callbacks(self, __ev)
    }
    #[inline]
    pub unsafe fn _M_dispose_callbacks(&mut self) {
        std_ios_base__M_dispose_callbacks(self)
    }
    #[inline]
    pub unsafe fn _M_grow_words(
        &mut self,
        __index: ::std::os::raw::c_int,
        __iword: bool,
    ) -> *mut std_ios_base__Words {
        std_ios_base__M_grow_words(self, __index, __iword)
    }
    #[inline]
    pub unsafe fn _M_init(&mut self) {
        std_ios_base__M_init(self)
    }
    #[inline]
    pub unsafe fn sync_with_stdio(__sync: bool) -> bool {
        std_ios_base_sync_with_stdio(__sync)
    }
    #[inline]
    pub unsafe fn imbue(&mut self, __loc: *const std_locale) -> std_locale {
        std_ios_base_imbue(self, __loc)
    }
    #[inline]
    pub unsafe fn xalloc() -> ::std::os::raw::c_int {
        std_ios_base_xalloc()
    }
    #[inline]
    pub unsafe fn _M_move(&mut self, arg1: *mut std_ios_base) {
        std_ios_base__M_move(self, arg1)
    }
    #[inline]
    pub unsafe fn _M_swap(&mut self, __rhs: *mut std_ios_base) {
        std_ios_base__M_swap(self, __rhs)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_ios_base(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11D1Ev"]
    pub fn std_ios_base_failure_failure_destructor(this: *mut std_ios_base_failure);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt8ios_base7failureB5cxx114whatEv"]
    pub fn std_ios_base_failure_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_baseD1Ev"]
    pub fn std_ios_base_ios_base_destructor(this: *mut std_ios_base);
}
#[repr(C)]
pub struct std_basic_streambuf__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_streambuf<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub vtable_: *const std_basic_streambuf__bindgen_vtable,
    pub _M_in_beg: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_in_cur: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_in_end: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_out_beg: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_out_cur: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_out_end: *mut std_basic_streambuf_char_type<_CharT>,
    pub _M_buf_locale: std_locale,
}
pub type std_basic_streambuf_char_type<_CharT> = _CharT;
pub type std_basic_streambuf_traits_type<_Traits> = _Traits;
pub type std_basic_streambuf_int_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_streambuf_pos_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_streambuf_off_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_streambuf___streambuf_type<_CharT> =
    std_basic_streambuf<std_basic_streambuf_char_type<_CharT>>;
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt21__copy_streambufs_eofIcSt11char_traitsIcEElPSt15basic_streambufIT_T0_ES6_Rb"]
    pub fn std___copy_streambufs_eof(
        __sbin: *mut std_basic_streambuf<::std::os::raw::c_char>,
        __sbout: *mut std_basic_streambuf<::std::os::raw::c_char>,
        __ineof: *mut bool,
    ) -> std_streamsize;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt21__copy_streambufs_eofIwSt11char_traitsIwEElPSt15basic_streambufIT_T0_ES6_Rb"]
    pub fn std___copy_streambufs_eof1(
        __sbin: *mut std_basic_streambuf<u32>,
        __sbout: *mut std_basic_streambuf<u32>,
        __ineof: *mut bool,
    ) -> std_streamsize;
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_streambuf_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_streambuf<::std::os::raw::c_char>>() - 64usize];
    [
        "Align of template specialization: std_basic_streambuf_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_streambuf<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_streambuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_streambuf<u32>>() - 64usize];
    [
        "Align of template specialization: std_basic_streambuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_streambuf<u32>>() - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ctype_base {
    pub _address: u8,
}
pub type std_ctype_base___to_type = *const ::std::os::raw::c_int;
pub type std_ctype_base_mask = ::std::os::raw::c_ushort;
pub const std_ctype_base_upper: std_ctype_base_mask = 256;
pub const std_ctype_base_lower: std_ctype_base_mask = 512;
pub const std_ctype_base_alpha: std_ctype_base_mask = 1024;
pub const std_ctype_base_digit: std_ctype_base_mask = 2048;
pub const std_ctype_base_xdigit: std_ctype_base_mask = 4096;
pub const std_ctype_base_space: std_ctype_base_mask = 8192;
pub const std_ctype_base_print: std_ctype_base_mask = 16384;
pub const std_ctype_base_graph: std_ctype_base_mask = 3076;
pub const std_ctype_base_cntrl: std_ctype_base_mask = 2;
pub const std_ctype_base_punct: std_ctype_base_mask = 4;
pub const std_ctype_base_alnum: std_ctype_base_mask = 3072;
pub const std_ctype_base_blank: std_ctype_base_mask = 1;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_ctype_base"][::std::mem::size_of::<std_ctype_base>() - 1usize];
    ["Alignment of std_ctype_base"][::std::mem::align_of::<std_ctype_base>() - 1usize];
};
#[repr(C)]
pub struct std_istreambuf_iterator<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _M_sbuf: *mut std_istreambuf_iterator_streambuf_type<_CharT>,
    pub _M_c: std_istreambuf_iterator_int_type,
}
pub type std_istreambuf_iterator_char_type<_CharT> = _CharT;
pub type std_istreambuf_iterator_traits_type<_Traits> = _Traits;
pub type std_istreambuf_iterator_int_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_istreambuf_iterator_streambuf_type<_CharT> = std_basic_streambuf<_CharT>;
pub type std_istreambuf_iterator_istream_type<_CharT> = std_basic_istream<_CharT>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ostreambuf_iterator<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _M_sbuf: *mut std_ostreambuf_iterator_streambuf_type<_CharT>,
    pub _M_failed: bool,
}
pub type std_ostreambuf_iterator_char_type<_CharT> = _CharT;
pub type std_ostreambuf_iterator_traits_type<_Traits> = _Traits;
pub type std_ostreambuf_iterator_streambuf_type<_CharT> = std_basic_streambuf<_CharT>;
pub type std_ostreambuf_iterator_ostream_type<_CharT> = std_basic_ostream<_CharT>;
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt14__convert_to_vIfEvPKcRT_RSt12_Ios_IostateRKP15__locale_struct"]
    pub fn std___convert_to_v(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut f32,
        arg3: *mut std_ios_base_iostate,
        arg4: *const std___c_locale,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt14__convert_to_vIdEvPKcRT_RSt12_Ios_IostateRKP15__locale_struct"]
    pub fn std___convert_to_v1(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut f64,
        arg3: *mut std_ios_base_iostate,
        arg4: *const std___c_locale,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt14__convert_to_vIeEvPKcRT_RSt12_Ios_IostateRKP15__locale_struct"]
    pub fn std___convert_to_v2(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut u128,
        arg3: *mut std_ios_base_iostate,
        arg4: *const std___c_locale,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___pad {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std___ctype_abstract_base {
    pub _base: std_locale_facet,
}
pub type std___ctype_abstract_base_char_type<_CharT> = _CharT;
#[repr(C)]
#[derive(Debug)]
pub struct std_ctype {
    pub _base: std___ctype_abstract_base,
}
pub type std_ctype_char_type<_CharT> = _CharT;
pub type std_ctype_mask = std___ctype_abstract_base;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_ctype_open0_char_close0"]
        [::std::mem::size_of::<std_ctype>() - 576usize];
    ["Align of template specialization: std_ctype_open0_char_close0"]
        [::std::mem::align_of::<std_ctype>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_ctype_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_ctype>() - 1344usize];
    ["Align of template specialization: std_ctype_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_ctype>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct std_ctype_byname {
    pub _base: std_ctype,
}
pub type std_ctype_byname_mask = std_ctype;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_ctype_byname_open0_char_close0"]
        [::std::mem::size_of::<std_ctype_byname>() - 576usize];
    ["Align of template specialization: std_ctype_byname_open0_char_close0"]
        [::std::mem::align_of::<std_ctype_byname>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_ctype_byname_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_ctype_byname>() - 1344usize];
    ["Align of template specialization: std_ctype_byname_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_ctype_byname>() - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___num_base {
    pub _address: u8,
}
pub const std___num_base__S_ominus: std___num_base__bindgen_ty_1 = 0;
pub const std___num_base__S_oplus: std___num_base__bindgen_ty_1 = 1;
pub const std___num_base__S_ox: std___num_base__bindgen_ty_1 = 2;
pub const std___num_base__S_oX: std___num_base__bindgen_ty_1 = 3;
pub const std___num_base__S_odigits: std___num_base__bindgen_ty_1 = 4;
pub const std___num_base__S_odigits_end: std___num_base__bindgen_ty_1 = 20;
pub const std___num_base__S_oudigits: std___num_base__bindgen_ty_1 = 20;
pub const std___num_base__S_oudigits_end: std___num_base__bindgen_ty_1 = 36;
pub const std___num_base__S_oe: std___num_base__bindgen_ty_1 = 18;
pub const std___num_base__S_oE: std___num_base__bindgen_ty_1 = 34;
pub const std___num_base__S_oend: std___num_base__bindgen_ty_1 = 36;
pub type std___num_base__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const std___num_base__S_iminus: std___num_base__bindgen_ty_2 = 0;
pub const std___num_base__S_iplus: std___num_base__bindgen_ty_2 = 1;
pub const std___num_base__S_ix: std___num_base__bindgen_ty_2 = 2;
pub const std___num_base__S_iX: std___num_base__bindgen_ty_2 = 3;
pub const std___num_base__S_izero: std___num_base__bindgen_ty_2 = 4;
pub const std___num_base__S_ie: std___num_base__bindgen_ty_2 = 18;
pub const std___num_base__S_iE: std___num_base__bindgen_ty_2 = 24;
pub const std___num_base__S_iend: std___num_base__bindgen_ty_2 = 26;
pub type std___num_base__bindgen_ty_2 = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10__num_base12_S_atoms_outE"]
    pub static mut std___num_base__S_atoms_out: *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10__num_base11_S_atoms_inE"]
    pub static mut std___num_base__S_atoms_in: *const ::std::os::raw::c_char;
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___num_base"][::std::mem::size_of::<std___num_base>() - 1usize];
    ["Alignment of std___num_base"][::std::mem::align_of::<std___num_base>() - 1usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10__num_base15_S_format_floatERKSt8ios_basePcc"]
    pub fn std___num_base__S_format_float(
        __io: *const std_ios_base,
        __fptr: *mut ::std::os::raw::c_char,
        __mod: ::std::os::raw::c_char,
    );
}
impl std___num_base {
    #[inline]
    pub unsafe fn _S_format_float(
        __io: *const std_ios_base,
        __fptr: *mut ::std::os::raw::c_char,
        __mod: ::std::os::raw::c_char,
    ) {
        std___num_base__S_format_float(__io, __fptr, __mod)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std___numpunct_cache<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _base: std_locale_facet,
    pub _M_grouping: *const ::std::os::raw::c_char,
    pub _M_grouping_size: usize,
    pub _M_use_grouping: bool,
    pub _M_truename: *const _CharT,
    pub _M_truename_size: usize,
    pub _M_falsename: *const _CharT,
    pub _M_falsename_size: usize,
    pub _M_decimal_point: _CharT,
    pub _M_thousands_sep: _CharT,
    pub _M_atoms_out: [_CharT; 36usize],
    pub _M_atoms_in: [_CharT; 26usize],
    pub _M_allocated: bool,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_num_get {
    pub _base: std_locale_facet,
}
pub type std_num_get_char_type<_CharT> = _CharT;
pub type std_num_get_iter_type<_InIter> = _InIter;
#[repr(C)]
#[derive(Debug)]
pub struct std_num_put {
    pub _base: std_locale_facet,
}
pub type std_num_put_char_type<_CharT> = _CharT;
pub type std_num_put_iter_type<_OutIter> = _OutIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___use_cache {
    pub _address: u8,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt17__verify_groupingPKcmRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std___verify_grouping(
        __grouping: *const ::std::os::raw::c_char,
        __grouping_size: usize,
        __grouping_tmp: *const std_string,
    ) -> bool;
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numpunct_open0_char_close0"]
        [::std::mem::size_of::<std_numpunct<::std::os::raw::c_char>>() - 24usize];
    ["Align of template specialization: std_numpunct_open0_char_close0"]
        [::std::mem::align_of::<std_numpunct<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numpunct_byname_open0_char_close0"]
        [::std::mem::size_of::<std_numpunct_byname<::std::os::raw::c_char>>() - 24usize];
    ["Align of template specialization: std_numpunct_byname_open0_char_close0"]
        [::std::mem::align_of::<std_numpunct_byname<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_num_get_open0_char_std_istreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_num_get>() - 16usize];
    [
        "Align of template specialization: std_num_get_open0_char_std_istreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_num_get>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_num_put_open0_char_std_ostreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_num_put>() - 16usize];
    [
        "Align of template specialization: std_num_put_open0_char_std_ostreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_num_put>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numpunct_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_numpunct<u32>>() - 24usize];
    ["Align of template specialization: std_numpunct_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_numpunct<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_numpunct_byname_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_numpunct_byname<u32>>() - 24usize];
    ["Align of template specialization: std_numpunct_byname_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_numpunct_byname<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_num_get_open0_wchar_t_std_istreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0",
    ][::std::mem::size_of::<std_num_get>() - 16usize];
    [
        "Align of template specialization: std_num_get_open0_wchar_t_std_istreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0",
    ][::std::mem::align_of::<std_num_get>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_num_put_open0_wchar_t_std_ostreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0",
    ][::std::mem::size_of::<std_num_put>() - 16usize];
    [
        "Align of template specialization: std_num_put_open0_wchar_t_std_ostreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0",
    ][::std::mem::align_of::<std_num_put>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_ios<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _base: std_ios_base,
    pub _M_tie: *mut std_basic_ostream<_CharT>,
    pub _M_fill: std_basic_ios_char_type<_CharT>,
    pub _M_fill_init: bool,
    pub _M_streambuf: *mut std_basic_streambuf<_CharT>,
    pub _M_ctype: *const std_basic_ios___ctype_type,
    pub _M_num_put: *const std_basic_ios___num_put_type,
    pub _M_num_get: *const std_basic_ios___num_get_type,
}
pub type std_basic_ios_char_type<_CharT> = _CharT;
pub type std_basic_ios_int_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_ios_pos_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_ios_off_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_ios_traits_type<_Traits> = _Traits;
pub type std_basic_ios___ctype_type = std_ctype;
pub type std_basic_ios___num_put_type = std_num_put;
pub type std_basic_ios___num_get_type = std_num_get;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_ios_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_ios<::std::os::raw::c_char>>() - 264usize];
    [
        "Align of template specialization: std_basic_ios_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_ios<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_ios_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_ios<u32>>() - 264usize];
    [
        "Align of template specialization: std_basic_ios_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_ios<u32>>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_ostream<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_ostream_char_type<_CharT> = _CharT;
pub type std_basic_ostream_int_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_ostream_pos_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_ostream_off_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_ostream_traits_type<_Traits> = _Traits;
pub type std_basic_ostream___streambuf_type<_CharT> = std_basic_streambuf<_CharT>;
pub type std_basic_ostream___ios_type<_CharT> = std_basic_ios<_CharT>;
pub type std_basic_ostream___ostream_type<_CharT> = std_basic_ostream<_CharT>;
pub type std_basic_ostream___num_put_type = std_num_put;
pub type std_basic_ostream___ctype_type = std_ctype;
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_ostream_sentry {
    pub _M_ok: bool,
    pub _M_os: *mut std_basic_ostream<_CharT>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_convertible_to_basic_ostream_impl {
    pub _address: u8,
}
pub type std___is_convertible_to_basic_ostream_impl___ostream_type = ::std::os::raw::c_void;
pub type std___do_is_convertible_to_basic_ostream_impl = std_remove_reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_convertible_to_basic_ostream {
    pub _address: u8,
}
pub type std___is_convertible_to_basic_ostream_type = std___not_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_insertable {
    pub _base: std_false_type,
}
pub type std___rvalue_ostream_type = std___is_convertible_to_basic_ostream;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_ostream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_ostream<::std::os::raw::c_char>>() - 272usize];
    [
        "Align of template specialization: std_basic_ostream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_ostream<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_ostream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_ostream<u32>>() - 272usize];
    [
        "Align of template specialization: std_basic_ostream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_ostream<u32>>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_istream<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _M_gcount: std_streamsize,
}
pub type std_basic_istream_char_type<_CharT> = _CharT;
pub type std_basic_istream_int_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_istream_pos_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_istream_off_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_istream_traits_type<_Traits> = _Traits;
pub type std_basic_istream___streambuf_type<_CharT> = std_basic_streambuf<_CharT>;
pub type std_basic_istream___ios_type<_CharT> = std_basic_ios<_CharT>;
pub type std_basic_istream___istream_type<_CharT> = std_basic_istream<_CharT>;
pub type std_basic_istream___num_get_type = std_num_get;
pub type std_basic_istream___ctype_type = std_ctype;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_istream_sentry {
    pub _M_ok: bool,
}
pub type std_basic_istream_sentry_traits_type = _Traits;
pub type std_basic_istream_sentry___streambuf_type = std_basic_streambuf<_CharT>;
pub type std_basic_istream_sentry___istream_type = std_basic_istream<_CharT>;
pub type std_basic_istream_sentry___ctype_type = std_basic_istream___ctype_type;
pub type std_basic_istream_sentry___int_type = __BindgenOpaqueArray<u8, 0usize>;
#[repr(C)]
#[derive(Debug)]
pub struct std_basic_iostream<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _base: std_basic_istream<_CharT>,
    pub _base_1: std_basic_ostream<_CharT>,
}
pub type std_basic_iostream_char_type<_CharT> = _CharT;
pub type std_basic_iostream_int_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_iostream_pos_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_iostream_off_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_iostream_traits_type<_Traits> = _Traits;
pub type std_basic_iostream___istream_type<_CharT> = std_basic_istream<_CharT>;
pub type std_basic_iostream___ostream_type<_CharT> = std_basic_ostream<_CharT>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_convertible_to_basic_istream_impl {
    pub _address: u8,
}
pub type std___is_convertible_to_basic_istream_impl___istream_type = ::std::os::raw::c_void;
pub type std___do_is_convertible_to_basic_istream_impl = std_remove_reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_convertible_to_basic_istream {
    pub _address: u8,
}
pub type std___is_convertible_to_basic_istream_type = std___not_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_extractable {
    pub _base: std_false_type,
}
pub type std___rvalue_istream_type = std___is_convertible_to_basic_istream;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_istream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_istream<::std::os::raw::c_char>>() - 280usize];
    [
        "Align of template specialization: std_basic_istream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_istream<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_iostream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_iostream<::std::os::raw::c_char>>() - 288usize];
    [
        "Align of template specialization: std_basic_iostream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_iostream<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_istream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_istream<u32>>() - 280usize];
    [
        "Align of template specialization: std_basic_istream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_istream<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_iostream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_iostream<u32>>() - 288usize];
    [
        "Align of template specialization: std_basic_iostream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_iostream<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_stringbuf_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_stringbuf<::std::os::raw::c_char>>() - 104usize];
    [
        "Align of template specialization: std_basic_stringbuf_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_stringbuf<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_istringstream_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_istringstream<::std::os::raw::c_char>>() - 384usize];
    [
        "Align of template specialization: std_basic_istringstream_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_istringstream<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_ostringstream_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_ostringstream<::std::os::raw::c_char>>() - 376usize];
    [
        "Align of template specialization: std_basic_ostringstream_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_ostringstream<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_stringstream_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_stringstream<::std::os::raw::c_char>>() - 392usize];
    [
        "Align of template specialization: std_basic_stringstream_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_stringstream<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_stringbuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_stringbuf<u32>>() - 104usize];
    [
        "Align of template specialization: std_basic_stringbuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_stringbuf<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_istringstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_istringstream<u32>>() - 384usize];
    [
        "Align of template specialization: std_basic_istringstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_istringstream<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_ostringstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_ostringstream<u32>>() - 376usize];
    [
        "Align of template specialization: std_basic_ostringstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_ostringstream<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_stringstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_stringstream<u32>>() - 392usize];
    [
        "Align of template specialization: std_basic_stringstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_stringstream<u32>>() - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_complex<_Tp> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
    pub _M_real: _Tp,
    pub _M_imag: _Tp,
}
pub type std_complex_value_type<_Tp> = _Tp;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_complex_open0_float_close0"]
        [::std::mem::size_of::<std_complex<f32>>() - 8usize];
    ["Align of template specialization: std_complex_open0_float_close0"]
        [::std::mem::align_of::<std_complex<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_complex_open0_double_close0"]
        [::std::mem::size_of::<std_complex<f64>>() - 16usize];
    ["Align of template specialization: std_complex_open0_double_close0"]
        [::std::mem::align_of::<std_complex<f64>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_complex_open0_long_double_close0"]
        [::std::mem::size_of::<std_complex<u128>>() - 32usize];
    ["Align of template specialization: std_complex_open0_long_double_close0"]
        [::std::mem::align_of::<std_complex<u128>>() - 16usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_function_call {
    pub _base: std_exception,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_bad_function_call"][::std::mem::size_of::<std_bad_function_call>() - 8usize];
    ["Alignment of std_bad_function_call"]
        [::std::mem::align_of::<std_bad_function_call>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt17bad_function_callD1Ev"]
    pub fn std_bad_function_call_bad_function_call_destructor(this: *mut std_bad_function_call);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt17bad_function_call4whatEv"]
    pub fn std_bad_function_call_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_location_invariant {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Undefined_class {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union std__Nocopy_types {
    pub _M_object: *mut ::std::os::raw::c_void,
    pub _M_const_object: *const ::std::os::raw::c_void,
    pub _M_function_pointer: ::std::option::Option<unsafe extern "C" fn()>,
    pub _M_member_pointer: __BindgenOpaqueArray<u64, 2usize>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std__Nocopy_types"][::std::mem::size_of::<std__Nocopy_types>() - 16usize];
    ["Alignment of std__Nocopy_types"][::std::mem::align_of::<std__Nocopy_types>() - 8usize];
    ["Offset of field: std__Nocopy_types::_M_object"]
        [::std::mem::offset_of!(std__Nocopy_types, _M_object) - 0usize];
    ["Offset of field: std__Nocopy_types::_M_const_object"]
        [::std::mem::offset_of!(std__Nocopy_types, _M_const_object) - 0usize];
    ["Offset of field: std__Nocopy_types::_M_function_pointer"]
        [::std::mem::offset_of!(std__Nocopy_types, _M_function_pointer) - 0usize];
    ["Offset of field: std__Nocopy_types::_M_member_pointer"]
        [::std::mem::offset_of!(std__Nocopy_types, _M_member_pointer) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union std__Any_data {
    pub _M_unused: std__Nocopy_types,
    pub _M_pod_data: [::std::os::raw::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std__Any_data"][::std::mem::size_of::<std__Any_data>() - 16usize];
    ["Alignment of std__Any_data"][::std::mem::align_of::<std__Any_data>() - 8usize];
    ["Offset of field: std__Any_data::_M_unused"]
        [::std::mem::offset_of!(std__Any_data, _M_unused) - 0usize];
    ["Offset of field: std__Any_data::_M_pod_data"]
        [::std::mem::offset_of!(std__Any_data, _M_pod_data) - 0usize];
};
pub const std__Manager_operation___get_type_info: std__Manager_operation = 0;
pub const std__Manager_operation___get_functor_ptr: std__Manager_operation = 1;
pub const std__Manager_operation___clone_functor: std__Manager_operation = 2;
pub const std__Manager_operation___destroy_functor: std__Manager_operation = 3;
pub type std__Manager_operation = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_function {
    pub _address: u8,
}
#[repr(C)]
pub struct std__Function_base {
    pub _M_functor: std__Any_data,
    pub _M_manager: std__Function_base__Manager_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Function_base__Base_manager {
    pub _address: u8,
}
pub type std__Function_base__Base_manager__Local_storage = u8;
pub type std__Function_base__Manager_type = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut std__Any_data,
        arg2: *const std__Any_data,
        arg3: std__Manager_operation,
    ) -> bool,
>;
pub const std__Function_base__M_max_size: usize = 16;
pub const std__Function_base__M_max_align: usize = 8;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std__Function_base"][::std::mem::size_of::<std__Function_base>() - 24usize];
    ["Alignment of std__Function_base"][::std::mem::align_of::<std__Function_base>() - 8usize];
    ["Offset of field: std__Function_base::_M_functor"]
        [::std::mem::offset_of!(std__Function_base, _M_functor) - 0usize];
    ["Offset of field: std__Function_base::_M_manager"]
        [::std::mem::offset_of!(std__Function_base, _M_manager) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Function_handler {
    pub _address: u8,
}
pub type std__Mem_fn_base__Traits = std__Mem_fn_traits;
pub type std__Mem_fn_base__Arity = std__Mem_fn_base__Traits;
pub type std__Mem_fn_base__Varargs = std__Mem_fn_base__Traits;
pub type std__Mem_fn_base_result_type = std__Mem_fn_base__Traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Mem_fn {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_bind_expression {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_placeholder {
    pub _base: u8,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_1E"]
    pub static std_placeholders__1: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_2E"]
    pub static std_placeholders__2: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_3E"]
    pub static std_placeholders__3: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_4E"]
    pub static std_placeholders__4: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_5E"]
    pub static std_placeholders__5: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_6E"]
    pub static std_placeholders__6: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_7E"]
    pub static std_placeholders__7: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_8E"]
    pub static std_placeholders__8: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders2_9E"]
    pub static std_placeholders__9: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_10E"]
    pub static std_placeholders__10: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_11E"]
    pub static std_placeholders__11: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_12E"]
    pub static std_placeholders__12: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_13E"]
    pub static std_placeholders__13: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_14E"]
    pub static std_placeholders__14: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_15E"]
    pub static std_placeholders__15: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_16E"]
    pub static std_placeholders__16: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_17E"]
    pub static std_placeholders__17: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_18E"]
    pub static std_placeholders__18: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_19E"]
    pub static std_placeholders__19: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_20E"]
    pub static std_placeholders__20: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_21E"]
    pub static std_placeholders__21: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_22E"]
    pub static std_placeholders__22: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_23E"]
    pub static std_placeholders__23: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_24E"]
    pub static std_placeholders__24: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_25E"]
    pub static std_placeholders__25: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_26E"]
    pub static std_placeholders__26: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_27E"]
    pub static std_placeholders__27: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_28E"]
    pub static std_placeholders__28: u8;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt12placeholders3_29E"]
    pub static std_placeholders__29: u8;
}
pub type std__Safe_tuple_element_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bind {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bind_result {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bind_check_arity {
    pub _address: u8,
}
pub type std___is_socketlike = std___or_;
pub type std__Bind_helper___func_type = std_decay;
pub type std__Bind_helper_type = std__Bind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bindres_helper {
    pub _address: u8,
}
pub type std__Bindres_helper___functor_type = std_decay;
pub type std__Bindres_helper_type = std__Bind_result;
pub const std___safe_multiply___c: uintmax_t = 4294967296;
unsafe extern "C" {
    #[link_name = "\u{1}__a0"]
    pub static std___safe_multiply___a0: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__a1"]
    pub static std___safe_multiply___a1: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__b0"]
    pub static std___safe_multiply___b0: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__b1"]
    pub static std___safe_multiply___b1: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}value"]
    pub static std___safe_multiply_value: intmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__lo"]
    pub static std___big_add___lo: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__hi"]
    pub static std___big_add___hi: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__lo"]
    pub static std___big_sub___lo: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__hi"]
    pub static std___big_sub___hi: uintmax_t;
}
pub const std___big_mul___c: uintmax_t = 4294967296;
unsafe extern "C" {
    #[link_name = "\u{1}__x0"]
    pub static std___big_mul___x0: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__x1"]
    pub static std___big_mul___x1: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__y0"]
    pub static std___big_mul___y0: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__y1"]
    pub static std___big_mul___y1: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__x0y0"]
    pub static std___big_mul___x0y0: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__x0y1"]
    pub static std___big_mul___x0y1: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__x1y0"]
    pub static std___big_mul___x1y0: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__x1y1"]
    pub static std___big_mul___x1y1: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__mix"]
    pub static std___big_mul___mix: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__mix_lo"]
    pub static std___big_mul___mix_lo: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__mix_hi"]
    pub static std___big_mul___mix_hi: uintmax_t;
}
pub type std___big_mul__Res = u8;
unsafe extern "C" {
    #[link_name = "\u{1}__hi"]
    pub static std___big_mul___hi: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__lo"]
    pub static std___big_mul___lo: uintmax_t;
}
pub const std___big_div_impl___c: uintmax_t = 4294967296;
unsafe extern "C" {
    #[link_name = "\u{1}__d1"]
    pub static std___big_div_impl___d1: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__d0"]
    pub static std___big_div_impl___d0: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__q1x"]
    pub static std___big_div_impl___q1x: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__r1x"]
    pub static std___big_div_impl___r1x: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__m"]
    pub static std___big_div_impl___m: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__r1y"]
    pub static std___big_div_impl___r1y: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__r1z"]
    pub static std___big_div_impl___r1z: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__r1"]
    pub static std___big_div_impl___r1: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__q1"]
    pub static std___big_div_impl___q1: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__q0x"]
    pub static std___big_div_impl___q0x: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__r0x"]
    pub static std___big_div_impl___r0x: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__n"]
    pub static std___big_div_impl___n: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__r0y"]
    pub static std___big_div_impl___r0y: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__r0z"]
    pub static std___big_div_impl___r0z: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__r0"]
    pub static std___big_div_impl___r0: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__q0"]
    pub static std___big_div_impl___q0: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__quot"]
    pub static std___big_div_impl___quot: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__rem"]
    pub static std___big_div_impl___rem: uintmax_t;
}
pub type std___big_div_impl__Prod = u8;
pub type std___big_div_impl__Sum = u8;
unsafe extern "C" {
    #[link_name = "\u{1}__shift"]
    pub static std___big_div___shift: ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__coshift_"]
    pub static std___big_div___coshift_: ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__coshift"]
    pub static std___big_div___coshift: ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__c1"]
    pub static std___big_div___c1: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__c2"]
    pub static std___big_div___c2: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__new_d"]
    pub static std___big_div___new_d: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__new_n0"]
    pub static std___big_div___new_n0: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__n1_shifted"]
    pub static std___big_div___n1_shifted: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__n0_top"]
    pub static std___big_div___n0_top: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__new_n1"]
    pub static std___big_div___new_n1: uintmax_t;
}
pub type std___big_div__Res = u8;
unsafe extern "C" {
    #[link_name = "\u{1}__quot_hi"]
    pub static std___big_div___quot_hi: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__quot_lo"]
    pub static std___big_div___quot_lo: uintmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}__rem"]
    pub static std___big_div___rem: uintmax_t;
}
pub type std___big_div__P0 = u8;
pub type std___big_div__P1 = u8;
pub type std___big_div__Sum = u8;
unsafe extern "C" {
    #[link_name = "\u{1}num"]
    pub static std_ratio_num: intmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}den"]
    pub static std_ratio_den: intmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}num"]
    pub static std_num: intmax_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}den"]
    pub static std_den: intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_multiply {
    pub _address: u8,
}
pub type std___ratio_multiply_type = u8;
pub type std_ratio_multiply = std___ratio_multiply;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_divide {
    pub _address: u8,
}
pub type std___ratio_divide_type = std___ratio_multiply;
pub type std_ratio_divide = std___ratio_divide;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_not_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_less_impl_1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_less_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_greater {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_greater_equal {
    pub _address: u8,
}
pub type std___ratio_add_impl___t = u8;
pub type std___ratio_add_impl_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_add {
    pub _address: u8,
}
pub type std___ratio_add_type = u8;
pub type std_ratio_add = std___ratio_add;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_subtract {
    pub _address: u8,
}
pub type std___ratio_subtract_type = std___ratio_add;
pub type std_ratio_subtract = std___ratio_subtract;
pub type std_atto = u8;
pub type std_femto = u8;
pub type std_pico = u8;
pub type std_nano = u8;
pub type std_micro = u8;
pub type std_milli = u8;
pub type std_centi = u8;
pub type std_deci = u8;
pub type std_deca = u8;
pub type std_hecto = u8;
pub type std_kilo = u8;
pub type std_mega = u8;
pub type std_giga = u8;
pub type std_tera = u8;
pub type std_peta = u8;
pub type std_exa = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono___is_duration {
    pub _base: std_false_type,
}
pub type std_chrono___enable_if_is_duration = u8;
pub type std_chrono___disable_if_is_duration = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_treat_as_floating_point {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_duration_values {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono___is_ratio {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_chrono_duration<_Rep> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Rep>>,
    pub __r: std_chrono_duration_rep<_Rep>,
}
pub type std_chrono_duration___is_float = std_chrono_treat_as_floating_point;
pub type std_chrono_duration___divide = u8;
pub type std_chrono_duration___is_harmonic = std___bool_constant;
pub type std_chrono_duration_rep<_Rep> = _Rep;
pub type std_chrono_duration_period = __BindgenOpaqueArray<u8, 0usize>;
pub type std_chrono___common_rep_t = u8;
pub type std_chrono_nanoseconds = std_chrono_duration<i64>;
pub type std_chrono_microseconds = std_chrono_duration<i64>;
pub type std_chrono_milliseconds = std_chrono_duration<i64>;
pub type std_chrono_seconds = std_chrono_duration<i64>;
pub type std_chrono_minutes = std_chrono_duration<i64>;
pub type std_chrono_hours = std_chrono_duration<i64>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_time_point<_Dur> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Dur>>,
    pub __d: std_chrono_time_point_duration<_Dur>,
}
pub type std_chrono_time_point_clock<_Clock> = _Clock;
pub type std_chrono_time_point_duration<_Dur> = _Dur;
pub type std_chrono_time_point_rep = __BindgenOpaqueArray<u8, 0usize>;
pub type std_chrono_time_point_period = __BindgenOpaqueArray<u8, 0usize>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_system_clock {
    pub _address: u8,
}
pub type std_chrono_system_clock_duration = std_chrono_nanoseconds;
pub type std_chrono_system_clock_rep = rep;
pub type std_chrono_system_clock_period = u8;
pub type std_chrono_system_clock_time_point =
    std_chrono_time_point<std_chrono_system_clock_duration>;
pub const std_chrono_system_clock_is_steady: bool = false;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_chrono_system_clock"][::std::mem::size_of::<std_chrono_system_clock>() - 1usize];
    ["Alignment of std_chrono_system_clock"]
        [::std::mem::align_of::<std_chrono_system_clock>() - 1usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6chrono3_V212system_clock3nowEv"]
    pub fn std_chrono_system_clock_now() -> std_chrono_system_clock_time_point;
}
impl std_chrono_system_clock {
    #[inline]
    pub unsafe fn now() -> std_chrono_system_clock_time_point {
        std_chrono_system_clock_now()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_steady_clock {
    pub _address: u8,
}
pub type std_chrono_steady_clock_duration = std_chrono_nanoseconds;
pub type std_chrono_steady_clock_rep = rep;
pub type std_chrono_steady_clock_period = u8;
pub type std_chrono_steady_clock_time_point =
    std_chrono_time_point<std_chrono_steady_clock_duration>;
pub const std_chrono_steady_clock_is_steady: bool = true;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_chrono_steady_clock"][::std::mem::size_of::<std_chrono_steady_clock>() - 1usize];
    ["Alignment of std_chrono_steady_clock"]
        [::std::mem::align_of::<std_chrono_steady_clock>() - 1usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6chrono3_V212steady_clock3nowEv"]
    pub fn std_chrono_steady_clock_now() -> std_chrono_steady_clock_time_point;
}
impl std_chrono_steady_clock {
    #[inline]
    pub unsafe fn now() -> std_chrono_steady_clock_time_point {
        std_chrono_steady_clock_now()
    }
}
pub type std_chrono_high_resolution_clock = std_chrono_system_clock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___duration_common_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___timepoint_common_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct std___mutex_base {
    pub _M_mutex: std___mutex_base___native_type,
}
pub type std___mutex_base___native_type = __gthread_mutex_t;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___mutex_base"][::std::mem::size_of::<std___mutex_base>() - 40usize];
    ["Alignment of std___mutex_base"][::std::mem::align_of::<std___mutex_base>() - 8usize];
    ["Offset of field: std___mutex_base::_M_mutex"]
        [::std::mem::offset_of!(std___mutex_base, _M_mutex) - 0usize];
};
#[repr(C)]
pub struct std_mutex {
    pub _base: std___mutex_base,
}
pub type std_mutex_native_handle_type = *mut std___mutex_base___native_type;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_mutex"][::std::mem::size_of::<std_mutex>() - 40usize];
    ["Alignment of std_mutex"][::std::mem::align_of::<std_mutex>() - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_defer_lock_t {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_defer_lock_t"][::std::mem::size_of::<std_defer_lock_t>() - 1usize];
    ["Alignment of std_defer_lock_t"][::std::mem::align_of::<std_defer_lock_t>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_try_to_lock_t {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_try_to_lock_t"][::std::mem::size_of::<std_try_to_lock_t>() - 1usize];
    ["Alignment of std_try_to_lock_t"][::std::mem::align_of::<std_try_to_lock_t>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_adopt_lock_t {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_adopt_lock_t"][::std::mem::size_of::<std_adopt_lock_t>() - 1usize];
    ["Alignment of std_adopt_lock_t"][::std::mem::align_of::<std_adopt_lock_t>() - 1usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZStL10defer_lock"]
    pub static std_defer_lock: std_defer_lock_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZStL11try_to_lock"]
    pub static std_try_to_lock: std_try_to_lock_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZStL10adopt_lock"]
    pub static std_adopt_lock: std_adopt_lock_t;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_lock_guard<_Mutex> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Mutex>>,
    pub _M_device: *mut std_lock_guard_mutex_type<_Mutex>,
}
pub type std_lock_guard_mutex_type<_Mutex> = _Mutex;
#[repr(C)]
#[derive(Debug)]
pub struct std_unique_lock<_Mutex> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Mutex>>,
    pub _M_device: *mut std_unique_lock_mutex_type<_Mutex>,
    pub _M_owns: bool,
}
pub type std_unique_lock_mutex_type<_Mutex> = _Mutex;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct std___recursive_mutex_base {
    pub _M_mutex: std___recursive_mutex_base___native_type,
}
pub type std___recursive_mutex_base___native_type = __gthread_recursive_mutex_t;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std___recursive_mutex_base"]
        [::std::mem::size_of::<std___recursive_mutex_base>() - 40usize];
    ["Alignment of std___recursive_mutex_base"]
        [::std::mem::align_of::<std___recursive_mutex_base>() - 8usize];
    ["Offset of field: std___recursive_mutex_base::_M_mutex"]
        [::std::mem::offset_of!(std___recursive_mutex_base, _M_mutex) - 0usize];
};
#[repr(C)]
pub struct std_recursive_mutex {
    pub _base: std___recursive_mutex_base,
}
pub type std_recursive_mutex_native_handle_type = *mut std___recursive_mutex_base___native_type;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_recursive_mutex"][::std::mem::size_of::<std_recursive_mutex>() - 40usize];
    ["Alignment of std_recursive_mutex"][::std::mem::align_of::<std_recursive_mutex>() - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___timed_mutex_impl {
    pub _address: u8,
}
#[repr(C)]
pub struct std_timed_mutex {
    pub _base: std___mutex_base,
}
pub type std_timed_mutex_native_handle_type = *mut std___mutex_base___native_type;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_timed_mutex"][::std::mem::size_of::<std_timed_mutex>() - 40usize];
    ["Alignment of std_timed_mutex"][::std::mem::align_of::<std_timed_mutex>() - 8usize];
};
#[repr(C)]
pub struct std_recursive_timed_mutex {
    pub _base: std___recursive_mutex_base,
}
pub type std_recursive_timed_mutex_native_handle_type =
    *mut std___recursive_mutex_base___native_type;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_recursive_timed_mutex"]
        [::std::mem::size_of::<std_recursive_timed_mutex>() - 40usize];
    ["Alignment of std_recursive_timed_mutex"]
        [::std::mem::align_of::<std_recursive_timed_mutex>() - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_once_flag {
    pub _M_once: std_once_flag___native_type,
}
pub type std_once_flag___native_type = __gthread_once_t;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_once_flag"][::std::mem::size_of::<std_once_flag>() - 4usize];
    ["Alignment of std_once_flag"][::std::mem::align_of::<std_once_flag>() - 4usize];
    ["Offset of field: std_once_flag::_M_once"]
        [::std::mem::offset_of!(std_once_flag, _M_once) - 0usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt15__once_callable"]
    pub static mut std___once_callable: *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt11__once_call"]
    pub static mut std___once_call: ::std::option::Option<unsafe extern "C" fn()>;
}
unsafe extern "C" {
    #[link_name = "\u{1}__once_proxy"]
    pub fn std___once_proxy();
}
pub const std__Rb_tree_color__S_red: std__Rb_tree_color = 0;
pub const std__Rb_tree_color__S_black: std__Rb_tree_color = 1;
pub type std__Rb_tree_color = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Rb_tree_node_base {
    pub _M_color: std__Rb_tree_color,
    pub _M_parent: std__Rb_tree_node_base__Base_ptr,
    pub _M_left: std__Rb_tree_node_base__Base_ptr,
    pub _M_right: std__Rb_tree_node_base__Base_ptr,
}
pub type std__Rb_tree_node_base__Base_ptr = *mut std__Rb_tree_node_base;
pub type std__Rb_tree_node_base__Const_Base_ptr = *const std__Rb_tree_node_base;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std__Rb_tree_node_base"][::std::mem::size_of::<std__Rb_tree_node_base>() - 32usize];
    ["Alignment of std__Rb_tree_node_base"]
        [::std::mem::align_of::<std__Rb_tree_node_base>() - 8usize];
    ["Offset of field: std__Rb_tree_node_base::_M_color"]
        [::std::mem::offset_of!(std__Rb_tree_node_base, _M_color) - 0usize];
    ["Offset of field: std__Rb_tree_node_base::_M_parent"]
        [::std::mem::offset_of!(std__Rb_tree_node_base, _M_parent) - 8usize];
    ["Offset of field: std__Rb_tree_node_base::_M_left"]
        [::std::mem::offset_of!(std__Rb_tree_node_base, _M_left) - 16usize];
    ["Offset of field: std__Rb_tree_node_base::_M_right"]
        [::std::mem::offset_of!(std__Rb_tree_node_base, _M_right) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Rb_tree_key_compare<_Key_compare> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Key_compare>>,
    pub _M_key_compare: _Key_compare,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Rb_tree_header {
    pub _M_header: std__Rb_tree_node_base,
    pub _M_node_count: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std__Rb_tree_header"][::std::mem::size_of::<std__Rb_tree_header>() - 40usize];
    ["Alignment of std__Rb_tree_header"][::std::mem::align_of::<std__Rb_tree_header>() - 8usize];
    ["Offset of field: std__Rb_tree_header::_M_header"]
        [::std::mem::offset_of!(std__Rb_tree_header, _M_header) - 0usize];
    ["Offset of field: std__Rb_tree_header::_M_node_count"]
        [::std::mem::offset_of!(std__Rb_tree_header, _M_node_count) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Rb_tree_node {
    pub _base: std__Rb_tree_node_base,
    pub _M_storage: __gnu_cxx___aligned_membuf,
}
pub type std__Rb_tree_node__Link_type = *mut std__Rb_tree_node;
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt18_Rb_tree_incrementPSt18_Rb_tree_node_base"]
    pub fn std__Rb_tree_increment(__x: *mut std__Rb_tree_node_base) -> *mut std__Rb_tree_node_base;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt18_Rb_tree_incrementPKSt18_Rb_tree_node_base"]
    pub fn std__Rb_tree_increment1(
        __x: *const std__Rb_tree_node_base,
    ) -> *const std__Rb_tree_node_base;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt18_Rb_tree_decrementPSt18_Rb_tree_node_base"]
    pub fn std__Rb_tree_decrement(__x: *mut std__Rb_tree_node_base) -> *mut std__Rb_tree_node_base;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt18_Rb_tree_decrementPKSt18_Rb_tree_node_base"]
    pub fn std__Rb_tree_decrement1(
        __x: *const std__Rb_tree_node_base,
    ) -> *const std__Rb_tree_node_base;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Rb_tree_iterator {
    pub _M_node: std__Rb_tree_iterator__Base_ptr,
}
pub type std__Rb_tree_iterator_value_type<_Tp> = _Tp;
pub type std__Rb_tree_iterator_reference<_Tp> = *mut _Tp;
pub type std__Rb_tree_iterator_pointer<_Tp> = *mut _Tp;
pub type std__Rb_tree_iterator_iterator_category = std_bidirectional_iterator_tag;
pub type std__Rb_tree_iterator_difference_type = isize;
pub type std__Rb_tree_iterator__Self = std__Rb_tree_iterator;
pub type std__Rb_tree_iterator__Base_ptr = std__Rb_tree_node_base__Base_ptr;
pub type std__Rb_tree_iterator__Link_type = *mut std__Rb_tree_node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Rb_tree_const_iterator {
    pub _M_node: std__Rb_tree_const_iterator__Base_ptr,
}
pub type std__Rb_tree_const_iterator_value_type<_Tp> = _Tp;
pub type std__Rb_tree_const_iterator_reference<_Tp> = *const _Tp;
pub type std__Rb_tree_const_iterator_pointer<_Tp> = *const _Tp;
pub type std__Rb_tree_const_iterator_iterator = std__Rb_tree_iterator;
pub type std__Rb_tree_const_iterator_iterator_category = std_bidirectional_iterator_tag;
pub type std__Rb_tree_const_iterator_difference_type = isize;
pub type std__Rb_tree_const_iterator__Self = std__Rb_tree_const_iterator;
pub type std__Rb_tree_const_iterator__Base_ptr = std__Rb_tree_node_base__Const_Base_ptr;
pub type std__Rb_tree_const_iterator__Link_type = *const std__Rb_tree_node;
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt29_Rb_tree_insert_and_rebalancebPSt18_Rb_tree_node_baseS0_RS_"]
    pub fn std__Rb_tree_insert_and_rebalance(
        __insert_left: bool,
        __x: *mut std__Rb_tree_node_base,
        __p: *mut std__Rb_tree_node_base,
        __header: *mut std__Rb_tree_node_base,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt28_Rb_tree_rebalance_for_erasePSt18_Rb_tree_node_baseRS_"]
    pub fn std__Rb_tree_rebalance_for_erase(
        __z: *mut std__Rb_tree_node_base,
        __header: *mut std__Rb_tree_node_base,
    ) -> *mut std__Rb_tree_node_base;
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Rb_tree {
    pub _M_impl: u8,
}
pub type std__Rb_tree__Node_allocator = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Rb_tree__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std__Rb_tree__Base_ptr = *mut std__Rb_tree_node_base;
pub type std__Rb_tree__Const_Base_ptr = *const std__Rb_tree_node_base;
pub type std__Rb_tree__Link_type = *mut std__Rb_tree_node;
pub type std__Rb_tree__Const_Link_type = *const std__Rb_tree_node;
#[repr(C)]
#[derive(Debug)]
pub struct std__Rb_tree__Reuse_or_alloc_node {
    pub _M_root: std__Rb_tree__Base_ptr,
    pub _M_nodes: std__Rb_tree__Base_ptr,
    pub _M_t: *mut std__Rb_tree,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Rb_tree__Alloc_node {
    pub _M_t: *mut std__Rb_tree,
}
pub type std__Rb_tree_key_type<_Key> = _Key;
pub type std__Rb_tree_value_type<_Val> = _Val;
pub type std__Rb_tree_pointer<_Val> = *mut std__Rb_tree_value_type<_Val>;
pub type std__Rb_tree_const_pointer<_Val> = *const std__Rb_tree_value_type<_Val>;
pub type std__Rb_tree_reference<_Val> = *mut std__Rb_tree_value_type<_Val>;
pub type std__Rb_tree_const_reference<_Val> = *const std__Rb_tree_value_type<_Val>;
pub type std__Rb_tree_size_type = usize;
pub type std__Rb_tree_difference_type = isize;
pub type std__Rb_tree_allocator_type<_Alloc> = _Alloc;
pub type std__Rb_tree_reverse_iterator = std_reverse_iterator<std__Rb_tree_iterator>;
pub type std__Rb_tree_const_reverse_iterator = std_reverse_iterator<std__Rb_tree_const_iterator>;
pub type std__Rb_tree___same_value_type = std_is_same;
pub type std__Rb_tree__Rb_tree_impl__Base_key_compare<_Key_compare> =
    std__Rb_tree_key_compare<_Key_compare>;
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt20_Rb_tree_black_countPKSt18_Rb_tree_node_baseS1_"]
    pub fn std__Rb_tree_black_count(
        __node: *const std__Rb_tree_node_base,
        __root: *const std__Rb_tree_node_base,
    ) -> ::std::os::raw::c_uint;
}
#[repr(C)]
pub struct std_map {
    pub _M_t: std_map__Rep_type,
}
pub type std_map_key_type<_Key> = _Key;
pub type std_map_mapped_type<_Tp> = _Tp;
pub type std_map_value_type<_Key, _Tp> = std_pair<_Key, _Tp>;
pub type std_map_key_compare<_Compare> = _Compare;
pub type std_map_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_map_value_compare<_Compare> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
    pub comp: _Compare,
}
pub type std_map__Pair_alloc_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_map__Rep_type = std__Rb_tree;
pub type std_map__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_map_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std_map_const_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std_map_reference = __BindgenOpaqueArray<u8, 0usize>;
pub type std_map_const_reference = __BindgenOpaqueArray<u8, 0usize>;
pub type std_map_iterator = __BindgenOpaqueArray<u8, 0usize>;
pub type std_map_const_iterator = __BindgenOpaqueArray<u8, 0usize>;
pub type std_map_size_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_map_difference_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_map_reverse_iterator = __BindgenOpaqueArray<u8, 0usize>;
pub type std_map_const_reverse_iterator = __BindgenOpaqueArray<u8, 0usize>;
#[repr(C)]
pub struct std_multimap {
    pub _M_t: std_multimap__Rep_type,
}
pub type std_multimap_key_type<_Key> = _Key;
pub type std_multimap_mapped_type<_Tp> = _Tp;
pub type std_multimap_value_type<_Key, _Tp> = std_pair<_Key, _Tp>;
pub type std_multimap_key_compare<_Compare> = _Compare;
pub type std_multimap_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_multimap_value_compare<_Compare> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
    pub comp: _Compare,
}
pub type std_multimap__Pair_alloc_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_multimap__Rep_type = std__Rb_tree;
pub type std_multimap__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_multimap_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std_multimap_const_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std_multimap_reference = __BindgenOpaqueArray<u8, 0usize>;
pub type std_multimap_const_reference = __BindgenOpaqueArray<u8, 0usize>;
pub type std_multimap_iterator = __BindgenOpaqueArray<u8, 0usize>;
pub type std_multimap_const_iterator = __BindgenOpaqueArray<u8, 0usize>;
pub type std_multimap_size_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_multimap_difference_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_multimap_reverse_iterator = __BindgenOpaqueArray<u8, 0usize>;
pub type std_multimap_const_reverse_iterator = __BindgenOpaqueArray<u8, 0usize>;
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt3cin"]
    pub static mut std_cin: std_istream;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt4cout"]
    pub static mut std_cout: std_ostream;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt4cerr"]
    pub static mut std_cerr: std_ostream;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt4clog"]
    pub static mut std_clog: std_ostream;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt4wcin"]
    pub static mut std_wcin: std_wistream;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt5wcout"]
    pub static mut std_wcout: std_wostream;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt5wcerr"]
    pub static mut std_wcerr: std_wostream;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt5wclog"]
    pub static mut std_wclog: std_wostream;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZStL8__ioinit"]
    pub static mut std___ioinit: std_ios_base_Init;
}
#[repr(C)]
pub struct std_set {
    pub _M_t: std_set__Rep_type,
}
pub type std_set_key_type<_Key> = _Key;
pub type std_set_value_type<_Key> = _Key;
pub type std_set_key_compare<_Compare> = _Compare;
pub type std_set_value_compare<_Compare> = _Compare;
pub type std_set_allocator_type<_Alloc> = _Alloc;
pub type std_set__Key_alloc_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_set__Rep_type = std__Rb_tree;
pub type std_set__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_set_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std_set_const_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std_set_reference = __BindgenOpaqueArray<u8, 0usize>;
pub type std_set_const_reference = __BindgenOpaqueArray<u8, 0usize>;
pub type std_set_iterator = __BindgenOpaqueArray<u8, 0usize>;
pub type std_set_const_iterator = __BindgenOpaqueArray<u8, 0usize>;
pub type std_set_reverse_iterator = __BindgenOpaqueArray<u8, 0usize>;
pub type std_set_const_reverse_iterator = __BindgenOpaqueArray<u8, 0usize>;
pub type std_set_size_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_set_difference_type = __BindgenOpaqueArray<u8, 0usize>;
#[repr(C)]
pub struct std_multiset {
    pub _M_t: std_multiset__Rep_type,
}
pub type std_multiset_key_type<_Key> = _Key;
pub type std_multiset_value_type<_Key> = _Key;
pub type std_multiset_key_compare<_Compare> = _Compare;
pub type std_multiset_value_compare<_Compare> = _Compare;
pub type std_multiset_allocator_type<_Alloc> = _Alloc;
pub type std_multiset__Key_alloc_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_multiset__Rep_type = std__Rb_tree;
pub type std_multiset__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_multiset_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std_multiset_const_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std_multiset_reference = __BindgenOpaqueArray<u8, 0usize>;
pub type std_multiset_const_reference = __BindgenOpaqueArray<u8, 0usize>;
pub type std_multiset_iterator = __BindgenOpaqueArray<u8, 0usize>;
pub type std_multiset_const_iterator = __BindgenOpaqueArray<u8, 0usize>;
pub type std_multiset_reverse_iterator = __BindgenOpaqueArray<u8, 0usize>;
pub type std_multiset_const_reverse_iterator = __BindgenOpaqueArray<u8, 0usize>;
pub type std_multiset_size_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_multiset_difference_type = __BindgenOpaqueArray<u8, 0usize>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_time_base {
    pub _address: u8,
}
pub const std_time_base_dateorder_no_order: std_time_base_dateorder = 0;
pub const std_time_base_dateorder_dmy: std_time_base_dateorder = 1;
pub const std_time_base_dateorder_mdy: std_time_base_dateorder = 2;
pub const std_time_base_dateorder_ymd: std_time_base_dateorder = 3;
pub const std_time_base_dateorder_ydm: std_time_base_dateorder = 4;
pub type std_time_base_dateorder = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_time_base"][::std::mem::size_of::<std_time_base>() - 1usize];
    ["Alignment of std_time_base"][::std::mem::align_of::<std_time_base>() - 1usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct std___timepunct_cache<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _base: std_locale_facet,
    pub _M_date_format: *const _CharT,
    pub _M_date_era_format: *const _CharT,
    pub _M_time_format: *const _CharT,
    pub _M_time_era_format: *const _CharT,
    pub _M_date_time_format: *const _CharT,
    pub _M_date_time_era_format: *const _CharT,
    pub _M_am: *const _CharT,
    pub _M_pm: *const _CharT,
    pub _M_am_pm_format: *const _CharT,
    pub _M_day1: *const _CharT,
    pub _M_day2: *const _CharT,
    pub _M_day3: *const _CharT,
    pub _M_day4: *const _CharT,
    pub _M_day5: *const _CharT,
    pub _M_day6: *const _CharT,
    pub _M_day7: *const _CharT,
    pub _M_aday1: *const _CharT,
    pub _M_aday2: *const _CharT,
    pub _M_aday3: *const _CharT,
    pub _M_aday4: *const _CharT,
    pub _M_aday5: *const _CharT,
    pub _M_aday6: *const _CharT,
    pub _M_aday7: *const _CharT,
    pub _M_month01: *const _CharT,
    pub _M_month02: *const _CharT,
    pub _M_month03: *const _CharT,
    pub _M_month04: *const _CharT,
    pub _M_month05: *const _CharT,
    pub _M_month06: *const _CharT,
    pub _M_month07: *const _CharT,
    pub _M_month08: *const _CharT,
    pub _M_month09: *const _CharT,
    pub _M_month10: *const _CharT,
    pub _M_month11: *const _CharT,
    pub _M_month12: *const _CharT,
    pub _M_amonth01: *const _CharT,
    pub _M_amonth02: *const _CharT,
    pub _M_amonth03: *const _CharT,
    pub _M_amonth04: *const _CharT,
    pub _M_amonth05: *const _CharT,
    pub _M_amonth06: *const _CharT,
    pub _M_amonth07: *const _CharT,
    pub _M_amonth08: *const _CharT,
    pub _M_amonth09: *const _CharT,
    pub _M_amonth10: *const _CharT,
    pub _M_amonth11: *const _CharT,
    pub _M_amonth12: *const _CharT,
    pub _M_allocated: bool,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt17__timepunct_cacheIcE12_S_timezonesE"]
    pub static mut std__S_timezones: [*const ::std::os::raw::c_char; 14usize];
}
#[repr(C)]
#[derive(Debug)]
pub struct std___timepunct<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _base: std_locale_facet,
    pub _M_data: *mut std___timepunct___cache_type<_CharT>,
    pub _M_c_locale_timepunct: std___c_locale,
    pub _M_name_timepunct: *const ::std::os::raw::c_char,
}
pub type std___timepunct___char_type<_CharT> = _CharT;
pub type std___timepunct___cache_type<_CharT> = std___timepunct_cache<_CharT>;
#[repr(C)]
#[derive(Debug)]
pub struct std_time_put {
    pub _base: std_locale_facet,
}
pub type std_time_put_char_type<_CharT> = _CharT;
pub type std_time_put_iter_type<_OutIter> = _OutIter;
#[repr(C)]
#[derive(Debug)]
pub struct std_time_put_byname {
    pub _base: std_time_put,
}
pub type std_time_put_byname_char_type<_CharT> = _CharT;
pub type std_time_put_byname_iter_type<_OutIter> = _OutIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_money_base {
    pub _address: u8,
}
pub const std_money_base_part_none: std_money_base_part = 0;
pub const std_money_base_part_space: std_money_base_part = 1;
pub const std_money_base_part_symbol: std_money_base_part = 2;
pub const std_money_base_part_sign: std_money_base_part = 3;
pub const std_money_base_part_value: std_money_base_part = 4;
pub type std_money_base_part = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_money_base_pattern {
    pub field: [::std::os::raw::c_char; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_money_base_pattern"][::std::mem::size_of::<std_money_base_pattern>() - 4usize];
    ["Alignment of std_money_base_pattern"]
        [::std::mem::align_of::<std_money_base_pattern>() - 1usize];
    ["Offset of field: std_money_base_pattern::field"]
        [::std::mem::offset_of!(std_money_base_pattern, field) - 0usize];
};
pub const std_money_base__S_minus: std_money_base__bindgen_ty_1 = 0;
pub const std_money_base__S_zero: std_money_base__bindgen_ty_1 = 1;
pub const std_money_base__S_end: std_money_base__bindgen_ty_1 = 11;
pub type std_money_base__bindgen_ty_1 = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10money_base18_S_default_patternE"]
    pub static std_money_base__S_default_pattern: std_money_base_pattern;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10money_base8_S_atomsE"]
    pub static mut std_money_base__S_atoms: *const ::std::os::raw::c_char;
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_money_base"][::std::mem::size_of::<std_money_base>() - 1usize];
    ["Alignment of std_money_base"][::std::mem::align_of::<std_money_base>() - 1usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10money_base20_S_construct_patternEccc"]
    pub fn std_money_base__S_construct_pattern(
        __precedes: ::std::os::raw::c_char,
        __space: ::std::os::raw::c_char,
        __posn: ::std::os::raw::c_char,
    ) -> std_money_base_pattern;
}
impl std_money_base {
    #[inline]
    pub unsafe fn _S_construct_pattern(
        __precedes: ::std::os::raw::c_char,
        __space: ::std::os::raw::c_char,
        __posn: ::std::os::raw::c_char,
    ) -> std_money_base_pattern {
        std_money_base__S_construct_pattern(__precedes, __space, __posn)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_messages_base {
    pub _address: u8,
}
pub type std_messages_base_catalog = ::std::os::raw::c_int;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_messages_base"][::std::mem::size_of::<std_messages_base>() - 1usize];
    ["Alignment of std_messages_base"][::std::mem::align_of::<std_messages_base>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_codecvt_base {
    pub _address: u8,
}
pub const std_codecvt_base_result_ok: std_codecvt_base_result = 0;
pub const std_codecvt_base_result_partial: std_codecvt_base_result = 1;
pub const std_codecvt_base_result_error: std_codecvt_base_result = 2;
pub const std_codecvt_base_result_noconv: std_codecvt_base_result = 3;
pub type std_codecvt_base_result = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std_codecvt_base"][::std::mem::size_of::<std_codecvt_base>() - 1usize];
    ["Alignment of std_codecvt_base"][::std::mem::align_of::<std_codecvt_base>() - 1usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct std___codecvt_abstract_base {
    pub _base: std_locale_facet,
}
pub use self::std_codecvt_base_result as std___codecvt_abstract_base_result;
pub type std___codecvt_abstract_base_intern_type<_InternT> = _InternT;
pub type std___codecvt_abstract_base_extern_type<_ExternT> = _ExternT;
pub type std___codecvt_abstract_base_state_type<_StateT> = _StateT;
#[repr(C)]
#[derive(Debug)]
pub struct std_codecvt {
    pub _base: std___codecvt_abstract_base,
    pub _M_c_locale_codecvt: std___c_locale,
}
pub use self::std_codecvt_base_result as std_codecvt_result;
pub type std_codecvt_intern_type<_InternT> = _InternT;
pub type std_codecvt_extern_type<_ExternT> = _ExternT;
pub type std_codecvt_state_type<_StateT> = _StateT;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_codecvt_open0_char_char___mbstate_t_close0"]
        [::std::mem::size_of::<std_codecvt>() - 24usize];
    ["Align of template specialization: std_codecvt_open0_char_char___mbstate_t_close0"]
        [::std::mem::align_of::<std_codecvt>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_codecvt_open0_wchar_t_char___mbstate_t_close0"]
        [::std::mem::size_of::<std_codecvt>() - 24usize];
    ["Align of template specialization: std_codecvt_open0_wchar_t_char___mbstate_t_close0"]
        [::std::mem::align_of::<std_codecvt>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_codecvt_open0_char16_t_char___mbstate_t_close0"]
        [::std::mem::size_of::<std_codecvt>() - 16usize];
    ["Align of template specialization: std_codecvt_open0_char16_t_char___mbstate_t_close0"]
        [::std::mem::align_of::<std_codecvt>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_codecvt_open0_char32_t_char___mbstate_t_close0"]
        [::std::mem::size_of::<std_codecvt>() - 16usize];
    ["Align of template specialization: std_codecvt_open0_char32_t_char___mbstate_t_close0"]
        [::std::mem::align_of::<std_codecvt>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct std_codecvt_byname {
    pub _base: std_codecvt,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_codecvt_byname_open0_char16_t_char___mbstate_t_close0"]
        [::std::mem::size_of::<std_codecvt_byname>() - 16usize];
    ["Align of template specialization: std_codecvt_byname_open0_char16_t_char___mbstate_t_close0"]
        [::std::mem::align_of::<std_codecvt_byname>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_codecvt_byname_open0_char32_t_char___mbstate_t_close0"]
        [::std::mem::size_of::<std_codecvt_byname>() - 16usize];
    ["Align of template specialization: std_codecvt_byname_open0_char32_t_char___mbstate_t_close0"]
        [::std::mem::align_of::<std_codecvt_byname>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_codecvt_byname_open0_char_char___mbstate_t_close0"]
        [::std::mem::size_of::<std_codecvt_byname>() - 24usize];
    ["Align of template specialization: std_codecvt_byname_open0_char_char___mbstate_t_close0"]
        [::std::mem::align_of::<std_codecvt_byname>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_codecvt_byname_open0_wchar_t_char___mbstate_t_close0"]
        [::std::mem::size_of::<std_codecvt_byname>() - 24usize];
    ["Align of template specialization: std_codecvt_byname_open0_wchar_t_char___mbstate_t_close0"]
        [::std::mem::align_of::<std_codecvt_byname>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_money_get_open0_char_std_istreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_money_get>() - 16usize];
    [
        "Align of template specialization: std_money_get_open0_char_std_istreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_money_get>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_money_put_open0_char_std_ostreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_money_put>() - 16usize];
    [
        "Align of template specialization: std_money_put_open0_char_std_ostreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_money_put>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___timepunct_open0_char_close0"]
        [::std::mem::size_of::<std___timepunct<::std::os::raw::c_char>>() - 40usize];
    ["Align of template specialization: std___timepunct_open0_char_close0"]
        [::std::mem::align_of::<std___timepunct<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_time_put_open0_char_std_ostreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_time_put>() - 16usize];
    [
        "Align of template specialization: std_time_put_open0_char_std_ostreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_time_put>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_time_put_byname_open0_char_std_ostreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_time_put_byname>() - 16usize];
    [
        "Align of template specialization: std_time_put_byname_open0_char_std_ostreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_time_put_byname>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_time_get_open0_char_std_istreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_time_get>() - 16usize];
    [
        "Align of template specialization: std_time_get_open0_char_std_istreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_time_get>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_time_get_byname_open0_char_std_istreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_time_get_byname>() - 16usize];
    [
        "Align of template specialization: std_time_get_byname_open0_char_std_istreambuf_iterator_open1_char_std_char_traits_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_time_get_byname>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_messages_open0_char_close0"]
        [::std::mem::size_of::<std_messages>() - 32usize];
    ["Align of template specialization: std_messages_open0_char_close0"]
        [::std::mem::align_of::<std_messages>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_messages_byname_open0_char_close0"]
        [::std::mem::size_of::<std_messages_byname>() - 32usize];
    ["Align of template specialization: std_messages_byname_open0_char_close0"]
        [::std::mem::align_of::<std_messages_byname>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_money_get_open0_wchar_t_std_istreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0",
    ][::std::mem::size_of::<std_money_get>() - 16usize];
    [
        "Align of template specialization: std_money_get_open0_wchar_t_std_istreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0",
    ][::std::mem::align_of::<std_money_get>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_money_put_open0_wchar_t_std_ostreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0",
    ][::std::mem::size_of::<std_money_put>() - 16usize];
    [
        "Align of template specialization: std_money_put_open0_wchar_t_std_ostreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0",
    ][::std::mem::align_of::<std_money_put>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___timepunct_open0_wchar_t_close0"]
        [::std::mem::size_of::<std___timepunct<u32>>() - 40usize];
    ["Align of template specialization: std___timepunct_open0_wchar_t_close0"]
        [::std::mem::align_of::<std___timepunct<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_time_put_open0_wchar_t_std_ostreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0",
    ][::std::mem::size_of::<std_time_put>() - 16usize];
    [
        "Align of template specialization: std_time_put_open0_wchar_t_std_ostreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0",
    ][::std::mem::align_of::<std_time_put>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_time_put_byname_open0_wchar_t_std_ostreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0",
    ][::std::mem::size_of::<std_time_put_byname>() - 16usize];
    [
        "Align of template specialization: std_time_put_byname_open0_wchar_t_std_ostreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0",
    ][::std::mem::align_of::<std_time_put_byname>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_time_get_open0_wchar_t_std_istreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0",
    ][::std::mem::size_of::<std_time_get>() - 16usize];
    [
        "Align of template specialization: std_time_get_open0_wchar_t_std_istreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0",
    ][::std::mem::align_of::<std_time_get>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_time_get_byname_open0_wchar_t_std_istreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0",
    ][::std::mem::size_of::<std_time_get_byname>() - 16usize];
    [
        "Align of template specialization: std_time_get_byname_open0_wchar_t_std_istreambuf_iterator_open1_wchar_t_std_char_traits_open2_wchar_t_close2_close1_close0",
    ][::std::mem::align_of::<std_time_get_byname>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_messages_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_messages>() - 32usize];
    ["Align of template specialization: std_messages_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_messages>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_messages_byname_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_messages_byname>() - 32usize];
    ["Align of template specialization: std_messages_byname_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_messages_byname>() - 8usize];
};
#[repr(C)]
pub struct std_wbuffer_convert<_Elem> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Elem>>,
    pub _base: std_basic_streambuf<_Elem>,
    pub _M_buf: *mut std_streambuf,
    pub _M_cvt: std_unique_ptr,
    pub _M_state: std_wbuffer_convert_state_type,
    pub _M_put_area: *mut _Elem,
    pub _M_get_area: *mut _Elem,
    pub _M_unconv: std_streamsize,
    pub _M_get_buf: *mut ::std::os::raw::c_char,
    pub _M_always_noconv: bool,
}
pub type std_wbuffer_convert__Wide_streambuf<_Elem> = std_basic_streambuf<_Elem>;
pub type std_wbuffer_convert_state_type = __BindgenOpaqueArray<u8, 0usize>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Resetiosflags {
    pub _M_mask: std_ios_base_fmtflags,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std__Resetiosflags"][::std::mem::size_of::<std__Resetiosflags>() - 4usize];
    ["Alignment of std__Resetiosflags"][::std::mem::align_of::<std__Resetiosflags>() - 4usize];
    ["Offset of field: std__Resetiosflags::_M_mask"]
        [::std::mem::offset_of!(std__Resetiosflags, _M_mask) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Setiosflags {
    pub _M_mask: std_ios_base_fmtflags,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std__Setiosflags"][::std::mem::size_of::<std__Setiosflags>() - 4usize];
    ["Alignment of std__Setiosflags"][::std::mem::align_of::<std__Setiosflags>() - 4usize];
    ["Offset of field: std__Setiosflags::_M_mask"]
        [::std::mem::offset_of!(std__Setiosflags, _M_mask) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Setbase {
    pub _M_base: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std__Setbase"][::std::mem::size_of::<std__Setbase>() - 4usize];
    ["Alignment of std__Setbase"][::std::mem::align_of::<std__Setbase>() - 4usize];
    ["Offset of field: std__Setbase::_M_base"]
        [::std::mem::offset_of!(std__Setbase, _M_base) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Setfill<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _M_c: _CharT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Setprecision {
    pub _M_n: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std__Setprecision"][::std::mem::size_of::<std__Setprecision>() - 4usize];
    ["Alignment of std__Setprecision"][::std::mem::align_of::<std__Setprecision>() - 4usize];
    ["Offset of field: std__Setprecision::_M_n"]
        [::std::mem::offset_of!(std__Setprecision, _M_n) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Setw {
    pub _M_n: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std__Setw"][::std::mem::size_of::<std__Setw>() - 4usize];
    ["Alignment of std__Setw"][::std::mem::align_of::<std__Setw>() - 4usize];
    ["Offset of field: std__Setw::_M_n"][::std::mem::offset_of!(std__Setw, _M_n) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Get_money<_MoneyT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_MoneyT>>,
    pub _M_mon: *mut _MoneyT,
    pub _M_intl: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Put_money<_MoneyT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_MoneyT>>,
    pub _M_mon: *const _MoneyT,
    pub _M_intl: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Put_time<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _M_tmb: *const tm,
    pub _M_fmt: *const _CharT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Get_time<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _M_tmb: *mut tm,
    pub _M_fmt: *const _CharT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Enable_default_constructor_tag {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of std__Enable_default_constructor_tag"]
        [::std::mem::size_of::<std__Enable_default_constructor_tag>() - 1usize];
    ["Alignment of std__Enable_default_constructor_tag"]
        [::std::mem::align_of::<std__Enable_default_constructor_tag>() - 1usize];
};
pub type std___cache_default = std___not_;
pub type std__Hashtable_enable_default_ctor = u8;
#[repr(C)]
#[derive(Debug)]
pub struct std__Hashtable<_RehashPolicy> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_RehashPolicy>>,
    pub _M_buckets: *mut std__Hashtable___bucket_type,
    pub _M_bucket_count: std__Hashtable_size_type,
    pub _M_before_begin: std__Hashtable___node_base,
    pub _M_element_count: std__Hashtable_size_type,
    pub _M_rehash_policy: _RehashPolicy,
    pub _M_single_bucket: std__Hashtable___bucket_type,
}
pub type std__Hashtable___traits_type<_Traits> = _Traits;
pub type std__Hashtable___hash_cached = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Hashtable___node_type = u8;
pub type std__Hashtable___node_alloc_type = std___alloc_rebind;
pub type std__Hashtable___hashtable_alloc = std___detail__Hashtable_alloc;
pub type std__Hashtable___value_alloc_traits = std__Hashtable___hashtable_alloc;
pub type std__Hashtable___node_alloc_traits = std__Hashtable___hashtable_alloc;
pub type std__Hashtable___node_base = std__Hashtable___hashtable_alloc;
pub type std__Hashtable___bucket_type = std__Hashtable___hashtable_alloc;
pub type std__Hashtable___enable_default_ctor = std__Hashtable_enable_default_ctor;
pub type std__Hashtable_key_type<_Key> = _Key;
pub type std__Hashtable_value_type<_Value> = _Value;
pub type std__Hashtable_allocator_type<_Alloc> = _Alloc;
pub type std__Hashtable_key_equal<_Equal> = _Equal;
pub type std__Hashtable_pointer = std__Hashtable___value_alloc_traits;
pub type std__Hashtable_const_pointer = std__Hashtable___value_alloc_traits;
pub type std__Hashtable_reference<_Value> = *mut std__Hashtable_value_type<_Value>;
pub type std__Hashtable_const_reference<_Value> = *const std__Hashtable_value_type<_Value>;
pub type std__Hashtable___rehash_type<_RehashPolicy> = _RehashPolicy;
pub type std__Hashtable___rehash_state = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Hashtable___constant_iterators = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Hashtable___unique_keys = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Hashtable___key_extract = u8;
pub type std__Hashtable___hashtable_base = std___detail__Hashtable_base;
pub type std__Hashtable___hash_code_base = std__Hashtable___hashtable_base;
pub type std__Hashtable___hash_code = std__Hashtable___hashtable_base;
pub type std__Hashtable___ireturn_type = std__Hashtable___hashtable_base;
pub type std__Hashtable___map_base = u8;
pub type std__Hashtable___rehash_base = std___detail__Rehash_base;
pub type std__Hashtable___eq_base = u8;
pub type std__Hashtable___reuse_or_alloc_node_gen_t = std___detail__ReuseOrAllocNode;
pub type std__Hashtable___alloc_node_gen_t = std___detail__AllocNode;
#[repr(C)]
#[derive(Debug)]
pub struct std__Hashtable__Scoped_node {
    pub _M_h: *mut std__Hashtable___hashtable_alloc,
    pub _M_node: *mut std__Hashtable___node_type,
}
pub type std__Hashtable___if_hash_cached = std___or_;
pub type std__Hashtable___if_hash_not_cached = std___or_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Hashtable___hash_code_base_access {
    pub _address: u8,
}
pub type std__Hashtable_size_type = std__Hashtable___hashtable_base;
pub type std__Hashtable_difference_type = std__Hashtable___hashtable_base;
pub type std__Hashtable_iterator = std__Hashtable___hashtable_base;
pub type std__Hashtable_const_iterator = std__Hashtable___hashtable_base;
pub type std__Hashtable_local_iterator = std__Hashtable___hashtable_base;
pub type std__Hashtable_const_local_iterator = std__Hashtable___hashtable_base;
pub type std___umap_traits = u8;
pub type std___umap_hashtable = std__Hashtable<_RehashPolicy>;
pub type std___ummap_traits = u8;
pub type std___ummap_hashtable = std__Hashtable<_RehashPolicy>;
#[repr(C)]
#[derive(Debug)]
pub struct std_unordered_map {
    pub _M_h: std_unordered_map__Hashtable,
}
pub type std_unordered_map__Hashtable = std___umap_hashtable;
pub type std_unordered_map_key_type = std_unordered_map__Hashtable;
pub type std_unordered_map_value_type = std_unordered_map__Hashtable;
pub type std_unordered_map_mapped_type = std_unordered_map__Hashtable;
pub type std_unordered_map_hasher = std_unordered_map__Hashtable;
pub type std_unordered_map_key_equal = std_unordered_map__Hashtable;
pub type std_unordered_map_allocator_type = std_unordered_map__Hashtable;
pub type std_unordered_map_pointer = std_unordered_map__Hashtable;
pub type std_unordered_map_const_pointer = std_unordered_map__Hashtable;
pub type std_unordered_map_reference = std_unordered_map__Hashtable;
pub type std_unordered_map_const_reference = std_unordered_map__Hashtable;
pub type std_unordered_map_iterator = std_unordered_map__Hashtable;
pub type std_unordered_map_const_iterator = std_unordered_map__Hashtable;
pub type std_unordered_map_local_iterator = std_unordered_map__Hashtable;
pub type std_unordered_map_const_local_iterator = std_unordered_map__Hashtable;
pub type std_unordered_map_size_type = std_unordered_map__Hashtable;
pub type std_unordered_map_difference_type = std_unordered_map__Hashtable;
#[repr(C)]
#[derive(Debug)]
pub struct std_unordered_multimap {
    pub _M_h: std_unordered_multimap__Hashtable,
}
pub type std_unordered_multimap__Hashtable = std___ummap_hashtable;
pub type std_unordered_multimap_key_type = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_value_type = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_mapped_type = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_hasher = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_key_equal = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_allocator_type = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_pointer = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_const_pointer = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_reference = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_const_reference = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_iterator = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_const_iterator = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_local_iterator = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_const_local_iterator = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_size_type = std_unordered_multimap__Hashtable;
pub type std_unordered_multimap_difference_type = std_unordered_multimap__Hashtable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__List_node {
    pub _base: std___detail__List_node_base,
    pub _M_storage: __gnu_cxx___aligned_membuf,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__List_iterator {
    pub _M_node: *mut std___detail__List_node_base,
}
pub type std__List_iterator__Self = std__List_iterator;
pub type std__List_iterator__Node = std__List_node;
pub type std__List_iterator_difference_type = isize;
pub type std__List_iterator_iterator_category = std_bidirectional_iterator_tag;
pub type std__List_iterator_value_type<_Tp> = _Tp;
pub type std__List_iterator_pointer<_Tp> = *mut _Tp;
pub type std__List_iterator_reference<_Tp> = *mut _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__List_const_iterator {
    pub _M_node: *const std___detail__List_node_base,
}
pub type std__List_const_iterator__Self = std__List_const_iterator;
pub type std__List_const_iterator__Node = std__List_node;
pub type std__List_const_iterator_iterator = std__List_iterator;
pub type std__List_const_iterator_difference_type = isize;
pub type std__List_const_iterator_iterator_category = std_bidirectional_iterator_tag;
pub type std__List_const_iterator_value_type<_Tp> = _Tp;
pub type std__List_const_iterator_pointer<_Tp> = *const _Tp;
pub type std__List_const_iterator_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Deque_iterator {
    pub _M_cur: std__Deque_iterator__Elt_pointer,
    pub _M_first: std__Deque_iterator__Elt_pointer,
    pub _M_last: std__Deque_iterator__Elt_pointer,
    pub _M_node: std__Deque_iterator__Map_pointer,
}
pub type std__Deque_iterator___iter = std__Deque_iterator;
pub type std__Deque_iterator_iterator = std__Deque_iterator___iter;
pub type std__Deque_iterator_const_iterator = std__Deque_iterator___iter;
pub type std__Deque_iterator__Elt_pointer = std___ptr_rebind;
pub type std__Deque_iterator__Map_pointer = std___ptr_rebind;
pub type std__Deque_iterator_iterator_category = std_random_access_iterator_tag;
pub type std__Deque_iterator_value_type<_Tp> = _Tp;
pub type std__Deque_iterator_pointer<_Ptr> = _Ptr;
pub type std__Deque_iterator_reference<_Ref> = _Ref;
pub type std__Deque_iterator_size_type = usize;
pub type std__Deque_iterator_difference_type = isize;
pub type std__Deque_iterator__Self = std__Deque_iterator;
#[repr(C)]
pub struct std__Deque_base {
    pub _M_impl: std__Deque_base__Deque_impl,
}
pub type std__Deque_base__Tp_alloc_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Deque_base__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std__Deque_base__Ptr = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Deque_base__Ptr_const = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Deque_base__Map_alloc_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std__Deque_base__Map_alloc_traits = __gnu_cxx___alloc_traits;
pub type std__Deque_base_allocator_type<_Alloc> = _Alloc;
pub type std__Deque_base_iterator = std__Deque_iterator;
pub type std__Deque_base_const_iterator = std__Deque_iterator;
pub type std__Deque_base__Map_pointer = __BindgenOpaqueArray<u8, 0usize>;
#[repr(C)]
pub struct std__Deque_base__Deque_impl_data {
    pub _M_map: std__Deque_base__Map_pointer,
    pub _M_map_size: usize,
    pub _M_start: std__Deque_base_iterator,
    pub _M_finish: std__Deque_base_iterator,
}
#[repr(C)]
pub struct std__Deque_base__Deque_impl {
    pub _base_1: std__Deque_base__Deque_impl_data,
}
pub const std__Deque_base__S_initial_map_size: std__Deque_base__bindgen_ty_1 = 0;
pub type std__Deque_base__bindgen_ty_1 = i32;
#[repr(C)]
pub struct std_deque {
    pub _base: std__Deque_base,
}
pub type std_deque__Base = std__Deque_base;
pub type std_deque__Tp_alloc_type = std_deque__Base;
pub type std_deque__Alloc_traits = std_deque__Base;
pub type std_deque__Map_pointer = std_deque__Base;
pub type std_deque_value_type<_Tp> = _Tp;
pub type std_deque_pointer = std_deque__Alloc_traits;
pub type std_deque_const_pointer = std_deque__Alloc_traits;
pub type std_deque_reference = std_deque__Alloc_traits;
pub type std_deque_const_reference = std_deque__Alloc_traits;
pub type std_deque_iterator = std_deque__Base;
pub type std_deque_const_iterator = std_deque__Base;
pub type std_deque_const_reverse_iterator = std_reverse_iterator<std_deque_const_iterator>;
pub type std_deque_reverse_iterator = std_reverse_iterator<std_deque_iterator>;
pub type std_deque_size_type = usize;
pub type std_deque_difference_type = isize;
pub type std_deque_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_queue<_Sequence> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Sequence>>,
    pub c: _Sequence,
}
pub type std_queue__Uses = u8;
pub type std_queue_value_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_queue_reference = __BindgenOpaqueArray<u8, 0usize>;
pub type std_queue_const_reference = __BindgenOpaqueArray<u8, 0usize>;
pub type std_queue_size_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_queue_container_type<_Sequence> = _Sequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_priority_queue<_Sequence, _Compare> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Sequence>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
    pub c: _Sequence,
    pub comp: _Compare,
}
pub type std_priority_queue__Uses = u8;
pub type std_priority_queue_value_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_priority_queue_reference = __BindgenOpaqueArray<u8, 0usize>;
pub type std_priority_queue_const_reference = __BindgenOpaqueArray<u8, 0usize>;
pub type std_priority_queue_size_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_priority_queue_container_type<_Sequence> = _Sequence;
pub type std_priority_queue_value_compare<_Compare> = _Compare;
pub type std___c_lock = __gthread_mutex_t;
pub type std___c_file = FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___basic_file {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___basic_file_open0_char_close0"]
        [::std::mem::size_of::<std___basic_file>() - 16usize];
    ["Align of template specialization: std___basic_file_open0_char_close0"]
        [::std::mem::align_of::<std___basic_file>() - 8usize];
};
#[repr(C)]
pub struct std_basic_filebuf<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _base: std_basic_streambuf<_CharT>,
    pub _M_lock: std___c_lock,
    pub _M_file: std_basic_filebuf___file_type,
    pub _M_mode: std_ios_base_openmode,
    pub _M_state_beg: std_basic_filebuf___state_type,
    pub _M_state_cur: std_basic_filebuf___state_type,
    pub _M_state_last: std_basic_filebuf___state_type,
    pub _M_buf: *mut std_basic_filebuf_char_type<_CharT>,
    pub _M_buf_size: usize,
    pub _M_buf_allocated: bool,
    pub _M_reading: bool,
    pub _M_writing: bool,
    pub _M_pback: std_basic_filebuf_char_type<_CharT>,
    pub _M_pback_cur_save: *mut std_basic_filebuf_char_type<_CharT>,
    pub _M_pback_end_save: *mut std_basic_filebuf_char_type<_CharT>,
    pub _M_pback_init: bool,
    pub _M_codecvt: *const std_basic_filebuf___codecvt_type,
    pub _M_ext_buf: *mut ::std::os::raw::c_char,
    pub _M_ext_buf_size: std_streamsize,
    pub _M_ext_next: *const ::std::os::raw::c_char,
    pub _M_ext_end: *mut ::std::os::raw::c_char,
}
pub type std_basic_filebuf___chk_state = std___and_;
pub type std_basic_filebuf_char_type<_CharT> = _CharT;
pub type std_basic_filebuf_traits_type<_Traits> = _Traits;
pub type std_basic_filebuf_int_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_filebuf_pos_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_filebuf_off_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_filebuf___streambuf_type<_CharT> =
    std_basic_streambuf<std_basic_filebuf_char_type<_CharT>>;
pub type std_basic_filebuf___filebuf_type<_CharT> =
    std_basic_filebuf<std_basic_filebuf_char_type<_CharT>>;
pub type std_basic_filebuf___file_type = std___basic_file;
pub type std_basic_filebuf___state_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_filebuf___codecvt_type = std_codecvt;
#[repr(C)]
pub struct std_basic_ifstream<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _base: std_basic_istream<_CharT>,
    pub _M_filebuf: std_basic_ifstream___filebuf_type<_CharT>,
}
pub type std_basic_ifstream_char_type<_CharT> = _CharT;
pub type std_basic_ifstream_traits_type<_Traits> = _Traits;
pub type std_basic_ifstream_int_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_ifstream_pos_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_ifstream_off_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_ifstream___filebuf_type<_CharT> =
    std_basic_filebuf<std_basic_ifstream_char_type<_CharT>>;
pub type std_basic_ifstream___istream_type<_CharT> =
    std_basic_istream<std_basic_ifstream_char_type<_CharT>>;
#[repr(C)]
pub struct std_basic_ofstream<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _base: std_basic_ostream<_CharT>,
    pub _M_filebuf: std_basic_ofstream___filebuf_type<_CharT>,
}
pub type std_basic_ofstream_char_type<_CharT> = _CharT;
pub type std_basic_ofstream_traits_type<_Traits> = _Traits;
pub type std_basic_ofstream_int_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_ofstream_pos_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_ofstream_off_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_ofstream___filebuf_type<_CharT> =
    std_basic_filebuf<std_basic_ofstream_char_type<_CharT>>;
pub type std_basic_ofstream___ostream_type<_CharT> =
    std_basic_ostream<std_basic_ofstream_char_type<_CharT>>;
#[repr(C)]
pub struct std_basic_fstream<_CharT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
    pub _base: std_basic_iostream<_CharT>,
    pub _M_filebuf: std_basic_fstream___filebuf_type<_CharT>,
}
pub type std_basic_fstream_char_type<_CharT> = _CharT;
pub type std_basic_fstream_traits_type<_Traits> = _Traits;
pub type std_basic_fstream_int_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_fstream_pos_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_fstream_off_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_basic_fstream___filebuf_type<_CharT> =
    std_basic_filebuf<std_basic_fstream_char_type<_CharT>>;
pub type std_basic_fstream___ios_type<_CharT> = std_basic_ios<std_basic_fstream_char_type<_CharT>>;
pub type std_basic_fstream___iostream_type<_CharT> =
    std_basic_iostream<std_basic_fstream_char_type<_CharT>>;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_filebuf_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_filebuf<::std::os::raw::c_char>>() - 240usize];
    [
        "Align of template specialization: std_basic_filebuf_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_filebuf<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_ifstream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_ifstream<::std::os::raw::c_char>>() - 520usize];
    [
        "Align of template specialization: std_basic_ifstream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_ifstream<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_ofstream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_ofstream<::std::os::raw::c_char>>() - 512usize];
    [
        "Align of template specialization: std_basic_ofstream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_ofstream<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_fstream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_fstream<::std::os::raw::c_char>>() - 528usize];
    [
        "Align of template specialization: std_basic_fstream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_fstream<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_filebuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_filebuf<u32>>() - 240usize];
    [
        "Align of template specialization: std_basic_filebuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_filebuf<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_ifstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_ifstream<u32>>() - 520usize];
    [
        "Align of template specialization: std_basic_ifstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_ifstream<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_ofstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_ofstream<u32>>() - 512usize];
    [
        "Align of template specialization: std_basic_ofstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_ofstream<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_fstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_fstream<u32>>() - 528usize];
    [
        "Align of template specialization: std_basic_fstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_fstream<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_void_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_void_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char16_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char16_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char32_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char32_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_ctype_open0_char_close0"]
        [::std::mem::size_of::<std_ctype>() - 576usize];
    ["Align of template specialization: std_ctype_open0_char_close0"]
        [::std::mem::align_of::<std_ctype>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_ctype_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_ctype>() - 1344usize];
    ["Align of template specialization: std_ctype_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_ctype>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_codecvt_open0_char_char___mbstate_t_close0"]
        [::std::mem::size_of::<std_codecvt>() - 24usize];
    ["Align of template specialization: std_codecvt_open0_char_char___mbstate_t_close0"]
        [::std::mem::align_of::<std_codecvt>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_codecvt_open0_wchar_t_char___mbstate_t_close0"]
        [::std::mem::size_of::<std_codecvt>() - 24usize];
    ["Align of template specialization: std_codecvt_open0_wchar_t_char___mbstate_t_close0"]
        [::std::mem::align_of::<std_codecvt>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_codecvt_open0_char16_t_char___mbstate_t_close0"]
        [::std::mem::size_of::<std_codecvt>() - 16usize];
    ["Align of template specialization: std_codecvt_open0_char16_t_char___mbstate_t_close0"]
        [::std::mem::align_of::<std_codecvt>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_codecvt_open0_char32_t_char___mbstate_t_close0"]
        [::std::mem::size_of::<std_codecvt>() - 16usize];
    ["Align of template specialization: std_codecvt_open0_char32_t_char___mbstate_t_close0"]
        [::std::mem::align_of::<std_codecvt>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_ctype_byname_open0_char_close0"]
        [::std::mem::size_of::<std_ctype_byname>() - 576usize];
    ["Align of template specialization: std_ctype_byname_open0_char_close0"]
        [::std::mem::align_of::<std_ctype_byname>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_ctype_byname_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_ctype_byname>() - 1344usize];
    ["Align of template specialization: std_ctype_byname_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_ctype_byname>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_complex_open0_float_close0"]
        [::std::mem::size_of::<std_complex<f32>>() - 8usize];
    ["Align of template specialization: std_complex_open0_float_close0"]
        [::std::mem::align_of::<std_complex<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_complex_open0_double_close0"]
        [::std::mem::size_of::<std_complex<f64>>() - 16usize];
    ["Align of template specialization: std_complex_open0_double_close0"]
        [::std::mem::align_of::<std_complex<f64>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_complex_open0_long_double_close0"]
        [::std::mem::size_of::<std_complex<u128>>() - 32usize];
    ["Align of template specialization: std_complex_open0_long_double_close0"]
        [::std::mem::align_of::<std_complex<u128>>() - 16usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_codecvt_byname_open0_char16_t_char___mbstate_t_close0"]
        [::std::mem::size_of::<std_codecvt_byname>() - 16usize];
    ["Align of template specialization: std_codecvt_byname_open0_char16_t_char___mbstate_t_close0"]
        [::std::mem::align_of::<std_codecvt_byname>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_codecvt_byname_open0_char32_t_char___mbstate_t_close0"]
        [::std::mem::size_of::<std_codecvt_byname>() - 16usize];
    ["Align of template specialization: std_codecvt_byname_open0_char32_t_char___mbstate_t_close0"]
        [::std::mem::align_of::<std_codecvt_byname>() - 8usize];
};
pub type __gnu_cxx___conditional_type___type<_Iftrue> = _Iftrue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___add_unsigned {
    pub _address: u8,
}
pub type __gnu_cxx___add_unsigned___if_type = u8;
pub type __gnu_cxx___add_unsigned___type = __gnu_cxx___add_unsigned___if_type;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: __gnu_cxx___add_unsigned_open0_char_close0"]
        [::std::mem::size_of::<__gnu_cxx___add_unsigned>() - 1usize];
    ["Align of template specialization: __gnu_cxx___add_unsigned_open0_char_close0"]
        [::std::mem::align_of::<__gnu_cxx___add_unsigned>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: __gnu_cxx___add_unsigned_open0_signed_char_close0"]
        [::std::mem::size_of::<__gnu_cxx___add_unsigned>() - 1usize];
    ["Align of template specialization: __gnu_cxx___add_unsigned_open0_signed_char_close0"]
        [::std::mem::align_of::<__gnu_cxx___add_unsigned>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: __gnu_cxx___add_unsigned_open0_short_close0"]
        [::std::mem::size_of::<__gnu_cxx___add_unsigned>() - 1usize];
    ["Align of template specialization: __gnu_cxx___add_unsigned_open0_short_close0"]
        [::std::mem::align_of::<__gnu_cxx___add_unsigned>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: __gnu_cxx___add_unsigned_open0_int_close0"]
        [::std::mem::size_of::<__gnu_cxx___add_unsigned>() - 1usize];
    ["Align of template specialization: __gnu_cxx___add_unsigned_open0_int_close0"]
        [::std::mem::align_of::<__gnu_cxx___add_unsigned>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: __gnu_cxx___add_unsigned_open0_long_close0"]
        [::std::mem::size_of::<__gnu_cxx___add_unsigned>() - 1usize];
    ["Align of template specialization: __gnu_cxx___add_unsigned_open0_long_close0"]
        [::std::mem::align_of::<__gnu_cxx___add_unsigned>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: __gnu_cxx___add_unsigned_open0_long_long_close0"]
        [::std::mem::size_of::<__gnu_cxx___add_unsigned>() - 1usize];
    ["Align of template specialization: __gnu_cxx___add_unsigned_open0_long_long_close0"]
        [::std::mem::align_of::<__gnu_cxx___add_unsigned>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___remove_unsigned {
    pub _address: u8,
}
pub type __gnu_cxx___remove_unsigned___if_type = u8;
pub type __gnu_cxx___remove_unsigned___type = __gnu_cxx___remove_unsigned___if_type;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: __gnu_cxx___remove_unsigned_open0_char_close0"]
        [::std::mem::size_of::<__gnu_cxx___remove_unsigned>() - 1usize];
    ["Align of template specialization: __gnu_cxx___remove_unsigned_open0_char_close0"]
        [::std::mem::align_of::<__gnu_cxx___remove_unsigned>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: __gnu_cxx___remove_unsigned_open0_unsigned_char_close0"]
        [::std::mem::size_of::<__gnu_cxx___remove_unsigned>() - 1usize];
    ["Align of template specialization: __gnu_cxx___remove_unsigned_open0_unsigned_char_close0"]
        [::std::mem::align_of::<__gnu_cxx___remove_unsigned>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: __gnu_cxx___remove_unsigned_open0_unsigned_short_close0"]
        [::std::mem::size_of::<__gnu_cxx___remove_unsigned>() - 1usize];
    ["Align of template specialization: __gnu_cxx___remove_unsigned_open0_unsigned_short_close0"]
        [::std::mem::align_of::<__gnu_cxx___remove_unsigned>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: __gnu_cxx___remove_unsigned_open0_unsigned_int_close0"]
        [::std::mem::size_of::<__gnu_cxx___remove_unsigned>() - 1usize];
    ["Align of template specialization: __gnu_cxx___remove_unsigned_open0_unsigned_int_close0"]
        [::std::mem::align_of::<__gnu_cxx___remove_unsigned>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: __gnu_cxx___remove_unsigned_open0_unsigned_long_close0"]
        [::std::mem::size_of::<__gnu_cxx___remove_unsigned>() - 1usize];
    ["Align of template specialization: __gnu_cxx___remove_unsigned_open0_unsigned_long_close0"]
        [::std::mem::align_of::<__gnu_cxx___remove_unsigned>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: __gnu_cxx___remove_unsigned_open0_unsigned_long_long_close0",
    ][::std::mem::size_of::<__gnu_cxx___remove_unsigned>() - 1usize];
    [
        "Align of template specialization: __gnu_cxx___remove_unsigned_open0_unsigned_long_long_close0",
    ][::std::mem::align_of::<__gnu_cxx___remove_unsigned>() - 1usize];
};
pub type __gnu_cxx___promote___type = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___promote_2 {
    pub _address: u8,
}
pub type __gnu_cxx___promote_2___type<_Tp2> = _Tp2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___promote_3 {
    pub _address: u8,
}
pub type __gnu_cxx___promote_3___type<_Tp2> = _Tp2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___promote_4 {
    pub _address: u8,
}
pub type __gnu_cxx___promote_4___type<_Tp2> = _Tp2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___is_integer_nonstrict {
    pub _address: u8,
}
pub const __gnu_cxx___is_integer_nonstrict___width: __gnu_cxx___is_integer_nonstrict__bindgen_ty_1 =
    0;
pub type __gnu_cxx___is_integer_nonstrict__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___numeric_traits_integer {
    pub _address: u8,
}
unsafe extern "C" {
    #[link_name = "\u{1}__min"]
    pub static __gnu_cxx___min: _Value;
}
unsafe extern "C" {
    #[link_name = "\u{1}__max"]
    pub static __gnu_cxx___max: _Value;
}
unsafe extern "C" {
    #[link_name = "\u{1}__is_signed"]
    pub static __gnu_cxx___is_signed: bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}__digits"]
    pub static __gnu_cxx___digits: ::std::os::raw::c_int;
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: __gnu_cxx___is_integer_nonstrict_open0___int128_close0"]
        [::std::mem::size_of::<__gnu_cxx___is_integer_nonstrict>() - 1usize];
    ["Align of template specialization: __gnu_cxx___is_integer_nonstrict_open0___int128_close0"]
        [::std::mem::align_of::<__gnu_cxx___is_integer_nonstrict>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: __gnu_cxx___is_integer_nonstrict_open0_unsigned___int128_close0",
    ][::std::mem::size_of::<__gnu_cxx___is_integer_nonstrict>() - 1usize];
    [
        "Align of template specialization: __gnu_cxx___is_integer_nonstrict_open0_unsigned___int128_close0",
    ][::std::mem::align_of::<__gnu_cxx___is_integer_nonstrict>() - 1usize];
};
pub type __gnu_cxx___int_traits = __gnu_cxx___numeric_traits_integer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___numeric_traits_floating {
    pub _address: u8,
}
unsafe extern "C" {
    #[link_name = "\u{1}__max_digits10"]
    pub static __gnu_cxx___max_digits10: ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__digits10"]
    pub static __gnu_cxx___digits10: ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__max_exponent10"]
    pub static __gnu_cxx___max_exponent10: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___numeric_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___normal_iterator<_Iterator> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
    pub _M_current: _Iterator,
}
pub type __gnu_cxx___normal_iterator___traits_type = std_iterator_traits;
pub type __gnu_cxx___normal_iterator_iterator_type<_Iterator> = _Iterator;
pub type __gnu_cxx___normal_iterator_iterator_category = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_value_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_difference_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_reference = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_pointer = __gnu_cxx___normal_iterator___traits_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_less_iter {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __gnu_cxx___ops__Iter_less_iter"]
        [::std::mem::size_of::<__gnu_cxx___ops__Iter_less_iter>() - 1usize];
    ["Alignment of __gnu_cxx___ops__Iter_less_iter"]
        [::std::mem::align_of::<__gnu_cxx___ops__Iter_less_iter>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_less_val {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __gnu_cxx___ops__Iter_less_val"]
        [::std::mem::size_of::<__gnu_cxx___ops__Iter_less_val>() - 1usize];
    ["Alignment of __gnu_cxx___ops__Iter_less_val"]
        [::std::mem::align_of::<__gnu_cxx___ops__Iter_less_val>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Val_less_iter {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __gnu_cxx___ops__Val_less_iter"]
        [::std::mem::size_of::<__gnu_cxx___ops__Val_less_iter>() - 1usize];
    ["Alignment of __gnu_cxx___ops__Val_less_iter"]
        [::std::mem::align_of::<__gnu_cxx___ops__Val_less_iter>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_equal_to_iter {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __gnu_cxx___ops__Iter_equal_to_iter"]
        [::std::mem::size_of::<__gnu_cxx___ops__Iter_equal_to_iter>() - 1usize];
    ["Alignment of __gnu_cxx___ops__Iter_equal_to_iter"]
        [::std::mem::align_of::<__gnu_cxx___ops__Iter_equal_to_iter>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_equal_to_val {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __gnu_cxx___ops__Iter_equal_to_val"]
        [::std::mem::size_of::<__gnu_cxx___ops__Iter_equal_to_val>() - 1usize];
    ["Alignment of __gnu_cxx___ops__Iter_equal_to_val"]
        [::std::mem::align_of::<__gnu_cxx___ops__Iter_equal_to_val>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_comp_iter<_Compare> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
    pub _M_comp: _Compare,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_comp_val<_Compare> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
    pub _M_comp: _Compare,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Val_comp_iter<_Compare> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
    pub _M_comp: _Compare,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_equals_val<_Value> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Value>>,
    pub _M_value: *mut _Value,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_equals_iter<_Iterator1> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator1>>,
    pub _M_it1: _Iterator1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_pred<_Predicate> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
    pub _M_pred: _Predicate,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_comp_to_val<_Compare, _Value> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Value>>,
    pub _M_comp: _Compare,
    pub _M_value: *mut _Value,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_comp_to_iter<_Compare, _Iterator1> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator1>>,
    pub _M_comp: _Compare,
    pub _M_it1: _Iterator1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___ops__Iter_negate<_Predicate> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
    pub _M_pred: _Predicate,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN9__gnu_cxx27__verbose_terminate_handlerEv"]
    pub fn __gnu_cxx___verbose_terminate_handler();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx__Char_types {
    pub _address: u8,
}
pub type __gnu_cxx__Char_types_int_type = ::std::os::raw::c_ulong;
pub type __gnu_cxx__Char_types_pos_type = std_streampos;
pub type __gnu_cxx__Char_types_off_type = std_streamoff;
pub type __gnu_cxx__Char_types_state_type = mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_char_traits {
    pub _address: u8,
}
pub type __gnu_cxx_char_traits_char_type<_CharT> = _CharT;
pub type __gnu_cxx_char_traits_int_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_pos_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_off_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_state_type = __gnu_cxx__Char_types;
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx_new_allocator {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_value_type<_Tp> = _Tp;
pub type __gnu_cxx_new_allocator_size_type = usize;
pub type __gnu_cxx_new_allocator_difference_type = isize;
pub type __gnu_cxx_new_allocator_pointer<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_pointer<_Tp> = *const _Tp;
pub type __gnu_cxx_new_allocator_reference<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_new_allocator_rebind {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_propagate_on_container_move_assignment = std_true_type;
unsafe extern "C" {
    #[link_name = "\u{1}__uselocale"]
    pub fn __gnu_cxx___uselocale(arg1: locale_t) -> locale_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_allocator_type<_Alloc> = _Alloc;
pub type __gnu_cxx___alloc_traits__Base_type = std_allocator_traits;
pub type __gnu_cxx___alloc_traits_value_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_const_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_size_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_difference_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_reference = *mut __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits_const_reference = *const __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits___is_custom_pointer = std___and_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits_rebind {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_rebind_other = __gnu_cxx___alloc_traits__Base_type;
pub const __gnu_cxx__Lock_policy__S_single: __gnu_cxx__Lock_policy = 0;
pub const __gnu_cxx__Lock_policy__S_mutex: __gnu_cxx__Lock_policy = 1;
pub const __gnu_cxx__Lock_policy__S_atomic: __gnu_cxx__Lock_policy = 2;
pub type __gnu_cxx__Lock_policy = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[link_name = "\u{1}_ZN9__gnu_cxxL21__default_lock_policyE"]
    pub static __gnu_cxx___default_lock_policy: __gnu_cxx__Lock_policy;
}
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___concurrence_lock_error {
    pub _base: std_exception,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __gnu_cxx___concurrence_lock_error"]
        [::std::mem::size_of::<__gnu_cxx___concurrence_lock_error>() - 8usize];
    ["Alignment of __gnu_cxx___concurrence_lock_error"]
        [::std::mem::align_of::<__gnu_cxx___concurrence_lock_error>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___concurrence_unlock_error {
    pub _base: std_exception,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __gnu_cxx___concurrence_unlock_error"]
        [::std::mem::size_of::<__gnu_cxx___concurrence_unlock_error>() - 8usize];
    ["Alignment of __gnu_cxx___concurrence_unlock_error"]
        [::std::mem::align_of::<__gnu_cxx___concurrence_unlock_error>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___concurrence_broadcast_error {
    pub _base: std_exception,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __gnu_cxx___concurrence_broadcast_error"]
        [::std::mem::size_of::<__gnu_cxx___concurrence_broadcast_error>() - 8usize];
    ["Alignment of __gnu_cxx___concurrence_broadcast_error"]
        [::std::mem::align_of::<__gnu_cxx___concurrence_broadcast_error>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___concurrence_wait_error {
    pub _base: std_exception,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __gnu_cxx___concurrence_wait_error"]
        [::std::mem::size_of::<__gnu_cxx___concurrence_wait_error>() - 8usize];
    ["Alignment of __gnu_cxx___concurrence_wait_error"]
        [::std::mem::align_of::<__gnu_cxx___concurrence_wait_error>() - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __gnu_cxx___mutex {
    pub _M_mutex: __gthread_mutex_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __gnu_cxx___mutex"][::std::mem::size_of::<__gnu_cxx___mutex>() - 40usize];
    ["Alignment of __gnu_cxx___mutex"][::std::mem::align_of::<__gnu_cxx___mutex>() - 8usize];
    ["Offset of field: __gnu_cxx___mutex::_M_mutex"]
        [::std::mem::offset_of!(__gnu_cxx___mutex, _M_mutex) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __gnu_cxx___recursive_mutex {
    pub _M_mutex: __gthread_recursive_mutex_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __gnu_cxx___recursive_mutex"]
        [::std::mem::size_of::<__gnu_cxx___recursive_mutex>() - 40usize];
    ["Alignment of __gnu_cxx___recursive_mutex"]
        [::std::mem::align_of::<__gnu_cxx___recursive_mutex>() - 8usize];
    ["Offset of field: __gnu_cxx___recursive_mutex::_M_mutex"]
        [::std::mem::offset_of!(__gnu_cxx___recursive_mutex, _M_mutex) - 0usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx___scoped_lock {
    pub _M_device: *mut __gnu_cxx___scoped_lock___mutex_type,
}
pub type __gnu_cxx___scoped_lock___mutex_type = __gnu_cxx___mutex;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __gnu_cxx___scoped_lock"][::std::mem::size_of::<__gnu_cxx___scoped_lock>() - 8usize];
    ["Alignment of __gnu_cxx___scoped_lock"]
        [::std::mem::align_of::<__gnu_cxx___scoped_lock>() - 8usize];
    ["Offset of field: __gnu_cxx___scoped_lock::_M_device"]
        [::std::mem::offset_of!(__gnu_cxx___scoped_lock, _M_device) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __gnu_cxx___cond {
    pub _M_cond: __gthread_cond_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __gnu_cxx___cond"][::std::mem::size_of::<__gnu_cxx___cond>() - 48usize];
    ["Alignment of __gnu_cxx___cond"][::std::mem::align_of::<__gnu_cxx___cond>() - 8usize];
    ["Offset of field: __gnu_cxx___cond::_M_cond"]
        [::std::mem::offset_of!(__gnu_cxx___cond, _M_cond) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___aligned_membuf {
    pub _M_storage: *mut ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___aligned_membuf__Tp2<_Tp> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
    pub _M_t: _Tp,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___aligned_buffer {
    pub _M_storage: u8,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type uint = u32;
pub type schar = ::std::os::raw::c_schar;
pub type uchar = ::std::os::raw::c_uchar;
pub type ushort = ::std::os::raw::c_ushort;
pub type int64 = i64;
pub type uint64 = u64;
pub const CpuFeatures_CPU_MMX: CpuFeatures = 1;
pub const CpuFeatures_CPU_SSE: CpuFeatures = 2;
pub const CpuFeatures_CPU_SSE2: CpuFeatures = 3;
pub const CpuFeatures_CPU_SSE3: CpuFeatures = 4;
pub const CpuFeatures_CPU_SSSE3: CpuFeatures = 5;
pub const CpuFeatures_CPU_SSE4_1: CpuFeatures = 6;
pub const CpuFeatures_CPU_SSE4_2: CpuFeatures = 7;
pub const CpuFeatures_CPU_POPCNT: CpuFeatures = 8;
pub const CpuFeatures_CPU_FP16: CpuFeatures = 9;
pub const CpuFeatures_CPU_AVX: CpuFeatures = 10;
pub const CpuFeatures_CPU_AVX2: CpuFeatures = 11;
pub const CpuFeatures_CPU_FMA3: CpuFeatures = 12;
pub const CpuFeatures_CPU_AVX_512F: CpuFeatures = 13;
pub const CpuFeatures_CPU_AVX_512BW: CpuFeatures = 14;
pub const CpuFeatures_CPU_AVX_512CD: CpuFeatures = 15;
pub const CpuFeatures_CPU_AVX_512DQ: CpuFeatures = 16;
pub const CpuFeatures_CPU_AVX_512ER: CpuFeatures = 17;
pub const CpuFeatures_CPU_AVX_512IFMA512: CpuFeatures = 18;
pub const CpuFeatures_CPU_AVX_512IFMA: CpuFeatures = 18;
pub const CpuFeatures_CPU_AVX_512PF: CpuFeatures = 19;
pub const CpuFeatures_CPU_AVX_512VBMI: CpuFeatures = 20;
pub const CpuFeatures_CPU_AVX_512VL: CpuFeatures = 21;
pub const CpuFeatures_CPU_AVX_512VBMI2: CpuFeatures = 22;
pub const CpuFeatures_CPU_AVX_512VNNI: CpuFeatures = 23;
pub const CpuFeatures_CPU_AVX_512BITALG: CpuFeatures = 24;
pub const CpuFeatures_CPU_AVX_512VPOPCNTDQ: CpuFeatures = 25;
pub const CpuFeatures_CPU_AVX_5124VNNIW: CpuFeatures = 26;
pub const CpuFeatures_CPU_AVX_5124FMAPS: CpuFeatures = 27;
pub const CpuFeatures_CPU_NEON: CpuFeatures = 100;
pub const CpuFeatures_CPU_MSA: CpuFeatures = 150;
pub const CpuFeatures_CPU_VSX: CpuFeatures = 200;
pub const CpuFeatures_CPU_VSX3: CpuFeatures = 201;
#[doc = "!< Skylake-X with AVX-512F/CD/BW/DQ/VL"]
pub const CpuFeatures_CPU_AVX512_SKX: CpuFeatures = 256;
#[doc = "!< Common instructions AVX-512F/CD for all CPUs that support AVX-512"]
pub const CpuFeatures_CPU_AVX512_COMMON: CpuFeatures = 257;
#[doc = "!< Knights Landing with AVX-512F/CD/ER/PF"]
pub const CpuFeatures_CPU_AVX512_KNL: CpuFeatures = 258;
#[doc = "!< Knights Mill with AVX-512F/CD/ER/PF/4FMAPS/4VNNIW/VPOPCNTDQ"]
pub const CpuFeatures_CPU_AVX512_KNM: CpuFeatures = 259;
#[doc = "!< Cannon Lake with AVX-512F/CD/BW/DQ/VL/IFMA/VBMI"]
pub const CpuFeatures_CPU_AVX512_CNL: CpuFeatures = 260;
#[doc = "!< Cascade Lake with AVX-512F/CD/BW/DQ/VL/VNNI"]
pub const CpuFeatures_CPU_AVX512_CLX: CpuFeatures = 261;
#[doc = "!< Ice Lake with AVX-512F/CD/BW/DQ/VL/IFMA/VBMI/VNNI/VBMI2/BITALG/VPOPCNTDQ"]
pub const CpuFeatures_CPU_AVX512_ICL: CpuFeatures = 262;
pub const CpuFeatures_CPU_MAX_FEATURE: CpuFeatures = 512;
#[doc = " @brief Available CPU features."]
pub type CpuFeatures = ::std::os::raw::c_uint;
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __m128_u = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::std::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::std::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::std::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::std::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::std::mem::size_of::<ldiv_t>() - 16usize];
    ["Alignment of ldiv_t"][::std::mem::align_of::<ldiv_t>() - 8usize];
    ["Offset of field: ldiv_t::quot"][::std::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::std::mem::offset_of!(ldiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::std::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::std::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::std::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::std::mem::offset_of!(lldiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
unsafe extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
unsafe extern "C" {
    pub fn strtof32(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float32;
}
unsafe extern "C" {
    pub fn strtof64(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float64;
}
unsafe extern "C" {
    pub fn strtof32x(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float32x;
}
unsafe extern "C" {
    pub fn strtof64x(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float64x;
}
unsafe extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strfromd(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfromf(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfroml(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: u128,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfromf32(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfromf64(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfromf32x(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float32x,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfromf64x(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float64x,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __locale_struct"][::std::mem::size_of::<__locale_struct>() - 232usize];
    ["Alignment of __locale_struct"][::std::mem::align_of::<__locale_struct>() - 8usize];
    ["Offset of field: __locale_struct::__locales"]
        [::std::mem::offset_of!(__locale_struct, __locales) - 0usize];
    ["Offset of field: __locale_struct::__ctype_b"]
        [::std::mem::offset_of!(__locale_struct, __ctype_b) - 104usize];
    ["Offset of field: __locale_struct::__ctype_tolower"]
        [::std::mem::offset_of!(__locale_struct, __ctype_tolower) - 112usize];
    ["Offset of field: __locale_struct::__ctype_toupper"]
        [::std::mem::offset_of!(__locale_struct, __ctype_toupper) - 120usize];
    ["Offset of field: __locale_struct::__names"]
        [::std::mem::offset_of!(__locale_struct, __names) - 128usize];
};
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
unsafe extern "C" {
    pub fn strtol_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoll_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtod_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtold_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> u128;
}
unsafe extern "C" {
    pub fn strtof32_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float32;
}
unsafe extern "C" {
    pub fn strtof64_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float64;
}
unsafe extern "C" {
    pub fn strtof32x_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float32x;
}
unsafe extern "C" {
    pub fn strtof64x_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float64x;
}
unsafe extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type ino64_t = __ino64_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type suseconds_t = __suseconds_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigset_t"][::std::mem::size_of::<__sigset_t>() - 128usize];
    ["Alignment of __sigset_t"][::std::mem::align_of::<__sigset_t>() - 8usize];
    ["Offset of field: __sigset_t::__val"][::std::mem::offset_of!(__sigset_t, __val) - 0usize];
};
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__fd_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 8usize];
    ["Offset of field: fd_set::fds_bits"][::std::mem::offset_of!(fd_set, fds_bits) - 0usize];
};
pub type fd_mask = __fd_mask;
unsafe extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type blkcnt64_t = __blkcnt64_t;
pub type fsblkcnt64_t = __fsblkcnt64_t;
pub type fsfilcnt64_t = __fsfilcnt64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_list"][::std::mem::size_of::<__pthread_internal_list>() - 16usize];
    ["Alignment of __pthread_internal_list"]
        [::std::mem::align_of::<__pthread_internal_list>() - 8usize];
    ["Offset of field: __pthread_internal_list::__prev"]
        [::std::mem::offset_of!(__pthread_internal_list, __prev) - 0usize];
    ["Offset of field: __pthread_internal_list::__next"]
        [::std::mem::offset_of!(__pthread_internal_list, __next) - 8usize];
};
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_slist"]
        [::std::mem::size_of::<__pthread_internal_slist>() - 8usize];
    ["Alignment of __pthread_internal_slist"]
        [::std::mem::align_of::<__pthread_internal_slist>() - 8usize];
    ["Offset of field: __pthread_internal_slist::__next"]
        [::std::mem::offset_of!(__pthread_internal_slist, __next) - 0usize];
};
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_mutex_s"][::std::mem::size_of::<__pthread_mutex_s>() - 40usize];
    ["Alignment of __pthread_mutex_s"][::std::mem::align_of::<__pthread_mutex_s>() - 8usize];
    ["Offset of field: __pthread_mutex_s::__lock"]
        [::std::mem::offset_of!(__pthread_mutex_s, __lock) - 0usize];
    ["Offset of field: __pthread_mutex_s::__count"]
        [::std::mem::offset_of!(__pthread_mutex_s, __count) - 4usize];
    ["Offset of field: __pthread_mutex_s::__owner"]
        [::std::mem::offset_of!(__pthread_mutex_s, __owner) - 8usize];
    ["Offset of field: __pthread_mutex_s::__nusers"]
        [::std::mem::offset_of!(__pthread_mutex_s, __nusers) - 12usize];
    ["Offset of field: __pthread_mutex_s::__kind"]
        [::std::mem::offset_of!(__pthread_mutex_s, __kind) - 16usize];
    ["Offset of field: __pthread_mutex_s::__spins"]
        [::std::mem::offset_of!(__pthread_mutex_s, __spins) - 20usize];
    ["Offset of field: __pthread_mutex_s::__elision"]
        [::std::mem::offset_of!(__pthread_mutex_s, __elision) - 22usize];
    ["Offset of field: __pthread_mutex_s::__list"]
        [::std::mem::offset_of!(__pthread_mutex_s, __list) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_rwlock_arch_t"][::std::mem::size_of::<__pthread_rwlock_arch_t>() - 56usize];
    ["Alignment of __pthread_rwlock_arch_t"]
        [::std::mem::align_of::<__pthread_rwlock_arch_t>() - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__readers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __readers) - 0usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers) - 4usize];
    ["Offset of field: __pthread_rwlock_arch_t::__wrphase_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __wrphase_futex) - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers_futex) - 12usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad3"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad3) - 16usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad4"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad4) - 20usize];
    ["Offset of field: __pthread_rwlock_arch_t::__cur_writer"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __cur_writer) - 24usize];
    ["Offset of field: __pthread_rwlock_arch_t::__shared"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __shared) - 28usize];
    ["Offset of field: __pthread_rwlock_arch_t::__rwelision"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __rwelision) - 32usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad1"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad1) - 33usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad2"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad2) - 40usize];
    ["Offset of field: __pthread_rwlock_arch_t::__flags"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __flags) - 48usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of __pthread_cond_s__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1::__low"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1::__high"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s__bindgen_ty_1"]
        [::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>() - 8usize];
    ["Alignment of __pthread_cond_s__bindgen_ty_1"]
        [::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>() - 8usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_1::__wseq"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_1, __wseq) - 0usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_1::__wseq32"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_1, __wseq32) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>() - 8usize];
    ["Alignment of __pthread_cond_s__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>() - 4usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1::__low"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1::__high"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s__bindgen_ty_2"]
        [::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>() - 8usize];
    ["Alignment of __pthread_cond_s__bindgen_ty_2"]
        [::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>() - 8usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_2::__g1_start"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_2, __g1_start) - 0usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_2::__g1_start32"]
        [::std::mem::offset_of!(__pthread_cond_s__bindgen_ty_2, __g1_start32) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s"][::std::mem::size_of::<__pthread_cond_s>() - 48usize];
    ["Alignment of __pthread_cond_s"][::std::mem::align_of::<__pthread_cond_s>() - 8usize];
    ["Offset of field: __pthread_cond_s::__g_refs"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_refs) - 16usize];
    ["Offset of field: __pthread_cond_s::__g_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_size) - 24usize];
    ["Offset of field: __pthread_cond_s::__g1_orig_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_orig_size) - 32usize];
    ["Offset of field: __pthread_cond_s::__wrefs"]
        [::std::mem::offset_of!(__pthread_cond_s, __wrefs) - 36usize];
    ["Offset of field: __pthread_cond_s::__g_signals"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_signals) - 40usize];
};
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutexattr_t"][::std::mem::size_of::<pthread_mutexattr_t>() - 4usize];
    ["Alignment of pthread_mutexattr_t"][::std::mem::align_of::<pthread_mutexattr_t>() - 4usize];
    ["Offset of field: pthread_mutexattr_t::__size"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __size) - 0usize];
    ["Offset of field: pthread_mutexattr_t::__align"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_condattr_t"][::std::mem::size_of::<pthread_condattr_t>() - 4usize];
    ["Alignment of pthread_condattr_t"][::std::mem::align_of::<pthread_condattr_t>() - 4usize];
    ["Offset of field: pthread_condattr_t::__size"]
        [::std::mem::offset_of!(pthread_condattr_t, __size) - 0usize];
    ["Offset of field: pthread_condattr_t::__align"]
        [::std::mem::offset_of!(pthread_condattr_t, __align) - 0usize];
};
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::std::mem::size_of::<pthread_attr_t>() - 56usize];
    ["Alignment of pthread_attr_t"][::std::mem::align_of::<pthread_attr_t>() - 8usize];
    ["Offset of field: pthread_attr_t::__size"]
        [::std::mem::offset_of!(pthread_attr_t, __size) - 0usize];
    ["Offset of field: pthread_attr_t::__align"]
        [::std::mem::offset_of!(pthread_attr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t"][::std::mem::size_of::<pthread_mutex_t>() - 40usize];
    ["Alignment of pthread_mutex_t"][::std::mem::align_of::<pthread_mutex_t>() - 8usize];
    ["Offset of field: pthread_mutex_t::__data"]
        [::std::mem::offset_of!(pthread_mutex_t, __data) - 0usize];
    ["Offset of field: pthread_mutex_t::__size"]
        [::std::mem::offset_of!(pthread_mutex_t, __size) - 0usize];
    ["Offset of field: pthread_mutex_t::__align"]
        [::std::mem::offset_of!(pthread_mutex_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t"][::std::mem::size_of::<pthread_cond_t>() - 48usize];
    ["Alignment of pthread_cond_t"][::std::mem::align_of::<pthread_cond_t>() - 8usize];
    ["Offset of field: pthread_cond_t::__data"]
        [::std::mem::offset_of!(pthread_cond_t, __data) - 0usize];
    ["Offset of field: pthread_cond_t::__size"]
        [::std::mem::offset_of!(pthread_cond_t, __size) - 0usize];
    ["Offset of field: pthread_cond_t::__align"]
        [::std::mem::offset_of!(pthread_cond_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t"][::std::mem::size_of::<pthread_rwlock_t>() - 56usize];
    ["Alignment of pthread_rwlock_t"][::std::mem::align_of::<pthread_rwlock_t>() - 8usize];
    ["Offset of field: pthread_rwlock_t::__data"]
        [::std::mem::offset_of!(pthread_rwlock_t, __data) - 0usize];
    ["Offset of field: pthread_rwlock_t::__size"]
        [::std::mem::offset_of!(pthread_rwlock_t, __size) - 0usize];
    ["Offset of field: pthread_rwlock_t::__align"]
        [::std::mem::offset_of!(pthread_rwlock_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlockattr_t"][::std::mem::size_of::<pthread_rwlockattr_t>() - 8usize];
    ["Alignment of pthread_rwlockattr_t"][::std::mem::align_of::<pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: pthread_rwlockattr_t::__size"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __size) - 0usize];
    ["Offset of field: pthread_rwlockattr_t::__align"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __align) - 0usize];
};
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrier_t"][::std::mem::size_of::<pthread_barrier_t>() - 32usize];
    ["Alignment of pthread_barrier_t"][::std::mem::align_of::<pthread_barrier_t>() - 8usize];
    ["Offset of field: pthread_barrier_t::__size"]
        [::std::mem::offset_of!(pthread_barrier_t, __size) - 0usize];
    ["Offset of field: pthread_barrier_t::__align"]
        [::std::mem::offset_of!(pthread_barrier_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrierattr_t"][::std::mem::size_of::<pthread_barrierattr_t>() - 4usize];
    ["Alignment of pthread_barrierattr_t"]
        [::std::mem::align_of::<pthread_barrierattr_t>() - 4usize];
    ["Offset of field: pthread_barrierattr_t::__size"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __size) - 0usize];
    ["Offset of field: pthread_barrierattr_t::__align"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __align) - 0usize];
};
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of random_data"][::std::mem::size_of::<random_data>() - 48usize];
    ["Alignment of random_data"][::std::mem::align_of::<random_data>() - 8usize];
    ["Offset of field: random_data::fptr"][::std::mem::offset_of!(random_data, fptr) - 0usize];
    ["Offset of field: random_data::rptr"][::std::mem::offset_of!(random_data, rptr) - 8usize];
    ["Offset of field: random_data::state"][::std::mem::offset_of!(random_data, state) - 16usize];
    ["Offset of field: random_data::rand_type"]
        [::std::mem::offset_of!(random_data, rand_type) - 24usize];
    ["Offset of field: random_data::rand_deg"]
        [::std::mem::offset_of!(random_data, rand_deg) - 28usize];
    ["Offset of field: random_data::rand_sep"]
        [::std::mem::offset_of!(random_data, rand_sep) - 32usize];
    ["Offset of field: random_data::end_ptr"]
        [::std::mem::offset_of!(random_data, end_ptr) - 40usize];
};
unsafe extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of drand48_data"][::std::mem::size_of::<drand48_data>() - 24usize];
    ["Alignment of drand48_data"][::std::mem::align_of::<drand48_data>() - 8usize];
    ["Offset of field: drand48_data::__x"][::std::mem::offset_of!(drand48_data, __x) - 0usize];
    ["Offset of field: drand48_data::__old_x"]
        [::std::mem::offset_of!(drand48_data, __old_x) - 6usize];
    ["Offset of field: drand48_data::__c"][::std::mem::offset_of!(drand48_data, __c) - 12usize];
    ["Offset of field: drand48_data::__init"]
        [::std::mem::offset_of!(drand48_data, __init) - 14usize];
    ["Offset of field: drand48_data::__a"][::std::mem::offset_of!(drand48_data, __a) - 16usize];
};
unsafe extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn secure_getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemp64(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps64(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkostemp(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkostemp64(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkostemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkostemps64(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn canonicalize_file_name(
        __name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type comparison_fn_t = __compar_fn_t;
pub type __compar_d_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
unsafe extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_d_fn_t,
        __arg: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
unsafe extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbtowc(
        __pwc: *mut u32,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(__pwcs: *mut u32, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const u32, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn posix_openpt(__oflag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn grantpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unlockpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ptsname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ptsname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpt() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _mm_sfence();
}
unsafe extern "C" {
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn _mm_setcsr(__i: ::std::os::raw::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __m128d_u = [f64; 2usize];
pub type __m128i_u = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
unsafe extern "C" {
    pub fn _mm_clflush(__p: *const ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn _mm_lfence();
}
unsafe extern "C" {
    pub fn _mm_mfence();
}
unsafe extern "C" {
    pub fn _mm_pause();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Cv16suf {
    pub i: ::std::os::raw::c_short,
    pub u: ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Cv16suf"][::std::mem::size_of::<Cv16suf>() - 2usize];
    ["Alignment of Cv16suf"][::std::mem::align_of::<Cv16suf>() - 2usize];
    ["Offset of field: Cv16suf::i"][::std::mem::offset_of!(Cv16suf, i) - 0usize];
    ["Offset of field: Cv16suf::u"][::std::mem::offset_of!(Cv16suf, u) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union Cv32suf {
    pub i: ::std::os::raw::c_int,
    pub u: ::std::os::raw::c_uint,
    pub f: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Cv32suf"][::std::mem::size_of::<Cv32suf>() - 4usize];
    ["Alignment of Cv32suf"][::std::mem::align_of::<Cv32suf>() - 4usize];
    ["Offset of field: Cv32suf::i"][::std::mem::offset_of!(Cv32suf, i) - 0usize];
    ["Offset of field: Cv32suf::u"][::std::mem::offset_of!(Cv32suf, u) - 0usize];
    ["Offset of field: Cv32suf::f"][::std::mem::offset_of!(Cv32suf, f) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union Cv64suf {
    pub i: int64,
    pub u: uint64,
    pub f: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Cv64suf"][::std::mem::size_of::<Cv64suf>() - 8usize];
    ["Alignment of Cv64suf"][::std::mem::align_of::<Cv64suf>() - 8usize];
    ["Offset of field: Cv64suf::i"][::std::mem::offset_of!(Cv64suf, i) - 0usize];
    ["Offset of field: Cv64suf::u"][::std::mem::offset_of!(Cv64suf, u) - 0usize];
    ["Offset of field: Cv64suf::f"][::std::mem::offset_of!(Cv64suf, f) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_debug__Safe_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_float16_t {
    pub w: ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_float16_t"][::std::mem::size_of::<cv_float16_t>() - 2usize];
    ["Alignment of cv_float16_t"][::std::mem::align_of::<cv_float16_t>() - 2usize];
    ["Offset of field: cv_float16_t::w"][::std::mem::offset_of!(cv_float16_t, w) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_DefaultDeleter {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_sfinae_has_parenthesis_operator {
    pub _address: u8,
}
pub type cv_sfinae_has_parenthesis_operator_type<C> = C;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_has_custom_delete {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_Ptr {
    pub _address: u8,
}
unsafe extern "C" {
    #[doc = " @brief Allocates an aligned memory buffer.\n\nThe function allocates the buffer of the specified size and returns it. When the buffer size is 16\nbytes or more, the returned buffer is aligned to 16 bytes.\n@param bufSize Allocated buffer size."]
    #[link_name = "\u{1}_ZN2cv10fastMallocEm"]
    pub fn cv_fastMalloc(bufSize: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " @brief Deallocates a memory buffer.\n\nThe function deallocates the buffer allocated with fastMalloc . If NULL pointer is passed, the\nfunction does nothing. C version of the function clears the pointer *pptr* to avoid problems with\ndouble memory deallocation.\n@param ptr Pointer to the allocated buffer."]
    #[link_name = "\u{1}_ZN2cv8fastFreeEPv"]
    pub fn cv_fastFree(ptr: *mut ::std::os::raw::c_void);
}
#[doc = "The STL-compliant memory Allocator based on cv::fastMalloc() and cv::fastFree()"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_Allocator {
    pub _address: u8,
}
pub type cv_Allocator_value_type<_Tp> = _Tp;
pub type cv_Allocator_pointer<_Tp> = *mut cv_Allocator_value_type<_Tp>;
pub type cv_Allocator_const_pointer<_Tp> = *const cv_Allocator_value_type<_Tp>;
pub type cv_Allocator_reference<_Tp> = *mut cv_Allocator_value_type<_Tp>;
pub type cv_Allocator_const_reference<_Tp> = *const cv_Allocator_value_type<_Tp>;
pub type cv_Allocator_size_type = usize;
pub type cv_Allocator_difference_type = isize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_Allocator_rebind {
    pub _address: u8,
}
pub type cv_String = std_string;
#[doc = "!< everything is ok"]
pub const cv_Error_Code_StsOk: cv_Error_Code = 0;
#[doc = "!< pseudo error for back trace"]
pub const cv_Error_Code_StsBackTrace: cv_Error_Code = -1;
#[doc = "!< unknown /unspecified error"]
pub const cv_Error_Code_StsError: cv_Error_Code = -2;
#[doc = "!< internal error (bad state)"]
pub const cv_Error_Code_StsInternal: cv_Error_Code = -3;
#[doc = "!< insufficient memory"]
pub const cv_Error_Code_StsNoMem: cv_Error_Code = -4;
#[doc = "!< function arg/param is bad"]
pub const cv_Error_Code_StsBadArg: cv_Error_Code = -5;
#[doc = "!< unsupported function"]
pub const cv_Error_Code_StsBadFunc: cv_Error_Code = -6;
#[doc = "!< iteration didn't converge"]
pub const cv_Error_Code_StsNoConv: cv_Error_Code = -7;
#[doc = "!< tracing"]
pub const cv_Error_Code_StsAutoTrace: cv_Error_Code = -8;
#[doc = "!< image header is NULL"]
pub const cv_Error_Code_HeaderIsNull: cv_Error_Code = -9;
#[doc = "!< image size is invalid"]
pub const cv_Error_Code_BadImageSize: cv_Error_Code = -10;
#[doc = "!< offset is invalid"]
pub const cv_Error_Code_BadOffset: cv_Error_Code = -11;
#[doc = "!<"]
pub const cv_Error_Code_BadDataPtr: cv_Error_Code = -12;
#[doc = "!< image step is wrong, this may happen for a non-continuous matrix."]
pub const cv_Error_Code_BadStep: cv_Error_Code = -13;
#[doc = "!<"]
pub const cv_Error_Code_BadModelOrChSeq: cv_Error_Code = -14;
#[doc = "!< bad number of channels, for example, some functions accept only single channel matrices."]
pub const cv_Error_Code_BadNumChannels: cv_Error_Code = -15;
#[doc = "!<"]
pub const cv_Error_Code_BadNumChannel1U: cv_Error_Code = -16;
#[doc = "!< input image depth is not supported by the function"]
pub const cv_Error_Code_BadDepth: cv_Error_Code = -17;
#[doc = "!<"]
pub const cv_Error_Code_BadAlphaChannel: cv_Error_Code = -18;
#[doc = "!< number of dimensions is out of range"]
pub const cv_Error_Code_BadOrder: cv_Error_Code = -19;
#[doc = "!< incorrect input origin"]
pub const cv_Error_Code_BadOrigin: cv_Error_Code = -20;
#[doc = "!< incorrect input align"]
pub const cv_Error_Code_BadAlign: cv_Error_Code = -21;
#[doc = "!<"]
pub const cv_Error_Code_BadCallBack: cv_Error_Code = -22;
#[doc = "!<"]
pub const cv_Error_Code_BadTileSize: cv_Error_Code = -23;
#[doc = "!< input COI is not supported"]
pub const cv_Error_Code_BadCOI: cv_Error_Code = -24;
#[doc = "!< incorrect input roi"]
pub const cv_Error_Code_BadROISize: cv_Error_Code = -25;
#[doc = "!<"]
pub const cv_Error_Code_MaskIsTiled: cv_Error_Code = -26;
#[doc = "!< null pointer"]
pub const cv_Error_Code_StsNullPtr: cv_Error_Code = -27;
#[doc = "!< incorrect vector length"]
pub const cv_Error_Code_StsVecLengthErr: cv_Error_Code = -28;
#[doc = "!< incorrect filter structure content"]
pub const cv_Error_Code_StsFilterStructContentErr: cv_Error_Code = -29;
#[doc = "!< incorrect transform kernel content"]
pub const cv_Error_Code_StsKernelStructContentErr: cv_Error_Code = -30;
#[doc = "!< incorrect filter offset value"]
pub const cv_Error_Code_StsFilterOffsetErr: cv_Error_Code = -31;
#[doc = "!< the input/output structure size is incorrect"]
pub const cv_Error_Code_StsBadSize: cv_Error_Code = -201;
#[doc = "!< division by zero"]
pub const cv_Error_Code_StsDivByZero: cv_Error_Code = -202;
#[doc = "!< in-place operation is not supported"]
pub const cv_Error_Code_StsInplaceNotSupported: cv_Error_Code = -203;
#[doc = "!< request can't be completed"]
pub const cv_Error_Code_StsObjectNotFound: cv_Error_Code = -204;
#[doc = "!< formats of input/output arrays differ"]
pub const cv_Error_Code_StsUnmatchedFormats: cv_Error_Code = -205;
#[doc = "!< flag is wrong or not supported"]
pub const cv_Error_Code_StsBadFlag: cv_Error_Code = -206;
#[doc = "!< bad CvPoint"]
pub const cv_Error_Code_StsBadPoint: cv_Error_Code = -207;
#[doc = "!< bad format of mask (neither 8uC1 nor 8sC1)"]
pub const cv_Error_Code_StsBadMask: cv_Error_Code = -208;
#[doc = "!< sizes of input/output structures do not match"]
pub const cv_Error_Code_StsUnmatchedSizes: cv_Error_Code = -209;
#[doc = "!< the data format/type is not supported by the function"]
pub const cv_Error_Code_StsUnsupportedFormat: cv_Error_Code = -210;
#[doc = "!< some of parameters are out of range"]
pub const cv_Error_Code_StsOutOfRange: cv_Error_Code = -211;
#[doc = "!< invalid syntax/structure of the parsed file"]
pub const cv_Error_Code_StsParseError: cv_Error_Code = -212;
#[doc = "!< the requested function/feature is not implemented"]
pub const cv_Error_Code_StsNotImplemented: cv_Error_Code = -213;
#[doc = "!< an allocated block has been corrupted"]
pub const cv_Error_Code_StsBadMemBlock: cv_Error_Code = -214;
#[doc = "!< assertion failed"]
pub const cv_Error_Code_StsAssert: cv_Error_Code = -215;
#[doc = "!< no CUDA support"]
pub const cv_Error_Code_GpuNotSupported: cv_Error_Code = -216;
#[doc = "!< GPU API call error"]
pub const cv_Error_Code_GpuApiCallError: cv_Error_Code = -217;
#[doc = "!< no OpenGL support"]
pub const cv_Error_Code_OpenGlNotSupported: cv_Error_Code = -218;
#[doc = "!< OpenGL API call error"]
pub const cv_Error_Code_OpenGlApiCallError: cv_Error_Code = -219;
#[doc = "!< OpenCL API call error"]
pub const cv_Error_Code_OpenCLApiCallError: cv_Error_Code = -220;
pub const cv_Error_Code_OpenCLDoubleNotSupported: cv_Error_Code = -221;
#[doc = "!< OpenCL initialization error"]
pub const cv_Error_Code_OpenCLInitError: cv_Error_Code = -222;
pub const cv_Error_Code_OpenCLNoAMDBlasFft: cv_Error_Code = -223;
#[doc = "! error codes"]
pub type cv_Error_Code = ::std::os::raw::c_int;
#[doc = " Gaussian elimination with the optimal pivot element chosen."]
pub const cv_DecompTypes_DECOMP_LU: cv_DecompTypes = 0;
#[doc = " singular value decomposition (SVD) method; the system can be over-defined and/or the matrix\nsrc1 can be singular"]
pub const cv_DecompTypes_DECOMP_SVD: cv_DecompTypes = 1;
#[doc = " eigenvalue decomposition; the matrix src1 must be symmetrical"]
pub const cv_DecompTypes_DECOMP_EIG: cv_DecompTypes = 2;
#[doc = " Cholesky \\f$LL^T\\f$ factorization; the matrix src1 must be symmetrical and positively\ndefined"]
pub const cv_DecompTypes_DECOMP_CHOLESKY: cv_DecompTypes = 3;
#[doc = " QR factorization; the system can be over-defined and/or the matrix src1 can be singular"]
pub const cv_DecompTypes_DECOMP_QR: cv_DecompTypes = 4;
#[doc = " while all the previous flags are mutually exclusive, this flag can be used together with\nany of the previous; it means that the normal equations\n\\f$\\texttt{src1}^T\\cdot\\texttt{src1}\\cdot\\texttt{dst}=\\texttt{src1}^T\\texttt{src2}\\f$ are\nsolved instead of the original system\n\\f$\\texttt{src1}\\cdot\\texttt{dst}=\\texttt{src2}\\f$"]
pub const cv_DecompTypes_DECOMP_NORMAL: cv_DecompTypes = 16;
#[doc = "! matrix decomposition types"]
pub type cv_DecompTypes = ::std::os::raw::c_uint;
#[doc = "\\f[\nnorm =  \\forkthree\n{\\|\\texttt{src1}\\|_{L_{\\infty}} =  \\max _I | \\texttt{src1} (I)|}{if  \\(\\texttt{normType} = \\texttt{NORM_INF}\\) }\n{\\|\\texttt{src1}-\\texttt{src2}\\|_{L_{\\infty}} =  \\max _I | \\texttt{src1} (I) -  \\texttt{src2} (I)|}{if  \\(\\texttt{normType} = \\texttt{NORM_INF}\\) }\n{\\frac{\\|\\texttt{src1}-\\texttt{src2}\\|_{L_{\\infty}}    }{\\|\\texttt{src2}\\|_{L_{\\infty}} }}{if  \\(\\texttt{normType} = \\texttt{NORM_RELATIVE | NORM_INF}\\) }\n\\f]"]
pub const cv_NormTypes_NORM_INF: cv_NormTypes = 1;
#[doc = "\\f[\nnorm =  \\forkthree\n{\\| \\texttt{src1} \\| _{L_1} =  \\sum _I | \\texttt{src1} (I)|}{if  \\(\\texttt{normType} = \\texttt{NORM_L1}\\)}\n{ \\| \\texttt{src1} - \\texttt{src2} \\| _{L_1} =  \\sum _I | \\texttt{src1} (I) -  \\texttt{src2} (I)|}{if  \\(\\texttt{normType} = \\texttt{NORM_L1}\\) }\n{ \\frac{\\|\\texttt{src1}-\\texttt{src2}\\|_{L_1} }{\\|\\texttt{src2}\\|_{L_1}} }{if  \\(\\texttt{normType} = \\texttt{NORM_RELATIVE | NORM_L1}\\) }\n\\f]"]
pub const cv_NormTypes_NORM_L1: cv_NormTypes = 2;
#[doc = "\\f[\nnorm =  \\forkthree\n{ \\| \\texttt{src1} \\| _{L_2} =  \\sqrt{\\sum_I \\texttt{src1}(I)^2} }{if  \\(\\texttt{normType} = \\texttt{NORM_L2}\\) }\n{ \\| \\texttt{src1} - \\texttt{src2} \\| _{L_2} =  \\sqrt{\\sum_I (\\texttt{src1}(I) - \\texttt{src2}(I))^2} }{if  \\(\\texttt{normType} = \\texttt{NORM_L2}\\) }\n{ \\frac{\\|\\texttt{src1}-\\texttt{src2}\\|_{L_2} }{\\|\\texttt{src2}\\|_{L_2}} }{if  \\(\\texttt{normType} = \\texttt{NORM_RELATIVE | NORM_L2}\\) }\n\\f]"]
pub const cv_NormTypes_NORM_L2: cv_NormTypes = 4;
#[doc = "\\f[\nnorm =  \\forkthree\n{ \\| \\texttt{src1} \\| _{L_2} ^{2} = \\sum_I \\texttt{src1}(I)^2} {if  \\(\\texttt{normType} = \\texttt{NORM_L2SQR}\\)}\n{ \\| \\texttt{src1} - \\texttt{src2} \\| _{L_2} ^{2} =  \\sum_I (\\texttt{src1}(I) - \\texttt{src2}(I))^2 }{if  \\(\\texttt{normType} = \\texttt{NORM_L2SQR}\\) }\n{ \\left(\\frac{\\|\\texttt{src1}-\\texttt{src2}\\|_{L_2} }{\\|\\texttt{src2}\\|_{L_2}}\\right)^2 }{if  \\(\\texttt{normType} = \\texttt{NORM_RELATIVE | NORM_L2SQR}\\) }\n\\f]"]
pub const cv_NormTypes_NORM_L2SQR: cv_NormTypes = 5;
#[doc = "In the case of one input array, calculates the Hamming distance of the array from zero,\nIn the case of two input arrays, calculates the Hamming distance between the arrays."]
pub const cv_NormTypes_NORM_HAMMING: cv_NormTypes = 6;
#[doc = "Similar to NORM_HAMMING, but in the calculation, each two bits of the input sequence will\nbe added and treated as a single bit to be used in the same calculation as NORM_HAMMING."]
pub const cv_NormTypes_NORM_HAMMING2: cv_NormTypes = 7;
#[doc = "!< bit-mask which can be used to separate norm type from norm flags"]
pub const cv_NormTypes_NORM_TYPE_MASK: cv_NormTypes = 7;
#[doc = "!< flag"]
pub const cv_NormTypes_NORM_RELATIVE: cv_NormTypes = 8;
#[doc = "!< flag"]
pub const cv_NormTypes_NORM_MINMAX: cv_NormTypes = 32;
#[doc = " norm types\n\nsrc1 and src2 denote input arrays."]
pub type cv_NormTypes = ::std::os::raw::c_uint;
#[doc = "!< src1 is equal to src2."]
pub const cv_CmpTypes_CMP_EQ: cv_CmpTypes = 0;
#[doc = "!< src1 is greater than src2."]
pub const cv_CmpTypes_CMP_GT: cv_CmpTypes = 1;
#[doc = "!< src1 is greater than or equal to src2."]
pub const cv_CmpTypes_CMP_GE: cv_CmpTypes = 2;
#[doc = "!< src1 is less than src2."]
pub const cv_CmpTypes_CMP_LT: cv_CmpTypes = 3;
#[doc = "!< src1 is less than or equal to src2."]
pub const cv_CmpTypes_CMP_LE: cv_CmpTypes = 4;
#[doc = "!< src1 is unequal to src2."]
pub const cv_CmpTypes_CMP_NE: cv_CmpTypes = 5;
#[doc = "! comparison types"]
pub type cv_CmpTypes = ::std::os::raw::c_uint;
#[doc = "!< transposes src1"]
pub const cv_GemmFlags_GEMM_1_T: cv_GemmFlags = 1;
#[doc = "!< transposes src2"]
pub const cv_GemmFlags_GEMM_2_T: cv_GemmFlags = 2;
#[doc = "!< transposes src3"]
pub const cv_GemmFlags_GEMM_3_T: cv_GemmFlags = 4;
#[doc = "! generalized matrix multiplication flags"]
pub type cv_GemmFlags = ::std::os::raw::c_uint;
#[doc = " performs an inverse 1D or 2D transform instead of the default forward\ntransform."]
pub const cv_DftFlags_DFT_INVERSE: cv_DftFlags = 1;
#[doc = " scales the result: divide it by the number of array elements. Normally, it is\ncombined with DFT_INVERSE."]
pub const cv_DftFlags_DFT_SCALE: cv_DftFlags = 2;
#[doc = " performs a forward or inverse transform of every individual row of the input\nmatrix; this flag enables you to transform multiple vectors simultaneously and can be used to\ndecrease the overhead (which is sometimes several times larger than the processing itself) to\nperform 3D and higher-dimensional transformations and so forth."]
pub const cv_DftFlags_DFT_ROWS: cv_DftFlags = 4;
#[doc = " performs a forward transformation of 1D or 2D real array; the result,\nthough being a complex array, has complex-conjugate symmetry (*CCS*, see the function\ndescription below for details), and such an array can be packed into a real array of the same\nsize as input, which is the fastest option and which is what the function does by default;\nhowever, you may wish to get a full complex array (for simpler spectrum analysis, and so on) -\npass the flag to enable the function to produce a full-size complex output array."]
pub const cv_DftFlags_DFT_COMPLEX_OUTPUT: cv_DftFlags = 16;
#[doc = " performs an inverse transformation of a 1D or 2D complex array; the\nresult is normally a complex array of the same size, however, if the input array has\nconjugate-complex symmetry (for example, it is a result of forward transformation with\nDFT_COMPLEX_OUTPUT flag), the output is a real array; while the function itself does not\ncheck whether the input is symmetrical or not, you can pass the flag and then the function\nwill assume the symmetry and produce the real output array (note that when the input is packed\ninto a real array and inverse transformation is executed, the function treats the input as a\npacked complex-conjugate symmetrical array, and the output will also be a real array)."]
pub const cv_DftFlags_DFT_REAL_OUTPUT: cv_DftFlags = 32;
#[doc = " specifies that input is complex input. If this flag is set, the input must have 2 channels.\nOn the other hand, for backwards compatibility reason, if input has 2 channels, input is\nalready considered complex."]
pub const cv_DftFlags_DFT_COMPLEX_INPUT: cv_DftFlags = 64;
#[doc = " performs an inverse 1D or 2D transform instead of the default forward transform."]
pub const cv_DftFlags_DCT_INVERSE: cv_DftFlags = 1;
#[doc = " performs a forward or inverse transform of every individual row of the input\nmatrix. This flag enables you to transform multiple vectors simultaneously and can be used to\ndecrease the overhead (which is sometimes several times larger than the processing itself) to\nperform 3D and higher-dimensional transforms and so forth."]
pub const cv_DftFlags_DCT_ROWS: cv_DftFlags = 4;
pub type cv_DftFlags = ::std::os::raw::c_uint;
#[doc = "!< `iiiiii|abcdefgh|iiiiiii`  with some specified `i`"]
pub const cv_BorderTypes_BORDER_CONSTANT: cv_BorderTypes = 0;
#[doc = "!< `aaaaaa|abcdefgh|hhhhhhh`"]
pub const cv_BorderTypes_BORDER_REPLICATE: cv_BorderTypes = 1;
#[doc = "!< `fedcba|abcdefgh|hgfedcb`"]
pub const cv_BorderTypes_BORDER_REFLECT: cv_BorderTypes = 2;
#[doc = "!< `cdefgh|abcdefgh|abcdefg`"]
pub const cv_BorderTypes_BORDER_WRAP: cv_BorderTypes = 3;
#[doc = "!< `gfedcb|abcdefgh|gfedcba`"]
pub const cv_BorderTypes_BORDER_REFLECT_101: cv_BorderTypes = 4;
#[doc = "!< `uvwxyz|abcdefgh|ijklmno`"]
pub const cv_BorderTypes_BORDER_TRANSPARENT: cv_BorderTypes = 5;
#[doc = "!< same as BORDER_REFLECT_101"]
pub const cv_BorderTypes_BORDER_REFLECT101: cv_BorderTypes = 4;
#[doc = "!< same as BORDER_REFLECT_101"]
pub const cv_BorderTypes_BORDER_DEFAULT: cv_BorderTypes = 4;
#[doc = "!< do not look outside of ROI"]
pub const cv_BorderTypes_BORDER_ISOLATED: cv_BorderTypes = 16;
#[doc = "! Various border types, image boundaries are denoted with `|`\n! @see borderInterpolate, copyMakeBorder"]
pub type cv_BorderTypes = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Signals an error and raises the exception.\n\nBy default the function prints information about the error to stderr,\nthen it either stops if setBreakOnError() had been called before or raises the exception.\nIt is possible to alternate error processing by using redirectError().\n@param _code - error code (Error::Code)\n@param _err - error description\n@param _func - function name. Available only when the compiler supports getting it\n@param _file - source file name where the error has occurred\n@param _line - line number in the source file where the error has occurred\n@see CV_Error, CV_Error_, CV_Assert, CV_DbgAssert"]
    #[link_name = "\u{1}_ZN2cv5errorEiRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPKcS9_i"]
    pub fn cv_error(
        _code: ::std::os::raw::c_int,
        _err: *const cv_String,
        _func: *const ::std::os::raw::c_char,
        _file: *const ::std::os::raw::c_char,
        _line: ::std::os::raw::c_int,
    ) -> !;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_Hamming {
    pub _address: u8,
}
pub type cv_Hamming_ValueType = ::std::os::raw::c_uchar;
pub type cv_Hamming_ResultType = ::std::os::raw::c_int;
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv7Hamming8normTypeE"]
    pub static cv_Hamming_normType: cv_NormTypes;
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_Hamming"][::std::mem::size_of::<cv_Hamming>() - 1usize];
    ["Alignment of cv_Hamming"][::std::mem::align_of::<cv_Hamming>() - 1usize];
};
pub type cv_HammingLUT = cv_Hamming;
unsafe extern "C" {
    #[doc = " @brief Computes the cube root of an argument.\n\nThe function cubeRoot computes \\f$\\sqrt[3]{\\texttt{val}}\\f$. Negative arguments are handled correctly.\nNaN and Inf are not handled. The accuracy approaches the maximum possible accuracy for\nsingle-precision data.\n@param val A function argument."]
    #[link_name = "\u{1}_ZN2cv8cubeRootEf"]
    pub fn cv_cubeRoot(val: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " @brief Calculates the angle of a 2D vector in degrees.\n\nThe function fastAtan2 calculates the full-range angle of an input 2D vector. The angle is measured\nin degrees and varies from 0 to 360 degrees. The accuracy is about 0.3 degrees.\n@param x x-coordinate of the vector.\n@param y y-coordinate of the vector."]
    #[link_name = "\u{1}_ZN2cv9fastAtan2Eff"]
    pub fn cv_fastAtan2(y: f32, x: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " proxy for hal::LU"]
    #[link_name = "\u{1}_ZN2cv2LUEPfmiS0_mi"]
    pub fn cv_LU(
        A: *mut f32,
        astep: usize,
        m: ::std::os::raw::c_int,
        b: *mut f32,
        bstep: usize,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " proxy for hal::LU"]
    #[link_name = "\u{1}_ZN2cv2LUEPdmiS0_mi"]
    pub fn cv_LU1(
        A: *mut f64,
        astep: usize,
        m: ::std::os::raw::c_int,
        b: *mut f64,
        bstep: usize,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " proxy for hal::Cholesky"]
    #[link_name = "\u{1}_ZN2cv8CholeskyEPfmiS0_mi"]
    pub fn cv_Cholesky(
        A: *mut f32,
        astep: usize,
        m: ::std::os::raw::c_int,
        b: *mut f32,
        bstep: usize,
        n: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " proxy for hal::Cholesky"]
    #[link_name = "\u{1}_ZN2cv8CholeskyEPdmiS0_mi"]
    pub fn cv_Cholesky1(
        A: *mut f64,
        astep: usize,
        m: ::std::os::raw::c_int,
        b: *mut f64,
        bstep: usize,
        n: ::std::os::raw::c_int,
    ) -> bool;
}
#[doc = " @brief n-dimensional dense array class \\anchor CVMat_Details\n\nThe class Mat represents an n-dimensional dense numerical single-channel or multi-channel array. It\ncan be used to store real or complex-valued vectors and matrices, grayscale or color images, voxel\nvolumes, vector fields, point clouds, tensors, histograms (though, very high-dimensional histograms\nmay be better stored in a SparseMat ). The data layout of the array `M` is defined by the array\n`M.step[]`, so that the address of element \\f$(i_0,...,i_{M.dims-1})\\f$, where \\f$0\\leq i_k<M.size[k]\\f$, is\ncomputed as:\n\\f[addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ... + M.step[M.dims-1]*i_{M.dims-1}\\f]\nIn case of a 2-dimensional array, the above formula is reduced to:\n\\f[addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j\\f]\nNote that `M.step[i] >= M.step[i+1]` (in fact, `M.step[i] >= M.step[i+1]*M.size[i+1]` ). This means\nthat 2-dimensional matrices are stored row-by-row, 3-dimensional matrices are stored plane-by-plane,\nand so on. M.step[M.dims-1] is minimal and always equal to the element size M.elemSize() .\n\nSo, the data layout in Mat is compatible with the majority of dense array types from the standard\ntoolkits and SDKs, such as Numpy (ndarray), Win32 (independent device bitmaps), and others,\nthat is, with any array that uses *steps* (or *strides*) to compute the position of a pixel.\nDue to this compatibility, it is possible to make a Mat header for user-allocated data and process\nit in-place using OpenCV functions.\n\nThere are many different ways to create a Mat object. The most popular options are listed below:\n\n- Use the create(nrows, ncols, type) method or the similar Mat(nrows, ncols, type[, fillValue])\nconstructor. A new array of the specified size and type is allocated. type has the same meaning as\nin the cvCreateMat method. For example, CV_8UC1 means a 8-bit single-channel array, CV_32FC2\nmeans a 2-channel (complex) floating-point array, and so on.\n@code\n// make a 7x7 complex matrix filled with 1+3j.\nMat M(7,7,CV_32FC2,Scalar(1,3));\n// and now turn M to a 100x60 15-channel 8-bit matrix.\n// The old content will be deallocated\nM.create(100,60,CV_8UC(15));\n@endcode\nAs noted in the introduction to this chapter, create() allocates only a new array when the shape\nor type of the current array are different from the specified ones.\n\n- Create a multi-dimensional array:\n@code\n// create a 100x100x100 8-bit array\nint sz[] = {100, 100, 100};\nMat bigCube(3, sz, CV_8U, Scalar::all(0));\n@endcode\nIt passes the number of dimensions =1 to the Mat constructor but the created array will be\n2-dimensional with the number of columns set to 1. So, Mat::dims is always \\>= 2 (can also be 0\nwhen the array is empty).\n\n- Use a copy constructor or assignment operator where there can be an array or expression on the\nright side (see below). As noted in the introduction, the array assignment is an O(1) operation\nbecause it only copies the header and increases the reference counter. The Mat::clone() method can\nbe used to get a full (deep) copy of the array when you need it.\n\n- Construct a header for a part of another array. It can be a single row, single column, several\nrows, several columns, rectangular region in the array (called a *minor* in algebra) or a\ndiagonal. Such operations are also O(1) because the new header references the same data. You can\nactually modify a part of the array using this feature, for example:\n@code\n// add the 5-th row, multiplied by 3 to the 3rd row\nM.row(3) = M.row(3) + M.row(5)*3;\n// now copy the 7-th column to the 1-st column\n// M.col(1) = M.col(7); // this will not work\nMat M1 = M.col(1);\nM.col(7).copyTo(M1);\n// create a new 320x240 image\nMat img(Size(320,240),CV_8UC3);\n// select a ROI\nMat roi(img, Rect(10,10,100,100));\n// fill the ROI with (0,255,0) (which is green in RGB space);\n// the original 320x240 image will be modified\nroi = Scalar(0,255,0);\n@endcode\nDue to the additional datastart and dataend members, it is possible to compute a relative\nsub-array position in the main *container* array using locateROI():\n@code\nMat A = Mat::eye(10, 10, CV_32S);\n// extracts A columns, 1 (inclusive) to 3 (exclusive).\nMat B = A(Range::all(), Range(1, 3));\n// extracts B rows, 5 (inclusive) to 9 (exclusive).\n// that is, C \\~ A(Range(5, 9), Range(1, 3))\nMat C = B(Range(5, 9), Range::all());\nSize size; Point ofs;\nC.locateROI(size, ofs);\n// size will be (width=10,height=10) and the ofs will be (x=1, y=5)\n@endcode\nAs in case of whole matrices, if you need a deep copy, use the `clone()` method of the extracted\nsub-matrices.\n\n- Make a header for user-allocated data. It can be useful to do the following:\n-# Process \"foreign\" data using OpenCV (for example, when you implement a DirectShow\\* filter or\na processing module for gstreamer, and so on). For example:\n@code\nvoid process_video_frame(const unsigned char* pixels,\nint width, int height, int step)\n{\nMat img(height, width, CV_8UC3, pixels, step);\nGaussianBlur(img, img, Size(7,7), 1.5, 1.5);\n}\n@endcode\n-# Quickly initialize small matrices and/or get a super-fast element access.\n@code\ndouble m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};\nMat M = Mat(3, 3, CV_64F, m).inv();\n@endcode\n.\n\n- Use MATLAB-style array initializers, zeros(), ones(), eye(), for example:\n@code\n// create a double-precision identity matrix and add it to M.\nM += Mat::eye(M.rows, M.cols, CV_64F);\n@endcode\n\n- Use a comma-separated initializer:\n@code\n// create a 3x3 double-precision identity matrix\nMat M = (Mat_<double>(3,3) << 1, 0, 0, 0, 1, 0, 0, 0, 1);\n@endcode\nWith this approach, you first call a constructor of the Mat class with the proper parameters, and\nthen you just put `<< operator` followed by comma-separated values that can be constants,\nvariables, expressions, and so on. Also, note the extra parentheses required to avoid compilation\nerrors.\n\nOnce the array is created, it is automatically managed via a reference-counting mechanism. If the\narray header is built on top of user-allocated data, you should handle the data by yourself. The\narray data is deallocated when no one points to it. If you want to release the data pointed by a\narray header before the array destructor is called, use Mat::release().\n\nThe next important thing to learn about the array class is element access. This manual already\ndescribed how to compute an address of each array element. Normally, you are not required to use the\nformula directly in the code. If you know the array element type (which can be retrieved using the\nmethod Mat::type() ), you can access the element \\f$M_{ij}\\f$ of a 2-dimensional array as:\n@code\nM.at<double>(i,j) += 1.f;\n@endcode\nassuming that `M` is a double-precision floating-point array. There are several variants of the method\nat for a different number of dimensions.\n\nIf you need to process a whole row of a 2D array, the most efficient way is to get the pointer to\nthe row first, and then just use the plain C operator [] :\n@code\n// compute sum of positive matrix elements\n// (assuming that M is a double-precision matrix)\ndouble sum=0;\nfor(int i = 0; i < M.rows; i++)\n{\nconst double* Mi = M.ptr<double>(i);\nfor(int j = 0; j < M.cols; j++)\nsum += std::max(Mi[j], 0.);\n}\n@endcode\nSome operations, like the one above, do not actually depend on the array shape. They just process\nelements of an array one by one (or elements from multiple arrays that have the same coordinates,\nfor example, array addition). Such operations are called *element-wise*. It makes sense to check\nwhether all the input/output arrays are continuous, namely, have no gaps at the end of each row. If\nyes, process them as a long single row:\n@code\n// compute the sum of positive matrix elements, optimized variant\ndouble sum=0;\nint cols = M.cols, rows = M.rows;\nif(M.isContinuous())\n{\ncols *= rows;\nrows = 1;\n}\nfor(int i = 0; i < rows; i++)\n{\nconst double* Mi = M.ptr<double>(i);\nfor(int j = 0; j < cols; j++)\nsum += std::max(Mi[j], 0.);\n}\n@endcode\nIn case of the continuous matrix, the outer loop body is executed just once. So, the overhead is\nsmaller, which is especially noticeable in case of small matrices.\n\nFinally, there are STL-style iterators that are smart enough to skip gaps between successive rows:\n@code\n// compute sum of positive matrix elements, iterator-based variant\ndouble sum=0;\nMatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();\nfor(; it != it_end; ++it)\nsum += std::max(*it, 0.);\n@endcode\nThe matrix iterators are random-access iterators, so they can be passed to any STL algorithm,\nincluding std::sort().\n\n@note Matrix Expressions and arithmetic see MatExpr"]
pub type cv_MatND = cv_Mat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_ogl_Buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_ogl_Texture2D {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_ogl_Arrays {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_cuda_DevPtr<T> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    pub data: *mut T,
}
pub type cv_cuda_DevPtr_elem_type<T> = T;
pub type cv_cuda_DevPtr_index_type = ::std::os::raw::c_int;
pub const cv_cuda_DevPtr_elem_size: cv_cuda_DevPtr__bindgen_ty_1 = 0;
pub type cv_cuda_DevPtr__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_cuda_PtrSz<T> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    pub _base: cv_cuda_DevPtr<T>,
    pub size: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_cuda_PtrStep<T> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    pub _base: cv_cuda_DevPtr<T>,
    pub step: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_cuda_PtrStepSz<T> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    pub _base: cv_cuda_PtrStep<T>,
    pub cols: ::std::os::raw::c_int,
    pub rows: ::std::os::raw::c_int,
}
pub type cv_cuda_PtrStepSzb = cv_cuda_PtrStepSz<::std::os::raw::c_uchar>;
pub type cv_cuda_PtrStepSzus = cv_cuda_PtrStepSz<::std::os::raw::c_ushort>;
pub type cv_cuda_PtrStepSzf = cv_cuda_PtrStepSz<f32>;
pub type cv_cuda_PtrStepSzi = cv_cuda_PtrStepSz<::std::os::raw::c_int>;
pub type cv_cuda_PtrStepb = cv_cuda_PtrStep<::std::os::raw::c_uchar>;
pub type cv_cuda_PtrStepus = cv_cuda_PtrStep<::std::os::raw::c_ushort>;
pub type cv_cuda_PtrStepf = cv_cuda_PtrStep<f32>;
pub type cv_cuda_PtrStepi = cv_cuda_PtrStep<::std::os::raw::c_int>;
#[doc = " @brief Base storage class for GPU memory with reference counting.\n\nIts interface matches the Mat interface with the following limitations:\n\n-   no arbitrary dimensions support (only 2D)\n-   no functions that return references to their data (because references on GPU are not valid for\nCPU)\n-   no expression templates technique support\n\nBeware that the latter limitation may lead to overloaded matrix operators that cause memory\nallocations. The GpuMat class is convertible to cuda::PtrStepSz and cuda::PtrStep so it can be\npassed directly to the kernel.\n\n@note In contrast with Mat, in most cases GpuMat::isContinuous() == false . This means that rows are\naligned to a size depending on the hardware. Single-row GpuMat is always a continuous matrix.\n\n@note You are not recommended to leave static or global GpuMat variables allocated, that is, to rely\non its destructor. The destruction order of such variables and CUDA context is undefined. GPU memory\nrelease function returns error if the CUDA context has been destroyed before.\n\nSome member functions are described as a \"Blocking Call\" while some are described as a\n\"Non-Blocking Call\". Blocking functions are synchronous to host. It is guaranteed that the GPU\noperation is finished when the function returns. However, non-blocking functions are asynchronous to\nhost. Those functions may return even if the GPU operation is not finished.\n\nCompared to their blocking counterpart, non-blocking functions accept Stream as an additional\nargument. If a non-default stream is passed, the GPU operation may overlap with operations in other\nstreams.\n\n@sa Mat"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_cuda_GpuMat {
    #[doc = " includes several bit-fields:\n- the magic signature\n- continuity flag\n- depth\n- number of channels"]
    pub flags: ::std::os::raw::c_int,
    #[doc = "! the number of rows and columns"]
    pub rows: ::std::os::raw::c_int,
    #[doc = "! the number of rows and columns"]
    pub cols: ::std::os::raw::c_int,
    #[doc = "! a distance between successive rows in bytes; includes the gap if any"]
    pub step: usize,
    #[doc = "! pointer to the data"]
    pub data: *mut uchar,
    #[doc = "! pointer to the reference counter;\n! when GpuMat points to user-allocated data, the pointer is NULL"]
    pub refcount: *mut ::std::os::raw::c_int,
    #[doc = "! helper fields used in locateROI and adjustROI"]
    pub datastart: *mut uchar,
    pub dataend: *const uchar,
    #[doc = "! allocator"]
    pub allocator: *mut cv_cuda_GpuMat_Allocator,
}
#[repr(C)]
pub struct cv_cuda_GpuMat_Allocator__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct cv_cuda_GpuMat_Allocator {
    pub vtable_: *const cv_cuda_GpuMat_Allocator__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_cuda_GpuMat_Allocator"]
        [::std::mem::size_of::<cv_cuda_GpuMat_Allocator>() - 8usize];
    ["Alignment of cv_cuda_GpuMat_Allocator"]
        [::std::mem::align_of::<cv_cuda_GpuMat_Allocator>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_cuda_GpuMat"][::std::mem::size_of::<cv_cuda_GpuMat>() - 64usize];
    ["Alignment of cv_cuda_GpuMat"][::std::mem::align_of::<cv_cuda_GpuMat>() - 8usize];
    ["Offset of field: cv_cuda_GpuMat::flags"]
        [::std::mem::offset_of!(cv_cuda_GpuMat, flags) - 0usize];
    ["Offset of field: cv_cuda_GpuMat::rows"]
        [::std::mem::offset_of!(cv_cuda_GpuMat, rows) - 4usize];
    ["Offset of field: cv_cuda_GpuMat::cols"]
        [::std::mem::offset_of!(cv_cuda_GpuMat, cols) - 8usize];
    ["Offset of field: cv_cuda_GpuMat::step"]
        [::std::mem::offset_of!(cv_cuda_GpuMat, step) - 16usize];
    ["Offset of field: cv_cuda_GpuMat::data"]
        [::std::mem::offset_of!(cv_cuda_GpuMat, data) - 24usize];
    ["Offset of field: cv_cuda_GpuMat::refcount"]
        [::std::mem::offset_of!(cv_cuda_GpuMat, refcount) - 32usize];
    ["Offset of field: cv_cuda_GpuMat::datastart"]
        [::std::mem::offset_of!(cv_cuda_GpuMat, datastart) - 40usize];
    ["Offset of field: cv_cuda_GpuMat::dataend"]
        [::std::mem::offset_of!(cv_cuda_GpuMat, dataend) - 48usize];
    ["Offset of field: cv_cuda_GpuMat::allocator"]
        [::std::mem::offset_of!(cv_cuda_GpuMat, allocator) - 56usize];
};
unsafe extern "C" {
    #[doc = "! default allocator"]
    #[link_name = "\u{1}_ZN2cv4cuda6GpuMat16defaultAllocatorEv"]
    pub fn cv_cuda_GpuMat_defaultAllocator() -> *mut cv_cuda_GpuMat_Allocator;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4cuda6GpuMat19setDefaultAllocatorEPNS1_9AllocatorE"]
    pub fn cv_cuda_GpuMat_setDefaultAllocator(allocator: *mut cv_cuda_GpuMat_Allocator);
}
unsafe extern "C" {
    #[doc = "! allocates new GpuMat data unless the GpuMat already has specified size and type"]
    #[link_name = "\u{1}_ZN2cv4cuda6GpuMat6createEiii"]
    pub fn cv_cuda_GpuMat_create(
        this: *mut cv_cuda_GpuMat,
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = "! decreases reference counter, deallocate the data when reference counter reaches 0"]
    #[link_name = "\u{1}_ZN2cv4cuda6GpuMat7releaseEv"]
    pub fn cv_cuda_GpuMat_release(this: *mut cv_cuda_GpuMat);
}
unsafe extern "C" {
    #[doc = " @brief Performs data upload to GpuMat (Blocking call)\n\nThis function copies data from host memory to device memory. As being a blocking call, it is\nguaranteed that the copy operation is finished when this function returns."]
    #[link_name = "\u{1}_ZN2cv4cuda6GpuMat6uploadERKNS_11_InputArrayE"]
    pub fn cv_cuda_GpuMat_upload(this: *mut cv_cuda_GpuMat, arr: cv_InputArray);
}
unsafe extern "C" {
    #[doc = " @brief Performs data upload to GpuMat (Non-Blocking call)\n\nThis function copies data from host memory to device memory. As being a non-blocking call, this\nfunction may return even if the copy operation is not finished.\n\nThe copy operation may be overlapped with operations in other non-default streams if \\p stream is\nnot the default stream and \\p dst is HostMem allocated with HostMem::PAGE_LOCKED option."]
    #[link_name = "\u{1}_ZN2cv4cuda6GpuMat6uploadERKNS_11_InputArrayERNS0_6StreamE"]
    pub fn cv_cuda_GpuMat_upload1(
        this: *mut cv_cuda_GpuMat,
        arr: cv_InputArray,
        stream: *mut cv_cuda_Stream,
    );
}
unsafe extern "C" {
    #[doc = " @brief Performs data download from GpuMat (Blocking call)\n\nThis function copies data from device memory to host memory. As being a blocking call, it is\nguaranteed that the copy operation is finished when this function returns."]
    #[link_name = "\u{1}_ZNK2cv4cuda6GpuMat8downloadERKNS_12_OutputArrayE"]
    pub fn cv_cuda_GpuMat_download(this: *const cv_cuda_GpuMat, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief Performs data download from GpuMat (Non-Blocking call)\n\nThis function copies data from device memory to host memory. As being a non-blocking call, this\nfunction may return even if the copy operation is not finished.\n\nThe copy operation may be overlapped with operations in other non-default streams if \\p stream is\nnot the default stream and \\p dst is HostMem allocated with HostMem::PAGE_LOCKED option."]
    #[link_name = "\u{1}_ZNK2cv4cuda6GpuMat8downloadERKNS_12_OutputArrayERNS0_6StreamE"]
    pub fn cv_cuda_GpuMat_download1(
        this: *const cv_cuda_GpuMat,
        dst: cv_OutputArray,
        stream: *mut cv_cuda_Stream,
    );
}
unsafe extern "C" {
    #[doc = "! copies the GpuMat content to device memory (Blocking call)"]
    #[link_name = "\u{1}_ZNK2cv4cuda6GpuMat6copyToERKNS_12_OutputArrayE"]
    pub fn cv_cuda_GpuMat_copyTo(this: *const cv_cuda_GpuMat, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = "! copies the GpuMat content to device memory (Non-Blocking call)"]
    #[link_name = "\u{1}_ZNK2cv4cuda6GpuMat6copyToERKNS_12_OutputArrayERNS0_6StreamE"]
    pub fn cv_cuda_GpuMat_copyTo1(
        this: *const cv_cuda_GpuMat,
        dst: cv_OutputArray,
        stream: *mut cv_cuda_Stream,
    );
}
unsafe extern "C" {
    #[doc = "! copies those GpuMat elements to \"m\" that are marked with non-zero mask elements (Non-Blocking call)"]
    #[link_name = "\u{1}_ZNK2cv4cuda6GpuMat6copyToERKNS_12_OutputArrayERKNS_11_InputArrayERNS0_6StreamE"]
    pub fn cv_cuda_GpuMat_copyTo2(
        this: *const cv_cuda_GpuMat,
        dst: cv_OutputArray,
        mask: cv_InputArray,
        stream: *mut cv_cuda_Stream,
    );
}
unsafe extern "C" {
    #[doc = "! sets some of the GpuMat elements to s (Non-Blocking call)"]
    #[link_name = "\u{1}_ZN2cv4cuda6GpuMat5setToENS_7Scalar_IdEERNS0_6StreamE"]
    pub fn cv_cuda_GpuMat_setTo(
        this: *mut cv_cuda_GpuMat,
        s: cv_Scalar,
        stream: *mut cv_cuda_Stream,
    ) -> *mut cv_cuda_GpuMat;
}
unsafe extern "C" {
    #[doc = "! sets some of the GpuMat elements to s, according to the mask (Non-Blocking call)"]
    #[link_name = "\u{1}_ZN2cv4cuda6GpuMat5setToENS_7Scalar_IdEERKNS_11_InputArrayERNS0_6StreamE"]
    pub fn cv_cuda_GpuMat_setTo1(
        this: *mut cv_cuda_GpuMat,
        s: cv_Scalar,
        mask: cv_InputArray,
        stream: *mut cv_cuda_Stream,
    ) -> *mut cv_cuda_GpuMat;
}
unsafe extern "C" {
    #[doc = "! converts GpuMat to another datatype (Non-Blocking call)"]
    #[link_name = "\u{1}_ZNK2cv4cuda6GpuMat9convertToERKNS_12_OutputArrayEiRNS0_6StreamE"]
    pub fn cv_cuda_GpuMat_convertTo(
        this: *const cv_cuda_GpuMat,
        dst: cv_OutputArray,
        rtype: ::std::os::raw::c_int,
        stream: *mut cv_cuda_Stream,
    );
}
unsafe extern "C" {
    #[doc = "! converts GpuMat to another datatype with scaling (Non-Blocking call)"]
    #[link_name = "\u{1}_ZNK2cv4cuda6GpuMat9convertToERKNS_12_OutputArrayEiddRNS0_6StreamE"]
    pub fn cv_cuda_GpuMat_convertTo1(
        this: *const cv_cuda_GpuMat,
        dst: cv_OutputArray,
        rtype: ::std::os::raw::c_int,
        alpha: f64,
        beta: f64,
        stream: *mut cv_cuda_Stream,
    );
}
unsafe extern "C" {
    #[doc = "! creates alternative GpuMat header for the same data, with different\n! number of channels and/or different number of rows"]
    #[link_name = "\u{1}_ZNK2cv4cuda6GpuMat7reshapeEii"]
    pub fn cv_cuda_GpuMat_reshape(
        this: *const cv_cuda_GpuMat,
        cn: ::std::os::raw::c_int,
        rows: ::std::os::raw::c_int,
    ) -> cv_cuda_GpuMat;
}
unsafe extern "C" {
    #[doc = "! locates GpuMat header within a parent GpuMat"]
    #[link_name = "\u{1}_ZNK2cv4cuda6GpuMat9locateROIERNS_5Size_IiEERNS_6Point_IiEE"]
    pub fn cv_cuda_GpuMat_locateROI(
        this: *const cv_cuda_GpuMat,
        wholeSize: *mut cv_Size,
        ofs: *mut cv_Point,
    );
}
unsafe extern "C" {
    #[doc = "! moves/resizes the current GpuMat ROI inside the parent GpuMat"]
    #[link_name = "\u{1}_ZN2cv4cuda6GpuMat9adjustROIEiiii"]
    pub fn cv_cuda_GpuMat_adjustROI(
        this: *mut cv_cuda_GpuMat,
        dtop: ::std::os::raw::c_int,
        dbottom: ::std::os::raw::c_int,
        dleft: ::std::os::raw::c_int,
        dright: ::std::os::raw::c_int,
    ) -> *mut cv_cuda_GpuMat;
}
unsafe extern "C" {
    #[doc = "! internal use method: updates the continuity flag"]
    #[link_name = "\u{1}_ZN2cv4cuda6GpuMat20updateContinuityFlagEv"]
    pub fn cv_cuda_GpuMat_updateContinuityFlag(this: *mut cv_cuda_GpuMat);
}
unsafe extern "C" {
    #[doc = "! constructor for GpuMat headers pointing to user-allocated data"]
    #[link_name = "\u{1}_ZN2cv4cuda6GpuMatC1EiiiPvm"]
    pub fn cv_cuda_GpuMat_GpuMat(
        this: *mut cv_cuda_GpuMat,
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        step: usize,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4cuda6GpuMatC1ENS_5Size_IiEEiPvm"]
    pub fn cv_cuda_GpuMat_GpuMat1(
        this: *mut cv_cuda_GpuMat,
        size: cv_Size,
        type_: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        step: usize,
    );
}
unsafe extern "C" {
    #[doc = "! creates a GpuMat header for a part of the bigger matrix"]
    #[link_name = "\u{1}_ZN2cv4cuda6GpuMatC1ERKS1_NS_5RangeES4_"]
    pub fn cv_cuda_GpuMat_GpuMat2(
        this: *mut cv_cuda_GpuMat,
        m: *const cv_cuda_GpuMat,
        rowRange: cv_Range,
        colRange: cv_Range,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4cuda6GpuMatC1ERKS1_NS_5Rect_IiEE"]
    pub fn cv_cuda_GpuMat_GpuMat3(
        this: *mut cv_cuda_GpuMat,
        m: *const cv_cuda_GpuMat,
        roi: cv_Rect,
    );
}
impl cv_cuda_GpuMat {
    #[inline]
    pub unsafe fn defaultAllocator() -> *mut cv_cuda_GpuMat_Allocator {
        cv_cuda_GpuMat_defaultAllocator()
    }
    #[inline]
    pub unsafe fn setDefaultAllocator(allocator: *mut cv_cuda_GpuMat_Allocator) {
        cv_cuda_GpuMat_setDefaultAllocator(allocator)
    }
    #[inline]
    pub unsafe fn create(
        &mut self,
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) {
        cv_cuda_GpuMat_create(self, rows, cols, type_)
    }
    #[inline]
    pub unsafe fn release(&mut self) {
        cv_cuda_GpuMat_release(self)
    }
    #[inline]
    pub unsafe fn upload(&mut self, arr: cv_InputArray) {
        cv_cuda_GpuMat_upload(self, arr)
    }
    #[inline]
    pub unsafe fn upload1(&mut self, arr: cv_InputArray, stream: *mut cv_cuda_Stream) {
        cv_cuda_GpuMat_upload1(self, arr, stream)
    }
    #[inline]
    pub unsafe fn download(&self, dst: cv_OutputArray) {
        cv_cuda_GpuMat_download(self, dst)
    }
    #[inline]
    pub unsafe fn download1(&self, dst: cv_OutputArray, stream: *mut cv_cuda_Stream) {
        cv_cuda_GpuMat_download1(self, dst, stream)
    }
    #[inline]
    pub unsafe fn copyTo(&self, dst: cv_OutputArray) {
        cv_cuda_GpuMat_copyTo(self, dst)
    }
    #[inline]
    pub unsafe fn copyTo1(&self, dst: cv_OutputArray, stream: *mut cv_cuda_Stream) {
        cv_cuda_GpuMat_copyTo1(self, dst, stream)
    }
    #[inline]
    pub unsafe fn copyTo2(
        &self,
        dst: cv_OutputArray,
        mask: cv_InputArray,
        stream: *mut cv_cuda_Stream,
    ) {
        cv_cuda_GpuMat_copyTo2(self, dst, mask, stream)
    }
    #[inline]
    pub unsafe fn setTo(
        &mut self,
        s: cv_Scalar,
        stream: *mut cv_cuda_Stream,
    ) -> *mut cv_cuda_GpuMat {
        cv_cuda_GpuMat_setTo(self, s, stream)
    }
    #[inline]
    pub unsafe fn setTo1(
        &mut self,
        s: cv_Scalar,
        mask: cv_InputArray,
        stream: *mut cv_cuda_Stream,
    ) -> *mut cv_cuda_GpuMat {
        cv_cuda_GpuMat_setTo1(self, s, mask, stream)
    }
    #[inline]
    pub unsafe fn convertTo(
        &self,
        dst: cv_OutputArray,
        rtype: ::std::os::raw::c_int,
        stream: *mut cv_cuda_Stream,
    ) {
        cv_cuda_GpuMat_convertTo(self, dst, rtype, stream)
    }
    #[inline]
    pub unsafe fn convertTo1(
        &self,
        dst: cv_OutputArray,
        rtype: ::std::os::raw::c_int,
        alpha: f64,
        beta: f64,
        stream: *mut cv_cuda_Stream,
    ) {
        cv_cuda_GpuMat_convertTo1(self, dst, rtype, alpha, beta, stream)
    }
    #[inline]
    pub unsafe fn reshape(
        &self,
        cn: ::std::os::raw::c_int,
        rows: ::std::os::raw::c_int,
    ) -> cv_cuda_GpuMat {
        cv_cuda_GpuMat_reshape(self, cn, rows)
    }
    #[inline]
    pub unsafe fn locateROI(&self, wholeSize: *mut cv_Size, ofs: *mut cv_Point) {
        cv_cuda_GpuMat_locateROI(self, wholeSize, ofs)
    }
    #[inline]
    pub unsafe fn adjustROI(
        &mut self,
        dtop: ::std::os::raw::c_int,
        dbottom: ::std::os::raw::c_int,
        dleft: ::std::os::raw::c_int,
        dright: ::std::os::raw::c_int,
    ) -> *mut cv_cuda_GpuMat {
        cv_cuda_GpuMat_adjustROI(self, dtop, dbottom, dleft, dright)
    }
    #[inline]
    pub unsafe fn updateContinuityFlag(&mut self) {
        cv_cuda_GpuMat_updateContinuityFlag(self)
    }
    #[inline]
    pub unsafe fn new(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        step: usize,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_cuda_GpuMat_GpuMat(__bindgen_tmp.as_mut_ptr(), rows, cols, type_, data, step);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        size: cv_Size,
        type_: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        step: usize,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_cuda_GpuMat_GpuMat1(__bindgen_tmp.as_mut_ptr(), size, type_, data, step);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(m: *const cv_cuda_GpuMat, rowRange: cv_Range, colRange: cv_Range) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_cuda_GpuMat_GpuMat2(__bindgen_tmp.as_mut_ptr(), m, rowRange, colRange);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(m: *const cv_cuda_GpuMat, roi: cv_Rect) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_cuda_GpuMat_GpuMat3(__bindgen_tmp.as_mut_ptr(), m, roi);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[doc = " @brief Creates a continuous matrix.\n\n@param rows Row count.\n@param cols Column count.\n@param type Type of the matrix.\n@param arr Destination matrix. This parameter changes only if it has a proper type and area (\n\\f$\\texttt{rows} \\times \\texttt{cols}\\f$ ).\n\nMatrix is called continuous if its elements are stored continuously, that is, without gaps at the\nend of each row."]
    #[link_name = "\u{1}_ZN2cv4cuda16createContinuousEiiiRKNS_12_OutputArrayE"]
    pub fn cv_cuda_createContinuous(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        arr: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Ensures that the size of a matrix is big enough and the matrix has a proper type.\n\n@param rows Minimum desired number of rows.\n@param cols Minimum desired number of columns.\n@param type Desired matrix type.\n@param arr Destination matrix.\n\nThe function does not reallocate memory if the matrix has proper attributes already."]
    #[link_name = "\u{1}_ZN2cv4cuda18ensureSizeIsEnoughEiiiRKNS_12_OutputArrayE"]
    pub fn cv_cuda_ensureSizeIsEnough(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        arr: cv_OutputArray,
    );
}
#[doc = " @brief BufferPool for use with CUDA streams\n\nBufferPool utilizes Stream's allocator to create new buffers for GpuMat's. It is\nonly useful when enabled with #setBufferPoolUsage.\n\n@code\nsetBufferPoolUsage(true);\n@endcode\n\n@note #setBufferPoolUsage must be called \\em before any Stream declaration.\n\nUsers may specify custom allocator for Stream and may implement their own stream based\nfunctions utilizing the same underlying GPU memory management.\n\nIf custom allocator is not specified, BufferPool utilizes StackAllocator by\ndefault. StackAllocator allocates a chunk of GPU device memory beforehand,\nand when GpuMat is declared later on, it is given the pre-allocated memory.\nThis kind of strategy reduces the number of calls for memory allocating APIs\nsuch as cudaMalloc or cudaMallocPitch.\n\nBelow is an example that utilizes BufferPool with StackAllocator:\n\n@code\n#include <opencv2/opencv.hpp>\n\nusing namespace cv;\nusing namespace cv::cuda\n\nint main()\n{\nsetBufferPoolUsage(true);                               // Tell OpenCV that we are going to utilize BufferPool\nsetBufferPoolConfig(getDevice(), 1024 * 1024 * 64, 2);  // Allocate 64 MB, 2 stacks (default is 10 MB, 5 stacks)\n\nStream stream1, stream2;                                // Each stream uses 1 stack\nBufferPool pool1(stream1), pool2(stream2);\n\nGpuMat d_src1 = pool1.getBuffer(4096, 4096, CV_8UC1);   // 16MB\nGpuMat d_dst1 = pool1.getBuffer(4096, 4096, CV_8UC3);   // 48MB, pool1 is now full\n\nGpuMat d_src2 = pool2.getBuffer(1024, 1024, CV_8UC1);   // 1MB\nGpuMat d_dst2 = pool2.getBuffer(1024, 1024, CV_8UC3);   // 3MB\n\ncvtColor(d_src1, d_dst1, CV_GRAY2BGR, 0, stream1);\ncvtColor(d_src2, d_dst2, CV_GRAY2BGR, 0, stream2);\n}\n@endcode\n\nIf we allocate another GpuMat on pool1 in the above example, it will be carried out by\nthe DefaultAllocator since the stack for pool1 is full.\n\n@code\nGpuMat d_add1 = pool1.getBuffer(1024, 1024, CV_8UC1);   // Stack for pool1 is full, memory is allocated with DefaultAllocator\n@endcode\n\nIf a third stream is declared in the above example, allocating with #getBuffer\nwithin that stream will also be carried out by the DefaultAllocator because we've run out of\nstacks.\n\n@code\nStream stream3;                                         // Only 2 stacks were allocated, we've run out of stacks\nBufferPool pool3(stream3);\nGpuMat d_src3 = pool3.getBuffer(1024, 1024, CV_8UC1);   // Memory is allocated with DefaultAllocator\n@endcode\n\n@warning When utilizing StackAllocator, deallocation order is important.\n\nJust like a stack, deallocation must be done in LIFO order. Below is an example of\nerroneous usage that violates LIFO rule. If OpenCV is compiled in Debug mode, this\nsample code will emit CV_Assert error.\n\n@code\nint main()\n{\nsetBufferPoolUsage(true);                               // Tell OpenCV that we are going to utilize BufferPool\nStream stream;                                          // A default size (10 MB) stack is allocated to this stream\nBufferPool pool(stream);\n\nGpuMat mat1 = pool.getBuffer(1024, 1024, CV_8UC1);      // Allocate mat1 (1MB)\nGpuMat mat2 = pool.getBuffer(1024, 1024, CV_8UC1);      // Allocate mat2 (1MB)\n\nmat1.release();                                         // erroneous usage : mat2 must be deallocated before mat1\n}\n@endcode\n\nSince C++ local variables are destroyed in the reverse order of construction,\nthe code sample below satisfies the LIFO rule. Local GpuMat's are deallocated\nand the corresponding memory is automatically returned to the pool for later usage.\n\n@code\nint main()\n{\nsetBufferPoolUsage(true);                               // Tell OpenCV that we are going to utilize BufferPool\nsetBufferPoolConfig(getDevice(), 1024 * 1024 * 64, 2);  // Allocate 64 MB, 2 stacks (default is 10 MB, 5 stacks)\n\nStream stream1, stream2;                                // Each stream uses 1 stack\nBufferPool pool1(stream1), pool2(stream2);\n\nfor (int i = 0; i < 10; i++)\n{\nGpuMat d_src1 = pool1.getBuffer(4096, 4096, CV_8UC1);   // 16MB\nGpuMat d_dst1 = pool1.getBuffer(4096, 4096, CV_8UC3);   // 48MB, pool1 is now full\n\nGpuMat d_src2 = pool2.getBuffer(1024, 1024, CV_8UC1);   // 1MB\nGpuMat d_dst2 = pool2.getBuffer(1024, 1024, CV_8UC3);   // 3MB\n\nd_src1.setTo(Scalar(i), stream1);\nd_src2.setTo(Scalar(i), stream2);\n\ncvtColor(d_src1, d_dst1, CV_GRAY2BGR, 0, stream1);\ncvtColor(d_src2, d_dst2, CV_GRAY2BGR, 0, stream2);\n// The order of destruction of the local variables is:\n//   d_dst2 => d_src2 => d_dst1 => d_src1\n// LIFO rule is satisfied, this code runs without error\n}\n}\n@endcode"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_cuda_BufferPool {
    pub allocator_: cv_Ptr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_cuda_BufferPool"][::std::mem::size_of::<cv_cuda_BufferPool>() - 16usize];
    ["Alignment of cv_cuda_BufferPool"][::std::mem::align_of::<cv_cuda_BufferPool>() - 8usize];
    ["Offset of field: cv_cuda_BufferPool::allocator_"]
        [::std::mem::offset_of!(cv_cuda_BufferPool, allocator_) - 0usize];
};
unsafe extern "C" {
    #[doc = "! Allocates a new GpuMat of given size and type."]
    #[link_name = "\u{1}_ZN2cv4cuda10BufferPool9getBufferEiii"]
    pub fn cv_cuda_BufferPool_getBuffer(
        this: *mut cv_cuda_BufferPool,
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_cuda_GpuMat;
}
unsafe extern "C" {
    #[doc = "! Gets the BufferPool for the given stream."]
    #[link_name = "\u{1}_ZN2cv4cuda10BufferPoolC1ERNS0_6StreamE"]
    pub fn cv_cuda_BufferPool_BufferPool(
        this: *mut cv_cuda_BufferPool,
        stream: *mut cv_cuda_Stream,
    );
}
impl cv_cuda_BufferPool {
    #[inline]
    pub unsafe fn getBuffer(
        &mut self,
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_cuda_GpuMat {
        cv_cuda_BufferPool_getBuffer(self, rows, cols, type_)
    }
    #[inline]
    pub unsafe fn new(stream: *mut cv_cuda_Stream) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_cuda_BufferPool_BufferPool(__bindgen_tmp.as_mut_ptr(), stream);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[doc = "! BufferPool management (must be called before Stream creation)"]
    #[link_name = "\u{1}_ZN2cv4cuda18setBufferPoolUsageEb"]
    pub fn cv_cuda_setBufferPoolUsage(on: bool);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4cuda19setBufferPoolConfigEimi"]
    pub fn cv_cuda_setBufferPoolConfig(
        deviceId: ::std::os::raw::c_int,
        stackSize: usize,
        stackCount: ::std::os::raw::c_int,
    );
}
#[doc = " @brief Class with reference counting wrapping special memory type allocation functions from CUDA.\n\nIts interface is also Mat-like but with additional memory type parameters.\n\n-   **PAGE_LOCKED** sets a page locked memory type used commonly for fast and asynchronous\nuploading/downloading data from/to GPU.\n-   **SHARED** specifies a zero copy memory allocation that enables mapping the host memory to GPU\naddress space, if supported.\n-   **WRITE_COMBINED** sets the write combined buffer that is not cached by CPU. Such buffers are\nused to supply GPU with data when GPU only reads it. The advantage is a better CPU cache\nutilization.\n\n@note Allocation size of such memory types is usually limited. For more details, see *CUDA 2.2\nPinned Memory APIs* document or *CUDA C Programming Guide*."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_cuda_HostMem {
    pub flags: ::std::os::raw::c_int,
    pub rows: ::std::os::raw::c_int,
    pub cols: ::std::os::raw::c_int,
    pub step: usize,
    pub data: *mut uchar,
    pub refcount: *mut ::std::os::raw::c_int,
    pub datastart: *mut uchar,
    pub dataend: *const uchar,
    pub alloc_type: cv_cuda_HostMem_AllocType,
}
pub const cv_cuda_HostMem_AllocType_PAGE_LOCKED: cv_cuda_HostMem_AllocType = 1;
pub const cv_cuda_HostMem_AllocType_SHARED: cv_cuda_HostMem_AllocType = 2;
pub const cv_cuda_HostMem_AllocType_WRITE_COMBINED: cv_cuda_HostMem_AllocType = 4;
pub type cv_cuda_HostMem_AllocType = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_cuda_HostMem"][::std::mem::size_of::<cv_cuda_HostMem>() - 64usize];
    ["Alignment of cv_cuda_HostMem"][::std::mem::align_of::<cv_cuda_HostMem>() - 8usize];
    ["Offset of field: cv_cuda_HostMem::flags"]
        [::std::mem::offset_of!(cv_cuda_HostMem, flags) - 0usize];
    ["Offset of field: cv_cuda_HostMem::rows"]
        [::std::mem::offset_of!(cv_cuda_HostMem, rows) - 4usize];
    ["Offset of field: cv_cuda_HostMem::cols"]
        [::std::mem::offset_of!(cv_cuda_HostMem, cols) - 8usize];
    ["Offset of field: cv_cuda_HostMem::step"]
        [::std::mem::offset_of!(cv_cuda_HostMem, step) - 16usize];
    ["Offset of field: cv_cuda_HostMem::data"]
        [::std::mem::offset_of!(cv_cuda_HostMem, data) - 24usize];
    ["Offset of field: cv_cuda_HostMem::refcount"]
        [::std::mem::offset_of!(cv_cuda_HostMem, refcount) - 32usize];
    ["Offset of field: cv_cuda_HostMem::datastart"]
        [::std::mem::offset_of!(cv_cuda_HostMem, datastart) - 40usize];
    ["Offset of field: cv_cuda_HostMem::dataend"]
        [::std::mem::offset_of!(cv_cuda_HostMem, dataend) - 48usize];
    ["Offset of field: cv_cuda_HostMem::alloc_type"]
        [::std::mem::offset_of!(cv_cuda_HostMem, alloc_type) - 56usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4cuda7HostMem12getAllocatorENS1_9AllocTypeE"]
    pub fn cv_cuda_HostMem_getAllocator(
        alloc_type: cv_cuda_HostMem_AllocType,
    ) -> *mut cv_MatAllocator;
}
unsafe extern "C" {
    #[doc = "! allocates new matrix data unless the matrix already has specified size and type."]
    #[link_name = "\u{1}_ZN2cv4cuda7HostMem6createEiii"]
    pub fn cv_cuda_HostMem_create(
        this: *mut cv_cuda_HostMem,
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = "! creates alternative HostMem header for the same data, with different\n! number of channels and/or different number of rows"]
    #[link_name = "\u{1}_ZNK2cv4cuda7HostMem7reshapeEii"]
    pub fn cv_cuda_HostMem_reshape(
        this: *const cv_cuda_HostMem,
        cn: ::std::os::raw::c_int,
        rows: ::std::os::raw::c_int,
    ) -> cv_cuda_HostMem;
}
unsafe extern "C" {
    #[doc = "! decrements reference counter and released memory if needed."]
    #[link_name = "\u{1}_ZN2cv4cuda7HostMem7releaseEv"]
    pub fn cv_cuda_HostMem_release(this: *mut cv_cuda_HostMem);
}
unsafe extern "C" {
    #[doc = " @brief Maps CPU memory to GPU address space and creates the cuda::GpuMat header without reference counting\nfor it.\n\nThis can be done only if memory was allocated with the SHARED flag and if it is supported by the\nhardware. Laptops often share video and CPU memory, so address spaces can be mapped, which\neliminates an extra copy."]
    #[link_name = "\u{1}_ZNK2cv4cuda7HostMem18createGpuMatHeaderEv"]
    pub fn cv_cuda_HostMem_createGpuMatHeader(this: *const cv_cuda_HostMem) -> cv_cuda_GpuMat;
}
impl cv_cuda_HostMem {
    #[inline]
    pub unsafe fn getAllocator(alloc_type: cv_cuda_HostMem_AllocType) -> *mut cv_MatAllocator {
        cv_cuda_HostMem_getAllocator(alloc_type)
    }
    #[inline]
    pub unsafe fn create(
        &mut self,
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) {
        cv_cuda_HostMem_create(self, rows, cols, type_)
    }
    #[inline]
    pub unsafe fn reshape(
        &self,
        cn: ::std::os::raw::c_int,
        rows: ::std::os::raw::c_int,
    ) -> cv_cuda_HostMem {
        cv_cuda_HostMem_reshape(self, cn, rows)
    }
    #[inline]
    pub unsafe fn release(&mut self) {
        cv_cuda_HostMem_release(self)
    }
    #[inline]
    pub unsafe fn createGpuMatHeader(&self) -> cv_cuda_GpuMat {
        cv_cuda_HostMem_createGpuMatHeader(self)
    }
}
unsafe extern "C" {
    #[doc = " @brief Page-locks the memory of matrix and maps it for the device(s).\n\n@param m Input matrix."]
    #[link_name = "\u{1}_ZN2cv4cuda18registerPageLockedERNS_3MatE"]
    pub fn cv_cuda_registerPageLocked(m: *mut cv_Mat);
}
unsafe extern "C" {
    #[doc = " @brief Unmaps the memory of matrix and makes it pageable again.\n\n@param m Input matrix."]
    #[link_name = "\u{1}_ZN2cv4cuda20unregisterPageLockedERNS_3MatE"]
    pub fn cv_cuda_unregisterPageLocked(m: *mut cv_Mat);
}
#[doc = " @brief This class encapsulates a queue of asynchronous calls.\n\n@note Currently, you may face problems if an operation is enqueued twice with different data. Some\nfunctions use the constant GPU memory, and next call may update the memory before the previous one\nhas been finished. But calling different operations asynchronously is safe because each operation\nhas its own constant buffer. Memory copy/upload/download/set operations to the buffers you hold are\nalso safe.\n\n@note The Stream class is not thread-safe. Please use different Stream objects for different CPU threads.\n\n@code\nvoid thread1()\n{\ncv::cuda::Stream stream1;\ncv::cuda::func1(..., stream1);\n}\n\nvoid thread2()\n{\ncv::cuda::Stream stream2;\ncv::cuda::func2(..., stream2);\n}\n@endcode\n\n@note By default all CUDA routines are launched in Stream::Null() object, if the stream is not specified by user.\nIn multi-threading environment the stream objects must be passed explicitly (see previous note)."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_cuda_Stream {
    pub impl_: cv_Ptr,
}
pub type cv_cuda_Stream_bool_type = __BindgenOpaqueArray<u64, 2usize>;
pub type cv_cuda_Stream_StreamCallback = ::std::option::Option<
    unsafe extern "C" fn(status: ::std::os::raw::c_int, userData: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_cuda_Stream_Impl {
    _unused: [u8; 0],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_cuda_Stream"][::std::mem::size_of::<cv_cuda_Stream>() - 16usize];
    ["Alignment of cv_cuda_Stream"][::std::mem::align_of::<cv_cuda_Stream>() - 8usize];
    ["Offset of field: cv_cuda_Stream::impl_"]
        [::std::mem::offset_of!(cv_cuda_Stream, impl_) - 0usize];
};
unsafe extern "C" {
    #[doc = " @brief Returns true if the current stream queue is finished. Otherwise, it returns false."]
    #[link_name = "\u{1}_ZNK2cv4cuda6Stream15queryIfCompleteEv"]
    pub fn cv_cuda_Stream_queryIfComplete(this: *const cv_cuda_Stream) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Blocks the current CPU thread until all operations in the stream are complete."]
    #[link_name = "\u{1}_ZN2cv4cuda6Stream17waitForCompletionEv"]
    pub fn cv_cuda_Stream_waitForCompletion(this: *mut cv_cuda_Stream);
}
unsafe extern "C" {
    #[doc = " @brief Makes a compute stream wait on an event."]
    #[link_name = "\u{1}_ZN2cv4cuda6Stream9waitEventERKNS0_5EventE"]
    pub fn cv_cuda_Stream_waitEvent(this: *mut cv_cuda_Stream, event: *const cv_cuda_Event);
}
unsafe extern "C" {
    #[doc = " @brief Adds a callback to be called on the host after all currently enqueued items in the stream have\ncompleted.\n\n@note Callbacks must not make any CUDA API calls. Callbacks must not perform any synchronization\nthat may depend on outstanding device work or other callbacks that are not mandated to run earlier.\nCallbacks without a mandated order (in independent streams) execute in undefined order and may be\nserialized."]
    #[link_name = "\u{1}_ZN2cv4cuda6Stream19enqueueHostCallbackEPFviPvES2_"]
    pub fn cv_cuda_Stream_enqueueHostCallback(
        this: *mut cv_cuda_Stream,
        callback: cv_cuda_Stream_StreamCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "! return Stream object for default CUDA stream"]
    #[link_name = "\u{1}_ZN2cv4cuda6Stream4NullEv"]
    pub fn cv_cuda_Stream_Null() -> *mut cv_cuda_Stream;
}
unsafe extern "C" {
    #[doc = "! creates a new asynchronous stream"]
    #[link_name = "\u{1}_ZN2cv4cuda6StreamC1Ev"]
    pub fn cv_cuda_Stream_Stream(this: *mut cv_cuda_Stream);
}
unsafe extern "C" {
    #[doc = "! creates a new asynchronous stream with custom allocator"]
    #[link_name = "\u{1}_ZN2cv4cuda6StreamC1ERKNS_3PtrINS0_6GpuMat9AllocatorEEE"]
    pub fn cv_cuda_Stream_Stream1(this: *mut cv_cuda_Stream, allocator: *const cv_Ptr);
}
impl cv_cuda_Stream {
    #[inline]
    pub unsafe fn queryIfComplete(&self) -> bool {
        cv_cuda_Stream_queryIfComplete(self)
    }
    #[inline]
    pub unsafe fn waitForCompletion(&mut self) {
        cv_cuda_Stream_waitForCompletion(self)
    }
    #[inline]
    pub unsafe fn waitEvent(&mut self, event: *const cv_cuda_Event) {
        cv_cuda_Stream_waitEvent(self, event)
    }
    #[inline]
    pub unsafe fn enqueueHostCallback(
        &mut self,
        callback: cv_cuda_Stream_StreamCallback,
        userData: *mut ::std::os::raw::c_void,
    ) {
        cv_cuda_Stream_enqueueHostCallback(self, callback, userData)
    }
    #[inline]
    pub unsafe fn Null() -> *mut cv_cuda_Stream {
        cv_cuda_Stream_Null()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_cuda_Stream_Stream(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(allocator: *const cv_Ptr) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_cuda_Stream_Stream1(__bindgen_tmp.as_mut_ptr(), allocator);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_cuda_Event {
    pub impl_: cv_Ptr,
}
#[doc = "< Default event flag"]
pub const cv_cuda_Event_CreateFlags_DEFAULT: cv_cuda_Event_CreateFlags = 0;
#[doc = "< Event uses blocking synchronization"]
pub const cv_cuda_Event_CreateFlags_BLOCKING_SYNC: cv_cuda_Event_CreateFlags = 1;
#[doc = "< Event will not record timing data"]
pub const cv_cuda_Event_CreateFlags_DISABLE_TIMING: cv_cuda_Event_CreateFlags = 2;
#[doc = "< Event is suitable for interprocess use. DisableTiming must be set"]
pub const cv_cuda_Event_CreateFlags_INTERPROCESS: cv_cuda_Event_CreateFlags = 4;
pub type cv_cuda_Event_CreateFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_cuda_Event_Impl {
    _unused: [u8; 0],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_cuda_Event"][::std::mem::size_of::<cv_cuda_Event>() - 16usize];
    ["Alignment of cv_cuda_Event"][::std::mem::align_of::<cv_cuda_Event>() - 8usize];
    ["Offset of field: cv_cuda_Event::impl_"]
        [::std::mem::offset_of!(cv_cuda_Event, impl_) - 0usize];
};
unsafe extern "C" {
    #[doc = "! records an event"]
    #[link_name = "\u{1}_ZN2cv4cuda5Event6recordERNS0_6StreamE"]
    pub fn cv_cuda_Event_record(this: *mut cv_cuda_Event, stream: *mut cv_cuda_Stream);
}
unsafe extern "C" {
    #[doc = "! queries an event's status"]
    #[link_name = "\u{1}_ZNK2cv4cuda5Event15queryIfCompleteEv"]
    pub fn cv_cuda_Event_queryIfComplete(this: *const cv_cuda_Event) -> bool;
}
unsafe extern "C" {
    #[doc = "! waits for an event to complete"]
    #[link_name = "\u{1}_ZN2cv4cuda5Event17waitForCompletionEv"]
    pub fn cv_cuda_Event_waitForCompletion(this: *mut cv_cuda_Event);
}
unsafe extern "C" {
    #[doc = "! computes the elapsed time between events"]
    #[link_name = "\u{1}_ZN2cv4cuda5Event11elapsedTimeERKS1_S3_"]
    pub fn cv_cuda_Event_elapsedTime(start: *const cv_cuda_Event, end: *const cv_cuda_Event)
    -> f32;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4cuda5EventC1ENS1_11CreateFlagsE"]
    pub fn cv_cuda_Event_Event(this: *mut cv_cuda_Event, flags: cv_cuda_Event_CreateFlags);
}
impl cv_cuda_Event {
    #[inline]
    pub unsafe fn record(&mut self, stream: *mut cv_cuda_Stream) {
        cv_cuda_Event_record(self, stream)
    }
    #[inline]
    pub unsafe fn queryIfComplete(&self) -> bool {
        cv_cuda_Event_queryIfComplete(self)
    }
    #[inline]
    pub unsafe fn waitForCompletion(&mut self) {
        cv_cuda_Event_waitForCompletion(self)
    }
    #[inline]
    pub unsafe fn elapsedTime(start: *const cv_cuda_Event, end: *const cv_cuda_Event) -> f32 {
        cv_cuda_Event_elapsedTime(start, end)
    }
    #[inline]
    pub unsafe fn new(flags: cv_cuda_Event_CreateFlags) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_cuda_Event_Event(__bindgen_tmp.as_mut_ptr(), flags);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[doc = " @brief Returns the number of installed CUDA-enabled devices.\n\nUse this function before any other CUDA functions calls. If OpenCV is compiled without CUDA support,\nthis function returns 0. If the CUDA driver is not installed, or is incompatible, this function\nreturns -1."]
    #[link_name = "\u{1}_ZN2cv4cuda25getCudaEnabledDeviceCountEv"]
    pub fn cv_cuda_getCudaEnabledDeviceCount() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Sets a device and initializes it for the current thread.\n\n@param device System index of a CUDA device starting with 0.\n\nIf the call of this function is omitted, a default device is initialized at the fist CUDA usage."]
    #[link_name = "\u{1}_ZN2cv4cuda9setDeviceEi"]
    pub fn cv_cuda_setDevice(device: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @brief Returns the current device index set by cuda::setDevice or initialized by default."]
    #[link_name = "\u{1}_ZN2cv4cuda9getDeviceEv"]
    pub fn cv_cuda_getDevice() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Explicitly destroys and cleans up all resources associated with the current device in the current\nprocess.\n\nAny subsequent API call to this device will reinitialize the device."]
    #[link_name = "\u{1}_ZN2cv4cuda11resetDeviceEv"]
    pub fn cv_cuda_resetDevice();
}
pub const cv_cuda_FeatureSet_FEATURE_SET_COMPUTE_10: cv_cuda_FeatureSet = 10;
pub const cv_cuda_FeatureSet_FEATURE_SET_COMPUTE_11: cv_cuda_FeatureSet = 11;
pub const cv_cuda_FeatureSet_FEATURE_SET_COMPUTE_12: cv_cuda_FeatureSet = 12;
pub const cv_cuda_FeatureSet_FEATURE_SET_COMPUTE_13: cv_cuda_FeatureSet = 13;
pub const cv_cuda_FeatureSet_FEATURE_SET_COMPUTE_20: cv_cuda_FeatureSet = 20;
pub const cv_cuda_FeatureSet_FEATURE_SET_COMPUTE_21: cv_cuda_FeatureSet = 21;
pub const cv_cuda_FeatureSet_FEATURE_SET_COMPUTE_30: cv_cuda_FeatureSet = 30;
pub const cv_cuda_FeatureSet_FEATURE_SET_COMPUTE_32: cv_cuda_FeatureSet = 32;
pub const cv_cuda_FeatureSet_FEATURE_SET_COMPUTE_35: cv_cuda_FeatureSet = 35;
pub const cv_cuda_FeatureSet_FEATURE_SET_COMPUTE_50: cv_cuda_FeatureSet = 50;
pub const cv_cuda_FeatureSet_GLOBAL_ATOMICS: cv_cuda_FeatureSet = 11;
pub const cv_cuda_FeatureSet_SHARED_ATOMICS: cv_cuda_FeatureSet = 12;
pub const cv_cuda_FeatureSet_NATIVE_DOUBLE: cv_cuda_FeatureSet = 13;
pub const cv_cuda_FeatureSet_WARP_SHUFFLE_FUNCTIONS: cv_cuda_FeatureSet = 30;
pub const cv_cuda_FeatureSet_DYNAMIC_PARALLELISM: cv_cuda_FeatureSet = 35;
#[doc = " @brief Enumeration providing CUDA computing features."]
pub type cv_cuda_FeatureSet = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = "! checks whether current device supports the given feature"]
    #[link_name = "\u{1}_ZN2cv4cuda14deviceSupportsENS0_10FeatureSetE"]
    pub fn cv_cuda_deviceSupports(feature_set: cv_cuda_FeatureSet) -> bool;
}
#[doc = " @brief Class providing a set of static methods to check what NVIDIA\\* card architecture the CUDA module was\nbuilt for.\n\nAccording to the CUDA C Programming Guide Version 3.2: \"PTX code produced for some specific compute\ncapability can always be compiled to binary code of greater or equal compute capability\"."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_cuda_TargetArchs {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_cuda_TargetArchs"][::std::mem::size_of::<cv_cuda_TargetArchs>() - 1usize];
    ["Alignment of cv_cuda_TargetArchs"][::std::mem::align_of::<cv_cuda_TargetArchs>() - 1usize];
};
unsafe extern "C" {
    #[doc = " @brief The following method checks whether the module was built with the support of the given feature:\n\n@param feature_set Features to be checked. See :ocvcuda::FeatureSet."]
    #[link_name = "\u{1}_ZN2cv4cuda11TargetArchs9builtWithENS0_10FeatureSetE"]
    pub fn cv_cuda_TargetArchs_builtWith(feature_set: cv_cuda_FeatureSet) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4cuda11TargetArchs6hasPtxEii"]
    pub fn cv_cuda_TargetArchs_hasPtx(
        major: ::std::os::raw::c_int,
        minor: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4cuda11TargetArchs6hasBinEii"]
    pub fn cv_cuda_TargetArchs_hasBin(
        major: ::std::os::raw::c_int,
        minor: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4cuda11TargetArchs17hasEqualOrLessPtxEii"]
    pub fn cv_cuda_TargetArchs_hasEqualOrLessPtx(
        major: ::std::os::raw::c_int,
        minor: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4cuda11TargetArchs20hasEqualOrGreaterPtxEii"]
    pub fn cv_cuda_TargetArchs_hasEqualOrGreaterPtx(
        major: ::std::os::raw::c_int,
        minor: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4cuda11TargetArchs20hasEqualOrGreaterBinEii"]
    pub fn cv_cuda_TargetArchs_hasEqualOrGreaterBin(
        major: ::std::os::raw::c_int,
        minor: ::std::os::raw::c_int,
    ) -> bool;
}
impl cv_cuda_TargetArchs {
    #[inline]
    pub unsafe fn builtWith(feature_set: cv_cuda_FeatureSet) -> bool {
        cv_cuda_TargetArchs_builtWith(feature_set)
    }
    #[inline]
    pub unsafe fn hasPtx(major: ::std::os::raw::c_int, minor: ::std::os::raw::c_int) -> bool {
        cv_cuda_TargetArchs_hasPtx(major, minor)
    }
    #[inline]
    pub unsafe fn hasBin(major: ::std::os::raw::c_int, minor: ::std::os::raw::c_int) -> bool {
        cv_cuda_TargetArchs_hasBin(major, minor)
    }
    #[inline]
    pub unsafe fn hasEqualOrLessPtx(
        major: ::std::os::raw::c_int,
        minor: ::std::os::raw::c_int,
    ) -> bool {
        cv_cuda_TargetArchs_hasEqualOrLessPtx(major, minor)
    }
    #[inline]
    pub unsafe fn hasEqualOrGreaterPtx(
        major: ::std::os::raw::c_int,
        minor: ::std::os::raw::c_int,
    ) -> bool {
        cv_cuda_TargetArchs_hasEqualOrGreaterPtx(major, minor)
    }
    #[inline]
    pub unsafe fn hasEqualOrGreaterBin(
        major: ::std::os::raw::c_int,
        minor: ::std::os::raw::c_int,
    ) -> bool {
        cv_cuda_TargetArchs_hasEqualOrGreaterBin(major, minor)
    }
}
#[doc = " @brief Class providing functionality for querying the specified GPU properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_cuda_DeviceInfo {
    pub device_id_: ::std::os::raw::c_int,
}
#[doc = "< default compute mode (Multiple threads can use cudaSetDevice with this device)"]
pub const cv_cuda_DeviceInfo_ComputeMode_ComputeModeDefault: cv_cuda_DeviceInfo_ComputeMode = 0;
#[doc = "< compute-exclusive-thread mode (Only one thread in one process will be able to use cudaSetDevice with this device)"]
pub const cv_cuda_DeviceInfo_ComputeMode_ComputeModeExclusive: cv_cuda_DeviceInfo_ComputeMode = 1;
#[doc = "< compute-prohibited mode (No threads can use cudaSetDevice with this device)"]
pub const cv_cuda_DeviceInfo_ComputeMode_ComputeModeProhibited: cv_cuda_DeviceInfo_ComputeMode = 2;
#[doc = "< compute-exclusive-process mode (Many threads in one process will be able to use cudaSetDevice with this device)"]
pub const cv_cuda_DeviceInfo_ComputeMode_ComputeModeExclusiveProcess:
    cv_cuda_DeviceInfo_ComputeMode = 3;
pub type cv_cuda_DeviceInfo_ComputeMode = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_cuda_DeviceInfo"][::std::mem::size_of::<cv_cuda_DeviceInfo>() - 4usize];
    ["Alignment of cv_cuda_DeviceInfo"][::std::mem::align_of::<cv_cuda_DeviceInfo>() - 4usize];
    ["Offset of field: cv_cuda_DeviceInfo::device_id_"]
        [::std::mem::offset_of!(cv_cuda_DeviceInfo, device_id_) - 0usize];
};
unsafe extern "C" {
    #[doc = "! ASCII string identifying device"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo4nameEv"]
    pub fn cv_cuda_DeviceInfo_name(
        this: *const cv_cuda_DeviceInfo,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "! global memory available on device in bytes"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo14totalGlobalMemEv"]
    pub fn cv_cuda_DeviceInfo_totalGlobalMem(this: *const cv_cuda_DeviceInfo) -> usize;
}
unsafe extern "C" {
    #[doc = "! shared memory available per block in bytes"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo17sharedMemPerBlockEv"]
    pub fn cv_cuda_DeviceInfo_sharedMemPerBlock(this: *const cv_cuda_DeviceInfo) -> usize;
}
unsafe extern "C" {
    #[doc = "! 32-bit registers available per block"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo12regsPerBlockEv"]
    pub fn cv_cuda_DeviceInfo_regsPerBlock(
        this: *const cv_cuda_DeviceInfo,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! warp size in threads"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo8warpSizeEv"]
    pub fn cv_cuda_DeviceInfo_warpSize(this: *const cv_cuda_DeviceInfo) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! maximum pitch in bytes allowed by memory copies"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo8memPitchEv"]
    pub fn cv_cuda_DeviceInfo_memPitch(this: *const cv_cuda_DeviceInfo) -> usize;
}
unsafe extern "C" {
    #[doc = "! maximum number of threads per block"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo18maxThreadsPerBlockEv"]
    pub fn cv_cuda_DeviceInfo_maxThreadsPerBlock(
        this: *const cv_cuda_DeviceInfo,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! maximum size of each dimension of a block"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo13maxThreadsDimEv"]
    pub fn cv_cuda_DeviceInfo_maxThreadsDim(this: *const cv_cuda_DeviceInfo) -> cv_Vec3i;
}
unsafe extern "C" {
    #[doc = "! maximum size of each dimension of a grid"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo11maxGridSizeEv"]
    pub fn cv_cuda_DeviceInfo_maxGridSize(this: *const cv_cuda_DeviceInfo) -> cv_Vec3i;
}
unsafe extern "C" {
    #[doc = "! clock frequency in kilohertz"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo9clockRateEv"]
    pub fn cv_cuda_DeviceInfo_clockRate(this: *const cv_cuda_DeviceInfo) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! constant memory available on device in bytes"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo13totalConstMemEv"]
    pub fn cv_cuda_DeviceInfo_totalConstMem(this: *const cv_cuda_DeviceInfo) -> usize;
}
unsafe extern "C" {
    #[doc = "! major compute capability"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo12majorVersionEv"]
    pub fn cv_cuda_DeviceInfo_majorVersion(
        this: *const cv_cuda_DeviceInfo,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! minor compute capability"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo12minorVersionEv"]
    pub fn cv_cuda_DeviceInfo_minorVersion(
        this: *const cv_cuda_DeviceInfo,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! alignment requirement for textures"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo16textureAlignmentEv"]
    pub fn cv_cuda_DeviceInfo_textureAlignment(this: *const cv_cuda_DeviceInfo) -> usize;
}
unsafe extern "C" {
    #[doc = "! pitch alignment requirement for texture references bound to pitched memory"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo21texturePitchAlignmentEv"]
    pub fn cv_cuda_DeviceInfo_texturePitchAlignment(this: *const cv_cuda_DeviceInfo) -> usize;
}
unsafe extern "C" {
    #[doc = "! number of multiprocessors on device"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo19multiProcessorCountEv"]
    pub fn cv_cuda_DeviceInfo_multiProcessorCount(
        this: *const cv_cuda_DeviceInfo,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! specified whether there is a run time limit on kernels"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo24kernelExecTimeoutEnabledEv"]
    pub fn cv_cuda_DeviceInfo_kernelExecTimeoutEnabled(this: *const cv_cuda_DeviceInfo) -> bool;
}
unsafe extern "C" {
    #[doc = "! device is integrated as opposed to discrete"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo10integratedEv"]
    pub fn cv_cuda_DeviceInfo_integrated(this: *const cv_cuda_DeviceInfo) -> bool;
}
unsafe extern "C" {
    #[doc = "! device can map host memory with cudaHostAlloc/cudaHostGetDevicePointer"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo16canMapHostMemoryEv"]
    pub fn cv_cuda_DeviceInfo_canMapHostMemory(this: *const cv_cuda_DeviceInfo) -> bool;
}
unsafe extern "C" {
    #[doc = "! compute mode"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo11computeModeEv"]
    pub fn cv_cuda_DeviceInfo_computeMode(
        this: *const cv_cuda_DeviceInfo,
    ) -> cv_cuda_DeviceInfo_ComputeMode;
}
unsafe extern "C" {
    #[doc = "! maximum 1D texture size"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo12maxTexture1DEv"]
    pub fn cv_cuda_DeviceInfo_maxTexture1D(
        this: *const cv_cuda_DeviceInfo,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! maximum 1D mipmapped texture size"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo18maxTexture1DMipmapEv"]
    pub fn cv_cuda_DeviceInfo_maxTexture1DMipmap(
        this: *const cv_cuda_DeviceInfo,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! maximum size for 1D textures bound to linear memory"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo18maxTexture1DLinearEv"]
    pub fn cv_cuda_DeviceInfo_maxTexture1DLinear(
        this: *const cv_cuda_DeviceInfo,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! maximum 2D texture dimensions"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo12maxTexture2DEv"]
    pub fn cv_cuda_DeviceInfo_maxTexture2D(this: *const cv_cuda_DeviceInfo) -> cv_Vec2i;
}
unsafe extern "C" {
    #[doc = "! maximum 2D mipmapped texture dimensions"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo18maxTexture2DMipmapEv"]
    pub fn cv_cuda_DeviceInfo_maxTexture2DMipmap(this: *const cv_cuda_DeviceInfo) -> cv_Vec2i;
}
unsafe extern "C" {
    #[doc = "! maximum dimensions (width, height, pitch) for 2D textures bound to pitched memory"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo18maxTexture2DLinearEv"]
    pub fn cv_cuda_DeviceInfo_maxTexture2DLinear(this: *const cv_cuda_DeviceInfo) -> cv_Vec3i;
}
unsafe extern "C" {
    #[doc = "! maximum 2D texture dimensions if texture gather operations have to be performed"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo18maxTexture2DGatherEv"]
    pub fn cv_cuda_DeviceInfo_maxTexture2DGather(this: *const cv_cuda_DeviceInfo) -> cv_Vec2i;
}
unsafe extern "C" {
    #[doc = "! maximum 3D texture dimensions"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo12maxTexture3DEv"]
    pub fn cv_cuda_DeviceInfo_maxTexture3D(this: *const cv_cuda_DeviceInfo) -> cv_Vec3i;
}
unsafe extern "C" {
    #[doc = "! maximum Cubemap texture dimensions"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo17maxTextureCubemapEv"]
    pub fn cv_cuda_DeviceInfo_maxTextureCubemap(
        this: *const cv_cuda_DeviceInfo,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! maximum 1D layered texture dimensions"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo19maxTexture1DLayeredEv"]
    pub fn cv_cuda_DeviceInfo_maxTexture1DLayered(this: *const cv_cuda_DeviceInfo) -> cv_Vec2i;
}
unsafe extern "C" {
    #[doc = "! maximum 2D layered texture dimensions"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo19maxTexture2DLayeredEv"]
    pub fn cv_cuda_DeviceInfo_maxTexture2DLayered(this: *const cv_cuda_DeviceInfo) -> cv_Vec3i;
}
unsafe extern "C" {
    #[doc = "! maximum Cubemap layered texture dimensions"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo24maxTextureCubemapLayeredEv"]
    pub fn cv_cuda_DeviceInfo_maxTextureCubemapLayered(this: *const cv_cuda_DeviceInfo)
    -> cv_Vec2i;
}
unsafe extern "C" {
    #[doc = "! maximum 1D surface size"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo12maxSurface1DEv"]
    pub fn cv_cuda_DeviceInfo_maxSurface1D(
        this: *const cv_cuda_DeviceInfo,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! maximum 2D surface dimensions"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo12maxSurface2DEv"]
    pub fn cv_cuda_DeviceInfo_maxSurface2D(this: *const cv_cuda_DeviceInfo) -> cv_Vec2i;
}
unsafe extern "C" {
    #[doc = "! maximum 3D surface dimensions"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo12maxSurface3DEv"]
    pub fn cv_cuda_DeviceInfo_maxSurface3D(this: *const cv_cuda_DeviceInfo) -> cv_Vec3i;
}
unsafe extern "C" {
    #[doc = "! maximum 1D layered surface dimensions"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo19maxSurface1DLayeredEv"]
    pub fn cv_cuda_DeviceInfo_maxSurface1DLayered(this: *const cv_cuda_DeviceInfo) -> cv_Vec2i;
}
unsafe extern "C" {
    #[doc = "! maximum 2D layered surface dimensions"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo19maxSurface2DLayeredEv"]
    pub fn cv_cuda_DeviceInfo_maxSurface2DLayered(this: *const cv_cuda_DeviceInfo) -> cv_Vec3i;
}
unsafe extern "C" {
    #[doc = "! maximum Cubemap surface dimensions"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo17maxSurfaceCubemapEv"]
    pub fn cv_cuda_DeviceInfo_maxSurfaceCubemap(
        this: *const cv_cuda_DeviceInfo,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! maximum Cubemap layered surface dimensions"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo24maxSurfaceCubemapLayeredEv"]
    pub fn cv_cuda_DeviceInfo_maxSurfaceCubemapLayered(this: *const cv_cuda_DeviceInfo)
    -> cv_Vec2i;
}
unsafe extern "C" {
    #[doc = "! alignment requirements for surfaces"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo16surfaceAlignmentEv"]
    pub fn cv_cuda_DeviceInfo_surfaceAlignment(this: *const cv_cuda_DeviceInfo) -> usize;
}
unsafe extern "C" {
    #[doc = "! device can possibly execute multiple kernels concurrently"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo17concurrentKernelsEv"]
    pub fn cv_cuda_DeviceInfo_concurrentKernels(this: *const cv_cuda_DeviceInfo) -> bool;
}
unsafe extern "C" {
    #[doc = "! device has ECC support enabled"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo10ECCEnabledEv"]
    pub fn cv_cuda_DeviceInfo_ECCEnabled(this: *const cv_cuda_DeviceInfo) -> bool;
}
unsafe extern "C" {
    #[doc = "! PCI bus ID of the device"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo8pciBusIDEv"]
    pub fn cv_cuda_DeviceInfo_pciBusID(this: *const cv_cuda_DeviceInfo) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! PCI device ID of the device"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo11pciDeviceIDEv"]
    pub fn cv_cuda_DeviceInfo_pciDeviceID(this: *const cv_cuda_DeviceInfo)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! PCI domain ID of the device"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo11pciDomainIDEv"]
    pub fn cv_cuda_DeviceInfo_pciDomainID(this: *const cv_cuda_DeviceInfo)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! true if device is a Tesla device using TCC driver, false otherwise"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo9tccDriverEv"]
    pub fn cv_cuda_DeviceInfo_tccDriver(this: *const cv_cuda_DeviceInfo) -> bool;
}
unsafe extern "C" {
    #[doc = "! number of asynchronous engines"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo16asyncEngineCountEv"]
    pub fn cv_cuda_DeviceInfo_asyncEngineCount(
        this: *const cv_cuda_DeviceInfo,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! device shares a unified address space with the host"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo17unifiedAddressingEv"]
    pub fn cv_cuda_DeviceInfo_unifiedAddressing(this: *const cv_cuda_DeviceInfo) -> bool;
}
unsafe extern "C" {
    #[doc = "! peak memory clock frequency in kilohertz"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo15memoryClockRateEv"]
    pub fn cv_cuda_DeviceInfo_memoryClockRate(
        this: *const cv_cuda_DeviceInfo,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! global memory bus width in bits"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo14memoryBusWidthEv"]
    pub fn cv_cuda_DeviceInfo_memoryBusWidth(
        this: *const cv_cuda_DeviceInfo,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! size of L2 cache in bytes"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo11l2CacheSizeEv"]
    pub fn cv_cuda_DeviceInfo_l2CacheSize(this: *const cv_cuda_DeviceInfo)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! maximum resident threads per multiprocessor"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo27maxThreadsPerMultiProcessorEv"]
    pub fn cv_cuda_DeviceInfo_maxThreadsPerMultiProcessor(
        this: *const cv_cuda_DeviceInfo,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! gets free and total device memory"]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo11queryMemoryERmS2_"]
    pub fn cv_cuda_DeviceInfo_queryMemory(
        this: *const cv_cuda_DeviceInfo,
        totalMemory: *mut usize,
        freeMemory: *mut usize,
    );
}
unsafe extern "C" {
    #[doc = " @brief Checks the CUDA module and device compatibility.\n\nThis function returns true if the CUDA module can be run on the specified device. Otherwise, it\nreturns false ."]
    #[link_name = "\u{1}_ZNK2cv4cuda10DeviceInfo12isCompatibleEv"]
    pub fn cv_cuda_DeviceInfo_isCompatible(this: *const cv_cuda_DeviceInfo) -> bool;
}
impl cv_cuda_DeviceInfo {
    #[inline]
    pub unsafe fn name(&self) -> *const ::std::os::raw::c_char {
        cv_cuda_DeviceInfo_name(self)
    }
    #[inline]
    pub unsafe fn totalGlobalMem(&self) -> usize {
        cv_cuda_DeviceInfo_totalGlobalMem(self)
    }
    #[inline]
    pub unsafe fn sharedMemPerBlock(&self) -> usize {
        cv_cuda_DeviceInfo_sharedMemPerBlock(self)
    }
    #[inline]
    pub unsafe fn regsPerBlock(&self) -> ::std::os::raw::c_int {
        cv_cuda_DeviceInfo_regsPerBlock(self)
    }
    #[inline]
    pub unsafe fn warpSize(&self) -> ::std::os::raw::c_int {
        cv_cuda_DeviceInfo_warpSize(self)
    }
    #[inline]
    pub unsafe fn memPitch(&self) -> usize {
        cv_cuda_DeviceInfo_memPitch(self)
    }
    #[inline]
    pub unsafe fn maxThreadsPerBlock(&self) -> ::std::os::raw::c_int {
        cv_cuda_DeviceInfo_maxThreadsPerBlock(self)
    }
    #[inline]
    pub unsafe fn maxThreadsDim(&self) -> cv_Vec3i {
        cv_cuda_DeviceInfo_maxThreadsDim(self)
    }
    #[inline]
    pub unsafe fn maxGridSize(&self) -> cv_Vec3i {
        cv_cuda_DeviceInfo_maxGridSize(self)
    }
    #[inline]
    pub unsafe fn clockRate(&self) -> ::std::os::raw::c_int {
        cv_cuda_DeviceInfo_clockRate(self)
    }
    #[inline]
    pub unsafe fn totalConstMem(&self) -> usize {
        cv_cuda_DeviceInfo_totalConstMem(self)
    }
    #[inline]
    pub unsafe fn majorVersion(&self) -> ::std::os::raw::c_int {
        cv_cuda_DeviceInfo_majorVersion(self)
    }
    #[inline]
    pub unsafe fn minorVersion(&self) -> ::std::os::raw::c_int {
        cv_cuda_DeviceInfo_minorVersion(self)
    }
    #[inline]
    pub unsafe fn textureAlignment(&self) -> usize {
        cv_cuda_DeviceInfo_textureAlignment(self)
    }
    #[inline]
    pub unsafe fn texturePitchAlignment(&self) -> usize {
        cv_cuda_DeviceInfo_texturePitchAlignment(self)
    }
    #[inline]
    pub unsafe fn multiProcessorCount(&self) -> ::std::os::raw::c_int {
        cv_cuda_DeviceInfo_multiProcessorCount(self)
    }
    #[inline]
    pub unsafe fn kernelExecTimeoutEnabled(&self) -> bool {
        cv_cuda_DeviceInfo_kernelExecTimeoutEnabled(self)
    }
    #[inline]
    pub unsafe fn integrated(&self) -> bool {
        cv_cuda_DeviceInfo_integrated(self)
    }
    #[inline]
    pub unsafe fn canMapHostMemory(&self) -> bool {
        cv_cuda_DeviceInfo_canMapHostMemory(self)
    }
    #[inline]
    pub unsafe fn computeMode(&self) -> cv_cuda_DeviceInfo_ComputeMode {
        cv_cuda_DeviceInfo_computeMode(self)
    }
    #[inline]
    pub unsafe fn maxTexture1D(&self) -> ::std::os::raw::c_int {
        cv_cuda_DeviceInfo_maxTexture1D(self)
    }
    #[inline]
    pub unsafe fn maxTexture1DMipmap(&self) -> ::std::os::raw::c_int {
        cv_cuda_DeviceInfo_maxTexture1DMipmap(self)
    }
    #[inline]
    pub unsafe fn maxTexture1DLinear(&self) -> ::std::os::raw::c_int {
        cv_cuda_DeviceInfo_maxTexture1DLinear(self)
    }
    #[inline]
    pub unsafe fn maxTexture2D(&self) -> cv_Vec2i {
        cv_cuda_DeviceInfo_maxTexture2D(self)
    }
    #[inline]
    pub unsafe fn maxTexture2DMipmap(&self) -> cv_Vec2i {
        cv_cuda_DeviceInfo_maxTexture2DMipmap(self)
    }
    #[inline]
    pub unsafe fn maxTexture2DLinear(&self) -> cv_Vec3i {
        cv_cuda_DeviceInfo_maxTexture2DLinear(self)
    }
    #[inline]
    pub unsafe fn maxTexture2DGather(&self) -> cv_Vec2i {
        cv_cuda_DeviceInfo_maxTexture2DGather(self)
    }
    #[inline]
    pub unsafe fn maxTexture3D(&self) -> cv_Vec3i {
        cv_cuda_DeviceInfo_maxTexture3D(self)
    }
    #[inline]
    pub unsafe fn maxTextureCubemap(&self) -> ::std::os::raw::c_int {
        cv_cuda_DeviceInfo_maxTextureCubemap(self)
    }
    #[inline]
    pub unsafe fn maxTexture1DLayered(&self) -> cv_Vec2i {
        cv_cuda_DeviceInfo_maxTexture1DLayered(self)
    }
    #[inline]
    pub unsafe fn maxTexture2DLayered(&self) -> cv_Vec3i {
        cv_cuda_DeviceInfo_maxTexture2DLayered(self)
    }
    #[inline]
    pub unsafe fn maxTextureCubemapLayered(&self) -> cv_Vec2i {
        cv_cuda_DeviceInfo_maxTextureCubemapLayered(self)
    }
    #[inline]
    pub unsafe fn maxSurface1D(&self) -> ::std::os::raw::c_int {
        cv_cuda_DeviceInfo_maxSurface1D(self)
    }
    #[inline]
    pub unsafe fn maxSurface2D(&self) -> cv_Vec2i {
        cv_cuda_DeviceInfo_maxSurface2D(self)
    }
    #[inline]
    pub unsafe fn maxSurface3D(&self) -> cv_Vec3i {
        cv_cuda_DeviceInfo_maxSurface3D(self)
    }
    #[inline]
    pub unsafe fn maxSurface1DLayered(&self) -> cv_Vec2i {
        cv_cuda_DeviceInfo_maxSurface1DLayered(self)
    }
    #[inline]
    pub unsafe fn maxSurface2DLayered(&self) -> cv_Vec3i {
        cv_cuda_DeviceInfo_maxSurface2DLayered(self)
    }
    #[inline]
    pub unsafe fn maxSurfaceCubemap(&self) -> ::std::os::raw::c_int {
        cv_cuda_DeviceInfo_maxSurfaceCubemap(self)
    }
    #[inline]
    pub unsafe fn maxSurfaceCubemapLayered(&self) -> cv_Vec2i {
        cv_cuda_DeviceInfo_maxSurfaceCubemapLayered(self)
    }
    #[inline]
    pub unsafe fn surfaceAlignment(&self) -> usize {
        cv_cuda_DeviceInfo_surfaceAlignment(self)
    }
    #[inline]
    pub unsafe fn concurrentKernels(&self) -> bool {
        cv_cuda_DeviceInfo_concurrentKernels(self)
    }
    #[inline]
    pub unsafe fn ECCEnabled(&self) -> bool {
        cv_cuda_DeviceInfo_ECCEnabled(self)
    }
    #[inline]
    pub unsafe fn pciBusID(&self) -> ::std::os::raw::c_int {
        cv_cuda_DeviceInfo_pciBusID(self)
    }
    #[inline]
    pub unsafe fn pciDeviceID(&self) -> ::std::os::raw::c_int {
        cv_cuda_DeviceInfo_pciDeviceID(self)
    }
    #[inline]
    pub unsafe fn pciDomainID(&self) -> ::std::os::raw::c_int {
        cv_cuda_DeviceInfo_pciDomainID(self)
    }
    #[inline]
    pub unsafe fn tccDriver(&self) -> bool {
        cv_cuda_DeviceInfo_tccDriver(self)
    }
    #[inline]
    pub unsafe fn asyncEngineCount(&self) -> ::std::os::raw::c_int {
        cv_cuda_DeviceInfo_asyncEngineCount(self)
    }
    #[inline]
    pub unsafe fn unifiedAddressing(&self) -> bool {
        cv_cuda_DeviceInfo_unifiedAddressing(self)
    }
    #[inline]
    pub unsafe fn memoryClockRate(&self) -> ::std::os::raw::c_int {
        cv_cuda_DeviceInfo_memoryClockRate(self)
    }
    #[inline]
    pub unsafe fn memoryBusWidth(&self) -> ::std::os::raw::c_int {
        cv_cuda_DeviceInfo_memoryBusWidth(self)
    }
    #[inline]
    pub unsafe fn l2CacheSize(&self) -> ::std::os::raw::c_int {
        cv_cuda_DeviceInfo_l2CacheSize(self)
    }
    #[inline]
    pub unsafe fn maxThreadsPerMultiProcessor(&self) -> ::std::os::raw::c_int {
        cv_cuda_DeviceInfo_maxThreadsPerMultiProcessor(self)
    }
    #[inline]
    pub unsafe fn queryMemory(&self, totalMemory: *mut usize, freeMemory: *mut usize) {
        cv_cuda_DeviceInfo_queryMemory(self, totalMemory, freeMemory)
    }
    #[inline]
    pub unsafe fn isCompatible(&self) -> bool {
        cv_cuda_DeviceInfo_isCompatible(self)
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4cuda19printCudaDeviceInfoEi"]
    pub fn cv_cuda_printCudaDeviceInfo(device: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4cuda24printShortCudaDeviceInfoEi"]
    pub fn cv_cuda_printShortCudaDeviceInfo(device: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @brief Converts an array to half precision floating number.\n\n@param _src input array.\n@param _dst output array.\n@param stream Stream for the asynchronous version.\n@sa convertFp16"]
    #[link_name = "\u{1}_ZN2cv4cuda11convertFp16ERKNS_11_InputArrayERKNS_12_OutputArrayERNS0_6StreamE"]
    pub fn cv_cuda_convertFp16(
        _src: cv_InputArray,
        _dst: cv_OutputArray,
        stream: *mut cv_cuda_Stream,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_cudev_GpuMat_ {
    pub _address: u8,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3ipp14getIppFeaturesEv"]
    pub fn cv_ipp_getIppFeatures() -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3ipp12setIppStatusEiPKcS2_i"]
    pub fn cv_ipp_setIppStatus(
        status: ::std::os::raw::c_int,
        funcname: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3ipp12getIppStatusEv"]
    pub fn cv_ipp_getIppStatus() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3ipp19getIppErrorLocationB5cxx11Ev"]
    pub fn cv_ipp_getIppErrorLocation() -> cv_String;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3ipp6useIPPEv"]
    pub fn cv_ipp_useIPP() -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3ipp9setUseIPPEb"]
    pub fn cv_ipp_setUseIPP(flag: bool);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3ipp13getIppVersionB5cxx11Ev"]
    pub fn cv_ipp_getIppVersion() -> cv_String;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3ipp15useIPP_NotExactEv"]
    pub fn cv_ipp_useIPP_NotExact() -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3ipp18setUseIPP_NotExactEb"]
    pub fn cv_ipp_setUseIPP_NotExact(flag: bool);
}
unsafe extern "C" {
    #[doc = " Returns string of cv::Mat depth value: CV_8U -> \"CV_8U\" or \"<invalid depth>\""]
    #[link_name = "\u{1}_ZN2cv13depthToStringEi"]
    pub fn cv_depthToString(depth: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns string of cv::Mat depth value: CV_8UC3 -> \"CV_8UC3\" or \"<invalid type>\""]
    #[link_name = "\u{1}_ZN2cv12typeToStringB5cxx11Ei"]
    pub fn cv_typeToString(type_: ::std::os::raw::c_int) -> cv_String;
}
unsafe extern "C" {
    #[doc = " Returns string of cv::Mat depth value: CV_8U -> \"CV_8U\" or NULL"]
    #[link_name = "\u{1}_ZN2cv6detail14depthToString_Ei"]
    pub fn cv_detail_depthToString_(depth: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns string of cv::Mat depth value: CV_8UC3 -> \"CV_8UC3\" or cv::String()"]
    #[link_name = "\u{1}_ZN2cv6detail13typeToString_B5cxx11Ei"]
    pub fn cv_detail_typeToString_(type_: ::std::os::raw::c_int) -> cv_String;
}
pub const cv_detail_TestOp_TEST_CUSTOM: cv_detail_TestOp = 0;
pub const cv_detail_TestOp_TEST_EQ: cv_detail_TestOp = 1;
pub const cv_detail_TestOp_TEST_NE: cv_detail_TestOp = 2;
pub const cv_detail_TestOp_TEST_LE: cv_detail_TestOp = 3;
pub const cv_detail_TestOp_TEST_LT: cv_detail_TestOp = 4;
pub const cv_detail_TestOp_TEST_GE: cv_detail_TestOp = 5;
pub const cv_detail_TestOp_TEST_GT: cv_detail_TestOp = 6;
pub const cv_detail_TestOp_CV__LAST_TEST_OP: cv_detail_TestOp = 7;
pub type cv_detail_TestOp = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_detail_CheckContext {
    pub func: *const ::std::os::raw::c_char,
    pub file: *const ::std::os::raw::c_char,
    pub line: ::std::os::raw::c_int,
    pub testOp: cv_detail_TestOp,
    pub message: *const ::std::os::raw::c_char,
    pub p1_str: *const ::std::os::raw::c_char,
    pub p2_str: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_CheckContext"][::std::mem::size_of::<cv_detail_CheckContext>() - 48usize];
    ["Alignment of cv_detail_CheckContext"]
        [::std::mem::align_of::<cv_detail_CheckContext>() - 8usize];
    ["Offset of field: cv_detail_CheckContext::func"]
        [::std::mem::offset_of!(cv_detail_CheckContext, func) - 0usize];
    ["Offset of field: cv_detail_CheckContext::file"]
        [::std::mem::offset_of!(cv_detail_CheckContext, file) - 8usize];
    ["Offset of field: cv_detail_CheckContext::line"]
        [::std::mem::offset_of!(cv_detail_CheckContext, line) - 16usize];
    ["Offset of field: cv_detail_CheckContext::testOp"]
        [::std::mem::offset_of!(cv_detail_CheckContext, testOp) - 20usize];
    ["Offset of field: cv_detail_CheckContext::message"]
        [::std::mem::offset_of!(cv_detail_CheckContext, message) - 24usize];
    ["Offset of field: cv_detail_CheckContext::p1_str"]
        [::std::mem::offset_of!(cv_detail_CheckContext, p1_str) - 32usize];
    ["Offset of field: cv_detail_CheckContext::p2_str"]
        [::std::mem::offset_of!(cv_detail_CheckContext, p2_str) - 40usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail17check_failed_autoEiiRKNS0_12CheckContextE"]
    pub fn cv_detail_check_failed_auto(
        v1: ::std::os::raw::c_int,
        v2: ::std::os::raw::c_int,
        ctx: *const cv_detail_CheckContext,
    ) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail17check_failed_autoEmmRKNS0_12CheckContextE"]
    pub fn cv_detail_check_failed_auto1(
        v1: usize,
        v2: usize,
        ctx: *const cv_detail_CheckContext,
    ) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail17check_failed_autoEffRKNS0_12CheckContextE"]
    pub fn cv_detail_check_failed_auto2(v1: f32, v2: f32, ctx: *const cv_detail_CheckContext) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail17check_failed_autoEddRKNS0_12CheckContextE"]
    pub fn cv_detail_check_failed_auto3(v1: f64, v2: f64, ctx: *const cv_detail_CheckContext) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail17check_failed_autoENS_5Size_IiEES2_RKNS0_12CheckContextE"]
    pub fn cv_detail_check_failed_auto4(
        v1: cv_Size_<::std::os::raw::c_int>,
        v2: cv_Size_<::std::os::raw::c_int>,
        ctx: *const cv_detail_CheckContext,
    ) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail21check_failed_MatDepthEiiRKNS0_12CheckContextE"]
    pub fn cv_detail_check_failed_MatDepth(
        v1: ::std::os::raw::c_int,
        v2: ::std::os::raw::c_int,
        ctx: *const cv_detail_CheckContext,
    ) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail20check_failed_MatTypeEiiRKNS0_12CheckContextE"]
    pub fn cv_detail_check_failed_MatType(
        v1: ::std::os::raw::c_int,
        v2: ::std::os::raw::c_int,
        ctx: *const cv_detail_CheckContext,
    ) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail24check_failed_MatChannelsEiiRKNS0_12CheckContextE"]
    pub fn cv_detail_check_failed_MatChannels(
        v1: ::std::os::raw::c_int,
        v2: ::std::os::raw::c_int,
        ctx: *const cv_detail_CheckContext,
    ) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail17check_failed_autoEiRKNS0_12CheckContextE"]
    pub fn cv_detail_check_failed_auto5(
        v: ::std::os::raw::c_int,
        ctx: *const cv_detail_CheckContext,
    ) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail17check_failed_autoEmRKNS0_12CheckContextE"]
    pub fn cv_detail_check_failed_auto6(v: usize, ctx: *const cv_detail_CheckContext) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail17check_failed_autoEfRKNS0_12CheckContextE"]
    pub fn cv_detail_check_failed_auto7(v: f32, ctx: *const cv_detail_CheckContext) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail17check_failed_autoEdRKNS0_12CheckContextE"]
    pub fn cv_detail_check_failed_auto8(v: f64, ctx: *const cv_detail_CheckContext) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail17check_failed_autoENS_5Size_IiEERKNS0_12CheckContextE"]
    pub fn cv_detail_check_failed_auto9(
        v: cv_Size_<::std::os::raw::c_int>,
        ctx: *const cv_detail_CheckContext,
    ) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail21check_failed_MatDepthEiRKNS0_12CheckContextE"]
    pub fn cv_detail_check_failed_MatDepth1(
        v: ::std::os::raw::c_int,
        ctx: *const cv_detail_CheckContext,
    ) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail20check_failed_MatTypeEiRKNS0_12CheckContextE"]
    pub fn cv_detail_check_failed_MatType1(
        v: ::std::os::raw::c_int,
        ctx: *const cv_detail_CheckContext,
    ) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail24check_failed_MatChannelsEiRKNS0_12CheckContextE"]
    pub fn cv_detail_check_failed_MatChannels1(
        v: ::std::os::raw::c_int,
        ctx: *const cv_detail_CheckContext,
    ) -> !;
}
#[repr(C)]
pub struct cv_detail_RotationWarper__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief Rotation-only model image warper interface."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_RotationWarper {
    pub vtable_: *const cv_detail_RotationWarper__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_RotationWarper"]
        [::std::mem::size_of::<cv_detail_RotationWarper>() - 8usize];
    ["Alignment of cv_detail_RotationWarper"]
        [::std::mem::align_of::<cv_detail_RotationWarper>() - 8usize];
};
#[doc = " @brief Base class for warping logic implementation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_detail_ProjectorBase {
    pub scale: f32,
    pub k: [f32; 9usize],
    pub rinv: [f32; 9usize],
    pub r_kinv: [f32; 9usize],
    pub k_rinv: [f32; 9usize],
    pub t: [f32; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_ProjectorBase"]
        [::std::mem::size_of::<cv_detail_ProjectorBase>() - 160usize];
    ["Alignment of cv_detail_ProjectorBase"]
        [::std::mem::align_of::<cv_detail_ProjectorBase>() - 4usize];
    ["Offset of field: cv_detail_ProjectorBase::scale"]
        [::std::mem::offset_of!(cv_detail_ProjectorBase, scale) - 0usize];
    ["Offset of field: cv_detail_ProjectorBase::k"]
        [::std::mem::offset_of!(cv_detail_ProjectorBase, k) - 4usize];
    ["Offset of field: cv_detail_ProjectorBase::rinv"]
        [::std::mem::offset_of!(cv_detail_ProjectorBase, rinv) - 40usize];
    ["Offset of field: cv_detail_ProjectorBase::r_kinv"]
        [::std::mem::offset_of!(cv_detail_ProjectorBase, r_kinv) - 76usize];
    ["Offset of field: cv_detail_ProjectorBase::k_rinv"]
        [::std::mem::offset_of!(cv_detail_ProjectorBase, k_rinv) - 112usize];
    ["Offset of field: cv_detail_ProjectorBase::t"]
        [::std::mem::offset_of!(cv_detail_ProjectorBase, t) - 148usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail13ProjectorBase15setCameraParamsERKNS_11_InputArrayES4_S4_"]
    pub fn cv_detail_ProjectorBase_setCameraParams(
        this: *mut cv_detail_ProjectorBase,
        K: cv_InputArray,
        R: cv_InputArray,
        T: cv_InputArray,
    );
}
impl cv_detail_ProjectorBase {
    #[inline]
    pub unsafe fn setCameraParams(&mut self, K: cv_InputArray, R: cv_InputArray, T: cv_InputArray) {
        cv_detail_ProjectorBase_setCameraParams(self, K, R, T)
    }
}
#[doc = " @brief Base class for rotation-based warper using a detail::ProjectorBase_ derived class."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_RotationWarperBase<P> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<P>>,
    pub _base: cv_detail_RotationWarper,
    pub projector_: P,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_detail_PlaneProjector {
    pub _base: cv_detail_ProjectorBase,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_PlaneProjector"]
        [::std::mem::size_of::<cv_detail_PlaneProjector>() - 160usize];
    ["Alignment of cv_detail_PlaneProjector"]
        [::std::mem::align_of::<cv_detail_PlaneProjector>() - 4usize];
};
#[doc = " @brief Warper that maps an image onto the z = 1 plane."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_PlaneWarper {
    pub _base: cv_detail_RotationWarperBase<cv_detail_PlaneProjector>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_PlaneWarper"][::std::mem::size_of::<cv_detail_PlaneWarper>() - 168usize];
    ["Alignment of cv_detail_PlaneWarper"]
        [::std::mem::align_of::<cv_detail_PlaneWarper>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail11PlaneWarper9warpPointERKNS_6Point_IfEERKNS_11_InputArrayES8_S8_"]
    pub fn cv_detail_PlaneWarper_warpPoint1(
        this: *mut cv_detail_PlaneWarper,
        pt: *const cv_Point2f,
        K: cv_InputArray,
        R: cv_InputArray,
        T: cv_InputArray,
    ) -> cv_Point2f;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail11PlaneWarper7warpRoiENS_5Size_IiEERKNS_11_InputArrayES6_S6_"]
    pub fn cv_detail_PlaneWarper_warpRoi1(
        this: *mut cv_detail_PlaneWarper,
        src_size: cv_Size,
        K: cv_InputArray,
        R: cv_InputArray,
        T: cv_InputArray,
    ) -> cv_Rect;
}
impl cv_detail_PlaneWarper {
    #[inline]
    pub unsafe fn warpPoint(
        &mut self,
        pt: *const cv_Point2f,
        K: cv_InputArray,
        R: cv_InputArray,
        T: cv_InputArray,
    ) -> cv_Point2f {
        cv_detail_PlaneWarper_warpPoint1(self, pt, K, R, T)
    }
    #[inline]
    pub unsafe fn warpRoi(
        &mut self,
        src_size: cv_Size,
        K: cv_InputArray,
        R: cv_InputArray,
        T: cv_InputArray,
    ) -> cv_Rect {
        cv_detail_PlaneWarper_warpRoi1(self, src_size, K, R, T)
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail11PlaneWarper9warpPointERKNS_6Point_IfEERKNS_11_InputArrayES8_"]
    pub fn cv_detail_PlaneWarper_warpPoint(
        this: *mut ::std::os::raw::c_void,
        pt: *const cv_Point2f,
        K: cv_InputArray,
        R: cv_InputArray,
    ) -> cv_Point2f;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail11PlaneWarper9buildMapsENS_5Size_IiEERKNS_11_InputArrayES6_S6_RKNS_12_OutputArrayES9_"]
    pub fn cv_detail_PlaneWarper_buildMaps(
        this: *mut ::std::os::raw::c_void,
        src_size: cv_Size,
        K: cv_InputArray,
        R: cv_InputArray,
        T: cv_InputArray,
        xmap: cv_OutputArray,
        ymap: cv_OutputArray,
    ) -> cv_Rect;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail11PlaneWarper9buildMapsENS_5Size_IiEERKNS_11_InputArrayES6_RKNS_12_OutputArrayES9_"]
    pub fn cv_detail_PlaneWarper_buildMaps1(
        this: *mut ::std::os::raw::c_void,
        src_size: cv_Size,
        K: cv_InputArray,
        R: cv_InputArray,
        xmap: cv_OutputArray,
        ymap: cv_OutputArray,
    ) -> cv_Rect;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail11PlaneWarper4warpERKNS_11_InputArrayES4_S4_iiRKNS_12_OutputArrayE"]
    pub fn cv_detail_PlaneWarper_warp(
        this: *mut ::std::os::raw::c_void,
        src: cv_InputArray,
        K: cv_InputArray,
        R: cv_InputArray,
        interp_mode: ::std::os::raw::c_int,
        border_mode: ::std::os::raw::c_int,
        dst: cv_OutputArray,
    ) -> cv_Point;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail11PlaneWarper4warpERKNS_11_InputArrayES4_S4_S4_iiRKNS_12_OutputArrayE"]
    pub fn cv_detail_PlaneWarper_warp1(
        this: *mut ::std::os::raw::c_void,
        src: cv_InputArray,
        K: cv_InputArray,
        R: cv_InputArray,
        T: cv_InputArray,
        interp_mode: ::std::os::raw::c_int,
        border_mode: ::std::os::raw::c_int,
        dst: cv_OutputArray,
    ) -> cv_Point;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail11PlaneWarper7warpRoiENS_5Size_IiEERKNS_11_InputArrayES6_"]
    pub fn cv_detail_PlaneWarper_warpRoi(
        this: *mut ::std::os::raw::c_void,
        src_size: cv_Size,
        K: cv_InputArray,
        R: cv_InputArray,
    ) -> cv_Rect;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail11PlaneWarper15detectResultRoiENS_5Size_IiEERNS_6Point_IiEES6_"]
    pub fn cv_detail_PlaneWarper_detectResultRoi(
        this: *mut ::std::os::raw::c_void,
        src_size: cv_Size,
        dst_tl: *mut cv_Point,
        dst_br: *mut cv_Point,
    );
}
#[doc = " @brief Affine warper that uses rotations and translations\n\nUses affine transformation in homogeneous coordinates to represent both rotation and\ntranslation in camera rotation matrix."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_AffineWarper {
    pub _base: cv_detail_PlaneWarper,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_AffineWarper"][::std::mem::size_of::<cv_detail_AffineWarper>() - 168usize];
    ["Alignment of cv_detail_AffineWarper"]
        [::std::mem::align_of::<cv_detail_AffineWarper>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Extracts rotation and translation matrices from matrix H representing\naffine transformation in homogeneous coordinates"]
    #[link_name = "\u{1}_ZN2cv6detail12AffineWarper20getRTfromHomogeneousERKNS_11_InputArrayERNS_3MatES6_"]
    pub fn cv_detail_AffineWarper_getRTfromHomogeneous(
        this: *mut cv_detail_AffineWarper,
        H: cv_InputArray,
        R: *mut cv_Mat,
        T: *mut cv_Mat,
    );
}
impl cv_detail_AffineWarper {
    #[inline]
    pub unsafe fn getRTfromHomogeneous(
        &mut self,
        H: cv_InputArray,
        R: *mut cv_Mat,
        T: *mut cv_Mat,
    ) {
        cv_detail_AffineWarper_getRTfromHomogeneous(self, H, R, T)
    }
}
unsafe extern "C" {
    #[doc = " @brief Projects the image point.\n\n@param pt Source point\n@param K Camera intrinsic parameters\n@param H Camera extrinsic parameters\n@return Projected point"]
    #[link_name = "\u{1}_ZN2cv6detail12AffineWarper9warpPointERKNS_6Point_IfEERKNS_11_InputArrayES8_"]
    pub fn cv_detail_AffineWarper_warpPoint(
        this: *mut ::std::os::raw::c_void,
        pt: *const cv_Point2f,
        K: cv_InputArray,
        H: cv_InputArray,
    ) -> cv_Point2f;
}
unsafe extern "C" {
    #[doc = " @brief Builds the projection maps according to the given camera data.\n\n@param src_size Source image size\n@param K Camera intrinsic parameters\n@param H Camera extrinsic parameters\n@param xmap Projection map for the x axis\n@param ymap Projection map for the y axis\n@return Projected image minimum bounding box"]
    #[link_name = "\u{1}_ZN2cv6detail12AffineWarper9buildMapsENS_5Size_IiEERKNS_11_InputArrayES6_RKNS_12_OutputArrayES9_"]
    pub fn cv_detail_AffineWarper_buildMaps(
        this: *mut ::std::os::raw::c_void,
        src_size: cv_Size,
        K: cv_InputArray,
        H: cv_InputArray,
        xmap: cv_OutputArray,
        ymap: cv_OutputArray,
    ) -> cv_Rect;
}
unsafe extern "C" {
    #[doc = " @brief Projects the image.\n\n@param src Source image\n@param K Camera intrinsic parameters\n@param H Camera extrinsic parameters\n@param interp_mode Interpolation mode\n@param border_mode Border extrapolation mode\n@param dst Projected image\n@return Project image top-left corner"]
    #[link_name = "\u{1}_ZN2cv6detail12AffineWarper4warpERKNS_11_InputArrayES4_S4_iiRKNS_12_OutputArrayE"]
    pub fn cv_detail_AffineWarper_warp(
        this: *mut ::std::os::raw::c_void,
        src: cv_InputArray,
        K: cv_InputArray,
        H: cv_InputArray,
        interp_mode: ::std::os::raw::c_int,
        border_mode: ::std::os::raw::c_int,
        dst: cv_OutputArray,
    ) -> cv_Point;
}
unsafe extern "C" {
    #[doc = "@param src_size Source image bounding box\n@param K Camera intrinsic parameters\n@param H Camera extrinsic parameters\n@return Projected image minimum bounding box"]
    #[link_name = "\u{1}_ZN2cv6detail12AffineWarper7warpRoiENS_5Size_IiEERKNS_11_InputArrayES6_"]
    pub fn cv_detail_AffineWarper_warpRoi(
        this: *mut ::std::os::raw::c_void,
        src_size: cv_Size,
        K: cv_InputArray,
        H: cv_InputArray,
    ) -> cv_Rect;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_detail_SphericalProjector {
    pub _base: cv_detail_ProjectorBase,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_SphericalProjector"]
        [::std::mem::size_of::<cv_detail_SphericalProjector>() - 160usize];
    ["Alignment of cv_detail_SphericalProjector"]
        [::std::mem::align_of::<cv_detail_SphericalProjector>() - 4usize];
};
#[doc = " @brief Warper that maps an image onto the unit sphere located at the origin.\n\nProjects image onto unit sphere with origin at (0, 0, 0) and radius scale, measured in pixels.\nA 360 panorama would therefore have a resulting width of 2 * scale * PI pixels.\nPoles are located at (0, -1, 0) and (0, 1, 0) points."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_SphericalWarper {
    pub _base: cv_detail_RotationWarperBase<cv_detail_SphericalProjector>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_SphericalWarper"]
        [::std::mem::size_of::<cv_detail_SphericalWarper>() - 168usize];
    ["Alignment of cv_detail_SphericalWarper"]
        [::std::mem::align_of::<cv_detail_SphericalWarper>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail15SphericalWarper9buildMapsENS_5Size_IiEERKNS_11_InputArrayES6_RKNS_12_OutputArrayES9_"]
    pub fn cv_detail_SphericalWarper_buildMaps(
        this: *mut ::std::os::raw::c_void,
        src_size: cv_Size,
        K: cv_InputArray,
        R: cv_InputArray,
        xmap: cv_OutputArray,
        ymap: cv_OutputArray,
    ) -> cv_Rect;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail15SphericalWarper4warpERKNS_11_InputArrayES4_S4_iiRKNS_12_OutputArrayE"]
    pub fn cv_detail_SphericalWarper_warp(
        this: *mut ::std::os::raw::c_void,
        src: cv_InputArray,
        K: cv_InputArray,
        R: cv_InputArray,
        interp_mode: ::std::os::raw::c_int,
        border_mode: ::std::os::raw::c_int,
        dst: cv_OutputArray,
    ) -> cv_Point;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail15SphericalWarper15detectResultRoiENS_5Size_IiEERNS_6Point_IiEES6_"]
    pub fn cv_detail_SphericalWarper_detectResultRoi(
        this: *mut ::std::os::raw::c_void,
        src_size: cv_Size,
        dst_tl: *mut cv_Point,
        dst_br: *mut cv_Point,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_detail_CylindricalProjector {
    pub _base: cv_detail_ProjectorBase,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_CylindricalProjector"]
        [::std::mem::size_of::<cv_detail_CylindricalProjector>() - 160usize];
    ["Alignment of cv_detail_CylindricalProjector"]
        [::std::mem::align_of::<cv_detail_CylindricalProjector>() - 4usize];
};
#[doc = " @brief Warper that maps an image onto the x\\*x + z\\*z = 1 cylinder."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_CylindricalWarper {
    pub _base: cv_detail_RotationWarperBase<cv_detail_CylindricalProjector>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_CylindricalWarper"]
        [::std::mem::size_of::<cv_detail_CylindricalWarper>() - 168usize];
    ["Alignment of cv_detail_CylindricalWarper"]
        [::std::mem::align_of::<cv_detail_CylindricalWarper>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail17CylindricalWarper9buildMapsENS_5Size_IiEERKNS_11_InputArrayES6_RKNS_12_OutputArrayES9_"]
    pub fn cv_detail_CylindricalWarper_buildMaps(
        this: *mut ::std::os::raw::c_void,
        src_size: cv_Size,
        K: cv_InputArray,
        R: cv_InputArray,
        xmap: cv_OutputArray,
        ymap: cv_OutputArray,
    ) -> cv_Rect;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail17CylindricalWarper4warpERKNS_11_InputArrayES4_S4_iiRKNS_12_OutputArrayE"]
    pub fn cv_detail_CylindricalWarper_warp(
        this: *mut ::std::os::raw::c_void,
        src: cv_InputArray,
        K: cv_InputArray,
        R: cv_InputArray,
        interp_mode: ::std::os::raw::c_int,
        border_mode: ::std::os::raw::c_int,
        dst: cv_OutputArray,
    ) -> cv_Point;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_detail_FisheyeProjector {
    pub _base: cv_detail_ProjectorBase,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_FisheyeProjector"]
        [::std::mem::size_of::<cv_detail_FisheyeProjector>() - 160usize];
    ["Alignment of cv_detail_FisheyeProjector"]
        [::std::mem::align_of::<cv_detail_FisheyeProjector>() - 4usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_FisheyeWarper {
    pub _base: cv_detail_RotationWarperBase<cv_detail_FisheyeProjector>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_FisheyeWarper"]
        [::std::mem::size_of::<cv_detail_FisheyeWarper>() - 168usize];
    ["Alignment of cv_detail_FisheyeWarper"]
        [::std::mem::align_of::<cv_detail_FisheyeWarper>() - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_detail_StereographicProjector {
    pub _base: cv_detail_ProjectorBase,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_StereographicProjector"]
        [::std::mem::size_of::<cv_detail_StereographicProjector>() - 160usize];
    ["Alignment of cv_detail_StereographicProjector"]
        [::std::mem::align_of::<cv_detail_StereographicProjector>() - 4usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_StereographicWarper {
    pub _base: cv_detail_RotationWarperBase<cv_detail_StereographicProjector>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_StereographicWarper"]
        [::std::mem::size_of::<cv_detail_StereographicWarper>() - 168usize];
    ["Alignment of cv_detail_StereographicWarper"]
        [::std::mem::align_of::<cv_detail_StereographicWarper>() - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_detail_CompressedRectilinearProjector {
    pub _base: cv_detail_ProjectorBase,
    pub a: f32,
    pub b: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_CompressedRectilinearProjector"]
        [::std::mem::size_of::<cv_detail_CompressedRectilinearProjector>() - 168usize];
    ["Alignment of cv_detail_CompressedRectilinearProjector"]
        [::std::mem::align_of::<cv_detail_CompressedRectilinearProjector>() - 4usize];
    ["Offset of field: cv_detail_CompressedRectilinearProjector::a"]
        [::std::mem::offset_of!(cv_detail_CompressedRectilinearProjector, a) - 160usize];
    ["Offset of field: cv_detail_CompressedRectilinearProjector::b"]
        [::std::mem::offset_of!(cv_detail_CompressedRectilinearProjector, b) - 164usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_CompressedRectilinearWarper {
    pub _base: cv_detail_RotationWarperBase<cv_detail_CompressedRectilinearProjector>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_CompressedRectilinearWarper"]
        [::std::mem::size_of::<cv_detail_CompressedRectilinearWarper>() - 176usize];
    ["Alignment of cv_detail_CompressedRectilinearWarper"]
        [::std::mem::align_of::<cv_detail_CompressedRectilinearWarper>() - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_detail_CompressedRectilinearPortraitProjector {
    pub _base: cv_detail_ProjectorBase,
    pub a: f32,
    pub b: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_CompressedRectilinearPortraitProjector"]
        [::std::mem::size_of::<cv_detail_CompressedRectilinearPortraitProjector>() - 168usize];
    ["Alignment of cv_detail_CompressedRectilinearPortraitProjector"]
        [::std::mem::align_of::<cv_detail_CompressedRectilinearPortraitProjector>() - 4usize];
    ["Offset of field: cv_detail_CompressedRectilinearPortraitProjector::a"]
        [::std::mem::offset_of!(cv_detail_CompressedRectilinearPortraitProjector, a) - 160usize];
    ["Offset of field: cv_detail_CompressedRectilinearPortraitProjector::b"]
        [::std::mem::offset_of!(cv_detail_CompressedRectilinearPortraitProjector, b) - 164usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_CompressedRectilinearPortraitWarper {
    pub _base: cv_detail_RotationWarperBase<cv_detail_CompressedRectilinearPortraitProjector>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_CompressedRectilinearPortraitWarper"]
        [::std::mem::size_of::<cv_detail_CompressedRectilinearPortraitWarper>() - 176usize];
    ["Alignment of cv_detail_CompressedRectilinearPortraitWarper"]
        [::std::mem::align_of::<cv_detail_CompressedRectilinearPortraitWarper>() - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_detail_PaniniProjector {
    pub _base: cv_detail_ProjectorBase,
    pub a: f32,
    pub b: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_PaniniProjector"]
        [::std::mem::size_of::<cv_detail_PaniniProjector>() - 168usize];
    ["Alignment of cv_detail_PaniniProjector"]
        [::std::mem::align_of::<cv_detail_PaniniProjector>() - 4usize];
    ["Offset of field: cv_detail_PaniniProjector::a"]
        [::std::mem::offset_of!(cv_detail_PaniniProjector, a) - 160usize];
    ["Offset of field: cv_detail_PaniniProjector::b"]
        [::std::mem::offset_of!(cv_detail_PaniniProjector, b) - 164usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_PaniniWarper {
    pub _base: cv_detail_RotationWarperBase<cv_detail_PaniniProjector>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_PaniniWarper"][::std::mem::size_of::<cv_detail_PaniniWarper>() - 176usize];
    ["Alignment of cv_detail_PaniniWarper"]
        [::std::mem::align_of::<cv_detail_PaniniWarper>() - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_detail_PaniniPortraitProjector {
    pub _base: cv_detail_ProjectorBase,
    pub a: f32,
    pub b: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_PaniniPortraitProjector"]
        [::std::mem::size_of::<cv_detail_PaniniPortraitProjector>() - 168usize];
    ["Alignment of cv_detail_PaniniPortraitProjector"]
        [::std::mem::align_of::<cv_detail_PaniniPortraitProjector>() - 4usize];
    ["Offset of field: cv_detail_PaniniPortraitProjector::a"]
        [::std::mem::offset_of!(cv_detail_PaniniPortraitProjector, a) - 160usize];
    ["Offset of field: cv_detail_PaniniPortraitProjector::b"]
        [::std::mem::offset_of!(cv_detail_PaniniPortraitProjector, b) - 164usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_PaniniPortraitWarper {
    pub _base: cv_detail_RotationWarperBase<cv_detail_PaniniPortraitProjector>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_PaniniPortraitWarper"]
        [::std::mem::size_of::<cv_detail_PaniniPortraitWarper>() - 176usize];
    ["Alignment of cv_detail_PaniniPortraitWarper"]
        [::std::mem::align_of::<cv_detail_PaniniPortraitWarper>() - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_detail_MercatorProjector {
    pub _base: cv_detail_ProjectorBase,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_MercatorProjector"]
        [::std::mem::size_of::<cv_detail_MercatorProjector>() - 160usize];
    ["Alignment of cv_detail_MercatorProjector"]
        [::std::mem::align_of::<cv_detail_MercatorProjector>() - 4usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_MercatorWarper {
    pub _base: cv_detail_RotationWarperBase<cv_detail_MercatorProjector>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_MercatorWarper"]
        [::std::mem::size_of::<cv_detail_MercatorWarper>() - 168usize];
    ["Alignment of cv_detail_MercatorWarper"]
        [::std::mem::align_of::<cv_detail_MercatorWarper>() - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_detail_TransverseMercatorProjector {
    pub _base: cv_detail_ProjectorBase,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_TransverseMercatorProjector"]
        [::std::mem::size_of::<cv_detail_TransverseMercatorProjector>() - 160usize];
    ["Alignment of cv_detail_TransverseMercatorProjector"]
        [::std::mem::align_of::<cv_detail_TransverseMercatorProjector>() - 4usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_TransverseMercatorWarper {
    pub _base: cv_detail_RotationWarperBase<cv_detail_TransverseMercatorProjector>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_TransverseMercatorWarper"]
        [::std::mem::size_of::<cv_detail_TransverseMercatorWarper>() - 168usize];
    ["Alignment of cv_detail_TransverseMercatorWarper"]
        [::std::mem::align_of::<cv_detail_TransverseMercatorWarper>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_PlaneWarperGpu {
    pub _base: cv_detail_PlaneWarper,
    pub d_xmap_: cv_cuda_GpuMat,
    pub d_ymap_: cv_cuda_GpuMat,
    pub d_src_: cv_cuda_GpuMat,
    pub d_dst_: cv_cuda_GpuMat,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_PlaneWarperGpu"]
        [::std::mem::size_of::<cv_detail_PlaneWarperGpu>() - 424usize];
    ["Alignment of cv_detail_PlaneWarperGpu"]
        [::std::mem::align_of::<cv_detail_PlaneWarperGpu>() - 8usize];
    ["Offset of field: cv_detail_PlaneWarperGpu::d_xmap_"]
        [::std::mem::offset_of!(cv_detail_PlaneWarperGpu, d_xmap_) - 168usize];
    ["Offset of field: cv_detail_PlaneWarperGpu::d_ymap_"]
        [::std::mem::offset_of!(cv_detail_PlaneWarperGpu, d_ymap_) - 232usize];
    ["Offset of field: cv_detail_PlaneWarperGpu::d_src_"]
        [::std::mem::offset_of!(cv_detail_PlaneWarperGpu, d_src_) - 296usize];
    ["Offset of field: cv_detail_PlaneWarperGpu::d_dst_"]
        [::std::mem::offset_of!(cv_detail_PlaneWarperGpu, d_dst_) - 360usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail14PlaneWarperGpu9buildMapsENS_5Size_IiEERKNS_11_InputArrayES6_RNS_4cuda6GpuMatES9_"]
    pub fn cv_detail_PlaneWarperGpu_buildMaps(
        this: *mut cv_detail_PlaneWarperGpu,
        src_size: cv_Size,
        K: cv_InputArray,
        R: cv_InputArray,
        xmap: *mut cv_cuda_GpuMat,
        ymap: *mut cv_cuda_GpuMat,
    ) -> cv_Rect;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail14PlaneWarperGpu9buildMapsENS_5Size_IiEERKNS_11_InputArrayES6_S6_RNS_4cuda6GpuMatES9_"]
    pub fn cv_detail_PlaneWarperGpu_buildMaps1(
        this: *mut cv_detail_PlaneWarperGpu,
        src_size: cv_Size,
        K: cv_InputArray,
        R: cv_InputArray,
        T: cv_InputArray,
        xmap: *mut cv_cuda_GpuMat,
        ymap: *mut cv_cuda_GpuMat,
    ) -> cv_Rect;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail14PlaneWarperGpu4warpERKNS_4cuda6GpuMatERKNS_11_InputArrayES8_iiRS3_"]
    pub fn cv_detail_PlaneWarperGpu_warp(
        this: *mut cv_detail_PlaneWarperGpu,
        src: *const cv_cuda_GpuMat,
        K: cv_InputArray,
        R: cv_InputArray,
        interp_mode: ::std::os::raw::c_int,
        border_mode: ::std::os::raw::c_int,
        dst: *mut cv_cuda_GpuMat,
    ) -> cv_Point;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail14PlaneWarperGpu4warpERKNS_4cuda6GpuMatERKNS_11_InputArrayES8_S8_iiRS3_"]
    pub fn cv_detail_PlaneWarperGpu_warp1(
        this: *mut cv_detail_PlaneWarperGpu,
        src: *const cv_cuda_GpuMat,
        K: cv_InputArray,
        R: cv_InputArray,
        T: cv_InputArray,
        interp_mode: ::std::os::raw::c_int,
        border_mode: ::std::os::raw::c_int,
        dst: *mut cv_cuda_GpuMat,
    ) -> cv_Point;
}
impl cv_detail_PlaneWarperGpu {
    #[inline]
    pub unsafe fn buildMaps(
        &mut self,
        src_size: cv_Size,
        K: cv_InputArray,
        R: cv_InputArray,
        xmap: *mut cv_cuda_GpuMat,
        ymap: *mut cv_cuda_GpuMat,
    ) -> cv_Rect {
        cv_detail_PlaneWarperGpu_buildMaps(self, src_size, K, R, xmap, ymap)
    }
    #[inline]
    pub unsafe fn buildMaps1(
        &mut self,
        src_size: cv_Size,
        K: cv_InputArray,
        R: cv_InputArray,
        T: cv_InputArray,
        xmap: *mut cv_cuda_GpuMat,
        ymap: *mut cv_cuda_GpuMat,
    ) -> cv_Rect {
        cv_detail_PlaneWarperGpu_buildMaps1(self, src_size, K, R, T, xmap, ymap)
    }
    #[inline]
    pub unsafe fn warp(
        &mut self,
        src: *const cv_cuda_GpuMat,
        K: cv_InputArray,
        R: cv_InputArray,
        interp_mode: ::std::os::raw::c_int,
        border_mode: ::std::os::raw::c_int,
        dst: *mut cv_cuda_GpuMat,
    ) -> cv_Point {
        cv_detail_PlaneWarperGpu_warp(self, src, K, R, interp_mode, border_mode, dst)
    }
    #[inline]
    pub unsafe fn warp1(
        &mut self,
        src: *const cv_cuda_GpuMat,
        K: cv_InputArray,
        R: cv_InputArray,
        T: cv_InputArray,
        interp_mode: ::std::os::raw::c_int,
        border_mode: ::std::os::raw::c_int,
        dst: *mut cv_cuda_GpuMat,
    ) -> cv_Point {
        cv_detail_PlaneWarperGpu_warp1(self, src, K, R, T, interp_mode, border_mode, dst)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_SphericalWarperGpu {
    pub _base: cv_detail_SphericalWarper,
    pub d_xmap_: cv_cuda_GpuMat,
    pub d_ymap_: cv_cuda_GpuMat,
    pub d_src_: cv_cuda_GpuMat,
    pub d_dst_: cv_cuda_GpuMat,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_SphericalWarperGpu"]
        [::std::mem::size_of::<cv_detail_SphericalWarperGpu>() - 424usize];
    ["Alignment of cv_detail_SphericalWarperGpu"]
        [::std::mem::align_of::<cv_detail_SphericalWarperGpu>() - 8usize];
    ["Offset of field: cv_detail_SphericalWarperGpu::d_xmap_"]
        [::std::mem::offset_of!(cv_detail_SphericalWarperGpu, d_xmap_) - 168usize];
    ["Offset of field: cv_detail_SphericalWarperGpu::d_ymap_"]
        [::std::mem::offset_of!(cv_detail_SphericalWarperGpu, d_ymap_) - 232usize];
    ["Offset of field: cv_detail_SphericalWarperGpu::d_src_"]
        [::std::mem::offset_of!(cv_detail_SphericalWarperGpu, d_src_) - 296usize];
    ["Offset of field: cv_detail_SphericalWarperGpu::d_dst_"]
        [::std::mem::offset_of!(cv_detail_SphericalWarperGpu, d_dst_) - 360usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail18SphericalWarperGpu9buildMapsENS_5Size_IiEERKNS_11_InputArrayES6_RNS_4cuda6GpuMatES9_"]
    pub fn cv_detail_SphericalWarperGpu_buildMaps(
        this: *mut cv_detail_SphericalWarperGpu,
        src_size: cv_Size,
        K: cv_InputArray,
        R: cv_InputArray,
        xmap: *mut cv_cuda_GpuMat,
        ymap: *mut cv_cuda_GpuMat,
    ) -> cv_Rect;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail18SphericalWarperGpu4warpERKNS_4cuda6GpuMatERKNS_11_InputArrayES8_iiRS3_"]
    pub fn cv_detail_SphericalWarperGpu_warp(
        this: *mut cv_detail_SphericalWarperGpu,
        src: *const cv_cuda_GpuMat,
        K: cv_InputArray,
        R: cv_InputArray,
        interp_mode: ::std::os::raw::c_int,
        border_mode: ::std::os::raw::c_int,
        dst: *mut cv_cuda_GpuMat,
    ) -> cv_Point;
}
impl cv_detail_SphericalWarperGpu {
    #[inline]
    pub unsafe fn buildMaps(
        &mut self,
        src_size: cv_Size,
        K: cv_InputArray,
        R: cv_InputArray,
        xmap: *mut cv_cuda_GpuMat,
        ymap: *mut cv_cuda_GpuMat,
    ) -> cv_Rect {
        cv_detail_SphericalWarperGpu_buildMaps(self, src_size, K, R, xmap, ymap)
    }
    #[inline]
    pub unsafe fn warp(
        &mut self,
        src: *const cv_cuda_GpuMat,
        K: cv_InputArray,
        R: cv_InputArray,
        interp_mode: ::std::os::raw::c_int,
        border_mode: ::std::os::raw::c_int,
        dst: *mut cv_cuda_GpuMat,
    ) -> cv_Point {
        cv_detail_SphericalWarperGpu_warp(self, src, K, R, interp_mode, border_mode, dst)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_CylindricalWarperGpu {
    pub _base: cv_detail_CylindricalWarper,
    pub d_xmap_: cv_cuda_GpuMat,
    pub d_ymap_: cv_cuda_GpuMat,
    pub d_src_: cv_cuda_GpuMat,
    pub d_dst_: cv_cuda_GpuMat,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_CylindricalWarperGpu"]
        [::std::mem::size_of::<cv_detail_CylindricalWarperGpu>() - 424usize];
    ["Alignment of cv_detail_CylindricalWarperGpu"]
        [::std::mem::align_of::<cv_detail_CylindricalWarperGpu>() - 8usize];
    ["Offset of field: cv_detail_CylindricalWarperGpu::d_xmap_"]
        [::std::mem::offset_of!(cv_detail_CylindricalWarperGpu, d_xmap_) - 168usize];
    ["Offset of field: cv_detail_CylindricalWarperGpu::d_ymap_"]
        [::std::mem::offset_of!(cv_detail_CylindricalWarperGpu, d_ymap_) - 232usize];
    ["Offset of field: cv_detail_CylindricalWarperGpu::d_src_"]
        [::std::mem::offset_of!(cv_detail_CylindricalWarperGpu, d_src_) - 296usize];
    ["Offset of field: cv_detail_CylindricalWarperGpu::d_dst_"]
        [::std::mem::offset_of!(cv_detail_CylindricalWarperGpu, d_dst_) - 360usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail20CylindricalWarperGpu9buildMapsENS_5Size_IiEERKNS_11_InputArrayES6_RNS_4cuda6GpuMatES9_"]
    pub fn cv_detail_CylindricalWarperGpu_buildMaps(
        this: *mut cv_detail_CylindricalWarperGpu,
        src_size: cv_Size,
        K: cv_InputArray,
        R: cv_InputArray,
        xmap: *mut cv_cuda_GpuMat,
        ymap: *mut cv_cuda_GpuMat,
    ) -> cv_Rect;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail20CylindricalWarperGpu4warpERKNS_4cuda6GpuMatERKNS_11_InputArrayES8_iiRS3_"]
    pub fn cv_detail_CylindricalWarperGpu_warp(
        this: *mut cv_detail_CylindricalWarperGpu,
        src: *const cv_cuda_GpuMat,
        K: cv_InputArray,
        R: cv_InputArray,
        interp_mode: ::std::os::raw::c_int,
        border_mode: ::std::os::raw::c_int,
        dst: *mut cv_cuda_GpuMat,
    ) -> cv_Point;
}
impl cv_detail_CylindricalWarperGpu {
    #[inline]
    pub unsafe fn buildMaps(
        &mut self,
        src_size: cv_Size,
        K: cv_InputArray,
        R: cv_InputArray,
        xmap: *mut cv_cuda_GpuMat,
        ymap: *mut cv_cuda_GpuMat,
    ) -> cv_Rect {
        cv_detail_CylindricalWarperGpu_buildMaps(self, src_size, K, R, xmap, ymap)
    }
    #[inline]
    pub unsafe fn warp(
        &mut self,
        src: *const cv_cuda_GpuMat,
        K: cv_InputArray,
        R: cv_InputArray,
        interp_mode: ::std::os::raw::c_int,
        border_mode: ::std::os::raw::c_int,
        dst: *mut cv_cuda_GpuMat,
    ) -> cv_Point {
        cv_detail_CylindricalWarperGpu_warp(self, src, K, R, interp_mode, border_mode, dst)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_detail_SphericalPortraitProjector {
    pub _base: cv_detail_ProjectorBase,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_SphericalPortraitProjector"]
        [::std::mem::size_of::<cv_detail_SphericalPortraitProjector>() - 160usize];
    ["Alignment of cv_detail_SphericalPortraitProjector"]
        [::std::mem::align_of::<cv_detail_SphericalPortraitProjector>() - 4usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_SphericalPortraitWarper {
    pub _base: cv_detail_RotationWarperBase<cv_detail_SphericalPortraitProjector>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_SphericalPortraitWarper"]
        [::std::mem::size_of::<cv_detail_SphericalPortraitWarper>() - 168usize];
    ["Alignment of cv_detail_SphericalPortraitWarper"]
        [::std::mem::align_of::<cv_detail_SphericalPortraitWarper>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail23SphericalPortraitWarper15detectResultRoiENS_5Size_IiEERNS_6Point_IiEES6_"]
    pub fn cv_detail_SphericalPortraitWarper_detectResultRoi(
        this: *mut ::std::os::raw::c_void,
        src_size: cv_Size,
        dst_tl: *mut cv_Point,
        dst_br: *mut cv_Point,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_detail_CylindricalPortraitProjector {
    pub _base: cv_detail_ProjectorBase,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_CylindricalPortraitProjector"]
        [::std::mem::size_of::<cv_detail_CylindricalPortraitProjector>() - 160usize];
    ["Alignment of cv_detail_CylindricalPortraitProjector"]
        [::std::mem::align_of::<cv_detail_CylindricalPortraitProjector>() - 4usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_CylindricalPortraitWarper {
    pub _base: cv_detail_RotationWarperBase<cv_detail_CylindricalPortraitProjector>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_CylindricalPortraitWarper"]
        [::std::mem::size_of::<cv_detail_CylindricalPortraitWarper>() - 168usize];
    ["Alignment of cv_detail_CylindricalPortraitWarper"]
        [::std::mem::align_of::<cv_detail_CylindricalPortraitWarper>() - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_detail_PlanePortraitProjector {
    pub _base: cv_detail_ProjectorBase,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_PlanePortraitProjector"]
        [::std::mem::size_of::<cv_detail_PlanePortraitProjector>() - 160usize];
    ["Alignment of cv_detail_PlanePortraitProjector"]
        [::std::mem::align_of::<cv_detail_PlanePortraitProjector>() - 4usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_PlanePortraitWarper {
    pub _base: cv_detail_RotationWarperBase<cv_detail_PlanePortraitProjector>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_PlanePortraitWarper"]
        [::std::mem::size_of::<cv_detail_PlanePortraitWarper>() - 168usize];
    ["Alignment of cv_detail_PlanePortraitWarper"]
        [::std::mem::align_of::<cv_detail_PlanePortraitWarper>() - 8usize];
};
#[doc = " @brief Structure containing image keypoints and descriptors."]
#[repr(C)]
pub struct cv_detail_ImageFeatures {
    pub img_idx: ::std::os::raw::c_int,
    pub img_size: cv_Size,
    pub keypoints: std_vector,
    pub descriptors: cv_UMat,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_ImageFeatures"]
        [::std::mem::size_of::<cv_detail_ImageFeatures>() - 120usize];
    ["Alignment of cv_detail_ImageFeatures"]
        [::std::mem::align_of::<cv_detail_ImageFeatures>() - 8usize];
    ["Offset of field: cv_detail_ImageFeatures::img_idx"]
        [::std::mem::offset_of!(cv_detail_ImageFeatures, img_idx) - 0usize];
    ["Offset of field: cv_detail_ImageFeatures::img_size"]
        [::std::mem::offset_of!(cv_detail_ImageFeatures, img_size) - 4usize];
    ["Offset of field: cv_detail_ImageFeatures::keypoints"]
        [::std::mem::offset_of!(cv_detail_ImageFeatures, keypoints) - 16usize];
    ["Offset of field: cv_detail_ImageFeatures::descriptors"]
        [::std::mem::offset_of!(cv_detail_ImageFeatures, descriptors) - 40usize];
};
unsafe extern "C" {
    #[doc = " @brief\n\n@param featuresFinder\n@param images\n@param features\n@param masks"]
    #[link_name = "\u{1}_ZN2cv6detail20computeImageFeaturesERKNS_3PtrINS_9Feature2DEEERKNS_11_InputArrayERSt6vectorINS0_13ImageFeaturesESaISA_EES8_"]
    pub fn cv_detail_computeImageFeatures(
        featuresFinder: *const cv_Ptr,
        images: cv_InputArrayOfArrays,
        features: *mut std_vector,
        masks: cv_InputArrayOfArrays,
    );
}
unsafe extern "C" {
    #[doc = " @brief\n\n@param featuresFinder\n@param image\n@param features\n@param mask"]
    #[link_name = "\u{1}_ZN2cv6detail20computeImageFeaturesERKNS_3PtrINS_9Feature2DEEERKNS_11_InputArrayERNS0_13ImageFeaturesES8_"]
    pub fn cv_detail_computeImageFeatures1(
        featuresFinder: *const cv_Ptr,
        image: cv_InputArray,
        features: *mut cv_detail_ImageFeatures,
        mask: cv_InputArray,
    );
}
#[doc = " @brief Structure containing information about matches between two images.\n\nIt's assumed that there is a transformation between those images. Transformation may be\nhomography or affine transformation based on selected matcher.\n\n@sa detail::FeaturesMatcher"]
#[repr(C)]
pub struct cv_detail_MatchesInfo {
    pub src_img_idx: ::std::os::raw::c_int,
    #[doc = "!< Images indices (optional)"]
    pub dst_img_idx: ::std::os::raw::c_int,
    pub matches: std_vector,
    #[doc = "!< Geometrically consistent matches mask"]
    pub inliers_mask: std_vector,
    #[doc = "!< Number of geometrically consistent matches"]
    pub num_inliers: ::std::os::raw::c_int,
    #[doc = "!< Estimated transformation"]
    pub H: cv_Mat,
    #[doc = "!< Confidence two images are from the same panorama"]
    pub confidence: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_MatchesInfo"][::std::mem::size_of::<cv_detail_MatchesInfo>() - 168usize];
    ["Alignment of cv_detail_MatchesInfo"]
        [::std::mem::align_of::<cv_detail_MatchesInfo>() - 8usize];
    ["Offset of field: cv_detail_MatchesInfo::src_img_idx"]
        [::std::mem::offset_of!(cv_detail_MatchesInfo, src_img_idx) - 0usize];
    ["Offset of field: cv_detail_MatchesInfo::dst_img_idx"]
        [::std::mem::offset_of!(cv_detail_MatchesInfo, dst_img_idx) - 4usize];
    ["Offset of field: cv_detail_MatchesInfo::matches"]
        [::std::mem::offset_of!(cv_detail_MatchesInfo, matches) - 8usize];
    ["Offset of field: cv_detail_MatchesInfo::inliers_mask"]
        [::std::mem::offset_of!(cv_detail_MatchesInfo, inliers_mask) - 32usize];
    ["Offset of field: cv_detail_MatchesInfo::num_inliers"]
        [::std::mem::offset_of!(cv_detail_MatchesInfo, num_inliers) - 56usize];
    ["Offset of field: cv_detail_MatchesInfo::H"]
        [::std::mem::offset_of!(cv_detail_MatchesInfo, H) - 64usize];
    ["Offset of field: cv_detail_MatchesInfo::confidence"]
        [::std::mem::offset_of!(cv_detail_MatchesInfo, confidence) - 160usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail11MatchesInfoC1Ev"]
    pub fn cv_detail_MatchesInfo_MatchesInfo(this: *mut cv_detail_MatchesInfo);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail11MatchesInfoC1ERKS1_"]
    pub fn cv_detail_MatchesInfo_MatchesInfo1(
        this: *mut cv_detail_MatchesInfo,
        other: *const cv_detail_MatchesInfo,
    );
}
impl cv_detail_MatchesInfo {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_detail_MatchesInfo_MatchesInfo(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(other: *const cv_detail_MatchesInfo) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_detail_MatchesInfo_MatchesInfo1(__bindgen_tmp.as_mut_ptr(), other);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct cv_detail_FeaturesMatcher__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief Feature matchers base class."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_FeaturesMatcher {
    pub vtable_: *const cv_detail_FeaturesMatcher__bindgen_vtable,
    pub is_thread_safe_: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_FeaturesMatcher"]
        [::std::mem::size_of::<cv_detail_FeaturesMatcher>() - 16usize];
    ["Alignment of cv_detail_FeaturesMatcher"]
        [::std::mem::align_of::<cv_detail_FeaturesMatcher>() - 8usize];
    ["Offset of field: cv_detail_FeaturesMatcher::is_thread_safe_"]
        [::std::mem::offset_of!(cv_detail_FeaturesMatcher, is_thread_safe_) - 8usize];
};
#[doc = " @brief Features matcher which finds two best matches for each feature and leaves the best one only if the\nratio between descriptor distances is greater than the threshold match_conf\n\n@sa detail::FeaturesMatcher"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_BestOf2NearestMatcher {
    pub _base: cv_detail_FeaturesMatcher,
    pub num_matches_thresh1_: ::std::os::raw::c_int,
    pub num_matches_thresh2_: ::std::os::raw::c_int,
    pub impl_: cv_Ptr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_BestOf2NearestMatcher"]
        [::std::mem::size_of::<cv_detail_BestOf2NearestMatcher>() - 40usize];
    ["Alignment of cv_detail_BestOf2NearestMatcher"]
        [::std::mem::align_of::<cv_detail_BestOf2NearestMatcher>() - 8usize];
    ["Offset of field: cv_detail_BestOf2NearestMatcher::num_matches_thresh1_"]
        [::std::mem::offset_of!(cv_detail_BestOf2NearestMatcher, num_matches_thresh1_) - 12usize];
    ["Offset of field: cv_detail_BestOf2NearestMatcher::num_matches_thresh2_"]
        [::std::mem::offset_of!(cv_detail_BestOf2NearestMatcher, num_matches_thresh2_) - 16usize];
    ["Offset of field: cv_detail_BestOf2NearestMatcher::impl_"]
        [::std::mem::offset_of!(cv_detail_BestOf2NearestMatcher, impl_) - 24usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail21BestOf2NearestMatcher6createEbfii"]
    pub fn cv_detail_BestOf2NearestMatcher_create(
        try_use_gpu: bool,
        match_conf: f32,
        num_matches_thresh1: ::std::os::raw::c_int,
        num_matches_thresh2: ::std::os::raw::c_int,
    ) -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Constructs a \"best of 2 nearest\" matcher.\n\n@param try_use_gpu Should try to use GPU or not\n@param match_conf Match distances ration threshold\n@param num_matches_thresh1 Minimum number of matches required for the 2D projective transform\nestimation used in the inliers classification step\n@param num_matches_thresh2 Minimum number of matches required for the 2D projective transform\nre-estimation on inliers"]
    #[link_name = "\u{1}_ZN2cv6detail21BestOf2NearestMatcherC1Ebfii"]
    pub fn cv_detail_BestOf2NearestMatcher_BestOf2NearestMatcher(
        this: *mut cv_detail_BestOf2NearestMatcher,
        try_use_gpu: bool,
        match_conf: f32,
        num_matches_thresh1: ::std::os::raw::c_int,
        num_matches_thresh2: ::std::os::raw::c_int,
    );
}
impl cv_detail_BestOf2NearestMatcher {
    #[inline]
    pub unsafe fn create(
        try_use_gpu: bool,
        match_conf: f32,
        num_matches_thresh1: ::std::os::raw::c_int,
        num_matches_thresh2: ::std::os::raw::c_int,
    ) -> cv_Ptr {
        cv_detail_BestOf2NearestMatcher_create(
            try_use_gpu,
            match_conf,
            num_matches_thresh1,
            num_matches_thresh2,
        )
    }
    #[inline]
    pub unsafe fn new(
        try_use_gpu: bool,
        match_conf: f32,
        num_matches_thresh1: ::std::os::raw::c_int,
        num_matches_thresh2: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_detail_BestOf2NearestMatcher_BestOf2NearestMatcher(
            __bindgen_tmp.as_mut_ptr(),
            try_use_gpu,
            match_conf,
            num_matches_thresh1,
            num_matches_thresh2,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail21BestOf2NearestMatcher14collectGarbageEv"]
    pub fn cv_detail_BestOf2NearestMatcher_collectGarbage(this: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail21BestOf2NearestMatcher5matchERKNS0_13ImageFeaturesES4_RNS0_11MatchesInfoE"]
    pub fn cv_detail_BestOf2NearestMatcher_match(
        this: *mut ::std::os::raw::c_void,
        features1: *const cv_detail_ImageFeatures,
        features2: *const cv_detail_ImageFeatures,
        matches_info: *mut cv_detail_MatchesInfo,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_BestOf2NearestRangeMatcher {
    pub _base: cv_detail_BestOf2NearestMatcher,
    pub range_width_: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_BestOf2NearestRangeMatcher"]
        [::std::mem::size_of::<cv_detail_BestOf2NearestRangeMatcher>() - 48usize];
    ["Alignment of cv_detail_BestOf2NearestRangeMatcher"]
        [::std::mem::align_of::<cv_detail_BestOf2NearestRangeMatcher>() - 8usize];
    ["Offset of field: cv_detail_BestOf2NearestRangeMatcher::range_width_"]
        [::std::mem::offset_of!(cv_detail_BestOf2NearestRangeMatcher, range_width_) - 40usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail26BestOf2NearestRangeMatcherC1Eibfii"]
    pub fn cv_detail_BestOf2NearestRangeMatcher_BestOf2NearestRangeMatcher(
        this: *mut cv_detail_BestOf2NearestRangeMatcher,
        range_width: ::std::os::raw::c_int,
        try_use_gpu: bool,
        match_conf: f32,
        num_matches_thresh1: ::std::os::raw::c_int,
        num_matches_thresh2: ::std::os::raw::c_int,
    );
}
impl cv_detail_BestOf2NearestRangeMatcher {
    #[inline]
    pub unsafe fn new(
        range_width: ::std::os::raw::c_int,
        try_use_gpu: bool,
        match_conf: f32,
        num_matches_thresh1: ::std::os::raw::c_int,
        num_matches_thresh2: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_detail_BestOf2NearestRangeMatcher_BestOf2NearestRangeMatcher(
            __bindgen_tmp.as_mut_ptr(),
            range_width,
            try_use_gpu,
            match_conf,
            num_matches_thresh1,
            num_matches_thresh2,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief Features matcher similar to cv::detail::BestOf2NearestMatcher which\nfinds two best matches for each feature and leaves the best one only if the\nratio between descriptor distances is greater than the threshold match_conf.\n\nUnlike cv::detail::BestOf2NearestMatcher this matcher uses affine\ntransformation (affine trasformation estimate will be placed in matches_info).\n\n@sa cv::detail::FeaturesMatcher cv::detail::BestOf2NearestMatcher"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_AffineBestOf2NearestMatcher {
    pub _base: cv_detail_BestOf2NearestMatcher,
    pub full_affine_: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_AffineBestOf2NearestMatcher"]
        [::std::mem::size_of::<cv_detail_AffineBestOf2NearestMatcher>() - 48usize];
    ["Alignment of cv_detail_AffineBestOf2NearestMatcher"]
        [::std::mem::align_of::<cv_detail_AffineBestOf2NearestMatcher>() - 8usize];
    ["Offset of field: cv_detail_AffineBestOf2NearestMatcher::full_affine_"]
        [::std::mem::offset_of!(cv_detail_AffineBestOf2NearestMatcher, full_affine_) - 40usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail27AffineBestOf2NearestMatcher5matchERKNS0_13ImageFeaturesES4_RNS0_11MatchesInfoE"]
    pub fn cv_detail_AffineBestOf2NearestMatcher_match(
        this: *mut ::std::os::raw::c_void,
        features1: *const cv_detail_ImageFeatures,
        features2: *const cv_detail_ImageFeatures,
        matches_info: *mut cv_detail_MatchesInfo,
    );
}
#[doc = "! @addtogroup stitching\n! @{"]
#[repr(C)]
pub struct cv_detail_DisjointSets {
    pub parent: std_vector,
    pub size: std_vector,
    pub rank_: std_vector,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_DisjointSets"][::std::mem::size_of::<cv_detail_DisjointSets>() - 72usize];
    ["Alignment of cv_detail_DisjointSets"]
        [::std::mem::align_of::<cv_detail_DisjointSets>() - 8usize];
    ["Offset of field: cv_detail_DisjointSets::parent"]
        [::std::mem::offset_of!(cv_detail_DisjointSets, parent) - 0usize];
    ["Offset of field: cv_detail_DisjointSets::size"]
        [::std::mem::offset_of!(cv_detail_DisjointSets, size) - 24usize];
    ["Offset of field: cv_detail_DisjointSets::rank_"]
        [::std::mem::offset_of!(cv_detail_DisjointSets, rank_) - 48usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail12DisjointSets17createOneElemSetsEi"]
    pub fn cv_detail_DisjointSets_createOneElemSets(
        this: *mut cv_detail_DisjointSets,
        elem_count: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail12DisjointSets13findSetByElemEi"]
    pub fn cv_detail_DisjointSets_findSetByElem(
        this: *mut cv_detail_DisjointSets,
        elem: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail12DisjointSets9mergeSetsEii"]
    pub fn cv_detail_DisjointSets_mergeSets(
        this: *mut cv_detail_DisjointSets,
        set1: ::std::os::raw::c_int,
        set2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
impl cv_detail_DisjointSets {
    #[inline]
    pub unsafe fn createOneElemSets(&mut self, elem_count: ::std::os::raw::c_int) {
        cv_detail_DisjointSets_createOneElemSets(self, elem_count)
    }
    #[inline]
    pub unsafe fn findSetByElem(&mut self, elem: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        cv_detail_DisjointSets_findSetByElem(self, elem)
    }
    #[inline]
    pub unsafe fn mergeSets(
        &mut self,
        set1: ::std::os::raw::c_int,
        set2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        cv_detail_DisjointSets_mergeSets(self, set1, set2)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_detail_GraphEdge {
    pub from: ::std::os::raw::c_int,
    pub to: ::std::os::raw::c_int,
    pub weight: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_GraphEdge"][::std::mem::size_of::<cv_detail_GraphEdge>() - 12usize];
    ["Alignment of cv_detail_GraphEdge"][::std::mem::align_of::<cv_detail_GraphEdge>() - 4usize];
    ["Offset of field: cv_detail_GraphEdge::from"]
        [::std::mem::offset_of!(cv_detail_GraphEdge, from) - 0usize];
    ["Offset of field: cv_detail_GraphEdge::to"]
        [::std::mem::offset_of!(cv_detail_GraphEdge, to) - 4usize];
    ["Offset of field: cv_detail_GraphEdge::weight"]
        [::std::mem::offset_of!(cv_detail_GraphEdge, weight) - 8usize];
};
#[repr(C)]
pub struct cv_detail_Graph {
    pub edges_: std_vector,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_Graph"][::std::mem::size_of::<cv_detail_Graph>() - 24usize];
    ["Alignment of cv_detail_Graph"][::std::mem::align_of::<cv_detail_Graph>() - 8usize];
    ["Offset of field: cv_detail_Graph::edges_"]
        [::std::mem::offset_of!(cv_detail_Graph, edges_) - 0usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail5Graph7addEdgeEiif"]
    pub fn cv_detail_Graph_addEdge(
        this: *mut cv_detail_Graph,
        from: ::std::os::raw::c_int,
        to: ::std::os::raw::c_int,
        weight: f32,
    );
}
impl cv_detail_Graph {
    #[inline]
    pub unsafe fn addEdge(
        &mut self,
        from: ::std::os::raw::c_int,
        to: ::std::os::raw::c_int,
        weight: f32,
    ) {
        cv_detail_Graph_addEdge(self, from, to, weight)
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail10overlapRoiENS_6Point_IiEES2_NS_5Size_IiEES4_RNS_5Rect_IiEE"]
    pub fn cv_detail_overlapRoi(
        tl1: cv_Point,
        tl2: cv_Point,
        sz1: cv_Size,
        sz2: cv_Size,
        roi: *mut cv_Rect,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail9resultRoiERKSt6vectorINS_6Point_IiEESaIS3_EERKS1_INS_4UMatESaIS8_EE"]
    pub fn cv_detail_resultRoi(corners: *const std_vector, images: *const std_vector) -> cv_Rect;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail9resultRoiERKSt6vectorINS_6Point_IiEESaIS3_EERKS1_INS_5Size_IiEESaIS9_EE"]
    pub fn cv_detail_resultRoi1(corners: *const std_vector, sizes: *const std_vector) -> cv_Rect;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail21resultRoiIntersectionERKSt6vectorINS_6Point_IiEESaIS3_EERKS1_INS_5Size_IiEESaIS9_EE"]
    pub fn cv_detail_resultRoiIntersection(
        corners: *const std_vector,
        sizes: *const std_vector,
    ) -> cv_Rect;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail8resultTlERKSt6vectorINS_6Point_IiEESaIS3_EE"]
    pub fn cv_detail_resultTl(corners: *const std_vector) -> cv_Point;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail18selectRandomSubsetEiiRSt6vectorIiSaIiEE"]
    pub fn cv_detail_selectRandomSubset(
        count: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
        subset: *mut std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail17stitchingLogLevelEv"]
    pub fn cv_detail_stitchingLogLevel() -> *mut ::std::os::raw::c_int;
}
#[doc = " @brief Describes camera parameters.\n\n@note Translation is assumed to be zero during the whole stitching pipeline. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_CameraParams {
    pub focal: f64,
    pub aspect: f64,
    pub ppx: f64,
    pub ppy: f64,
    pub R: cv_Mat,
    pub t: cv_Mat,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_CameraParams"][::std::mem::size_of::<cv_detail_CameraParams>() - 224usize];
    ["Alignment of cv_detail_CameraParams"]
        [::std::mem::align_of::<cv_detail_CameraParams>() - 8usize];
    ["Offset of field: cv_detail_CameraParams::focal"]
        [::std::mem::offset_of!(cv_detail_CameraParams, focal) - 0usize];
    ["Offset of field: cv_detail_CameraParams::aspect"]
        [::std::mem::offset_of!(cv_detail_CameraParams, aspect) - 8usize];
    ["Offset of field: cv_detail_CameraParams::ppx"]
        [::std::mem::offset_of!(cv_detail_CameraParams, ppx) - 16usize];
    ["Offset of field: cv_detail_CameraParams::ppy"]
        [::std::mem::offset_of!(cv_detail_CameraParams, ppy) - 24usize];
    ["Offset of field: cv_detail_CameraParams::R"]
        [::std::mem::offset_of!(cv_detail_CameraParams, R) - 32usize];
    ["Offset of field: cv_detail_CameraParams::t"]
        [::std::mem::offset_of!(cv_detail_CameraParams, t) - 128usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv6detail12CameraParams1KEv"]
    pub fn cv_detail_CameraParams_K(this: *const cv_detail_CameraParams) -> cv_Mat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail12CameraParamsC1Ev"]
    pub fn cv_detail_CameraParams_CameraParams(this: *mut cv_detail_CameraParams);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail12CameraParamsC1ERKS1_"]
    pub fn cv_detail_CameraParams_CameraParams1(
        this: *mut cv_detail_CameraParams,
        other: *const cv_detail_CameraParams,
    );
}
impl cv_detail_CameraParams {
    #[inline]
    pub unsafe fn K(&self) -> cv_Mat {
        cv_detail_CameraParams_K(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_detail_CameraParams_CameraParams(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(other: *const cv_detail_CameraParams) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_detail_CameraParams_CameraParams1(__bindgen_tmp.as_mut_ptr(), other);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct cv_detail_Estimator__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief Rotation estimator base class.\n\nIt takes features of all images, pairwise matches between all images and estimates rotations of all\ncameras.\n\n@note The coordinate system origin is implementation-dependent, but you can always normalize the\nrotations in respect to the first camera, for instance. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_Estimator {
    pub vtable_: *const cv_detail_Estimator__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_Estimator"][::std::mem::size_of::<cv_detail_Estimator>() - 8usize];
    ["Alignment of cv_detail_Estimator"][::std::mem::align_of::<cv_detail_Estimator>() - 8usize];
};
#[doc = " @brief Homography based rotation estimator."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_HomographyBasedEstimator {
    pub _base: cv_detail_Estimator,
    pub is_focals_estimated_: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_HomographyBasedEstimator"]
        [::std::mem::size_of::<cv_detail_HomographyBasedEstimator>() - 16usize];
    ["Alignment of cv_detail_HomographyBasedEstimator"]
        [::std::mem::align_of::<cv_detail_HomographyBasedEstimator>() - 8usize];
    ["Offset of field: cv_detail_HomographyBasedEstimator::is_focals_estimated_"]
        [::std::mem::offset_of!(cv_detail_HomographyBasedEstimator, is_focals_estimated_) - 8usize];
};
#[doc = " @brief Affine transformation based estimator.\n\nThis estimator uses pairwise transformations estimated by matcher to estimate\nfinal transformation for each camera.\n\n@sa cv::detail::HomographyBasedEstimator"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_AffineBasedEstimator {
    pub _base: cv_detail_Estimator,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_AffineBasedEstimator"]
        [::std::mem::size_of::<cv_detail_AffineBasedEstimator>() - 8usize];
    ["Alignment of cv_detail_AffineBasedEstimator"]
        [::std::mem::align_of::<cv_detail_AffineBasedEstimator>() - 8usize];
};
#[doc = " @brief Base class for all camera parameters refinement methods."]
#[repr(C)]
pub struct cv_detail_BundleAdjusterBase {
    pub _base: cv_detail_Estimator,
    pub refinement_mask_: cv_Mat,
    pub num_images_: ::std::os::raw::c_int,
    pub total_num_matches_: ::std::os::raw::c_int,
    pub num_params_per_cam_: ::std::os::raw::c_int,
    pub num_errs_per_measurement_: ::std::os::raw::c_int,
    pub features_: *const cv_detail_ImageFeatures,
    pub pairwise_matches_: *const cv_detail_MatchesInfo,
    pub conf_thresh_: f64,
    pub term_criteria_: cv_TermCriteria,
    pub cam_params_: cv_Mat,
    pub edges_: std_vector,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_BundleAdjusterBase"]
        [::std::mem::size_of::<cv_detail_BundleAdjusterBase>() - 280usize];
    ["Alignment of cv_detail_BundleAdjusterBase"]
        [::std::mem::align_of::<cv_detail_BundleAdjusterBase>() - 8usize];
    ["Offset of field: cv_detail_BundleAdjusterBase::refinement_mask_"]
        [::std::mem::offset_of!(cv_detail_BundleAdjusterBase, refinement_mask_) - 8usize];
    ["Offset of field: cv_detail_BundleAdjusterBase::num_images_"]
        [::std::mem::offset_of!(cv_detail_BundleAdjusterBase, num_images_) - 104usize];
    ["Offset of field: cv_detail_BundleAdjusterBase::total_num_matches_"]
        [::std::mem::offset_of!(cv_detail_BundleAdjusterBase, total_num_matches_) - 108usize];
    ["Offset of field: cv_detail_BundleAdjusterBase::num_params_per_cam_"]
        [::std::mem::offset_of!(cv_detail_BundleAdjusterBase, num_params_per_cam_) - 112usize];
    ["Offset of field: cv_detail_BundleAdjusterBase::num_errs_per_measurement_"][::std::mem::offset_of!(
        cv_detail_BundleAdjusterBase,
        num_errs_per_measurement_
    ) - 116usize];
    ["Offset of field: cv_detail_BundleAdjusterBase::features_"]
        [::std::mem::offset_of!(cv_detail_BundleAdjusterBase, features_) - 120usize];
    ["Offset of field: cv_detail_BundleAdjusterBase::pairwise_matches_"]
        [::std::mem::offset_of!(cv_detail_BundleAdjusterBase, pairwise_matches_) - 128usize];
    ["Offset of field: cv_detail_BundleAdjusterBase::conf_thresh_"]
        [::std::mem::offset_of!(cv_detail_BundleAdjusterBase, conf_thresh_) - 136usize];
    ["Offset of field: cv_detail_BundleAdjusterBase::term_criteria_"]
        [::std::mem::offset_of!(cv_detail_BundleAdjusterBase, term_criteria_) - 144usize];
    ["Offset of field: cv_detail_BundleAdjusterBase::cam_params_"]
        [::std::mem::offset_of!(cv_detail_BundleAdjusterBase, cam_params_) - 160usize];
    ["Offset of field: cv_detail_BundleAdjusterBase::edges_"]
        [::std::mem::offset_of!(cv_detail_BundleAdjusterBase, edges_) - 256usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail18BundleAdjusterBase8estimateERKSt6vectorINS0_13ImageFeaturesESaIS3_EERKS2_INS0_11MatchesInfoESaIS8_EERS2_INS0_12CameraParamsESaISD_EE"]
    pub fn cv_detail_BundleAdjusterBase_estimate(
        this: *mut ::std::os::raw::c_void,
        features: *const std_vector,
        pairwise_matches: *const std_vector,
        cameras: *mut std_vector,
    ) -> bool;
}
#[doc = " @brief Stub bundle adjuster that does nothing."]
#[repr(C)]
pub struct cv_detail_NoBundleAdjuster {
    pub _base: cv_detail_BundleAdjusterBase,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_NoBundleAdjuster"]
        [::std::mem::size_of::<cv_detail_NoBundleAdjuster>() - 280usize];
    ["Alignment of cv_detail_NoBundleAdjuster"]
        [::std::mem::align_of::<cv_detail_NoBundleAdjuster>() - 8usize];
};
#[doc = " @brief Implementation of the camera parameters refinement algorithm which minimizes sum of the reprojection\nerror squares\n\nIt can estimate focal length, aspect ratio, principal point.\nYou can affect only on them via the refinement mask."]
#[repr(C)]
pub struct cv_detail_BundleAdjusterReproj {
    pub _base: cv_detail_BundleAdjusterBase,
    pub err1_: cv_Mat,
    pub err2_: cv_Mat,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_BundleAdjusterReproj"]
        [::std::mem::size_of::<cv_detail_BundleAdjusterReproj>() - 472usize];
    ["Alignment of cv_detail_BundleAdjusterReproj"]
        [::std::mem::align_of::<cv_detail_BundleAdjusterReproj>() - 8usize];
    ["Offset of field: cv_detail_BundleAdjusterReproj::err1_"]
        [::std::mem::offset_of!(cv_detail_BundleAdjusterReproj, err1_) - 280usize];
    ["Offset of field: cv_detail_BundleAdjusterReproj::err2_"]
        [::std::mem::offset_of!(cv_detail_BundleAdjusterReproj, err2_) - 376usize];
};
#[doc = " @brief Implementation of the camera parameters refinement algorithm which minimizes sum of the distances\nbetween the rays passing through the camera center and a feature. :\n\nIt can estimate focal length. It ignores the refinement mask for now."]
#[repr(C)]
pub struct cv_detail_BundleAdjusterRay {
    pub _base: cv_detail_BundleAdjusterBase,
    pub err1_: cv_Mat,
    pub err2_: cv_Mat,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_BundleAdjusterRay"]
        [::std::mem::size_of::<cv_detail_BundleAdjusterRay>() - 472usize];
    ["Alignment of cv_detail_BundleAdjusterRay"]
        [::std::mem::align_of::<cv_detail_BundleAdjusterRay>() - 8usize];
    ["Offset of field: cv_detail_BundleAdjusterRay::err1_"]
        [::std::mem::offset_of!(cv_detail_BundleAdjusterRay, err1_) - 280usize];
    ["Offset of field: cv_detail_BundleAdjusterRay::err2_"]
        [::std::mem::offset_of!(cv_detail_BundleAdjusterRay, err2_) - 376usize];
};
#[doc = " @brief Bundle adjuster that expects affine transformation\nrepresented in homogeneous coordinates in R for each camera param. Implements\ncamera parameters refinement algorithm which minimizes sum of the reprojection\nerror squares\n\nIt estimates all transformation parameters. Refinement mask is ignored.\n\n@sa AffineBasedEstimator AffineBestOf2NearestMatcher BundleAdjusterAffinePartial"]
#[repr(C)]
pub struct cv_detail_BundleAdjusterAffine {
    pub _base: cv_detail_BundleAdjusterBase,
    pub err1_: cv_Mat,
    pub err2_: cv_Mat,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_BundleAdjusterAffine"]
        [::std::mem::size_of::<cv_detail_BundleAdjusterAffine>() - 472usize];
    ["Alignment of cv_detail_BundleAdjusterAffine"]
        [::std::mem::align_of::<cv_detail_BundleAdjusterAffine>() - 8usize];
    ["Offset of field: cv_detail_BundleAdjusterAffine::err1_"]
        [::std::mem::offset_of!(cv_detail_BundleAdjusterAffine, err1_) - 280usize];
    ["Offset of field: cv_detail_BundleAdjusterAffine::err2_"]
        [::std::mem::offset_of!(cv_detail_BundleAdjusterAffine, err2_) - 376usize];
};
#[doc = " @brief Bundle adjuster that expects affine transformation with 4 DOF\nrepresented in homogeneous coordinates in R for each camera param. Implements\ncamera parameters refinement algorithm which minimizes sum of the reprojection\nerror squares\n\nIt estimates all transformation parameters. Refinement mask is ignored.\n\n@sa AffineBasedEstimator AffineBestOf2NearestMatcher BundleAdjusterAffine"]
#[repr(C)]
pub struct cv_detail_BundleAdjusterAffinePartial {
    pub _base: cv_detail_BundleAdjusterBase,
    pub err1_: cv_Mat,
    pub err2_: cv_Mat,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_BundleAdjusterAffinePartial"]
        [::std::mem::size_of::<cv_detail_BundleAdjusterAffinePartial>() - 472usize];
    ["Alignment of cv_detail_BundleAdjusterAffinePartial"]
        [::std::mem::align_of::<cv_detail_BundleAdjusterAffinePartial>() - 8usize];
    ["Offset of field: cv_detail_BundleAdjusterAffinePartial::err1_"]
        [::std::mem::offset_of!(cv_detail_BundleAdjusterAffinePartial, err1_) - 280usize];
    ["Offset of field: cv_detail_BundleAdjusterAffinePartial::err2_"]
        [::std::mem::offset_of!(cv_detail_BundleAdjusterAffinePartial, err2_) - 376usize];
};
pub const cv_detail_WaveCorrectKind_WAVE_CORRECT_HORIZ: cv_detail_WaveCorrectKind = 0;
pub const cv_detail_WaveCorrectKind_WAVE_CORRECT_VERT: cv_detail_WaveCorrectKind = 1;
pub type cv_detail_WaveCorrectKind = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Tries to make panorama more horizontal (or vertical).\n\n@param rmats Camera rotation matrices.\n@param kind Correction kind, see detail::WaveCorrectKind."]
    #[link_name = "\u{1}_ZN2cv6detail11waveCorrectERSt6vectorINS_3MatESaIS2_EENS0_15WaveCorrectKindE"]
    pub fn cv_detail_waveCorrect(rmats: *mut std_vector, kind: cv_detail_WaveCorrectKind);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail20matchesGraphAsStringERSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS7_EERS1_INS0_11MatchesInfoESaISB_EEf"]
    pub fn cv_detail_matchesGraphAsString(
        pathes: *mut std_vector,
        pairwise_matches: *mut std_vector,
        conf_threshold: f32,
    ) -> cv_String;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail21leaveBiggestComponentERSt6vectorINS0_13ImageFeaturesESaIS2_EERS1_INS0_11MatchesInfoESaIS6_EEf"]
    pub fn cv_detail_leaveBiggestComponent(
        features: *mut std_vector,
        pairwise_matches: *mut std_vector,
        conf_threshold: f32,
    ) -> std_vector;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail19findMaxSpanningTreeEiRKSt6vectorINS0_11MatchesInfoESaIS2_EERNS0_5GraphERS1_IiSaIiEE"]
    pub fn cv_detail_findMaxSpanningTree(
        num_images: ::std::os::raw::c_int,
        pairwise_matches: *const std_vector,
        span_tree: *mut cv_detail_Graph,
        centers: *mut std_vector,
    );
}
#[repr(C)]
pub struct cv_detail_ExposureCompensator__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief Base class for all exposure compensators."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_ExposureCompensator {
    pub vtable_: *const cv_detail_ExposureCompensator__bindgen_vtable,
    pub updateGain: bool,
}
pub const cv_detail_ExposureCompensator_NO: cv_detail_ExposureCompensator__bindgen_ty_1 = 0;
pub const cv_detail_ExposureCompensator_GAIN: cv_detail_ExposureCompensator__bindgen_ty_1 = 1;
pub const cv_detail_ExposureCompensator_GAIN_BLOCKS: cv_detail_ExposureCompensator__bindgen_ty_1 =
    2;
pub const cv_detail_ExposureCompensator_CHANNELS: cv_detail_ExposureCompensator__bindgen_ty_1 = 3;
pub const cv_detail_ExposureCompensator_CHANNELS_BLOCKS:
    cv_detail_ExposureCompensator__bindgen_ty_1 = 4;
pub type cv_detail_ExposureCompensator__bindgen_ty_1 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_ExposureCompensator"]
        [::std::mem::size_of::<cv_detail_ExposureCompensator>() - 16usize];
    ["Alignment of cv_detail_ExposureCompensator"]
        [::std::mem::align_of::<cv_detail_ExposureCompensator>() - 8usize];
    ["Offset of field: cv_detail_ExposureCompensator::updateGain"]
        [::std::mem::offset_of!(cv_detail_ExposureCompensator, updateGain) - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail19ExposureCompensator13createDefaultEi"]
    pub fn cv_detail_ExposureCompensator_createDefault(type_: ::std::os::raw::c_int) -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = "@param corners Source image top-left corners\n@param images Source images\n@param masks Image masks to update (second value in pair specifies the value which should be used\nto detect where image is)"]
    #[link_name = "\u{1}_ZN2cv6detail19ExposureCompensator4feedERKSt6vectorINS_6Point_IiEESaIS4_EERKS2_INS_4UMatESaIS9_EESD_"]
    pub fn cv_detail_ExposureCompensator_feed(
        this: *mut cv_detail_ExposureCompensator,
        corners: *const std_vector,
        images: *const std_vector,
        masks: *const std_vector,
    );
}
impl cv_detail_ExposureCompensator {
    #[inline]
    pub unsafe fn createDefault(type_: ::std::os::raw::c_int) -> cv_Ptr {
        cv_detail_ExposureCompensator_createDefault(type_)
    }
    #[inline]
    pub unsafe fn feed(
        &mut self,
        corners: *const std_vector,
        images: *const std_vector,
        masks: *const std_vector,
    ) {
        cv_detail_ExposureCompensator_feed(self, corners, images, masks)
    }
}
#[doc = " @brief Stub exposure compensator which does nothing."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_NoExposureCompensator {
    pub _base: cv_detail_ExposureCompensator,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_NoExposureCompensator"]
        [::std::mem::size_of::<cv_detail_NoExposureCompensator>() - 16usize];
    ["Alignment of cv_detail_NoExposureCompensator"]
        [::std::mem::align_of::<cv_detail_NoExposureCompensator>() - 8usize];
};
#[doc = " @brief Exposure compensator which tries to remove exposure related artifacts by adjusting image\nintensities, see @cite BL07 and @cite WJ10 for details."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_GainCompensator {
    pub _base: cv_detail_ExposureCompensator,
    pub gains_: cv_Mat_,
    pub nr_feeds_: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_GainCompensator"]
        [::std::mem::size_of::<cv_detail_GainCompensator>() - 120usize];
    ["Alignment of cv_detail_GainCompensator"]
        [::std::mem::align_of::<cv_detail_GainCompensator>() - 8usize];
    ["Offset of field: cv_detail_GainCompensator::gains_"]
        [::std::mem::offset_of!(cv_detail_GainCompensator, gains_) - 16usize];
    ["Offset of field: cv_detail_GainCompensator::nr_feeds_"]
        [::std::mem::offset_of!(cv_detail_GainCompensator, nr_feeds_) - 112usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail15GainCompensator10singleFeedERKSt6vectorINS_6Point_IiEESaIS4_EERKS2_INS_4UMatESaIS9_EERKS2_ISt4pairIS9_hESaISF_EE"]
    pub fn cv_detail_GainCompensator_singleFeed(
        this: *mut cv_detail_GainCompensator,
        corners: *const std_vector,
        images: *const std_vector,
        masks: *const std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv6detail15GainCompensator5gainsEv"]
    pub fn cv_detail_GainCompensator_gains(this: *const cv_detail_GainCompensator) -> std_vector;
}
impl cv_detail_GainCompensator {
    #[inline]
    pub unsafe fn singleFeed(
        &mut self,
        corners: *const std_vector,
        images: *const std_vector,
        masks: *const std_vector,
    ) {
        cv_detail_GainCompensator_singleFeed(self, corners, images, masks)
    }
    #[inline]
    pub unsafe fn gains(&self) -> std_vector {
        cv_detail_GainCompensator_gains(self)
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail15GainCompensator4feedERKSt6vectorINS_6Point_IiEESaIS4_EERKS2_INS_4UMatESaIS9_EERKS2_ISt4pairIS9_hESaISF_EE"]
    pub fn cv_detail_GainCompensator_feed(
        this: *mut ::std::os::raw::c_void,
        corners: *const std_vector,
        images: *const std_vector,
        masks: *const std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail15GainCompensator5applyEiNS_6Point_IiEERKNS_17_InputOutputArrayERKNS_11_InputArrayE"]
    pub fn cv_detail_GainCompensator_apply(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
        corner: cv_Point,
        image: cv_InputOutputArray,
        mask: cv_InputArray,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail15GainCompensator11getMatGainsERSt6vectorINS_3MatESaIS3_EE"]
    pub fn cv_detail_GainCompensator_getMatGains(
        this: *mut ::std::os::raw::c_void,
        umv: *mut std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail15GainCompensator11setMatGainsERSt6vectorINS_3MatESaIS3_EE"]
    pub fn cv_detail_GainCompensator_setMatGains(
        this: *mut ::std::os::raw::c_void,
        umv: *mut std_vector,
    );
}
#[doc = " @brief Exposure compensator which tries to remove exposure related artifacts by adjusting image\nintensities on each channel independently."]
#[repr(C)]
pub struct cv_detail_ChannelsCompensator {
    pub _base: cv_detail_ExposureCompensator,
    pub gains_: std_vector,
    pub nr_feeds_: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_ChannelsCompensator"]
        [::std::mem::size_of::<cv_detail_ChannelsCompensator>() - 48usize];
    ["Alignment of cv_detail_ChannelsCompensator"]
        [::std::mem::align_of::<cv_detail_ChannelsCompensator>() - 8usize];
    ["Offset of field: cv_detail_ChannelsCompensator::gains_"]
        [::std::mem::offset_of!(cv_detail_ChannelsCompensator, gains_) - 16usize];
    ["Offset of field: cv_detail_ChannelsCompensator::nr_feeds_"]
        [::std::mem::offset_of!(cv_detail_ChannelsCompensator, nr_feeds_) - 40usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail19ChannelsCompensator4feedERKSt6vectorINS_6Point_IiEESaIS4_EERKS2_INS_4UMatESaIS9_EERKS2_ISt4pairIS9_hESaISF_EE"]
    pub fn cv_detail_ChannelsCompensator_feed(
        this: *mut ::std::os::raw::c_void,
        corners: *const std_vector,
        images: *const std_vector,
        masks: *const std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail19ChannelsCompensator5applyEiNS_6Point_IiEERKNS_17_InputOutputArrayERKNS_11_InputArrayE"]
    pub fn cv_detail_ChannelsCompensator_apply(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
        corner: cv_Point,
        image: cv_InputOutputArray,
        mask: cv_InputArray,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail19ChannelsCompensator11getMatGainsERSt6vectorINS_3MatESaIS3_EE"]
    pub fn cv_detail_ChannelsCompensator_getMatGains(
        this: *mut ::std::os::raw::c_void,
        umv: *mut std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail19ChannelsCompensator11setMatGainsERSt6vectorINS_3MatESaIS3_EE"]
    pub fn cv_detail_ChannelsCompensator_setMatGains(
        this: *mut ::std::os::raw::c_void,
        umv: *mut std_vector,
    );
}
#[doc = " @brief Exposure compensator which tries to remove exposure related artifacts by adjusting image blocks."]
#[repr(C)]
pub struct cv_detail_BlocksCompensator {
    pub _base: cv_detail_ExposureCompensator,
    pub bl_width_: ::std::os::raw::c_int,
    pub bl_height_: ::std::os::raw::c_int,
    pub gain_maps_: std_vector,
    pub nr_feeds_: ::std::os::raw::c_int,
    pub nr_gain_filtering_iterations_: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_BlocksCompensator"]
        [::std::mem::size_of::<cv_detail_BlocksCompensator>() - 56usize];
    ["Alignment of cv_detail_BlocksCompensator"]
        [::std::mem::align_of::<cv_detail_BlocksCompensator>() - 8usize];
    ["Offset of field: cv_detail_BlocksCompensator::bl_width_"]
        [::std::mem::offset_of!(cv_detail_BlocksCompensator, bl_width_) - 12usize];
    ["Offset of field: cv_detail_BlocksCompensator::bl_height_"]
        [::std::mem::offset_of!(cv_detail_BlocksCompensator, bl_height_) - 16usize];
    ["Offset of field: cv_detail_BlocksCompensator::gain_maps_"]
        [::std::mem::offset_of!(cv_detail_BlocksCompensator, gain_maps_) - 24usize];
    ["Offset of field: cv_detail_BlocksCompensator::nr_feeds_"]
        [::std::mem::offset_of!(cv_detail_BlocksCompensator, nr_feeds_) - 48usize];
    ["Offset of field: cv_detail_BlocksCompensator::nr_gain_filtering_iterations_"][::std::mem::offset_of!(
        cv_detail_BlocksCompensator,
        nr_gain_filtering_iterations_
    ) - 52usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail17BlocksCompensator5applyEiNS_6Point_IiEERKNS_17_InputOutputArrayERKNS_11_InputArrayE"]
    pub fn cv_detail_BlocksCompensator_apply(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
        corner: cv_Point,
        image: cv_InputOutputArray,
        mask: cv_InputArray,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail17BlocksCompensator11getMatGainsERSt6vectorINS_3MatESaIS3_EE"]
    pub fn cv_detail_BlocksCompensator_getMatGains(
        this: *mut ::std::os::raw::c_void,
        umv: *mut std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail17BlocksCompensator11setMatGainsERSt6vectorINS_3MatESaIS3_EE"]
    pub fn cv_detail_BlocksCompensator_setMatGains(
        this: *mut ::std::os::raw::c_void,
        umv: *mut std_vector,
    );
}
#[doc = " @brief Exposure compensator which tries to remove exposure related artifacts by adjusting image block\nintensities, see @cite UES01 for details."]
#[repr(C)]
pub struct cv_detail_BlocksGainCompensator {
    pub _base: cv_detail_BlocksCompensator,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_BlocksGainCompensator"]
        [::std::mem::size_of::<cv_detail_BlocksGainCompensator>() - 56usize];
    ["Alignment of cv_detail_BlocksGainCompensator"]
        [::std::mem::align_of::<cv_detail_BlocksGainCompensator>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail21BlocksGainCompensator4feedERKSt6vectorINS_6Point_IiEESaIS4_EERKS2_INS_4UMatESaIS9_EERKS2_ISt4pairIS9_hESaISF_EE"]
    pub fn cv_detail_BlocksGainCompensator_feed(
        this: *mut ::std::os::raw::c_void,
        corners: *const std_vector,
        images: *const std_vector,
        masks: *const std_vector,
    );
}
#[doc = " @brief Exposure compensator which tries to remove exposure related artifacts by adjusting image block\non each channel."]
#[repr(C)]
pub struct cv_detail_BlocksChannelsCompensator {
    pub _base: cv_detail_BlocksCompensator,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_BlocksChannelsCompensator"]
        [::std::mem::size_of::<cv_detail_BlocksChannelsCompensator>() - 56usize];
    ["Alignment of cv_detail_BlocksChannelsCompensator"]
        [::std::mem::align_of::<cv_detail_BlocksChannelsCompensator>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail25BlocksChannelsCompensator4feedERKSt6vectorINS_6Point_IiEESaIS4_EERKS2_INS_4UMatESaIS9_EERKS2_ISt4pairIS9_hESaISF_EE"]
    pub fn cv_detail_BlocksChannelsCompensator_feed(
        this: *mut ::std::os::raw::c_void,
        corners: *const std_vector,
        images: *const std_vector,
        masks: *const std_vector,
    );
}
#[repr(C)]
pub struct cv_detail_SeamFinder__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief Base class for a seam estimator."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_SeamFinder {
    pub vtable_: *const cv_detail_SeamFinder__bindgen_vtable,
}
pub const cv_detail_SeamFinder_NO: cv_detail_SeamFinder__bindgen_ty_1 = 0;
pub const cv_detail_SeamFinder_VORONOI_SEAM: cv_detail_SeamFinder__bindgen_ty_1 = 1;
pub const cv_detail_SeamFinder_DP_SEAM: cv_detail_SeamFinder__bindgen_ty_1 = 2;
pub type cv_detail_SeamFinder__bindgen_ty_1 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_SeamFinder"][::std::mem::size_of::<cv_detail_SeamFinder>() - 8usize];
    ["Alignment of cv_detail_SeamFinder"][::std::mem::align_of::<cv_detail_SeamFinder>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail10SeamFinder13createDefaultEi"]
    pub fn cv_detail_SeamFinder_createDefault(type_: ::std::os::raw::c_int) -> cv_Ptr;
}
impl cv_detail_SeamFinder {
    #[inline]
    pub unsafe fn createDefault(type_: ::std::os::raw::c_int) -> cv_Ptr {
        cv_detail_SeamFinder_createDefault(type_)
    }
}
#[doc = " @brief Stub seam estimator which does nothing."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_NoSeamFinder {
    pub _base: cv_detail_SeamFinder,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_NoSeamFinder"][::std::mem::size_of::<cv_detail_NoSeamFinder>() - 8usize];
    ["Alignment of cv_detail_NoSeamFinder"]
        [::std::mem::align_of::<cv_detail_NoSeamFinder>() - 8usize];
};
#[doc = " @brief Base class for all pairwise seam estimators."]
#[repr(C)]
pub struct cv_detail_PairwiseSeamFinder {
    pub _base: cv_detail_SeamFinder,
    pub images_: std_vector,
    pub sizes_: std_vector,
    pub corners_: std_vector,
    pub masks_: std_vector,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_PairwiseSeamFinder"]
        [::std::mem::size_of::<cv_detail_PairwiseSeamFinder>() - 104usize];
    ["Alignment of cv_detail_PairwiseSeamFinder"]
        [::std::mem::align_of::<cv_detail_PairwiseSeamFinder>() - 8usize];
    ["Offset of field: cv_detail_PairwiseSeamFinder::images_"]
        [::std::mem::offset_of!(cv_detail_PairwiseSeamFinder, images_) - 8usize];
    ["Offset of field: cv_detail_PairwiseSeamFinder::sizes_"]
        [::std::mem::offset_of!(cv_detail_PairwiseSeamFinder, sizes_) - 32usize];
    ["Offset of field: cv_detail_PairwiseSeamFinder::corners_"]
        [::std::mem::offset_of!(cv_detail_PairwiseSeamFinder, corners_) - 56usize];
    ["Offset of field: cv_detail_PairwiseSeamFinder::masks_"]
        [::std::mem::offset_of!(cv_detail_PairwiseSeamFinder, masks_) - 80usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail18PairwiseSeamFinder3runEv"]
    pub fn cv_detail_PairwiseSeamFinder_run(this: *mut cv_detail_PairwiseSeamFinder);
}
impl cv_detail_PairwiseSeamFinder {
    #[inline]
    pub unsafe fn run(&mut self) {
        cv_detail_PairwiseSeamFinder_run(self)
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail18PairwiseSeamFinder4findERKSt6vectorINS_4UMatESaIS3_EERKS2_INS_6Point_IiEESaIS9_EERS5_"]
    pub fn cv_detail_PairwiseSeamFinder_find(
        this: *mut ::std::os::raw::c_void,
        src: *const std_vector,
        corners: *const std_vector,
        masks: *mut std_vector,
    );
}
#[doc = " @brief Voronoi diagram-based seam estimator."]
#[repr(C)]
pub struct cv_detail_VoronoiSeamFinder {
    pub _base: cv_detail_PairwiseSeamFinder,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_VoronoiSeamFinder"]
        [::std::mem::size_of::<cv_detail_VoronoiSeamFinder>() - 104usize];
    ["Alignment of cv_detail_VoronoiSeamFinder"]
        [::std::mem::align_of::<cv_detail_VoronoiSeamFinder>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail17VoronoiSeamFinder4findERKSt6vectorINS_4UMatESaIS3_EERKS2_INS_6Point_IiEESaIS9_EERS5_"]
    pub fn cv_detail_VoronoiSeamFinder_find(
        this: *mut ::std::os::raw::c_void,
        src: *const std_vector,
        corners: *const std_vector,
        masks: *mut std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail17VoronoiSeamFinder4findERKSt6vectorINS_5Size_IiEESaIS4_EERKS2_INS_6Point_IiEESaISA_EERS2_INS_4UMatESaISF_EE"]
    pub fn cv_detail_VoronoiSeamFinder_find1(
        this: *mut ::std::os::raw::c_void,
        size: *const std_vector,
        corners: *const std_vector,
        masks: *mut std_vector,
    );
}
#[repr(C)]
pub struct cv_detail_DpSeamFinder {
    pub _base: cv_detail_SeamFinder,
    pub costFunc_: cv_detail_DpSeamFinder_CostFunction,
    pub unionTl_: cv_Point,
    pub unionBr_: cv_Point,
    pub unionSize_: cv_Size,
    pub mask1_: cv_Mat_,
    pub mask2_: cv_Mat_,
    pub contour1mask_: cv_Mat_,
    pub contour2mask_: cv_Mat_,
    pub gradx1_: cv_Mat_,
    pub grady1_: cv_Mat_,
    pub gradx2_: cv_Mat_,
    pub grady2_: cv_Mat_,
    pub ncomps_: ::std::os::raw::c_int,
    pub labels_: cv_Mat_,
    pub states_: std_vector,
    pub tls_: std_vector,
    pub brs_: std_vector,
    pub contours_: std_vector,
    pub edges_: std_set,
}
pub const cv_detail_DpSeamFinder_CostFunction_COLOR: cv_detail_DpSeamFinder_CostFunction = 0;
pub const cv_detail_DpSeamFinder_CostFunction_COLOR_GRAD: cv_detail_DpSeamFinder_CostFunction = 1;
pub type cv_detail_DpSeamFinder_CostFunction = ::std::os::raw::c_uint;
pub const cv_detail_DpSeamFinder_ComponentState_FIRST: cv_detail_DpSeamFinder_ComponentState = 1;
pub const cv_detail_DpSeamFinder_ComponentState_SECOND: cv_detail_DpSeamFinder_ComponentState = 2;
pub const cv_detail_DpSeamFinder_ComponentState_INTERS: cv_detail_DpSeamFinder_ComponentState = 4;
pub const cv_detail_DpSeamFinder_ComponentState_INTERS_FIRST:
    cv_detail_DpSeamFinder_ComponentState = 5;
pub const cv_detail_DpSeamFinder_ComponentState_INTERS_SECOND:
    cv_detail_DpSeamFinder_ComponentState = 6;
pub type cv_detail_DpSeamFinder_ComponentState = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_detail_DpSeamFinder_ImagePairLess {
    pub src_: *const cv_Mat,
    pub corners_: *const cv_Point,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_DpSeamFinder_ImagePairLess"]
        [::std::mem::size_of::<cv_detail_DpSeamFinder_ImagePairLess>() - 16usize];
    ["Alignment of cv_detail_DpSeamFinder_ImagePairLess"]
        [::std::mem::align_of::<cv_detail_DpSeamFinder_ImagePairLess>() - 8usize];
    ["Offset of field: cv_detail_DpSeamFinder_ImagePairLess::src_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder_ImagePairLess, src_) - 0usize];
    ["Offset of field: cv_detail_DpSeamFinder_ImagePairLess::corners_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder_ImagePairLess, corners_) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_detail_DpSeamFinder_ClosePoints {
    pub minDist_: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_DpSeamFinder_ClosePoints"]
        [::std::mem::size_of::<cv_detail_DpSeamFinder_ClosePoints>() - 4usize];
    ["Alignment of cv_detail_DpSeamFinder_ClosePoints"]
        [::std::mem::align_of::<cv_detail_DpSeamFinder_ClosePoints>() - 4usize];
    ["Offset of field: cv_detail_DpSeamFinder_ClosePoints::minDist_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder_ClosePoints, minDist_) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_DpSeamFinder"][::std::mem::size_of::<cv_detail_DpSeamFinder>() - 1056usize];
    ["Alignment of cv_detail_DpSeamFinder"]
        [::std::mem::align_of::<cv_detail_DpSeamFinder>() - 8usize];
    ["Offset of field: cv_detail_DpSeamFinder::costFunc_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder, costFunc_) - 8usize];
    ["Offset of field: cv_detail_DpSeamFinder::unionTl_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder, unionTl_) - 12usize];
    ["Offset of field: cv_detail_DpSeamFinder::unionBr_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder, unionBr_) - 20usize];
    ["Offset of field: cv_detail_DpSeamFinder::unionSize_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder, unionSize_) - 28usize];
    ["Offset of field: cv_detail_DpSeamFinder::mask1_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder, mask1_) - 40usize];
    ["Offset of field: cv_detail_DpSeamFinder::mask2_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder, mask2_) - 136usize];
    ["Offset of field: cv_detail_DpSeamFinder::contour1mask_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder, contour1mask_) - 232usize];
    ["Offset of field: cv_detail_DpSeamFinder::contour2mask_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder, contour2mask_) - 328usize];
    ["Offset of field: cv_detail_DpSeamFinder::gradx1_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder, gradx1_) - 424usize];
    ["Offset of field: cv_detail_DpSeamFinder::grady1_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder, grady1_) - 520usize];
    ["Offset of field: cv_detail_DpSeamFinder::gradx2_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder, gradx2_) - 616usize];
    ["Offset of field: cv_detail_DpSeamFinder::grady2_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder, grady2_) - 712usize];
    ["Offset of field: cv_detail_DpSeamFinder::ncomps_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder, ncomps_) - 808usize];
    ["Offset of field: cv_detail_DpSeamFinder::labels_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder, labels_) - 816usize];
    ["Offset of field: cv_detail_DpSeamFinder::states_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder, states_) - 912usize];
    ["Offset of field: cv_detail_DpSeamFinder::tls_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder, tls_) - 936usize];
    ["Offset of field: cv_detail_DpSeamFinder::brs_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder, brs_) - 960usize];
    ["Offset of field: cv_detail_DpSeamFinder::contours_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder, contours_) - 984usize];
    ["Offset of field: cv_detail_DpSeamFinder::edges_"]
        [::std::mem::offset_of!(cv_detail_DpSeamFinder, edges_) - 1008usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail12DpSeamFinder15setCostFunctionENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_detail_DpSeamFinder_setCostFunction(
        this: *mut cv_detail_DpSeamFinder,
        val: cv_String,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail12DpSeamFinderC1ENS1_12CostFunctionE"]
    pub fn cv_detail_DpSeamFinder_DpSeamFinder(
        this: *mut cv_detail_DpSeamFinder,
        costFunc: cv_detail_DpSeamFinder_CostFunction,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail12DpSeamFinderC1ENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_detail_DpSeamFinder_DpSeamFinder1(
        this: *mut cv_detail_DpSeamFinder,
        costFunc: cv_String,
    );
}
impl cv_detail_DpSeamFinder {
    #[inline]
    pub unsafe fn setCostFunction(&mut self, val: cv_String) {
        cv_detail_DpSeamFinder_setCostFunction(self, val)
    }
    #[inline]
    pub unsafe fn new(costFunc: cv_detail_DpSeamFinder_CostFunction) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_detail_DpSeamFinder_DpSeamFinder(__bindgen_tmp.as_mut_ptr(), costFunc);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(costFunc: cv_String) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_detail_DpSeamFinder_DpSeamFinder1(__bindgen_tmp.as_mut_ptr(), costFunc);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail12DpSeamFinder4findERKSt6vectorINS_4UMatESaIS3_EERKS2_INS_6Point_IiEESaIS9_EERS5_"]
    pub fn cv_detail_DpSeamFinder_find(
        this: *mut ::std::os::raw::c_void,
        src: *const std_vector,
        corners: *const std_vector,
        masks: *mut std_vector,
    );
}
#[doc = " @brief Base class for all minimum graph-cut-based seam estimators."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_detail_GraphCutSeamFinderBase {
    pub _address: u8,
}
pub const cv_detail_GraphCutSeamFinderBase_CostType_COST_COLOR:
    cv_detail_GraphCutSeamFinderBase_CostType = 0;
pub const cv_detail_GraphCutSeamFinderBase_CostType_COST_COLOR_GRAD:
    cv_detail_GraphCutSeamFinderBase_CostType = 1;
pub type cv_detail_GraphCutSeamFinderBase_CostType = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_GraphCutSeamFinderBase"]
        [::std::mem::size_of::<cv_detail_GraphCutSeamFinderBase>() - 1usize];
    ["Alignment of cv_detail_GraphCutSeamFinderBase"]
        [::std::mem::align_of::<cv_detail_GraphCutSeamFinderBase>() - 1usize];
};
#[doc = " @brief Minimum graph cut-based seam estimator. See details in @cite V03 ."]
#[repr(C)]
pub struct cv_detail_GraphCutSeamFinder {
    pub _base_1: cv_detail_SeamFinder,
    pub impl_: cv_Ptr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_detail_GraphCutSeamFinder_Impl {
    _unused: [u8; 0],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_GraphCutSeamFinder"]
        [::std::mem::size_of::<cv_detail_GraphCutSeamFinder>() - 24usize];
    ["Alignment of cv_detail_GraphCutSeamFinder"]
        [::std::mem::align_of::<cv_detail_GraphCutSeamFinder>() - 8usize];
    ["Offset of field: cv_detail_GraphCutSeamFinder::impl_"]
        [::std::mem::offset_of!(cv_detail_GraphCutSeamFinder, impl_) - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail18GraphCutSeamFinderC1Eiff"]
    pub fn cv_detail_GraphCutSeamFinder_GraphCutSeamFinder(
        this: *mut cv_detail_GraphCutSeamFinder,
        cost_type: ::std::os::raw::c_int,
        terminal_cost: f32,
        bad_region_penalty: f32,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail18GraphCutSeamFinderC1ENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEff"]
    pub fn cv_detail_GraphCutSeamFinder_GraphCutSeamFinder1(
        this: *mut cv_detail_GraphCutSeamFinder,
        cost_type: cv_String,
        terminal_cost: f32,
        bad_region_penalty: f32,
    );
}
impl cv_detail_GraphCutSeamFinder {
    #[inline]
    pub unsafe fn new(
        cost_type: ::std::os::raw::c_int,
        terminal_cost: f32,
        bad_region_penalty: f32,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_detail_GraphCutSeamFinder_GraphCutSeamFinder(
            __bindgen_tmp.as_mut_ptr(),
            cost_type,
            terminal_cost,
            bad_region_penalty,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(cost_type: cv_String, terminal_cost: f32, bad_region_penalty: f32) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_detail_GraphCutSeamFinder_GraphCutSeamFinder1(
            __bindgen_tmp.as_mut_ptr(),
            cost_type,
            terminal_cost,
            bad_region_penalty,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail18GraphCutSeamFinderD1Ev"]
    pub fn cv_detail_GraphCutSeamFinder_GraphCutSeamFinder_destructor(
        this: *mut cv_detail_GraphCutSeamFinder,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail18GraphCutSeamFinder4findERKSt6vectorINS_4UMatESaIS3_EERKS2_INS_6Point_IiEESaIS9_EERS5_"]
    pub fn cv_detail_GraphCutSeamFinder_find(
        this: *mut ::std::os::raw::c_void,
        src: *const std_vector,
        corners: *const std_vector,
        masks: *mut std_vector,
    );
}
#[repr(C)]
pub struct cv_detail_Blender__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief Base class for all blenders.\n\nSimple blender which puts one image over another"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_Blender {
    pub vtable_: *const cv_detail_Blender__bindgen_vtable,
    pub dst_: cv_UMat,
    pub dst_mask_: cv_UMat,
    pub dst_roi_: cv_Rect,
}
pub const cv_detail_Blender_NO: cv_detail_Blender__bindgen_ty_1 = 0;
pub const cv_detail_Blender_FEATHER: cv_detail_Blender__bindgen_ty_1 = 1;
pub const cv_detail_Blender_MULTI_BAND: cv_detail_Blender__bindgen_ty_1 = 2;
pub type cv_detail_Blender__bindgen_ty_1 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_Blender"][::std::mem::size_of::<cv_detail_Blender>() - 184usize];
    ["Alignment of cv_detail_Blender"][::std::mem::align_of::<cv_detail_Blender>() - 8usize];
    ["Offset of field: cv_detail_Blender::dst_"]
        [::std::mem::offset_of!(cv_detail_Blender, dst_) - 8usize];
    ["Offset of field: cv_detail_Blender::dst_mask_"]
        [::std::mem::offset_of!(cv_detail_Blender, dst_mask_) - 88usize];
    ["Offset of field: cv_detail_Blender::dst_roi_"]
        [::std::mem::offset_of!(cv_detail_Blender, dst_roi_) - 168usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail7Blender13createDefaultEib"]
    pub fn cv_detail_Blender_createDefault(type_: ::std::os::raw::c_int, try_gpu: bool) -> cv_Ptr;
}
impl cv_detail_Blender {
    #[inline]
    pub unsafe fn createDefault(type_: ::std::os::raw::c_int, try_gpu: bool) -> cv_Ptr {
        cv_detail_Blender_createDefault(type_, try_gpu)
    }
}
unsafe extern "C" {
    #[doc = " @brief Prepares the blender for blending.\n\n@param corners Source images top-left corners\n@param sizes Source image sizes"]
    #[link_name = "\u{1}_ZN2cv6detail7Blender7prepareERKSt6vectorINS_6Point_IiEESaIS4_EERKS2_INS_5Size_IiEESaISA_EE"]
    pub fn cv_detail_Blender_prepare(
        this: *mut ::std::os::raw::c_void,
        corners: *const std_vector,
        sizes: *const std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv6detail7Blender7prepareENS_5Rect_IiEE"]
    pub fn cv_detail_Blender_prepare1(this: *mut ::std::os::raw::c_void, dst_roi: cv_Rect);
}
unsafe extern "C" {
    #[doc = " @brief Processes the image.\n\n@param img Source image\n@param mask Source image mask\n@param tl Source image top-left corners"]
    #[link_name = "\u{1}_ZN2cv6detail7Blender4feedERKNS_11_InputArrayES4_NS_6Point_IiEE"]
    pub fn cv_detail_Blender_feed(
        this: *mut ::std::os::raw::c_void,
        img: cv_InputArray,
        mask: cv_InputArray,
        tl: cv_Point,
    );
}
unsafe extern "C" {
    #[doc = " @brief Blends and returns the final pano.\n\n@param dst Final pano\n@param dst_mask Final pano mask"]
    #[link_name = "\u{1}_ZN2cv6detail7Blender5blendERKNS_17_InputOutputArrayES4_"]
    pub fn cv_detail_Blender_blend(
        this: *mut ::std::os::raw::c_void,
        dst: cv_InputOutputArray,
        dst_mask: cv_InputOutputArray,
    );
}
#[doc = " @brief Simple blender which mixes images at its borders."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_detail_FeatherBlender {
    pub _base: cv_detail_Blender,
    pub sharpness_: f32,
    pub weight_map_: cv_UMat,
    pub dst_weight_map_: cv_UMat,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_FeatherBlender"]
        [::std::mem::size_of::<cv_detail_FeatherBlender>() - 352usize];
    ["Alignment of cv_detail_FeatherBlender"]
        [::std::mem::align_of::<cv_detail_FeatherBlender>() - 8usize];
    ["Offset of field: cv_detail_FeatherBlender::sharpness_"]
        [::std::mem::offset_of!(cv_detail_FeatherBlender, sharpness_) - 184usize];
    ["Offset of field: cv_detail_FeatherBlender::weight_map_"]
        [::std::mem::offset_of!(cv_detail_FeatherBlender, weight_map_) - 192usize];
    ["Offset of field: cv_detail_FeatherBlender::dst_weight_map_"]
        [::std::mem::offset_of!(cv_detail_FeatherBlender, dst_weight_map_) - 272usize];
};
unsafe extern "C" {
    #[doc = "! Creates weight maps for fixed set of source images by their masks and top-left corners.\n! Final image can be obtained by simple weighting of the source images."]
    #[link_name = "\u{1}_ZN2cv6detail14FeatherBlender16createWeightMapsERKSt6vectorINS_4UMatESaIS3_EERKS2_INS_6Point_IiEESaIS9_EERS5_"]
    pub fn cv_detail_FeatherBlender_createWeightMaps(
        this: *mut cv_detail_FeatherBlender,
        masks: *const std_vector,
        corners: *const std_vector,
        weight_maps: *mut std_vector,
    ) -> cv_Rect;
}
impl cv_detail_FeatherBlender {
    #[inline]
    pub unsafe fn createWeightMaps(
        &mut self,
        masks: *const std_vector,
        corners: *const std_vector,
        weight_maps: *mut std_vector,
    ) -> cv_Rect {
        cv_detail_FeatherBlender_createWeightMaps(self, masks, corners, weight_maps)
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail14FeatherBlender7prepareENS_5Rect_IiEE"]
    pub fn cv_detail_FeatherBlender_prepare(this: *mut ::std::os::raw::c_void, dst_roi: cv_Rect);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail14FeatherBlender4feedERKNS_11_InputArrayES4_NS_6Point_IiEE"]
    pub fn cv_detail_FeatherBlender_feed(
        this: *mut ::std::os::raw::c_void,
        img: cv_InputArray,
        mask: cv_InputArray,
        tl: cv_Point,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail14FeatherBlender5blendERKNS_17_InputOutputArrayES4_"]
    pub fn cv_detail_FeatherBlender_blend(
        this: *mut ::std::os::raw::c_void,
        dst: cv_InputOutputArray,
        dst_mask: cv_InputOutputArray,
    );
}
#[doc = " @brief Blender which uses multi-band blending algorithm (see @cite BA83)."]
#[repr(C)]
pub struct cv_detail_MultiBandBlender {
    pub _base: cv_detail_Blender,
    pub actual_num_bands_: ::std::os::raw::c_int,
    pub num_bands_: ::std::os::raw::c_int,
    pub dst_pyr_laplace_: std_vector,
    pub dst_band_weights_: std_vector,
    pub dst_roi_final_: cv_Rect,
    pub can_use_gpu_: bool,
    pub weight_type_: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_detail_MultiBandBlender"]
        [::std::mem::size_of::<cv_detail_MultiBandBlender>() - 264usize];
    ["Alignment of cv_detail_MultiBandBlender"]
        [::std::mem::align_of::<cv_detail_MultiBandBlender>() - 8usize];
    ["Offset of field: cv_detail_MultiBandBlender::actual_num_bands_"]
        [::std::mem::offset_of!(cv_detail_MultiBandBlender, actual_num_bands_) - 184usize];
    ["Offset of field: cv_detail_MultiBandBlender::num_bands_"]
        [::std::mem::offset_of!(cv_detail_MultiBandBlender, num_bands_) - 188usize];
    ["Offset of field: cv_detail_MultiBandBlender::dst_pyr_laplace_"]
        [::std::mem::offset_of!(cv_detail_MultiBandBlender, dst_pyr_laplace_) - 192usize];
    ["Offset of field: cv_detail_MultiBandBlender::dst_band_weights_"]
        [::std::mem::offset_of!(cv_detail_MultiBandBlender, dst_band_weights_) - 216usize];
    ["Offset of field: cv_detail_MultiBandBlender::dst_roi_final_"]
        [::std::mem::offset_of!(cv_detail_MultiBandBlender, dst_roi_final_) - 240usize];
    ["Offset of field: cv_detail_MultiBandBlender::can_use_gpu_"]
        [::std::mem::offset_of!(cv_detail_MultiBandBlender, can_use_gpu_) - 256usize];
    ["Offset of field: cv_detail_MultiBandBlender::weight_type_"]
        [::std::mem::offset_of!(cv_detail_MultiBandBlender, weight_type_) - 260usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail16MultiBandBlenderC1Eiii"]
    pub fn cv_detail_MultiBandBlender_MultiBandBlender(
        this: *mut cv_detail_MultiBandBlender,
        try_gpu: ::std::os::raw::c_int,
        num_bands: ::std::os::raw::c_int,
        weight_type: ::std::os::raw::c_int,
    );
}
impl cv_detail_MultiBandBlender {
    #[inline]
    pub unsafe fn new(
        try_gpu: ::std::os::raw::c_int,
        num_bands: ::std::os::raw::c_int,
        weight_type: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_detail_MultiBandBlender_MultiBandBlender(
            __bindgen_tmp.as_mut_ptr(),
            try_gpu,
            num_bands,
            weight_type,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail16MultiBandBlender7prepareENS_5Rect_IiEE"]
    pub fn cv_detail_MultiBandBlender_prepare(this: *mut ::std::os::raw::c_void, dst_roi: cv_Rect);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail16MultiBandBlender4feedERKNS_11_InputArrayES4_NS_6Point_IiEE"]
    pub fn cv_detail_MultiBandBlender_feed(
        this: *mut ::std::os::raw::c_void,
        img: cv_InputArray,
        mask: cv_InputArray,
        tl: cv_Point,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail16MultiBandBlender5blendERKNS_17_InputOutputArrayES4_"]
    pub fn cv_detail_MultiBandBlender_blend(
        this: *mut ::std::os::raw::c_void,
        dst: cv_InputOutputArray,
        dst_mask: cv_InputOutputArray,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail23normalizeUsingWeightMapERKNS_11_InputArrayERKNS_17_InputOutputArrayE"]
    pub fn cv_detail_normalizeUsingWeightMap(weight: cv_InputArray, src: cv_InputOutputArray);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail15createWeightMapERKNS_11_InputArrayEfRKNS_17_InputOutputArrayE"]
    pub fn cv_detail_createWeightMap(
        mask: cv_InputArray,
        sharpness: f32,
        weight: cv_InputOutputArray,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail16createLaplacePyrERKNS_11_InputArrayEiRSt6vectorINS_4UMatESaIS5_EE"]
    pub fn cv_detail_createLaplacePyr(
        img: cv_InputArray,
        num_levels: ::std::os::raw::c_int,
        pyr: *mut std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail19createLaplacePyrGpuERKNS_11_InputArrayEiRSt6vectorINS_4UMatESaIS5_EE"]
    pub fn cv_detail_createLaplacePyrGpu(
        img: cv_InputArray,
        num_levels: ::std::os::raw::c_int,
        pyr: *mut std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail26restoreImageFromLaplacePyrERSt6vectorINS_4UMatESaIS2_EE"]
    pub fn cv_detail_restoreImageFromLaplacePyr(pyr: *mut std_vector);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv6detail29restoreImageFromLaplacePyrGpuERSt6vectorINS_4UMatESaIS2_EE"]
    pub fn cv_detail_restoreImageFromLaplacePyrGpu(pyr: *mut std_vector);
}
#[doc = " @brief Template \"trait\" class for OpenCV primitive data types.\n\n@note Deprecated. This is replaced by \"single purpose\" traits: traits::Type and traits::Depth\n\nA primitive OpenCV data type is one of unsigned char, bool, signed char, unsigned short, signed\nshort, int, float, double, or a tuple of values of one of these types, where all the values in the\ntuple have the same type. Any primitive type from the list can be defined by an identifier in the\nform CV_\\<bit-depth\\>{U|S|F}C(\\<number_of_channels\\>), for example: uchar \\~ CV_8UC1, 3-element\nfloating-point tuple \\~ CV_32FC3, and so on. A universal OpenCV structure that is able to store a\nsingle instance of such a primitive data type is Vec. Multiple instances of such a type can be\nstored in a std::vector, Mat, Mat_, SparseMat, SparseMat_, or any other container that is able to\nstore Vec instances.\n\nThe DataType class is basically used to provide a description of such primitive data types without\nadding any fields or methods to the corresponding classes (and it is actually impossible to add\nanything to primitive C/C++ data types). This technique is known in C++ as class traits. It is not\nDataType itself that is used but its specialized versions, such as:\n@code\ntemplate<> class DataType<uchar>\n{\ntypedef uchar value_type;\ntypedef int work_type;\ntypedef uchar channel_type;\nenum { channel_type = CV_8U, channels = 1, fmt='u', type = CV_8U };\n};\n...\ntemplate<typename _Tp> DataType<std::complex<_Tp> >\n{\ntypedef std::complex<_Tp> value_type;\ntypedef std::complex<_Tp> work_type;\ntypedef _Tp channel_type;\n// DataDepth is another helper trait class\nenum { depth = DataDepth<_Tp>::value, channels=2,\nfmt=(channels-1)*256+DataDepth<_Tp>::fmt,\ntype=CV_MAKETYPE(depth, channels) };\n};\n...\n@endcode\nThe main purpose of this class is to convert compilation-time type information to an\nOpenCV-compatible data type identifier, for example:\n@code\n// allocates a 30x40 floating-point matrix\nMat A(30, 40, DataType<float>::type);\n\nMat B = Mat_<std::complex<double> >(3, 3);\n// the statement below will print 6, 2 , that is depth == CV_64F, channels == 2\ncout << B.depth() << \", \" << B.channels() << endl;\n@endcode\nSo, such traits are used to tell OpenCV which data type you are working with, even if such a type is\nnot native to OpenCV. For example, the matrix B initialization above is compiled because OpenCV\ndefines the proper specialized template class DataType\\<complex\\<_Tp\\> \\> . This mechanism is also\nuseful (and used in OpenCV this way) for generic algorithms implementations.\n\n@note Default values were dropped to stop confusing developers about using of unsupported types (see #7599)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_DataType {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_DataType_open0_bool__close0"]
        [::std::mem::size_of::<cv_DataType>() - 1usize];
    ["Align of template specialization: cv_DataType_open0_bool__close0"]
        [::std::mem::align_of::<cv_DataType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_DataType_open0_unsigned_char_close0"]
        [::std::mem::size_of::<cv_DataType>() - 1usize];
    ["Align of template specialization: cv_DataType_open0_unsigned_char_close0"]
        [::std::mem::align_of::<cv_DataType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_DataType_open0_signed_char_close0"]
        [::std::mem::size_of::<cv_DataType>() - 1usize];
    ["Align of template specialization: cv_DataType_open0_signed_char_close0"]
        [::std::mem::align_of::<cv_DataType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_DataType_open0_char_close0"]
        [::std::mem::size_of::<cv_DataType>() - 1usize];
    ["Align of template specialization: cv_DataType_open0_char_close0"]
        [::std::mem::align_of::<cv_DataType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_DataType_open0_unsigned_short_close0"]
        [::std::mem::size_of::<cv_DataType>() - 1usize];
    ["Align of template specialization: cv_DataType_open0_unsigned_short_close0"]
        [::std::mem::align_of::<cv_DataType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_DataType_open0_short_close0"]
        [::std::mem::size_of::<cv_DataType>() - 1usize];
    ["Align of template specialization: cv_DataType_open0_short_close0"]
        [::std::mem::align_of::<cv_DataType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_DataType_open0_int_close0"]
        [::std::mem::size_of::<cv_DataType>() - 1usize];
    ["Align of template specialization: cv_DataType_open0_int_close0"]
        [::std::mem::align_of::<cv_DataType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_DataType_open0_float_close0"]
        [::std::mem::size_of::<cv_DataType>() - 1usize];
    ["Align of template specialization: cv_DataType_open0_float_close0"]
        [::std::mem::align_of::<cv_DataType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_DataType_open0_double_close0"]
        [::std::mem::size_of::<cv_DataType>() - 1usize];
    ["Align of template specialization: cv_DataType_open0_double_close0"]
        [::std::mem::align_of::<cv_DataType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_DataType_open0_cv_float16_t_close0"]
        [::std::mem::size_of::<cv_DataType>() - 1usize];
    ["Align of template specialization: cv_DataType_open0_cv_float16_t_close0"]
        [::std::mem::align_of::<cv_DataType>() - 1usize];
};
#[doc = " @brief A helper class for cv::DataType\n\nThe class is specialized for each fundamental numerical data type supported by OpenCV. It provides\nDataDepth<T>::value constant."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_DataDepth {
    pub _address: u8,
}
pub const cv_DataDepth_value: cv_DataDepth__bindgen_ty_1 = 0;
pub const cv_DataDepth_fmt: cv_DataDepth__bindgen_ty_1 = 0;
pub type cv_DataDepth__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_traits_internal_CheckMember_fmt {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_traits_internal_CheckMember_fmt_Fallback {
    pub fmt: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_traits_internal_CheckMember_fmt_Derived<T> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    pub _base: T,
    pub _base_1: cv_traits_internal_CheckMember_fmt_Fallback,
}
pub type cv_traits_internal_CheckMember_fmt_CV_NO = [::std::os::raw::c_char; 1usize];
pub type cv_traits_internal_CheckMember_fmt_CV_YES = [::std::os::raw::c_char; 2usize];
pub type cv_traits_internal_CheckMember_fmt_type = cv_traits_internal_CheckMember_fmt;
pub const cv_traits_internal_CheckMember_fmt_value:
    cv_traits_internal_CheckMember_fmt__bindgen_ty_1 = 0;
pub type cv_traits_internal_CheckMember_fmt__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_traits_internal_CheckMember_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_traits_internal_CheckMember_type_Fallback {
    pub type_: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_traits_internal_CheckMember_type_Derived<T> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    pub _base: T,
    pub _base_1: cv_traits_internal_CheckMember_type_Fallback,
}
pub type cv_traits_internal_CheckMember_type_CV_NO = [::std::os::raw::c_char; 1usize];
pub type cv_traits_internal_CheckMember_type_CV_YES = [::std::os::raw::c_char; 2usize];
pub type cv_traits_internal_CheckMember_type_type = cv_traits_internal_CheckMember_type;
pub const cv_traits_internal_CheckMember_type_value:
    cv_traits_internal_CheckMember_type__bindgen_ty_1 = 0;
pub type cv_traits_internal_CheckMember_type__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_traits_Depth {
    pub _address: u8,
}
pub const cv_traits_Depth_value: cv_traits_Depth__bindgen_ty_1 = 0;
pub type cv_traits_Depth__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_traits_Type {
    pub _address: u8,
}
pub const cv_traits_Type_value: cv_traits_Type__bindgen_ty_1 = 0;
pub type cv_traits_Type__bindgen_ty_1 = i32;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_traits_Depth_open0_cv_RotatedRect_close0"]
        [::std::mem::size_of::<cv_traits_Depth>() - 1usize];
    ["Align of template specialization: cv_traits_Depth_open0_cv_RotatedRect_close0"]
        [::std::mem::align_of::<cv_traits_Depth>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_traits_Type_open0_cv_RotatedRect_close0"]
        [::std::mem::size_of::<cv_traits_Type>() - 1usize];
    ["Align of template specialization: cv_traits_Type_open0_cv_RotatedRect_close0"]
        [::std::mem::align_of::<cv_traits_Type>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_traits_Depth_open0_cv_Range_close0"]
        [::std::mem::size_of::<cv_traits_Depth>() - 1usize];
    ["Align of template specialization: cv_traits_Depth_open0_cv_Range_close0"]
        [::std::mem::align_of::<cv_traits_Depth>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_traits_Type_open0_cv_Range_close0"]
        [::std::mem::size_of::<cv_traits_Type>() - 1usize];
    ["Align of template specialization: cv_traits_Type_open0_cv_Range_close0"]
        [::std::mem::align_of::<cv_traits_Type>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_traits_Depth_open0_cv_Moments_close0"]
        [::std::mem::size_of::<cv_traits_Depth>() - 1usize];
    ["Align of template specialization: cv_traits_Depth_open0_cv_Moments_close0"]
        [::std::mem::align_of::<cv_traits_Depth>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_traits_Type_open0_cv_Moments_close0"]
        [::std::mem::size_of::<cv_traits_Type>() - 1usize];
    ["Align of template specialization: cv_traits_Type_open0_cv_Moments_close0"]
        [::std::mem::align_of::<cv_traits_Type>() - 1usize];
};
#[doc = "! @cond IGNORED"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_Matx_AddOp {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_Matx_AddOp"][::std::mem::size_of::<cv_Matx_AddOp>() - 1usize];
    ["Alignment of cv_Matx_AddOp"][::std::mem::align_of::<cv_Matx_AddOp>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_Matx_SubOp {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_Matx_SubOp"][::std::mem::size_of::<cv_Matx_SubOp>() - 1usize];
    ["Alignment of cv_Matx_SubOp"][::std::mem::align_of::<cv_Matx_SubOp>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_Matx_ScaleOp {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_Matx_ScaleOp"][::std::mem::size_of::<cv_Matx_ScaleOp>() - 1usize];
    ["Alignment of cv_Matx_ScaleOp"][::std::mem::align_of::<cv_Matx_ScaleOp>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_Matx_MulOp {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_Matx_MulOp"][::std::mem::size_of::<cv_Matx_MulOp>() - 1usize];
    ["Alignment of cv_Matx_MulOp"][::std::mem::align_of::<cv_Matx_MulOp>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_Matx_DivOp {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_Matx_DivOp"][::std::mem::size_of::<cv_Matx_DivOp>() - 1usize];
    ["Alignment of cv_Matx_DivOp"][::std::mem::align_of::<cv_Matx_DivOp>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_Matx_MatMulOp {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_Matx_MatMulOp"][::std::mem::size_of::<cv_Matx_MatMulOp>() - 1usize];
    ["Alignment of cv_Matx_MatMulOp"][::std::mem::align_of::<cv_Matx_MatMulOp>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_Matx_TOp {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_Matx_TOp"][::std::mem::size_of::<cv_Matx_TOp>() - 1usize];
    ["Alignment of cv_Matx_TOp"][::std::mem::align_of::<cv_Matx_TOp>() - 1usize];
};
pub const cv_Matx_rows: cv_Matx__bindgen_ty_1 = 0;
pub const cv_Matx_cols: cv_Matx__bindgen_ty_1 = 0;
pub const cv_Matx_channels: cv_Matx__bindgen_ty_1 = 0;
pub const cv_Matx_shortdim: cv_Matx__bindgen_ty_1 = 0;
pub type cv_Matx__bindgen_ty_1 = i32;
pub type cv_Matx_value_type<_Tp> = _Tp;
#[doc = " @brief Template class for small matrices whose type and size are known at compilation time\n\nIf you need a more flexible type, use Mat . The elements of the matrix M are accessible using the\nM(i,j) notation. Most of the common matrix operations (see also @ref MatrixExpressions ) are\navailable. To do an operation on Matx that is not implemented, you can easily convert the matrix to\nMat and backwards:\n@code{.cpp}\nMatx33f m(1, 2, 3,\n4, 5, 6,\n7, 8, 9);\ncout << sum(Mat(m*m.t())) << endl;\n@endcode\nExcept of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:\n@code{.cpp}\nfloat values[] = { 1, 2, 3};\nMatx31f m(values);\n@endcode\nIn case if C++11 features are available, std::initializer_list can be also used to initialize Matx:\n@code{.cpp}\nMatx31f m = { 1, 2, 3};\n@endcode"]
pub type cv_Matx_mat_type = u8;
#[doc = " @brief Template class for small matrices whose type and size are known at compilation time\n\nIf you need a more flexible type, use Mat . The elements of the matrix M are accessible using the\nM(i,j) notation. Most of the common matrix operations (see also @ref MatrixExpressions ) are\navailable. To do an operation on Matx that is not implemented, you can easily convert the matrix to\nMat and backwards:\n@code{.cpp}\nMatx33f m(1, 2, 3,\n4, 5, 6,\n7, 8, 9);\ncout << sum(Mat(m*m.t())) << endl;\n@endcode\nExcept of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:\n@code{.cpp}\nfloat values[] = { 1, 2, 3};\nMatx31f m(values);\n@endcode\nIn case if C++11 features are available, std::initializer_list can be also used to initialize Matx:\n@code{.cpp}\nMatx31f m = { 1, 2, 3};\n@endcode"]
pub type cv_Matx_diag_type = u8;
#[doc = " @brief Template class for small matrices whose type and size are known at compilation time\n\nIf you need a more flexible type, use Mat . The elements of the matrix M are accessible using the\nM(i,j) notation. Most of the common matrix operations (see also @ref MatrixExpressions ) are\navailable. To do an operation on Matx that is not implemented, you can easily convert the matrix to\nMat and backwards:\n@code{.cpp}\nMatx33f m(1, 2, 3,\n4, 5, 6,\n7, 8, 9);\ncout << sum(Mat(m*m.t())) << endl;\n@endcode\nExcept of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:\n@code{.cpp}\nfloat values[] = { 1, 2, 3};\nMatx31f m(values);\n@endcode\nIn case if C++11 features are available, std::initializer_list can be also used to initialize Matx:\n@code{.cpp}\nMatx31f m = { 1, 2, 3};\n@endcode"]
pub type cv_Matx12f = __BindgenOpaqueArray<u32, 2usize>;
#[doc = " @brief Template class for small matrices whose type and size are known at compilation time\n\nIf you need a more flexible type, use Mat . The elements of the matrix M are accessible using the\nM(i,j) notation. Most of the common matrix operations (see also @ref MatrixExpressions ) are\navailable. To do an operation on Matx that is not implemented, you can easily convert the matrix to\nMat and backwards:\n@code{.cpp}\nMatx33f m(1, 2, 3,\n4, 5, 6,\n7, 8, 9);\ncout << sum(Mat(m*m.t())) << endl;\n@endcode\nExcept of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:\n@code{.cpp}\nfloat values[] = { 1, 2, 3};\nMatx31f m(values);\n@endcode\nIn case if C++11 features are available, std::initializer_list can be also used to initialize Matx:\n@code{.cpp}\nMatx31f m = { 1, 2, 3};\n@endcode"]
pub type cv_Matx12d = __BindgenOpaqueArray<u64, 2usize>;
pub type cv_Matx13f = u8;
pub type cv_Matx13d = u8;
pub type cv_Matx14f = u8;
pub type cv_Matx14d = u8;
pub type cv_Matx16f = u8;
pub type cv_Matx16d = u8;
#[doc = " @brief Template class for small matrices whose type and size are known at compilation time\n\nIf you need a more flexible type, use Mat . The elements of the matrix M are accessible using the\nM(i,j) notation. Most of the common matrix operations (see also @ref MatrixExpressions ) are\navailable. To do an operation on Matx that is not implemented, you can easily convert the matrix to\nMat and backwards:\n@code{.cpp}\nMatx33f m(1, 2, 3,\n4, 5, 6,\n7, 8, 9);\ncout << sum(Mat(m*m.t())) << endl;\n@endcode\nExcept of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:\n@code{.cpp}\nfloat values[] = { 1, 2, 3};\nMatx31f m(values);\n@endcode\nIn case if C++11 features are available, std::initializer_list can be also used to initialize Matx:\n@code{.cpp}\nMatx31f m = { 1, 2, 3};\n@endcode"]
pub type cv_Matx21f = __BindgenOpaqueArray<u32, 2usize>;
#[doc = " @brief Template class for small matrices whose type and size are known at compilation time\n\nIf you need a more flexible type, use Mat . The elements of the matrix M are accessible using the\nM(i,j) notation. Most of the common matrix operations (see also @ref MatrixExpressions ) are\navailable. To do an operation on Matx that is not implemented, you can easily convert the matrix to\nMat and backwards:\n@code{.cpp}\nMatx33f m(1, 2, 3,\n4, 5, 6,\n7, 8, 9);\ncout << sum(Mat(m*m.t())) << endl;\n@endcode\nExcept of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:\n@code{.cpp}\nfloat values[] = { 1, 2, 3};\nMatx31f m(values);\n@endcode\nIn case if C++11 features are available, std::initializer_list can be also used to initialize Matx:\n@code{.cpp}\nMatx31f m = { 1, 2, 3};\n@endcode"]
pub type cv_Matx21d = __BindgenOpaqueArray<u64, 2usize>;
#[doc = " @brief Template class for small matrices whose type and size are known at compilation time\n\nIf you need a more flexible type, use Mat . The elements of the matrix M are accessible using the\nM(i,j) notation. Most of the common matrix operations (see also @ref MatrixExpressions ) are\navailable. To do an operation on Matx that is not implemented, you can easily convert the matrix to\nMat and backwards:\n@code{.cpp}\nMatx33f m(1, 2, 3,\n4, 5, 6,\n7, 8, 9);\ncout << sum(Mat(m*m.t())) << endl;\n@endcode\nExcept of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:\n@code{.cpp}\nfloat values[] = { 1, 2, 3};\nMatx31f m(values);\n@endcode\nIn case if C++11 features are available, std::initializer_list can be also used to initialize Matx:\n@code{.cpp}\nMatx31f m = { 1, 2, 3};\n@endcode"]
pub type cv_Matx31f = __BindgenOpaqueArray<u32, 3usize>;
#[doc = " @brief Template class for small matrices whose type and size are known at compilation time\n\nIf you need a more flexible type, use Mat . The elements of the matrix M are accessible using the\nM(i,j) notation. Most of the common matrix operations (see also @ref MatrixExpressions ) are\navailable. To do an operation on Matx that is not implemented, you can easily convert the matrix to\nMat and backwards:\n@code{.cpp}\nMatx33f m(1, 2, 3,\n4, 5, 6,\n7, 8, 9);\ncout << sum(Mat(m*m.t())) << endl;\n@endcode\nExcept of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:\n@code{.cpp}\nfloat values[] = { 1, 2, 3};\nMatx31f m(values);\n@endcode\nIn case if C++11 features are available, std::initializer_list can be also used to initialize Matx:\n@code{.cpp}\nMatx31f m = { 1, 2, 3};\n@endcode"]
pub type cv_Matx31d = __BindgenOpaqueArray<u64, 3usize>;
#[doc = " @brief Template class for small matrices whose type and size are known at compilation time\n\nIf you need a more flexible type, use Mat . The elements of the matrix M are accessible using the\nM(i,j) notation. Most of the common matrix operations (see also @ref MatrixExpressions ) are\navailable. To do an operation on Matx that is not implemented, you can easily convert the matrix to\nMat and backwards:\n@code{.cpp}\nMatx33f m(1, 2, 3,\n4, 5, 6,\n7, 8, 9);\ncout << sum(Mat(m*m.t())) << endl;\n@endcode\nExcept of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:\n@code{.cpp}\nfloat values[] = { 1, 2, 3};\nMatx31f m(values);\n@endcode\nIn case if C++11 features are available, std::initializer_list can be also used to initialize Matx:\n@code{.cpp}\nMatx31f m = { 1, 2, 3};\n@endcode"]
pub type cv_Matx41f = __BindgenOpaqueArray<u32, 4usize>;
#[doc = " @brief Template class for small matrices whose type and size are known at compilation time\n\nIf you need a more flexible type, use Mat . The elements of the matrix M are accessible using the\nM(i,j) notation. Most of the common matrix operations (see also @ref MatrixExpressions ) are\navailable. To do an operation on Matx that is not implemented, you can easily convert the matrix to\nMat and backwards:\n@code{.cpp}\nMatx33f m(1, 2, 3,\n4, 5, 6,\n7, 8, 9);\ncout << sum(Mat(m*m.t())) << endl;\n@endcode\nExcept of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:\n@code{.cpp}\nfloat values[] = { 1, 2, 3};\nMatx31f m(values);\n@endcode\nIn case if C++11 features are available, std::initializer_list can be also used to initialize Matx:\n@code{.cpp}\nMatx31f m = { 1, 2, 3};\n@endcode"]
pub type cv_Matx41d = __BindgenOpaqueArray<u64, 4usize>;
pub type cv_Matx61f = u8;
pub type cv_Matx61d = u8;
pub type cv_Matx22f = u8;
pub type cv_Matx22d = u8;
pub type cv_Matx23f = u8;
#[doc = " @brief Template class for small matrices whose type and size are known at compilation time\n\nIf you need a more flexible type, use Mat . The elements of the matrix M are accessible using the\nM(i,j) notation. Most of the common matrix operations (see also @ref MatrixExpressions ) are\navailable. To do an operation on Matx that is not implemented, you can easily convert the matrix to\nMat and backwards:\n@code{.cpp}\nMatx33f m(1, 2, 3,\n4, 5, 6,\n7, 8, 9);\ncout << sum(Mat(m*m.t())) << endl;\n@endcode\nExcept of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:\n@code{.cpp}\nfloat values[] = { 1, 2, 3};\nMatx31f m(values);\n@endcode\nIn case if C++11 features are available, std::initializer_list can be also used to initialize Matx:\n@code{.cpp}\nMatx31f m = { 1, 2, 3};\n@endcode"]
pub type cv_Matx23d = __BindgenOpaqueArray<u64, 6usize>;
pub type cv_Matx32f = u8;
pub type cv_Matx32d = u8;
#[doc = " @brief Template class for small matrices whose type and size are known at compilation time\n\nIf you need a more flexible type, use Mat . The elements of the matrix M are accessible using the\nM(i,j) notation. Most of the common matrix operations (see also @ref MatrixExpressions ) are\navailable. To do an operation on Matx that is not implemented, you can easily convert the matrix to\nMat and backwards:\n@code{.cpp}\nMatx33f m(1, 2, 3,\n4, 5, 6,\n7, 8, 9);\ncout << sum(Mat(m*m.t())) << endl;\n@endcode\nExcept of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:\n@code{.cpp}\nfloat values[] = { 1, 2, 3};\nMatx31f m(values);\n@endcode\nIn case if C++11 features are available, std::initializer_list can be also used to initialize Matx:\n@code{.cpp}\nMatx31f m = { 1, 2, 3};\n@endcode"]
pub type cv_Matx33f = __BindgenOpaqueArray<u32, 9usize>;
#[doc = " @brief Template class for small matrices whose type and size are known at compilation time\n\nIf you need a more flexible type, use Mat . The elements of the matrix M are accessible using the\nM(i,j) notation. Most of the common matrix operations (see also @ref MatrixExpressions ) are\navailable. To do an operation on Matx that is not implemented, you can easily convert the matrix to\nMat and backwards:\n@code{.cpp}\nMatx33f m(1, 2, 3,\n4, 5, 6,\n7, 8, 9);\ncout << sum(Mat(m*m.t())) << endl;\n@endcode\nExcept of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:\n@code{.cpp}\nfloat values[] = { 1, 2, 3};\nMatx31f m(values);\n@endcode\nIn case if C++11 features are available, std::initializer_list can be also used to initialize Matx:\n@code{.cpp}\nMatx31f m = { 1, 2, 3};\n@endcode"]
pub type cv_Matx33d = __BindgenOpaqueArray<u64, 9usize>;
pub type cv_Matx34f = u8;
pub type cv_Matx34d = u8;
pub type cv_Matx43f = u8;
pub type cv_Matx43d = u8;
#[doc = " @brief Template class for small matrices whose type and size are known at compilation time\n\nIf you need a more flexible type, use Mat . The elements of the matrix M are accessible using the\nM(i,j) notation. Most of the common matrix operations (see also @ref MatrixExpressions ) are\navailable. To do an operation on Matx that is not implemented, you can easily convert the matrix to\nMat and backwards:\n@code{.cpp}\nMatx33f m(1, 2, 3,\n4, 5, 6,\n7, 8, 9);\ncout << sum(Mat(m*m.t())) << endl;\n@endcode\nExcept of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:\n@code{.cpp}\nfloat values[] = { 1, 2, 3};\nMatx31f m(values);\n@endcode\nIn case if C++11 features are available, std::initializer_list can be also used to initialize Matx:\n@code{.cpp}\nMatx31f m = { 1, 2, 3};\n@endcode"]
pub type cv_Matx44f = __BindgenOpaqueArray<u32, 16usize>;
#[doc = " @brief Template class for small matrices whose type and size are known at compilation time\n\nIf you need a more flexible type, use Mat . The elements of the matrix M are accessible using the\nM(i,j) notation. Most of the common matrix operations (see also @ref MatrixExpressions ) are\navailable. To do an operation on Matx that is not implemented, you can easily convert the matrix to\nMat and backwards:\n@code{.cpp}\nMatx33f m(1, 2, 3,\n4, 5, 6,\n7, 8, 9);\ncout << sum(Mat(m*m.t())) << endl;\n@endcode\nExcept of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:\n@code{.cpp}\nfloat values[] = { 1, 2, 3};\nMatx31f m(values);\n@endcode\nIn case if C++11 features are available, std::initializer_list can be also used to initialize Matx:\n@code{.cpp}\nMatx31f m = { 1, 2, 3};\n@endcode"]
pub type cv_Matx44d = __BindgenOpaqueArray<u64, 16usize>;
pub type cv_Matx66f = u8;
pub type cv_Matx66d = u8;
pub type cv_Vec_value_type<_Tp> = _Tp;
pub const cv_Vec_channels: cv_Vec__bindgen_ty_1 = 0;
pub const cv_Vec__dummy_enum_finalizer: cv_Vec__bindgen_ty_1 = 0;
pub type cv_Vec__bindgen_ty_1 = i32;
#[doc = " @name Shorter aliases for the most popular specializations of Vec<T,n>\n@{"]
pub type cv_Vec2b = u8;
#[doc = "! @cond IGNORED"]
pub type cv_Vec3b = __BindgenOpaqueArray<u8, 3usize>;
pub type cv_Vec4b = u8;
pub type cv_Vec2s = u8;
pub type cv_Vec3s = u8;
pub type cv_Vec4s = u8;
pub type cv_Vec2w = u8;
pub type cv_Vec3w = u8;
pub type cv_Vec4w = u8;
#[doc = "! @cond IGNORED"]
pub type cv_Vec2i = __BindgenOpaqueArray<u32, 2usize>;
pub type cv_Vec3i = u8;
pub type cv_Vec4i = u8;
pub type cv_Vec6i = u8;
pub type cv_Vec8i = u8;
#[doc = "! @cond IGNORED"]
pub type cv_Vec2f = __BindgenOpaqueArray<u32, 2usize>;
#[doc = "! @cond IGNORED"]
pub type cv_Vec3f = __BindgenOpaqueArray<u32, 3usize>;
#[doc = "! @cond IGNORED"]
pub type cv_Vec4f = __BindgenOpaqueArray<u32, 4usize>;
pub type cv_Vec6f = u8;
#[doc = "! @cond IGNORED"]
pub type cv_Vec2d = __BindgenOpaqueArray<u64, 2usize>;
#[doc = "! @cond IGNORED"]
pub type cv_Vec3d = __BindgenOpaqueArray<u64, 3usize>;
#[doc = "! @cond IGNORED"]
pub type cv_Vec4d = __BindgenOpaqueArray<u64, 4usize>;
pub type cv_Vec6d = u8;
#[repr(C)]
#[derive(Debug)]
pub struct cv_internal_WriteStructContext {
    pub fs: *mut cv_FileStorage,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_internal_WriteStructContext"]
        [::std::mem::size_of::<cv_internal_WriteStructContext>() - 8usize];
    ["Alignment of cv_internal_WriteStructContext"]
        [::std::mem::align_of::<cv_internal_WriteStructContext>() - 8usize];
    ["Offset of field: cv_internal_WriteStructContext::fs"]
        [::std::mem::offset_of!(cv_internal_WriteStructContext, fs) - 0usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8internal18WriteStructContextC1ERNS_11FileStorageERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiSB_"]
    pub fn cv_internal_WriteStructContext_WriteStructContext(
        this: *mut cv_internal_WriteStructContext,
        _fs: *mut cv_FileStorage,
        name: *const cv_String,
        flags: ::std::os::raw::c_int,
        typeName: *const cv_String,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8internal18WriteStructContextD1Ev"]
    pub fn cv_internal_WriteStructContext_WriteStructContext_destructor(
        this: *mut cv_internal_WriteStructContext,
    );
}
impl cv_internal_WriteStructContext {
    #[inline]
    pub unsafe fn new(
        _fs: *mut cv_FileStorage,
        name: *const cv_String,
        flags: ::std::os::raw::c_int,
        typeName: *const cv_String,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_internal_WriteStructContext_WriteStructContext(
            __bindgen_tmp.as_mut_ptr(),
            _fs,
            name,
            flags,
            typeName,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cv_internal_WriteStructContext_WriteStructContext_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_internal_VideoCapturePrivateAccessor {
    _unused: [u8; 0],
}
#[doc = " @brief  A complex number class.\n\nThe template class is similar and compatible with std::complex, however it provides slightly\nmore convenient access to the real and imaginary parts using through the simple field access, as opposite\nto std::complex::real() and std::complex::imag()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_Complex<_Tp> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
    pub re: _Tp,
    pub im: _Tp,
}
pub type cv_Complexf = cv_Complex<f32>;
pub type cv_Complexd = cv_Complex<f64>;
#[doc = " @brief Template class for 2D points specified by its coordinates `x` and `y`.\n\nAn instance of the class is interchangeable with C structures, CvPoint and CvPoint2D32f . There is\nalso a cast operator to convert point coordinates to the specified type. The conversion from\nfloating-point coordinates to integer coordinates is done by rounding. Commonly, the conversion\nuses this operation for each of the coordinates. Besides the class members listed in the\ndeclaration above, the following operations on points are implemented:\n@code\npt1 = pt2 + pt3;\npt1 = pt2 - pt3;\npt1 = pt2 * a;\npt1 = a * pt2;\npt1 = pt2 / a;\npt1 += pt2;\npt1 -= pt2;\npt1 *= a;\npt1 /= a;\ndouble value = norm(pt); // L2 norm\npt1 == pt2;\npt1 != pt2;\n@endcode\nFor your convenience, the following type aliases are defined:\n@code\ntypedef Point_<int> Point2i;\ntypedef Point2i Point;\ntypedef Point_<float> Point2f;\ntypedef Point_<double> Point2d;\n@endcode\nExample:\n@code\nPoint2f a(0.3f, 0.f), b(0.f, 0.4f);\nPoint pt = (a + b)*10.f;\ncout << pt.x << \", \" << pt.y << endl;\n@endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_Point_<_Tp> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
    #[doc = "!< x coordinate of the point"]
    pub x: _Tp,
    #[doc = "!< y coordinate of the point"]
    pub y: _Tp,
}
pub type cv_Point__value_type<_Tp> = _Tp;
#[doc = " @brief Template class for 2D points specified by its coordinates `x` and `y`.\n\nAn instance of the class is interchangeable with C structures, CvPoint and CvPoint2D32f . There is\nalso a cast operator to convert point coordinates to the specified type. The conversion from\nfloating-point coordinates to integer coordinates is done by rounding. Commonly, the conversion\nuses this operation for each of the coordinates. Besides the class members listed in the\ndeclaration above, the following operations on points are implemented:\n@code\npt1 = pt2 + pt3;\npt1 = pt2 - pt3;\npt1 = pt2 * a;\npt1 = a * pt2;\npt1 = pt2 / a;\npt1 += pt2;\npt1 -= pt2;\npt1 *= a;\npt1 /= a;\ndouble value = norm(pt); // L2 norm\npt1 == pt2;\npt1 != pt2;\n@endcode\nFor your convenience, the following type aliases are defined:\n@code\ntypedef Point_<int> Point2i;\ntypedef Point2i Point;\ntypedef Point_<float> Point2f;\ntypedef Point_<double> Point2d;\n@endcode\nExample:\n@code\nPoint2f a(0.3f, 0.f), b(0.f, 0.4f);\nPoint pt = (a + b)*10.f;\ncout << pt.x << \", \" << pt.y << endl;\n@endcode"]
pub type cv_Point2i = cv_Point_<::std::os::raw::c_int>;
#[doc = " @brief Template class for 2D points specified by its coordinates `x` and `y`.\n\nAn instance of the class is interchangeable with C structures, CvPoint and CvPoint2D32f . There is\nalso a cast operator to convert point coordinates to the specified type. The conversion from\nfloating-point coordinates to integer coordinates is done by rounding. Commonly, the conversion\nuses this operation for each of the coordinates. Besides the class members listed in the\ndeclaration above, the following operations on points are implemented:\n@code\npt1 = pt2 + pt3;\npt1 = pt2 - pt3;\npt1 = pt2 * a;\npt1 = a * pt2;\npt1 = pt2 / a;\npt1 += pt2;\npt1 -= pt2;\npt1 *= a;\npt1 /= a;\ndouble value = norm(pt); // L2 norm\npt1 == pt2;\npt1 != pt2;\n@endcode\nFor your convenience, the following type aliases are defined:\n@code\ntypedef Point_<int> Point2i;\ntypedef Point2i Point;\ntypedef Point_<float> Point2f;\ntypedef Point_<double> Point2d;\n@endcode\nExample:\n@code\nPoint2f a(0.3f, 0.f), b(0.f, 0.4f);\nPoint pt = (a + b)*10.f;\ncout << pt.x << \", \" << pt.y << endl;\n@endcode"]
pub type cv_Point2l = cv_Point_<int64>;
#[doc = " @brief Template class for 2D points specified by its coordinates `x` and `y`.\n\nAn instance of the class is interchangeable with C structures, CvPoint and CvPoint2D32f . There is\nalso a cast operator to convert point coordinates to the specified type. The conversion from\nfloating-point coordinates to integer coordinates is done by rounding. Commonly, the conversion\nuses this operation for each of the coordinates. Besides the class members listed in the\ndeclaration above, the following operations on points are implemented:\n@code\npt1 = pt2 + pt3;\npt1 = pt2 - pt3;\npt1 = pt2 * a;\npt1 = a * pt2;\npt1 = pt2 / a;\npt1 += pt2;\npt1 -= pt2;\npt1 *= a;\npt1 /= a;\ndouble value = norm(pt); // L2 norm\npt1 == pt2;\npt1 != pt2;\n@endcode\nFor your convenience, the following type aliases are defined:\n@code\ntypedef Point_<int> Point2i;\ntypedef Point2i Point;\ntypedef Point_<float> Point2f;\ntypedef Point_<double> Point2d;\n@endcode\nExample:\n@code\nPoint2f a(0.3f, 0.f), b(0.f, 0.4f);\nPoint pt = (a + b)*10.f;\ncout << pt.x << \", \" << pt.y << endl;\n@endcode"]
pub type cv_Point2f = cv_Point_<f32>;
#[doc = " @brief Template class for 2D points specified by its coordinates `x` and `y`.\n\nAn instance of the class is interchangeable with C structures, CvPoint and CvPoint2D32f . There is\nalso a cast operator to convert point coordinates to the specified type. The conversion from\nfloating-point coordinates to integer coordinates is done by rounding. Commonly, the conversion\nuses this operation for each of the coordinates. Besides the class members listed in the\ndeclaration above, the following operations on points are implemented:\n@code\npt1 = pt2 + pt3;\npt1 = pt2 - pt3;\npt1 = pt2 * a;\npt1 = a * pt2;\npt1 = pt2 / a;\npt1 += pt2;\npt1 -= pt2;\npt1 *= a;\npt1 /= a;\ndouble value = norm(pt); // L2 norm\npt1 == pt2;\npt1 != pt2;\n@endcode\nFor your convenience, the following type aliases are defined:\n@code\ntypedef Point_<int> Point2i;\ntypedef Point2i Point;\ntypedef Point_<float> Point2f;\ntypedef Point_<double> Point2d;\n@endcode\nExample:\n@code\nPoint2f a(0.3f, 0.f), b(0.f, 0.4f);\nPoint pt = (a + b)*10.f;\ncout << pt.x << \", \" << pt.y << endl;\n@endcode"]
pub type cv_Point2d = cv_Point_<f64>;
#[doc = " @brief Template class for 2D points specified by its coordinates `x` and `y`.\n\nAn instance of the class is interchangeable with C structures, CvPoint and CvPoint2D32f . There is\nalso a cast operator to convert point coordinates to the specified type. The conversion from\nfloating-point coordinates to integer coordinates is done by rounding. Commonly, the conversion\nuses this operation for each of the coordinates. Besides the class members listed in the\ndeclaration above, the following operations on points are implemented:\n@code\npt1 = pt2 + pt3;\npt1 = pt2 - pt3;\npt1 = pt2 * a;\npt1 = a * pt2;\npt1 = pt2 / a;\npt1 += pt2;\npt1 -= pt2;\npt1 *= a;\npt1 /= a;\ndouble value = norm(pt); // L2 norm\npt1 == pt2;\npt1 != pt2;\n@endcode\nFor your convenience, the following type aliases are defined:\n@code\ntypedef Point_<int> Point2i;\ntypedef Point2i Point;\ntypedef Point_<float> Point2f;\ntypedef Point_<double> Point2d;\n@endcode\nExample:\n@code\nPoint2f a(0.3f, 0.f), b(0.f, 0.4f);\nPoint pt = (a + b)*10.f;\ncout << pt.x << \", \" << pt.y << endl;\n@endcode"]
pub type cv_Point = cv_Point2i;
#[doc = " @brief Template class for 3D points specified by its coordinates `x`, `y` and `z`.\n\nAn instance of the class is interchangeable with the C structure CvPoint2D32f . Similarly to\nPoint_ , the coordinates of 3D points can be converted to another type. The vector arithmetic and\ncomparison operations are also supported.\n\nThe following Point3_\\<\\> aliases are available:\n@code\ntypedef Point3_<int> Point3i;\ntypedef Point3_<float> Point3f;\ntypedef Point3_<double> Point3d;\n@endcode\n@see cv::Point3i, cv::Point3f and cv::Point3d"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_Point3_<_Tp> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
    #[doc = "!< x coordinate of the 3D point"]
    pub x: _Tp,
    #[doc = "!< y coordinate of the 3D point"]
    pub y: _Tp,
    #[doc = "!< z coordinate of the 3D point"]
    pub z: _Tp,
}
pub type cv_Point3__value_type<_Tp> = _Tp;
pub type cv_Point3i = cv_Point3_<::std::os::raw::c_int>;
#[doc = " @brief Template class for 3D points specified by its coordinates `x`, `y` and `z`.\n\nAn instance of the class is interchangeable with the C structure CvPoint2D32f . Similarly to\nPoint_ , the coordinates of 3D points can be converted to another type. The vector arithmetic and\ncomparison operations are also supported.\n\nThe following Point3_\\<\\> aliases are available:\n@code\ntypedef Point3_<int> Point3i;\ntypedef Point3_<float> Point3f;\ntypedef Point3_<double> Point3d;\n@endcode\n@see cv::Point3i, cv::Point3f and cv::Point3d"]
pub type cv_Point3f = cv_Point3_<f32>;
#[doc = " @brief Template class for 3D points specified by its coordinates `x`, `y` and `z`.\n\nAn instance of the class is interchangeable with the C structure CvPoint2D32f . Similarly to\nPoint_ , the coordinates of 3D points can be converted to another type. The vector arithmetic and\ncomparison operations are also supported.\n\nThe following Point3_\\<\\> aliases are available:\n@code\ntypedef Point3_<int> Point3i;\ntypedef Point3_<float> Point3f;\ntypedef Point3_<double> Point3d;\n@endcode\n@see cv::Point3i, cv::Point3f and cv::Point3d"]
pub type cv_Point3d = cv_Point3_<f64>;
#[doc = " @brief Template class for specifying the size of an image or rectangle.\n\nThe class includes two members called width and height. The structure can be converted to and from\nthe old OpenCV structures CvSize and CvSize2D32f . The same set of arithmetic and comparison\noperations as for Point_ is available.\n\nOpenCV defines the following Size_\\<\\> aliases:\n@code\ntypedef Size_<int> Size2i;\ntypedef Size2i Size;\ntypedef Size_<float> Size2f;\n@endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_Size_<_Tp> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
    #[doc = "!< the width"]
    pub width: _Tp,
    #[doc = "!< the height"]
    pub height: _Tp,
}
pub type cv_Size__value_type<_Tp> = _Tp;
#[doc = " @brief Template class for specifying the size of an image or rectangle.\n\nThe class includes two members called width and height. The structure can be converted to and from\nthe old OpenCV structures CvSize and CvSize2D32f . The same set of arithmetic and comparison\noperations as for Point_ is available.\n\nOpenCV defines the following Size_\\<\\> aliases:\n@code\ntypedef Size_<int> Size2i;\ntypedef Size2i Size;\ntypedef Size_<float> Size2f;\n@endcode"]
pub type cv_Size2i = cv_Size_<::std::os::raw::c_int>;
pub type cv_Size2l = cv_Size_<int64>;
#[doc = " @brief Template class for specifying the size of an image or rectangle.\n\nThe class includes two members called width and height. The structure can be converted to and from\nthe old OpenCV structures CvSize and CvSize2D32f . The same set of arithmetic and comparison\noperations as for Point_ is available.\n\nOpenCV defines the following Size_\\<\\> aliases:\n@code\ntypedef Size_<int> Size2i;\ntypedef Size2i Size;\ntypedef Size_<float> Size2f;\n@endcode"]
pub type cv_Size2f = cv_Size_<f32>;
#[doc = " @brief Template class for specifying the size of an image or rectangle.\n\nThe class includes two members called width and height. The structure can be converted to and from\nthe old OpenCV structures CvSize and CvSize2D32f . The same set of arithmetic and comparison\noperations as for Point_ is available.\n\nOpenCV defines the following Size_\\<\\> aliases:\n@code\ntypedef Size_<int> Size2i;\ntypedef Size2i Size;\ntypedef Size_<float> Size2f;\n@endcode"]
pub type cv_Size2d = cv_Size_<f64>;
#[doc = " @brief Template class for specifying the size of an image or rectangle.\n\nThe class includes two members called width and height. The structure can be converted to and from\nthe old OpenCV structures CvSize and CvSize2D32f . The same set of arithmetic and comparison\noperations as for Point_ is available.\n\nOpenCV defines the following Size_\\<\\> aliases:\n@code\ntypedef Size_<int> Size2i;\ntypedef Size2i Size;\ntypedef Size_<float> Size2f;\n@endcode"]
pub type cv_Size = cv_Size2i;
#[doc = " @brief Template class for 2D rectangles\n\ndescribed by the following parameters:\n-   Coordinates of the top-left corner. This is a default interpretation of Rect_::x and Rect_::y\nin OpenCV. Though, in your algorithms you may count x and y from the bottom-left corner.\n-   Rectangle width and height.\n\nOpenCV typically assumes that the top and left boundary of the rectangle are inclusive, while the\nright and bottom boundaries are not. For example, the method Rect_::contains returns true if\n\n\\f[x  \\leq pt.x < x+width,\ny  \\leq pt.y < y+height\\f]\n\nVirtually every loop over an image ROI in OpenCV (where ROI is specified by Rect_\\<int\\> ) is\nimplemented as:\n@code\nfor(int y = roi.y; y < roi.y + roi.height; y++)\nfor(int x = roi.x; x < roi.x + roi.width; x++)\n{\n// ...\n}\n@endcode\nIn addition to the class members, the following operations on rectangles are implemented:\n-   \\f$\\texttt{rect} = \\texttt{rect} \\pm \\texttt{point}\\f$ (shifting a rectangle by a certain offset)\n-   \\f$\\texttt{rect} = \\texttt{rect} \\pm \\texttt{size}\\f$ (expanding or shrinking a rectangle by a\ncertain amount)\n-   rect += point, rect -= point, rect += size, rect -= size (augmenting operations)\n-   rect = rect1 & rect2 (rectangle intersection)\n-   rect = rect1 | rect2 (minimum area rectangle containing rect1 and rect2 )\n-   rect &= rect1, rect |= rect1 (and the corresponding augmenting operations)\n-   rect == rect1, rect != rect1 (rectangle comparison)\n\nThis is an example how the partial ordering on rectangles can be established (rect1 \\f$\\subseteq\\f$\nrect2):\n@code\ntemplate<typename _Tp> inline bool\noperator <= (const Rect_<_Tp>& r1, const Rect_<_Tp>& r2)\n{\nreturn (r1 & r2) == r1;\n}\n@endcode\nFor your convenience, the Rect_\\<\\> alias is available: cv::Rect"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_Rect_<_Tp> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
    #[doc = "!< x coordinate of the top-left corner"]
    pub x: _Tp,
    #[doc = "!< y coordinate of the top-left corner"]
    pub y: _Tp,
    #[doc = "!< width of the rectangle"]
    pub width: _Tp,
    #[doc = "!< height of the rectangle"]
    pub height: _Tp,
}
pub type cv_Rect__value_type<_Tp> = _Tp;
#[doc = " @brief Template class for 2D rectangles\n\ndescribed by the following parameters:\n-   Coordinates of the top-left corner. This is a default interpretation of Rect_::x and Rect_::y\nin OpenCV. Though, in your algorithms you may count x and y from the bottom-left corner.\n-   Rectangle width and height.\n\nOpenCV typically assumes that the top and left boundary of the rectangle are inclusive, while the\nright and bottom boundaries are not. For example, the method Rect_::contains returns true if\n\n\\f[x  \\leq pt.x < x+width,\ny  \\leq pt.y < y+height\\f]\n\nVirtually every loop over an image ROI in OpenCV (where ROI is specified by Rect_\\<int\\> ) is\nimplemented as:\n@code\nfor(int y = roi.y; y < roi.y + roi.height; y++)\nfor(int x = roi.x; x < roi.x + roi.width; x++)\n{\n// ...\n}\n@endcode\nIn addition to the class members, the following operations on rectangles are implemented:\n-   \\f$\\texttt{rect} = \\texttt{rect} \\pm \\texttt{point}\\f$ (shifting a rectangle by a certain offset)\n-   \\f$\\texttt{rect} = \\texttt{rect} \\pm \\texttt{size}\\f$ (expanding or shrinking a rectangle by a\ncertain amount)\n-   rect += point, rect -= point, rect += size, rect -= size (augmenting operations)\n-   rect = rect1 & rect2 (rectangle intersection)\n-   rect = rect1 | rect2 (minimum area rectangle containing rect1 and rect2 )\n-   rect &= rect1, rect |= rect1 (and the corresponding augmenting operations)\n-   rect == rect1, rect != rect1 (rectangle comparison)\n\nThis is an example how the partial ordering on rectangles can be established (rect1 \\f$\\subseteq\\f$\nrect2):\n@code\ntemplate<typename _Tp> inline bool\noperator <= (const Rect_<_Tp>& r1, const Rect_<_Tp>& r2)\n{\nreturn (r1 & r2) == r1;\n}\n@endcode\nFor your convenience, the Rect_\\<\\> alias is available: cv::Rect"]
pub type cv_Rect2i = cv_Rect_<::std::os::raw::c_int>;
pub type cv_Rect2f = cv_Rect_<f32>;
pub type cv_Rect2d = cv_Rect_<f64>;
#[doc = " @brief Template class for 2D rectangles\n\ndescribed by the following parameters:\n-   Coordinates of the top-left corner. This is a default interpretation of Rect_::x and Rect_::y\nin OpenCV. Though, in your algorithms you may count x and y from the bottom-left corner.\n-   Rectangle width and height.\n\nOpenCV typically assumes that the top and left boundary of the rectangle are inclusive, while the\nright and bottom boundaries are not. For example, the method Rect_::contains returns true if\n\n\\f[x  \\leq pt.x < x+width,\ny  \\leq pt.y < y+height\\f]\n\nVirtually every loop over an image ROI in OpenCV (where ROI is specified by Rect_\\<int\\> ) is\nimplemented as:\n@code\nfor(int y = roi.y; y < roi.y + roi.height; y++)\nfor(int x = roi.x; x < roi.x + roi.width; x++)\n{\n// ...\n}\n@endcode\nIn addition to the class members, the following operations on rectangles are implemented:\n-   \\f$\\texttt{rect} = \\texttt{rect} \\pm \\texttt{point}\\f$ (shifting a rectangle by a certain offset)\n-   \\f$\\texttt{rect} = \\texttt{rect} \\pm \\texttt{size}\\f$ (expanding or shrinking a rectangle by a\ncertain amount)\n-   rect += point, rect -= point, rect += size, rect -= size (augmenting operations)\n-   rect = rect1 & rect2 (rectangle intersection)\n-   rect = rect1 | rect2 (minimum area rectangle containing rect1 and rect2 )\n-   rect &= rect1, rect |= rect1 (and the corresponding augmenting operations)\n-   rect == rect1, rect != rect1 (rectangle comparison)\n\nThis is an example how the partial ordering on rectangles can be established (rect1 \\f$\\subseteq\\f$\nrect2):\n@code\ntemplate<typename _Tp> inline bool\noperator <= (const Rect_<_Tp>& r1, const Rect_<_Tp>& r2)\n{\nreturn (r1 & r2) == r1;\n}\n@endcode\nFor your convenience, the Rect_\\<\\> alias is available: cv::Rect"]
pub type cv_Rect = cv_Rect2i;
#[doc = " @brief The class represents rotated (i.e. not up-right) rectangles on a plane.\n\nEach rectangle is specified by the center point (mass center), length of each side (represented by\n#Size2f structure) and the rotation angle in degrees.\n\nThe sample below demonstrates how to use RotatedRect:\n@snippet snippets/core_various.cpp RotatedRect_demo\n[image](pics/rotatedrect.png)\n\n@sa CamShift, fitEllipse, minAreaRect, CvBox2D"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_RotatedRect {
    #[doc = "! returns the rectangle mass center"]
    pub center: cv_Point2f,
    #[doc = "! returns width and height of the rectangle"]
    pub size: cv_Size2f,
    #[doc = "! returns the rotation angle. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle."]
    pub angle: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_RotatedRect"][::std::mem::size_of::<cv_RotatedRect>() - 20usize];
    ["Alignment of cv_RotatedRect"][::std::mem::align_of::<cv_RotatedRect>() - 4usize];
    ["Offset of field: cv_RotatedRect::center"]
        [::std::mem::offset_of!(cv_RotatedRect, center) - 0usize];
    ["Offset of field: cv_RotatedRect::size"]
        [::std::mem::offset_of!(cv_RotatedRect, size) - 8usize];
    ["Offset of field: cv_RotatedRect::angle"]
        [::std::mem::offset_of!(cv_RotatedRect, angle) - 16usize];
};
unsafe extern "C" {
    #[doc = " returns 4 vertices of the rectangle\n@param pts The points array for storing rectangle vertices. The order is bottomLeft, topLeft, topRight, bottomRight."]
    #[link_name = "\u{1}_ZNK2cv11RotatedRect6pointsEPNS_6Point_IfEE"]
    pub fn cv_RotatedRect_points(this: *const cv_RotatedRect, pts: *mut cv_Point2f);
}
unsafe extern "C" {
    #[doc = "! returns the minimal up-right integer rectangle containing the rotated rectangle"]
    #[link_name = "\u{1}_ZNK2cv11RotatedRect12boundingRectEv"]
    pub fn cv_RotatedRect_boundingRect(this: *const cv_RotatedRect) -> cv_Rect;
}
unsafe extern "C" {
    #[doc = "! returns the minimal (exact) floating point rectangle containing the rotated rectangle, not intended for use with images"]
    #[link_name = "\u{1}_ZNK2cv11RotatedRect14boundingRect2fEv"]
    pub fn cv_RotatedRect_boundingRect2f(this: *const cv_RotatedRect) -> cv_Rect_<f32>;
}
unsafe extern "C" {
    #[doc = "Any 3 end points of the RotatedRect. They must be given in order (either clockwise or\nanticlockwise)."]
    #[link_name = "\u{1}_ZN2cv11RotatedRectC1ERKNS_6Point_IfEES4_S4_"]
    pub fn cv_RotatedRect_RotatedRect(
        this: *mut cv_RotatedRect,
        point1: *const cv_Point2f,
        point2: *const cv_Point2f,
        point3: *const cv_Point2f,
    );
}
impl cv_RotatedRect {
    #[inline]
    pub unsafe fn points(&self, pts: *mut cv_Point2f) {
        cv_RotatedRect_points(self, pts)
    }
    #[inline]
    pub unsafe fn boundingRect(&self) -> cv_Rect {
        cv_RotatedRect_boundingRect(self)
    }
    #[inline]
    pub unsafe fn boundingRect2f(&self) -> cv_Rect_<f32> {
        cv_RotatedRect_boundingRect2f(self)
    }
    #[inline]
    pub unsafe fn new(
        point1: *const cv_Point2f,
        point2: *const cv_Point2f,
        point3: *const cv_Point2f,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_RotatedRect_RotatedRect(__bindgen_tmp.as_mut_ptr(), point1, point2, point3);
        __bindgen_tmp.assume_init()
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_DataType_open0_cv_RotatedRect_close0"]
        [::std::mem::size_of::<cv_DataType>() - 1usize];
    ["Align of template specialization: cv_DataType_open0_cv_RotatedRect_close0"]
        [::std::mem::align_of::<cv_DataType>() - 1usize];
};
#[doc = " @brief Template class specifying a continuous subsequence (slice) of a sequence.\n\nThe class is used to specify a row or a column span in a matrix ( Mat ) and for many other purposes.\nRange(a,b) is basically the same as a:b in Matlab or a..b in Python. As in Python, start is an\ninclusive left boundary of the range and end is an exclusive right boundary of the range. Such a\nhalf-opened interval is usually denoted as \\f$[start,end)\\f$ .\n\nThe static method Range::all() returns a special variable that means \"the whole sequence\" or \"the\nwhole range\", just like \" : \" in Matlab or \" ... \" in Python. All the methods and functions in\nOpenCV that take Range support this special Range::all() value. But, of course, in case of your own\ncustom processing, you will probably have to check and handle it explicitly:\n@code\nvoid my_function(..., const Range& r, ....)\n{\nif(r == Range::all()) {\n// process all the data\n}\nelse {\n// process [r.start, r.end)\n}\n}\n@endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_Range {
    pub start: ::std::os::raw::c_int,
    pub end: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_Range"][::std::mem::size_of::<cv_Range>() - 8usize];
    ["Alignment of cv_Range"][::std::mem::align_of::<cv_Range>() - 4usize];
    ["Offset of field: cv_Range::start"][::std::mem::offset_of!(cv_Range, start) - 0usize];
    ["Offset of field: cv_Range::end"][::std::mem::offset_of!(cv_Range, end) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_DataType_open0_cv_Range_close0"]
        [::std::mem::size_of::<cv_DataType>() - 1usize];
    ["Align of template specialization: cv_DataType_open0_cv_Range_close0"]
        [::std::mem::align_of::<cv_DataType>() - 1usize];
};
#[doc = " @brief Template class for a 4-element vector derived from Vec.\n\nBeing derived from Vec\\<_Tp, 4\\> , Scalar\\_ and Scalar can be used just as typical 4-element\nvectors. In addition, they can be converted to/from CvScalar . The type Scalar is widely used in\nOpenCV to pass pixel values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_Scalar_ {
    pub _address: u8,
}
#[doc = " @brief Template class for a 4-element vector derived from Vec.\n\nBeing derived from Vec\\<_Tp, 4\\> , Scalar\\_ and Scalar can be used just as typical 4-element\nvectors. In addition, they can be converted to/from CvScalar . The type Scalar is widely used in\nOpenCV to pass pixel values."]
pub type cv_Scalar = cv_Scalar_;
#[doc = " @brief Data structure for salient point detectors.\n\nThe class instance stores a keypoint, i.e. a point feature found by one of many available keypoint\ndetectors, such as Harris corner detector, #FAST, %StarDetector, %SURF, %SIFT etc.\n\nThe keypoint is characterized by the 2D position, scale (proportional to the diameter of the\nneighborhood that needs to be taken into account), orientation and some other parameters. The\nkeypoint neighborhood is then analyzed by another algorithm that builds a descriptor (usually\nrepresented as a feature vector). The keypoints representing the same object in different images\ncan then be matched using %KDTree or another method."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_KeyPoint {
    #[doc = "!< coordinates of the keypoints"]
    pub pt: cv_Point2f,
    #[doc = "!< diameter of the meaningful keypoint neighborhood"]
    pub size: f32,
    #[doc = "!< computed orientation of the keypoint (-1 if not applicable);\n!< it's in [0,360) degrees and measured relative to\n!< image coordinate system, ie in clockwise."]
    pub angle: f32,
    #[doc = "!< the response by which the most strong keypoints have been selected. Can be used for the further sorting or subsampling"]
    pub response: f32,
    #[doc = "!< octave (pyramid layer) from which the keypoint has been extracted"]
    pub octave: ::std::os::raw::c_int,
    #[doc = "!< object class (if the keypoints need to be clustered by an object they belong to)"]
    pub class_id: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_KeyPoint"][::std::mem::size_of::<cv_KeyPoint>() - 28usize];
    ["Alignment of cv_KeyPoint"][::std::mem::align_of::<cv_KeyPoint>() - 4usize];
    ["Offset of field: cv_KeyPoint::pt"][::std::mem::offset_of!(cv_KeyPoint, pt) - 0usize];
    ["Offset of field: cv_KeyPoint::size"][::std::mem::offset_of!(cv_KeyPoint, size) - 8usize];
    ["Offset of field: cv_KeyPoint::angle"][::std::mem::offset_of!(cv_KeyPoint, angle) - 12usize];
    ["Offset of field: cv_KeyPoint::response"]
        [::std::mem::offset_of!(cv_KeyPoint, response) - 16usize];
    ["Offset of field: cv_KeyPoint::octave"][::std::mem::offset_of!(cv_KeyPoint, octave) - 20usize];
    ["Offset of field: cv_KeyPoint::class_id"]
        [::std::mem::offset_of!(cv_KeyPoint, class_id) - 24usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv8KeyPoint4hashEv"]
    pub fn cv_KeyPoint_hash(this: *const cv_KeyPoint) -> usize;
}
unsafe extern "C" {
    #[doc = "This method converts vector of keypoints to vector of points or the reverse, where each keypoint is\nassigned the same size and the same orientation.\n\n@param keypoints Keypoints obtained from any feature detection algorithm like SIFT/SURF/ORB\n@param points2f Array of (x,y) coordinates of each keypoint\n@param keypointIndexes Array of indexes of keypoints to be converted to points. (Acts like a mask to\nconvert only specified keypoints)"]
    #[link_name = "\u{1}_ZN2cv8KeyPoint7convertERKSt6vectorIS0_SaIS0_EERS1_INS_6Point_IfEESaIS7_EERKS1_IiSaIiEE"]
    pub fn cv_KeyPoint_convert(
        keypoints: *const std_vector,
        points2f: *mut std_vector,
        keypointIndexes: *const std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param points2f Array of (x,y) coordinates of each keypoint\n@param keypoints Keypoints obtained from any feature detection algorithm like SIFT/SURF/ORB\n@param size keypoint diameter\n@param response keypoint detector response on the keypoint (that is, strength of the keypoint)\n@param octave pyramid octave in which the keypoint has been detected\n@param class_id object id"]
    #[link_name = "\u{1}_ZN2cv8KeyPoint7convertERKSt6vectorINS_6Point_IfEESaIS3_EERS1_IS0_SaIS0_EEffii"]
    pub fn cv_KeyPoint_convert1(
        points2f: *const std_vector,
        keypoints: *mut std_vector,
        size: f32,
        response: f32,
        octave: ::std::os::raw::c_int,
        class_id: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = "This method computes overlap for pair of keypoints. Overlap is the ratio between area of keypoint\nregions' intersection and area of keypoint regions' union (considering keypoint region as circle).\nIf they don't overlap, we get zero. If they coincide at same location with same size, we get 1.\n@param kp1 First keypoint\n@param kp2 Second keypoint"]
    #[link_name = "\u{1}_ZN2cv8KeyPoint7overlapERKS0_S2_"]
    pub fn cv_KeyPoint_overlap(kp1: *const cv_KeyPoint, kp2: *const cv_KeyPoint) -> f32;
}
impl cv_KeyPoint {
    #[inline]
    pub unsafe fn hash(&self) -> usize {
        cv_KeyPoint_hash(self)
    }
    #[inline]
    pub unsafe fn convert(
        keypoints: *const std_vector,
        points2f: *mut std_vector,
        keypointIndexes: *const std_vector,
    ) {
        cv_KeyPoint_convert(keypoints, points2f, keypointIndexes)
    }
    #[inline]
    pub unsafe fn convert1(
        points2f: *const std_vector,
        keypoints: *mut std_vector,
        size: f32,
        response: f32,
        octave: ::std::os::raw::c_int,
        class_id: ::std::os::raw::c_int,
    ) {
        cv_KeyPoint_convert1(points2f, keypoints, size, response, octave, class_id)
    }
    #[inline]
    pub unsafe fn overlap(kp1: *const cv_KeyPoint, kp2: *const cv_KeyPoint) -> f32 {
        cv_KeyPoint_overlap(kp1, kp2)
    }
}
#[doc = " @brief Class for matching keypoint descriptors\n\nquery descriptor index, train descriptor index, train image index, and distance between\ndescriptors."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_DMatch {
    #[doc = "!< query descriptor index"]
    pub queryIdx: ::std::os::raw::c_int,
    #[doc = "!< train descriptor index"]
    pub trainIdx: ::std::os::raw::c_int,
    #[doc = "!< train image index"]
    pub imgIdx: ::std::os::raw::c_int,
    pub distance: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_DMatch"][::std::mem::size_of::<cv_DMatch>() - 16usize];
    ["Alignment of cv_DMatch"][::std::mem::align_of::<cv_DMatch>() - 4usize];
    ["Offset of field: cv_DMatch::queryIdx"][::std::mem::offset_of!(cv_DMatch, queryIdx) - 0usize];
    ["Offset of field: cv_DMatch::trainIdx"][::std::mem::offset_of!(cv_DMatch, trainIdx) - 4usize];
    ["Offset of field: cv_DMatch::imgIdx"][::std::mem::offset_of!(cv_DMatch, imgIdx) - 8usize];
    ["Offset of field: cv_DMatch::distance"][::std::mem::offset_of!(cv_DMatch, distance) - 12usize];
};
#[doc = " @brief The class defining termination criteria for iterative algorithms.\n\nYou can initialize it by default constructor and then override any parameters, or the structure may\nbe fully initialized using the advanced variant of the constructor."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_TermCriteria {
    #[doc = "!< the type of termination criteria: COUNT, EPS or COUNT + EPS"]
    pub type_: ::std::os::raw::c_int,
    #[doc = "!< the maximum number of iterations/elements"]
    pub maxCount: ::std::os::raw::c_int,
    #[doc = "!< the desired accuracy"]
    pub epsilon: f64,
}
#[doc = "!< the maximum number of iterations or elements to compute"]
pub const cv_TermCriteria_Type_COUNT: cv_TermCriteria_Type = 1;
#[doc = "!< ditto"]
pub const cv_TermCriteria_Type_MAX_ITER: cv_TermCriteria_Type = 1;
#[doc = "!< the desired accuracy or change in parameters at which the iterative algorithm stops"]
pub const cv_TermCriteria_Type_EPS: cv_TermCriteria_Type = 2;
#[doc = "Criteria type, can be one of: COUNT, EPS or COUNT + EPS"]
pub type cv_TermCriteria_Type = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_TermCriteria"][::std::mem::size_of::<cv_TermCriteria>() - 16usize];
    ["Alignment of cv_TermCriteria"][::std::mem::align_of::<cv_TermCriteria>() - 8usize];
    ["Offset of field: cv_TermCriteria::type_"]
        [::std::mem::offset_of!(cv_TermCriteria, type_) - 0usize];
    ["Offset of field: cv_TermCriteria::maxCount"]
        [::std::mem::offset_of!(cv_TermCriteria, maxCount) - 4usize];
    ["Offset of field: cv_TermCriteria::epsilon"]
        [::std::mem::offset_of!(cv_TermCriteria, epsilon) - 8usize];
};
#[doc = " @brief struct returned by cv::moments\n\nThe spatial moments \\f$\\texttt{Moments::m}_{ji}\\f$ are computed as:\n\n\\f[\\texttt{m} _{ji}= \\sum _{x,y}  \\left ( \\texttt{array} (x,y)  \\cdot x^j  \\cdot y^i \\right )\\f]\n\nThe central moments \\f$\\texttt{Moments::mu}_{ji}\\f$ are computed as:\n\n\\f[\\texttt{mu} _{ji}= \\sum _{x,y}  \\left ( \\texttt{array} (x,y)  \\cdot (x -  \\bar{x} )^j  \\cdot (y -  \\bar{y} )^i \\right )\\f]\n\nwhere \\f$(\\bar{x}, \\bar{y})\\f$ is the mass center:\n\n\\f[\\bar{x} = \\frac{\\texttt{m}_{10}}{\\texttt{m}_{00}} , \\; \\bar{y} = \\frac{\\texttt{m}_{01}}{\\texttt{m}_{00}}\\f]\n\nThe normalized central moments \\f$\\texttt{Moments::nu}_{ij}\\f$ are computed as:\n\n\\f[\\texttt{nu} _{ji}= \\frac{\\texttt{mu}_{ji}}{\\texttt{m}_{00}^{(i+j)/2+1}} .\\f]\n\n@note\n\\f$\\texttt{mu}_{00}=\\texttt{m}_{00}\\f$, \\f$\\texttt{nu}_{00}=1\\f$\n\\f$\\texttt{nu}_{10}=\\texttt{mu}_{10}=\\texttt{mu}_{01}=\\texttt{mu}_{10}=0\\f$ , hence the values are not\nstored.\n\nThe moments of a contour are defined in the same way but computed using the Green's formula (see\n<http://en.wikipedia.org/wiki/Green_theorem>). So, due to a limited raster resolution, the moments\ncomputed for a contour are slightly different from the moments computed for the same rasterized\ncontour.\n\n@note\nSince the contour moments are computed using Green formula, you may get seemingly odd results for\ncontours with self-intersections, e.g. a zero area (m00) for butterfly-shaped contours."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_Moments {
    #[doc = "! @name spatial moments\n! @{"]
    pub m00: f64,
    #[doc = "! @name spatial moments\n! @{"]
    pub m10: f64,
    #[doc = "! @name spatial moments\n! @{"]
    pub m01: f64,
    #[doc = "! @name spatial moments\n! @{"]
    pub m20: f64,
    #[doc = "! @name spatial moments\n! @{"]
    pub m11: f64,
    #[doc = "! @name spatial moments\n! @{"]
    pub m02: f64,
    #[doc = "! @name spatial moments\n! @{"]
    pub m30: f64,
    #[doc = "! @name spatial moments\n! @{"]
    pub m21: f64,
    #[doc = "! @name spatial moments\n! @{"]
    pub m12: f64,
    #[doc = "! @name spatial moments\n! @{"]
    pub m03: f64,
    #[doc = "! @name central moments\n! @{"]
    pub mu20: f64,
    #[doc = "! @name central moments\n! @{"]
    pub mu11: f64,
    #[doc = "! @name central moments\n! @{"]
    pub mu02: f64,
    #[doc = "! @name central moments\n! @{"]
    pub mu30: f64,
    #[doc = "! @name central moments\n! @{"]
    pub mu21: f64,
    #[doc = "! @name central moments\n! @{"]
    pub mu12: f64,
    #[doc = "! @name central moments\n! @{"]
    pub mu03: f64,
    #[doc = "! @name central normalized moments\n! @{"]
    pub nu20: f64,
    #[doc = "! @name central normalized moments\n! @{"]
    pub nu11: f64,
    #[doc = "! @name central normalized moments\n! @{"]
    pub nu02: f64,
    #[doc = "! @name central normalized moments\n! @{"]
    pub nu30: f64,
    #[doc = "! @name central normalized moments\n! @{"]
    pub nu21: f64,
    #[doc = "! @name central normalized moments\n! @{"]
    pub nu12: f64,
    #[doc = "! @name central normalized moments\n! @{"]
    pub nu03: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_Moments"][::std::mem::size_of::<cv_Moments>() - 192usize];
    ["Alignment of cv_Moments"][::std::mem::align_of::<cv_Moments>() - 8usize];
    ["Offset of field: cv_Moments::m00"][::std::mem::offset_of!(cv_Moments, m00) - 0usize];
    ["Offset of field: cv_Moments::m10"][::std::mem::offset_of!(cv_Moments, m10) - 8usize];
    ["Offset of field: cv_Moments::m01"][::std::mem::offset_of!(cv_Moments, m01) - 16usize];
    ["Offset of field: cv_Moments::m20"][::std::mem::offset_of!(cv_Moments, m20) - 24usize];
    ["Offset of field: cv_Moments::m11"][::std::mem::offset_of!(cv_Moments, m11) - 32usize];
    ["Offset of field: cv_Moments::m02"][::std::mem::offset_of!(cv_Moments, m02) - 40usize];
    ["Offset of field: cv_Moments::m30"][::std::mem::offset_of!(cv_Moments, m30) - 48usize];
    ["Offset of field: cv_Moments::m21"][::std::mem::offset_of!(cv_Moments, m21) - 56usize];
    ["Offset of field: cv_Moments::m12"][::std::mem::offset_of!(cv_Moments, m12) - 64usize];
    ["Offset of field: cv_Moments::m03"][::std::mem::offset_of!(cv_Moments, m03) - 72usize];
    ["Offset of field: cv_Moments::mu20"][::std::mem::offset_of!(cv_Moments, mu20) - 80usize];
    ["Offset of field: cv_Moments::mu11"][::std::mem::offset_of!(cv_Moments, mu11) - 88usize];
    ["Offset of field: cv_Moments::mu02"][::std::mem::offset_of!(cv_Moments, mu02) - 96usize];
    ["Offset of field: cv_Moments::mu30"][::std::mem::offset_of!(cv_Moments, mu30) - 104usize];
    ["Offset of field: cv_Moments::mu21"][::std::mem::offset_of!(cv_Moments, mu21) - 112usize];
    ["Offset of field: cv_Moments::mu12"][::std::mem::offset_of!(cv_Moments, mu12) - 120usize];
    ["Offset of field: cv_Moments::mu03"][::std::mem::offset_of!(cv_Moments, mu03) - 128usize];
    ["Offset of field: cv_Moments::nu20"][::std::mem::offset_of!(cv_Moments, nu20) - 136usize];
    ["Offset of field: cv_Moments::nu11"][::std::mem::offset_of!(cv_Moments, nu11) - 144usize];
    ["Offset of field: cv_Moments::nu02"][::std::mem::offset_of!(cv_Moments, nu02) - 152usize];
    ["Offset of field: cv_Moments::nu30"][::std::mem::offset_of!(cv_Moments, nu30) - 160usize];
    ["Offset of field: cv_Moments::nu21"][::std::mem::offset_of!(cv_Moments, nu21) - 168usize];
    ["Offset of field: cv_Moments::nu12"][::std::mem::offset_of!(cv_Moments, nu12) - 176usize];
    ["Offset of field: cv_Moments::nu03"][::std::mem::offset_of!(cv_Moments, nu03) - 184usize];
};
unsafe extern "C" {
    #[doc = "! the default constructor"]
    #[link_name = "\u{1}_ZN2cv7MomentsC1Ev"]
    pub fn cv_Moments_Moments(this: *mut cv_Moments);
}
unsafe extern "C" {
    #[doc = "! the full constructor"]
    #[link_name = "\u{1}_ZN2cv7MomentsC1Edddddddddd"]
    pub fn cv_Moments_Moments1(
        this: *mut cv_Moments,
        m00: f64,
        m10: f64,
        m01: f64,
        m20: f64,
        m11: f64,
        m02: f64,
        m30: f64,
        m21: f64,
        m12: f64,
        m03: f64,
    );
}
impl cv_Moments {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_Moments_Moments(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        m00: f64,
        m10: f64,
        m01: f64,
        m20: f64,
        m11: f64,
        m02: f64,
        m30: f64,
        m21: f64,
        m12: f64,
        m03: f64,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_Moments_Moments1(
            __bindgen_tmp.as_mut_ptr(),
            m00,
            m10,
            m01,
            m20,
            m11,
            m02,
            m30,
            m21,
            m12,
            m03,
        );
        __bindgen_tmp.assume_init()
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_DataType_open0_cv_Moments_close0"]
        [::std::mem::size_of::<cv_DataType>() - 1usize];
    ["Align of template specialization: cv_DataType_open0_cv_Moments_close0"]
        [::std::mem::align_of::<cv_DataType>() - 1usize];
};
#[repr(C)]
pub struct cv_BufferPoolController__bindgen_vtable(::std::os::raw::c_void);
#[doc = "! @addtogroup core\n! @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_BufferPoolController {
    pub vtable_: *const cv_BufferPoolController__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_BufferPoolController"][::std::mem::size_of::<cv_BufferPoolController>() - 8usize];
    ["Alignment of cv_BufferPoolController"]
        [::std::mem::align_of::<cv_BufferPoolController>() - 8usize];
};
pub const cv_AccessFlag_ACCESS_READ: cv_AccessFlag = 16777216;
pub const cv_AccessFlag_ACCESS_WRITE: cv_AccessFlag = 33554432;
pub const cv_AccessFlag_ACCESS_RW: cv_AccessFlag = 50331648;
pub const cv_AccessFlag_ACCESS_MASK: cv_AccessFlag = 50331648;
pub const cv_AccessFlag_ACCESS_FAST: cv_AccessFlag = 67108864;
#[doc = "! @addtogroup core_basic\n! @{"]
pub type cv_AccessFlag = ::std::os::raw::c_uint;
#[doc = " @brief This is the proxy class for passing read-only input arrays into OpenCV functions.\n\nIt is defined as:\n@code\ntypedef const _InputArray& InputArray;\n@endcode\nwhere _InputArray is a class that can be constructed from `Mat`, `Mat_<T>`, `Matx<T, m, n>`,\n`std::vector<T>`, `std::vector<std::vector<T> >`, `std::vector<Mat>`, `std::vector<Mat_<T> >`,\n`UMat`, `std::vector<UMat>` or `double`. It can also be constructed from a matrix expression.\n\nSince this is mostly implementation-level class, and its interface may change in future versions, we\ndo not describe it in details. There are a few key things, though, that should be kept in mind:\n\n-   When you see in the reference manual or in OpenCV source code a function that takes\nInputArray, it means that you can actually pass `Mat`, `Matx`, `vector<T>` etc. (see above the\ncomplete list).\n-   Optional input arguments: If some of the input arrays may be empty, pass cv::noArray() (or\nsimply cv::Mat() as you probably did before).\n-   The class is designed solely for passing parameters. That is, normally you *should not*\ndeclare class members, local and global variables of this type.\n-   If you want to design your own function or a class method that can operate of arrays of\nmultiple types, you can use InputArray (or OutputArray) for the respective parameters. Inside\na function you should use _InputArray::getMat() method to construct a matrix header for the\narray (without copying data). _InputArray::kind() can be used to distinguish Mat from\n`vector<>` etc., but normally it is not needed.\n\nHere is how you can use a function that takes InputArray :\n@code\nstd::vector<Point2f> vec;\n// points or a circle\nfor( int i = 0; i < 30; i++ )\nvec.push_back(Point2f((float)(100 + 30*cos(i*CV_PI*2/5)),\n(float)(100 - 30*sin(i*CV_PI*2/5))));\ncv::transform(vec, vec, cv::Matx23f(0.707, -0.707, 10, 0.707, 0.707, 20));\n@endcode\nThat is, we form an STL vector containing points, and apply in-place affine transformation to the\nvector using the 2x3 matrix created inline as `Matx<float, 2, 3>` instance.\n\nHere is how such a function can be implemented (for simplicity, we implement a very specific case of\nit, according to the assertion statement inside) :\n@code\nvoid myAffineTransform(InputArray _src, OutputArray _dst, InputArray _m)\n{\n// get Mat headers for input arrays. This is O(1) operation,\n// unless _src and/or _m are matrix expressions.\nMat src = _src.getMat(), m = _m.getMat();\nCV_Assert( src.type() == CV_32FC2 && m.type() == CV_32F && m.size() == Size(3, 2) );\n\n// [re]create the output array so that it has the proper size and type.\n// In case of Mat it calls Mat::create, in case of STL vector it calls vector::resize.\n_dst.create(src.size(), src.type());\nMat dst = _dst.getMat();\n\nfor( int i = 0; i < src.rows; i++ )\nfor( int j = 0; j < src.cols; j++ )\n{\nPoint2f pt = src.at<Point2f>(i, j);\ndst.at<Point2f>(i, j) = Point2f(m.at<float>(0, 0)*pt.x +\nm.at<float>(0, 1)*pt.y +\nm.at<float>(0, 2),\nm.at<float>(1, 0)*pt.x +\nm.at<float>(1, 1)*pt.y +\nm.at<float>(1, 2));\n}\n}\n@endcode\nThere is another related type, InputArrayOfArrays, which is currently defined as a synonym for\nInputArray:\n@code\ntypedef InputArray InputArrayOfArrays;\n@endcode\nIt denotes function arguments that are either vectors of vectors or vectors of matrices. A separate\nsynonym is needed to generate Python/Java etc. wrappers properly. At the function implementation\nlevel their use is similar, but _InputArray::getMat(idx) should be used to get header for the\nidx-th component of the outer vector and _InputArray::size().area() should be used to find the\nnumber of components (vectors/matrices) of the outer vector.\n\nIn general, type support is limited to cv::Mat types. Other types are forbidden.\nBut in some cases we need to support passing of custom non-general Mat types, like arrays of cv::KeyPoint, cv::DMatch, etc.\nThis data is not intended to be interpreted as an image data, or processed somehow like regular cv::Mat.\nTo pass such custom type use rawIn() / rawOut() / rawInOut() wrappers.\nCustom type is wrapped as Mat-compatible `CV_8UC<N>` values (N = sizeof(T), N <= CV_CN_MAX)."]
#[repr(C)]
#[derive(Debug)]
pub struct cv__InputArray {
    pub flags: ::std::os::raw::c_int,
    pub obj: *mut ::std::os::raw::c_void,
    pub sz: cv_Size,
}
pub const cv__InputArray_KindFlag_KIND_SHIFT: cv__InputArray_KindFlag = 16;
pub const cv__InputArray_KindFlag_FIXED_TYPE: cv__InputArray_KindFlag = -2147483648;
pub const cv__InputArray_KindFlag_FIXED_SIZE: cv__InputArray_KindFlag = 1073741824;
pub const cv__InputArray_KindFlag_KIND_MASK: cv__InputArray_KindFlag = 2031616;
pub const cv__InputArray_KindFlag_NONE: cv__InputArray_KindFlag = 0;
pub const cv__InputArray_KindFlag_MAT: cv__InputArray_KindFlag = 65536;
pub const cv__InputArray_KindFlag_MATX: cv__InputArray_KindFlag = 131072;
pub const cv__InputArray_KindFlag_STD_VECTOR: cv__InputArray_KindFlag = 196608;
pub const cv__InputArray_KindFlag_STD_VECTOR_VECTOR: cv__InputArray_KindFlag = 262144;
pub const cv__InputArray_KindFlag_STD_VECTOR_MAT: cv__InputArray_KindFlag = 327680;
pub const cv__InputArray_KindFlag_EXPR: cv__InputArray_KindFlag = 393216;
pub const cv__InputArray_KindFlag_OPENGL_BUFFER: cv__InputArray_KindFlag = 458752;
pub const cv__InputArray_KindFlag_CUDA_HOST_MEM: cv__InputArray_KindFlag = 524288;
pub const cv__InputArray_KindFlag_CUDA_GPU_MAT: cv__InputArray_KindFlag = 589824;
pub const cv__InputArray_KindFlag_UMAT: cv__InputArray_KindFlag = 655360;
pub const cv__InputArray_KindFlag_STD_VECTOR_UMAT: cv__InputArray_KindFlag = 720896;
pub const cv__InputArray_KindFlag_STD_BOOL_VECTOR: cv__InputArray_KindFlag = 786432;
pub const cv__InputArray_KindFlag_STD_VECTOR_CUDA_GPU_MAT: cv__InputArray_KindFlag = 851968;
pub const cv__InputArray_KindFlag_STD_ARRAY: cv__InputArray_KindFlag = 917504;
pub const cv__InputArray_KindFlag_STD_ARRAY_MAT: cv__InputArray_KindFlag = 983040;
pub type cv__InputArray_KindFlag = ::std::os::raw::c_int;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv__InputArray"][::std::mem::size_of::<cv__InputArray>() - 24usize];
    ["Alignment of cv__InputArray"][::std::mem::align_of::<cv__InputArray>() - 8usize];
    ["Offset of field: cv__InputArray::flags"]
        [::std::mem::offset_of!(cv__InputArray, flags) - 0usize];
    ["Offset of field: cv__InputArray::obj"][::std::mem::offset_of!(cv__InputArray, obj) - 8usize];
    ["Offset of field: cv__InputArray::sz"][::std::mem::offset_of!(cv__InputArray, sz) - 16usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray7getMat_Ei"]
    pub fn cv__InputArray_getMat_(
        this: *const cv__InputArray,
        idx: ::std::os::raw::c_int,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray7getUMatEi"]
    pub fn cv__InputArray_getUMat(
        this: *const cv__InputArray,
        idx: ::std::os::raw::c_int,
    ) -> cv_UMat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray12getMatVectorERSt6vectorINS_3MatESaIS2_EE"]
    pub fn cv__InputArray_getMatVector(this: *const cv__InputArray, mv: *mut std_vector);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray13getUMatVectorERSt6vectorINS_4UMatESaIS2_EE"]
    pub fn cv__InputArray_getUMatVector(this: *const cv__InputArray, umv: *mut std_vector);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray15getGpuMatVectorERSt6vectorINS_4cuda6GpuMatESaIS3_EE"]
    pub fn cv__InputArray_getGpuMatVector(this: *const cv__InputArray, gpumv: *mut std_vector);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray9getGpuMatEv"]
    pub fn cv__InputArray_getGpuMat(this: *const cv__InputArray) -> cv_cuda_GpuMat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray12getOGlBufferEv"]
    pub fn cv__InputArray_getOGlBuffer(this: *const cv__InputArray) -> cv_ogl_Buffer;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray4kindEv"]
    pub fn cv__InputArray_kind(this: *const cv__InputArray) -> cv__InputArray_KindFlag;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray4dimsEi"]
    pub fn cv__InputArray_dims(
        this: *const cv__InputArray,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray4colsEi"]
    pub fn cv__InputArray_cols(
        this: *const cv__InputArray,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray4rowsEi"]
    pub fn cv__InputArray_rows(
        this: *const cv__InputArray,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray4sizeEi"]
    pub fn cv__InputArray_size(this: *const cv__InputArray, i: ::std::os::raw::c_int) -> cv_Size;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray6sizendEPii"]
    pub fn cv__InputArray_sizend(
        this: *const cv__InputArray,
        sz: *mut ::std::os::raw::c_int,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray8sameSizeERKS0_"]
    pub fn cv__InputArray_sameSize(this: *const cv__InputArray, arr: *const cv__InputArray)
    -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray5totalEi"]
    pub fn cv__InputArray_total(this: *const cv__InputArray, i: ::std::os::raw::c_int) -> usize;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray4typeEi"]
    pub fn cv__InputArray_type(
        this: *const cv__InputArray,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray5depthEi"]
    pub fn cv__InputArray_depth(
        this: *const cv__InputArray,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray8channelsEi"]
    pub fn cv__InputArray_channels(
        this: *const cv__InputArray,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray12isContinuousEi"]
    pub fn cv__InputArray_isContinuous(
        this: *const cv__InputArray,
        i: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray11isSubmatrixEi"]
    pub fn cv__InputArray_isSubmatrix(
        this: *const cv__InputArray,
        i: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray5emptyEv"]
    pub fn cv__InputArray_empty(this: *const cv__InputArray) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray6copyToERKNS_12_OutputArrayE"]
    pub fn cv__InputArray_copyTo(this: *const cv__InputArray, arr: *const cv__OutputArray);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray6copyToERKNS_12_OutputArrayERKS0_"]
    pub fn cv__InputArray_copyTo1(
        this: *const cv__InputArray,
        arr: *const cv__OutputArray,
        mask: *const cv__InputArray,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray6offsetEi"]
    pub fn cv__InputArray_offset(this: *const cv__InputArray, i: ::std::os::raw::c_int) -> usize;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv11_InputArray4stepEi"]
    pub fn cv__InputArray_step(this: *const cv__InputArray, i: ::std::os::raw::c_int) -> usize;
}
impl cv__InputArray {
    #[inline]
    pub unsafe fn getMat_(&self, idx: ::std::os::raw::c_int) -> cv_Mat {
        cv__InputArray_getMat_(self, idx)
    }
    #[inline]
    pub unsafe fn getUMat(&self, idx: ::std::os::raw::c_int) -> cv_UMat {
        cv__InputArray_getUMat(self, idx)
    }
    #[inline]
    pub unsafe fn getMatVector(&self, mv: *mut std_vector) {
        cv__InputArray_getMatVector(self, mv)
    }
    #[inline]
    pub unsafe fn getUMatVector(&self, umv: *mut std_vector) {
        cv__InputArray_getUMatVector(self, umv)
    }
    #[inline]
    pub unsafe fn getGpuMatVector(&self, gpumv: *mut std_vector) {
        cv__InputArray_getGpuMatVector(self, gpumv)
    }
    #[inline]
    pub unsafe fn getGpuMat(&self) -> cv_cuda_GpuMat {
        cv__InputArray_getGpuMat(self)
    }
    #[inline]
    pub unsafe fn getOGlBuffer(&self) -> cv_ogl_Buffer {
        cv__InputArray_getOGlBuffer(self)
    }
    #[inline]
    pub unsafe fn kind(&self) -> cv__InputArray_KindFlag {
        cv__InputArray_kind(self)
    }
    #[inline]
    pub unsafe fn dims(&self, i: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        cv__InputArray_dims(self, i)
    }
    #[inline]
    pub unsafe fn cols(&self, i: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        cv__InputArray_cols(self, i)
    }
    #[inline]
    pub unsafe fn rows(&self, i: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        cv__InputArray_rows(self, i)
    }
    #[inline]
    pub unsafe fn size(&self, i: ::std::os::raw::c_int) -> cv_Size {
        cv__InputArray_size(self, i)
    }
    #[inline]
    pub unsafe fn sizend(
        &self,
        sz: *mut ::std::os::raw::c_int,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        cv__InputArray_sizend(self, sz, i)
    }
    #[inline]
    pub unsafe fn sameSize(&self, arr: *const cv__InputArray) -> bool {
        cv__InputArray_sameSize(self, arr)
    }
    #[inline]
    pub unsafe fn total(&self, i: ::std::os::raw::c_int) -> usize {
        cv__InputArray_total(self, i)
    }
    #[inline]
    pub unsafe fn type_(&self, i: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        cv__InputArray_type(self, i)
    }
    #[inline]
    pub unsafe fn depth(&self, i: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        cv__InputArray_depth(self, i)
    }
    #[inline]
    pub unsafe fn channels(&self, i: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        cv__InputArray_channels(self, i)
    }
    #[inline]
    pub unsafe fn isContinuous(&self, i: ::std::os::raw::c_int) -> bool {
        cv__InputArray_isContinuous(self, i)
    }
    #[inline]
    pub unsafe fn isSubmatrix(&self, i: ::std::os::raw::c_int) -> bool {
        cv__InputArray_isSubmatrix(self, i)
    }
    #[inline]
    pub unsafe fn empty(&self) -> bool {
        cv__InputArray_empty(self)
    }
    #[inline]
    pub unsafe fn copyTo(&self, arr: *const cv__OutputArray) {
        cv__InputArray_copyTo(self, arr)
    }
    #[inline]
    pub unsafe fn copyTo1(&self, arr: *const cv__OutputArray, mask: *const cv__InputArray) {
        cv__InputArray_copyTo1(self, arr, mask)
    }
    #[inline]
    pub unsafe fn offset(&self, i: ::std::os::raw::c_int) -> usize {
        cv__InputArray_offset(self, i)
    }
    #[inline]
    pub unsafe fn step(&self, i: ::std::os::raw::c_int) -> usize {
        cv__InputArray_step(self, i)
    }
}
#[doc = " @brief This type is very similar to InputArray except that it is used for input/output and output function\nparameters.\n\nJust like with InputArray, OpenCV users should not care about OutputArray, they just pass `Mat`,\n`vector<T>` etc. to the functions. The same limitation as for `InputArray`: *Do not explicitly\ncreate OutputArray instances* applies here too.\n\nIf you want to make your function polymorphic (i.e. accept different arrays as output parameters),\nit is also not very difficult. Take the sample above as the reference. Note that\n_OutputArray::create() needs to be called before _OutputArray::getMat(). This way you guarantee\nthat the output array is properly allocated.\n\nOptional output parameters. If you do not need certain output array to be computed and returned to\nyou, pass cv::noArray(), just like you would in the case of optional input array. At the\nimplementation level, use _OutputArray::needed() to check if certain output array needs to be\ncomputed or not.\n\nThere are several synonyms for OutputArray that are used to assist automatic Python/Java/... wrapper\ngenerators:\n@code\ntypedef OutputArray OutputArrayOfArrays;\ntypedef OutputArray InputOutputArray;\ntypedef OutputArray InputOutputArrayOfArrays;\n@endcode"]
#[repr(C)]
#[derive(Debug)]
pub struct cv__OutputArray {
    pub _base: cv__InputArray,
}
pub const cv__OutputArray_DepthMask_DEPTH_MASK_8U: cv__OutputArray_DepthMask = 1;
pub const cv__OutputArray_DepthMask_DEPTH_MASK_8S: cv__OutputArray_DepthMask = 2;
pub const cv__OutputArray_DepthMask_DEPTH_MASK_16U: cv__OutputArray_DepthMask = 4;
pub const cv__OutputArray_DepthMask_DEPTH_MASK_16S: cv__OutputArray_DepthMask = 8;
pub const cv__OutputArray_DepthMask_DEPTH_MASK_32S: cv__OutputArray_DepthMask = 16;
pub const cv__OutputArray_DepthMask_DEPTH_MASK_32F: cv__OutputArray_DepthMask = 32;
pub const cv__OutputArray_DepthMask_DEPTH_MASK_64F: cv__OutputArray_DepthMask = 64;
pub const cv__OutputArray_DepthMask_DEPTH_MASK_16F: cv__OutputArray_DepthMask = 128;
pub const cv__OutputArray_DepthMask_DEPTH_MASK_ALL: cv__OutputArray_DepthMask = 127;
pub const cv__OutputArray_DepthMask_DEPTH_MASK_ALL_BUT_8S: cv__OutputArray_DepthMask = 125;
pub const cv__OutputArray_DepthMask_DEPTH_MASK_ALL_16F: cv__OutputArray_DepthMask = 255;
pub const cv__OutputArray_DepthMask_DEPTH_MASK_FLT: cv__OutputArray_DepthMask = 96;
pub type cv__OutputArray_DepthMask = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv__OutputArray"][::std::mem::size_of::<cv__OutputArray>() - 24usize];
    ["Alignment of cv__OutputArray"][::std::mem::align_of::<cv__OutputArray>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray9fixedSizeEv"]
    pub fn cv__OutputArray_fixedSize(this: *const cv__OutputArray) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray9fixedTypeEv"]
    pub fn cv__OutputArray_fixedType(this: *const cv__OutputArray) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray6neededEv"]
    pub fn cv__OutputArray_needed(this: *const cv__OutputArray) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray9getMatRefEi"]
    pub fn cv__OutputArray_getMatRef(
        this: *const cv__OutputArray,
        i: ::std::os::raw::c_int,
    ) -> *mut cv_Mat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray10getUMatRefEi"]
    pub fn cv__OutputArray_getUMatRef(
        this: *const cv__OutputArray,
        i: ::std::os::raw::c_int,
    ) -> *mut cv_UMat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray12getGpuMatRefEv"]
    pub fn cv__OutputArray_getGpuMatRef(this: *const cv__OutputArray) -> *mut cv_cuda_GpuMat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray15getGpuMatVecRefEv"]
    pub fn cv__OutputArray_getGpuMatVecRef(this: *const cv__OutputArray) -> *mut std_vector;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray15getOGlBufferRefEv"]
    pub fn cv__OutputArray_getOGlBufferRef(this: *const cv__OutputArray) -> *mut cv_ogl_Buffer;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray13getHostMemRefEv"]
    pub fn cv__OutputArray_getHostMemRef(this: *const cv__OutputArray) -> *mut cv_cuda_HostMem;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray6createENS_5Size_IiEEiibNS0_9DepthMaskE"]
    pub fn cv__OutputArray_create(
        this: *const cv__OutputArray,
        sz: cv_Size,
        type_: ::std::os::raw::c_int,
        i: ::std::os::raw::c_int,
        allowTransposed: bool,
        fixedDepthMask: cv__OutputArray_DepthMask,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray6createEiiiibNS0_9DepthMaskE"]
    pub fn cv__OutputArray_create1(
        this: *const cv__OutputArray,
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        i: ::std::os::raw::c_int,
        allowTransposed: bool,
        fixedDepthMask: cv__OutputArray_DepthMask,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray6createEiPKiiibNS0_9DepthMaskE"]
    pub fn cv__OutputArray_create2(
        this: *const cv__OutputArray,
        dims: ::std::os::raw::c_int,
        size: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        i: ::std::os::raw::c_int,
        allowTransposed: bool,
        fixedDepthMask: cv__OutputArray_DepthMask,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray14createSameSizeERKNS_11_InputArrayEi"]
    pub fn cv__OutputArray_createSameSize(
        this: *const cv__OutputArray,
        arr: *const cv__InputArray,
        mtype: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray7releaseEv"]
    pub fn cv__OutputArray_release(this: *const cv__OutputArray);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray5clearEv"]
    pub fn cv__OutputArray_clear(this: *const cv__OutputArray);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray5setToERKNS_11_InputArrayES3_"]
    pub fn cv__OutputArray_setTo(
        this: *const cv__OutputArray,
        value: *const cv__InputArray,
        mask: *const cv__InputArray,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray6assignERKNS_4UMatE"]
    pub fn cv__OutputArray_assign(this: *const cv__OutputArray, u: *const cv_UMat);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray6assignERKNS_3MatE"]
    pub fn cv__OutputArray_assign1(this: *const cv__OutputArray, m: *const cv_Mat);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray6assignERKSt6vectorINS_4UMatESaIS2_EE"]
    pub fn cv__OutputArray_assign2(this: *const cv__OutputArray, v: *const std_vector);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray6assignERKSt6vectorINS_3MatESaIS2_EE"]
    pub fn cv__OutputArray_assign3(this: *const cv__OutputArray, v: *const std_vector);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray4moveERNS_4UMatE"]
    pub fn cv__OutputArray_move(this: *const cv__OutputArray, u: *mut cv_UMat);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12_OutputArray4moveERNS_3MatE"]
    pub fn cv__OutputArray_move1(this: *const cv__OutputArray, m: *mut cv_Mat);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv12_OutputArrayC1ERKSt6vectorINS_4cuda6GpuMatESaIS3_EE"]
    pub fn cv__OutputArray__OutputArray(this: *mut cv__OutputArray, d_mat: *const std_vector);
}
impl cv__OutputArray {
    #[inline]
    pub unsafe fn fixedSize(&self) -> bool {
        cv__OutputArray_fixedSize(self)
    }
    #[inline]
    pub unsafe fn fixedType(&self) -> bool {
        cv__OutputArray_fixedType(self)
    }
    #[inline]
    pub unsafe fn needed(&self) -> bool {
        cv__OutputArray_needed(self)
    }
    #[inline]
    pub unsafe fn getMatRef(&self, i: ::std::os::raw::c_int) -> *mut cv_Mat {
        cv__OutputArray_getMatRef(self, i)
    }
    #[inline]
    pub unsafe fn getUMatRef(&self, i: ::std::os::raw::c_int) -> *mut cv_UMat {
        cv__OutputArray_getUMatRef(self, i)
    }
    #[inline]
    pub unsafe fn getGpuMatRef(&self) -> *mut cv_cuda_GpuMat {
        cv__OutputArray_getGpuMatRef(self)
    }
    #[inline]
    pub unsafe fn getGpuMatVecRef(&self) -> *mut std_vector {
        cv__OutputArray_getGpuMatVecRef(self)
    }
    #[inline]
    pub unsafe fn getOGlBufferRef(&self) -> *mut cv_ogl_Buffer {
        cv__OutputArray_getOGlBufferRef(self)
    }
    #[inline]
    pub unsafe fn getHostMemRef(&self) -> *mut cv_cuda_HostMem {
        cv__OutputArray_getHostMemRef(self)
    }
    #[inline]
    pub unsafe fn create(
        &self,
        sz: cv_Size,
        type_: ::std::os::raw::c_int,
        i: ::std::os::raw::c_int,
        allowTransposed: bool,
        fixedDepthMask: cv__OutputArray_DepthMask,
    ) {
        cv__OutputArray_create(self, sz, type_, i, allowTransposed, fixedDepthMask)
    }
    #[inline]
    pub unsafe fn create1(
        &self,
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        i: ::std::os::raw::c_int,
        allowTransposed: bool,
        fixedDepthMask: cv__OutputArray_DepthMask,
    ) {
        cv__OutputArray_create1(self, rows, cols, type_, i, allowTransposed, fixedDepthMask)
    }
    #[inline]
    pub unsafe fn create2(
        &self,
        dims: ::std::os::raw::c_int,
        size: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        i: ::std::os::raw::c_int,
        allowTransposed: bool,
        fixedDepthMask: cv__OutputArray_DepthMask,
    ) {
        cv__OutputArray_create2(self, dims, size, type_, i, allowTransposed, fixedDepthMask)
    }
    #[inline]
    pub unsafe fn createSameSize(&self, arr: *const cv__InputArray, mtype: ::std::os::raw::c_int) {
        cv__OutputArray_createSameSize(self, arr, mtype)
    }
    #[inline]
    pub unsafe fn release(&self) {
        cv__OutputArray_release(self)
    }
    #[inline]
    pub unsafe fn clear(&self) {
        cv__OutputArray_clear(self)
    }
    #[inline]
    pub unsafe fn setTo(&self, value: *const cv__InputArray, mask: *const cv__InputArray) {
        cv__OutputArray_setTo(self, value, mask)
    }
    #[inline]
    pub unsafe fn assign(&self, u: *const cv_UMat) {
        cv__OutputArray_assign(self, u)
    }
    #[inline]
    pub unsafe fn assign1(&self, m: *const cv_Mat) {
        cv__OutputArray_assign1(self, m)
    }
    #[inline]
    pub unsafe fn assign2(&self, v: *const std_vector) {
        cv__OutputArray_assign2(self, v)
    }
    #[inline]
    pub unsafe fn assign3(&self, v: *const std_vector) {
        cv__OutputArray_assign3(self, v)
    }
    #[inline]
    pub unsafe fn move_(&self, u: *mut cv_UMat) {
        cv__OutputArray_move(self, u)
    }
    #[inline]
    pub unsafe fn move1(&self, m: *mut cv_Mat) {
        cv__OutputArray_move1(self, m)
    }
    #[inline]
    pub unsafe fn new(d_mat: *const std_vector) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv__OutputArray__OutputArray(__bindgen_tmp.as_mut_ptr(), d_mat);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cv__InputOutputArray {
    pub _base: cv__OutputArray,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv__InputOutputArray"][::std::mem::size_of::<cv__InputOutputArray>() - 24usize];
    ["Alignment of cv__InputOutputArray"][::std::mem::align_of::<cv__InputOutputArray>() - 8usize];
};
pub type cv_InputArray = *const cv__InputArray;
pub type cv_InputArrayOfArrays = cv_InputArray;
pub type cv_OutputArray = *const cv__OutputArray;
pub type cv_OutputArrayOfArrays = cv_OutputArray;
pub type cv_InputOutputArray = *const cv__InputOutputArray;
pub type cv_InputOutputArrayOfArrays = cv_InputOutputArray;
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv7noArrayEv"]
    pub fn cv_noArray() -> cv_InputOutputArray;
}
pub const cv_UMatUsageFlags_USAGE_DEFAULT: cv_UMatUsageFlags = 0;
pub const cv_UMatUsageFlags_USAGE_ALLOCATE_HOST_MEMORY: cv_UMatUsageFlags = 1;
pub const cv_UMatUsageFlags_USAGE_ALLOCATE_DEVICE_MEMORY: cv_UMatUsageFlags = 2;
pub const cv_UMatUsageFlags_USAGE_ALLOCATE_SHARED_MEMORY: cv_UMatUsageFlags = 4;
pub const cv_UMatUsageFlags___UMAT_USAGE_FLAGS_32BIT: cv_UMatUsageFlags = 2147483647;
#[doc = "! Usage flags for allocator"]
pub type cv_UMatUsageFlags = ::std::os::raw::c_uint;
#[repr(C)]
pub struct cv_MatAllocator__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief  Custom array allocator"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_MatAllocator {
    pub vtable_: *const cv_MatAllocator__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_MatAllocator"][::std::mem::size_of::<cv_MatAllocator>() - 8usize];
    ["Alignment of cv_MatAllocator"][::std::mem::align_of::<cv_MatAllocator>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12MatAllocator3mapEPNS_8UMatDataENS_10AccessFlagE"]
    pub fn cv_MatAllocator_map(
        this: *mut ::std::os::raw::c_void,
        data: *mut cv_UMatData,
        accessflags: cv_AccessFlag,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12MatAllocator5unmapEPNS_8UMatDataE"]
    pub fn cv_MatAllocator_unmap(this: *mut ::std::os::raw::c_void, data: *mut cv_UMatData);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12MatAllocator8downloadEPNS_8UMatDataEPviPKmS5_S5_S5_"]
    pub fn cv_MatAllocator_download(
        this: *mut ::std::os::raw::c_void,
        data: *mut cv_UMatData,
        dst: *mut ::std::os::raw::c_void,
        dims: ::std::os::raw::c_int,
        sz: *const usize,
        srcofs: *const usize,
        srcstep: *const usize,
        dststep: *const usize,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12MatAllocator6uploadEPNS_8UMatDataEPKviPKmS6_S6_S6_"]
    pub fn cv_MatAllocator_upload(
        this: *mut ::std::os::raw::c_void,
        data: *mut cv_UMatData,
        src: *const ::std::os::raw::c_void,
        dims: ::std::os::raw::c_int,
        sz: *const usize,
        dstofs: *const usize,
        dststep: *const usize,
        srcstep: *const usize,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12MatAllocator4copyEPNS_8UMatDataES2_iPKmS4_S4_S4_S4_b"]
    pub fn cv_MatAllocator_copy(
        this: *mut ::std::os::raw::c_void,
        srcdata: *mut cv_UMatData,
        dstdata: *mut cv_UMatData,
        dims: ::std::os::raw::c_int,
        sz: *const usize,
        srcofs: *const usize,
        srcstep: *const usize,
        dstofs: *const usize,
        dststep: *const usize,
        sync: bool,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv12MatAllocator23getBufferPoolControllerEPKc"]
    pub fn cv_MatAllocator_getBufferPoolController(
        this: *mut ::std::os::raw::c_void,
        id: *const ::std::os::raw::c_char,
    ) -> *mut cv_BufferPoolController;
}
#[doc = " @brief  Comma-separated Matrix Initializer\n\nThe class instances are usually not created explicitly.\nInstead, they are created on \"matrix << firstValue\" operator.\n\nThe sample below initializes 2x2 rotation matrix:\n\n\\code\ndouble angle = 30, a = cos(angle*CV_PI/180), b = sin(angle*CV_PI/180);\nMat R = (Mat_<double>(2,2) << a, -b, b, a);\n\\endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_MatCommaInitializer_ {
    pub it: cv_MatIterator_,
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_UMatData {
    pub prevAllocator: *const cv_MatAllocator,
    pub currAllocator: *const cv_MatAllocator,
    pub urefcount: ::std::os::raw::c_int,
    pub refcount: ::std::os::raw::c_int,
    pub data: *mut uchar,
    pub origdata: *mut uchar,
    pub size: usize,
    pub flags: cv_UMatData_MemoryFlag,
    pub handle: *mut ::std::os::raw::c_void,
    pub userdata: *mut ::std::os::raw::c_void,
    pub allocatorFlags_: ::std::os::raw::c_int,
    pub mapcount: ::std::os::raw::c_int,
    pub originalUMatData: *mut cv_UMatData,
}
pub const cv_UMatData_MemoryFlag_COPY_ON_MAP: cv_UMatData_MemoryFlag = 1;
pub const cv_UMatData_MemoryFlag_HOST_COPY_OBSOLETE: cv_UMatData_MemoryFlag = 2;
pub const cv_UMatData_MemoryFlag_DEVICE_COPY_OBSOLETE: cv_UMatData_MemoryFlag = 4;
pub const cv_UMatData_MemoryFlag_TEMP_UMAT: cv_UMatData_MemoryFlag = 8;
pub const cv_UMatData_MemoryFlag_TEMP_COPIED_UMAT: cv_UMatData_MemoryFlag = 24;
pub const cv_UMatData_MemoryFlag_USER_ALLOCATED: cv_UMatData_MemoryFlag = 32;
pub const cv_UMatData_MemoryFlag_DEVICE_MEM_MAPPED: cv_UMatData_MemoryFlag = 64;
pub const cv_UMatData_MemoryFlag_ASYNC_CLEANUP: cv_UMatData_MemoryFlag = 128;
pub type cv_UMatData_MemoryFlag = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_UMatData"][::std::mem::size_of::<cv_UMatData>() - 88usize];
    ["Alignment of cv_UMatData"][::std::mem::align_of::<cv_UMatData>() - 8usize];
    ["Offset of field: cv_UMatData::prevAllocator"]
        [::std::mem::offset_of!(cv_UMatData, prevAllocator) - 0usize];
    ["Offset of field: cv_UMatData::currAllocator"]
        [::std::mem::offset_of!(cv_UMatData, currAllocator) - 8usize];
    ["Offset of field: cv_UMatData::urefcount"]
        [::std::mem::offset_of!(cv_UMatData, urefcount) - 16usize];
    ["Offset of field: cv_UMatData::refcount"]
        [::std::mem::offset_of!(cv_UMatData, refcount) - 20usize];
    ["Offset of field: cv_UMatData::data"][::std::mem::offset_of!(cv_UMatData, data) - 24usize];
    ["Offset of field: cv_UMatData::origdata"]
        [::std::mem::offset_of!(cv_UMatData, origdata) - 32usize];
    ["Offset of field: cv_UMatData::size"][::std::mem::offset_of!(cv_UMatData, size) - 40usize];
    ["Offset of field: cv_UMatData::flags"][::std::mem::offset_of!(cv_UMatData, flags) - 48usize];
    ["Offset of field: cv_UMatData::handle"][::std::mem::offset_of!(cv_UMatData, handle) - 56usize];
    ["Offset of field: cv_UMatData::userdata"]
        [::std::mem::offset_of!(cv_UMatData, userdata) - 64usize];
    ["Offset of field: cv_UMatData::allocatorFlags_"]
        [::std::mem::offset_of!(cv_UMatData, allocatorFlags_) - 72usize];
    ["Offset of field: cv_UMatData::mapcount"]
        [::std::mem::offset_of!(cv_UMatData, mapcount) - 76usize];
    ["Offset of field: cv_UMatData::originalUMatData"]
        [::std::mem::offset_of!(cv_UMatData, originalUMatData) - 80usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8UMatData4lockEv"]
    pub fn cv_UMatData_lock(this: *mut cv_UMatData);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8UMatData6unlockEv"]
    pub fn cv_UMatData_unlock(this: *mut cv_UMatData);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8UMatDataC1EPKNS_12MatAllocatorE"]
    pub fn cv_UMatData_UMatData(this: *mut cv_UMatData, allocator: *const cv_MatAllocator);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8UMatDataD1Ev"]
    pub fn cv_UMatData_UMatData_destructor(this: *mut cv_UMatData);
}
impl cv_UMatData {
    #[inline]
    pub unsafe fn lock(&mut self) {
        cv_UMatData_lock(self)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) {
        cv_UMatData_unlock(self)
    }
    #[inline]
    pub unsafe fn new(allocator: *const cv_MatAllocator) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_UMatData_UMatData(__bindgen_tmp.as_mut_ptr(), allocator);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cv_UMatData_UMatData_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_MatSize {
    pub p: *mut ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_MatSize"][::std::mem::size_of::<cv_MatSize>() - 8usize];
    ["Alignment of cv_MatSize"][::std::mem::align_of::<cv_MatSize>() - 8usize];
    ["Offset of field: cv_MatSize::p"][::std::mem::offset_of!(cv_MatSize, p) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_MatStep {
    pub p: *mut usize,
    pub buf: [usize; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_MatStep"][::std::mem::size_of::<cv_MatStep>() - 24usize];
    ["Alignment of cv_MatStep"][::std::mem::align_of::<cv_MatStep>() - 8usize];
    ["Offset of field: cv_MatStep::p"][::std::mem::offset_of!(cv_MatStep, p) - 0usize];
    ["Offset of field: cv_MatStep::buf"][::std::mem::offset_of!(cv_MatStep, buf) - 8usize];
};
#[doc = " @brief n-dimensional dense array class \\anchor CVMat_Details\n\nThe class Mat represents an n-dimensional dense numerical single-channel or multi-channel array. It\ncan be used to store real or complex-valued vectors and matrices, grayscale or color images, voxel\nvolumes, vector fields, point clouds, tensors, histograms (though, very high-dimensional histograms\nmay be better stored in a SparseMat ). The data layout of the array `M` is defined by the array\n`M.step[]`, so that the address of element \\f$(i_0,...,i_{M.dims-1})\\f$, where \\f$0\\leq i_k<M.size[k]\\f$, is\ncomputed as:\n\\f[addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ... + M.step[M.dims-1]*i_{M.dims-1}\\f]\nIn case of a 2-dimensional array, the above formula is reduced to:\n\\f[addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j\\f]\nNote that `M.step[i] >= M.step[i+1]` (in fact, `M.step[i] >= M.step[i+1]*M.size[i+1]` ). This means\nthat 2-dimensional matrices are stored row-by-row, 3-dimensional matrices are stored plane-by-plane,\nand so on. M.step[M.dims-1] is minimal and always equal to the element size M.elemSize() .\n\nSo, the data layout in Mat is compatible with the majority of dense array types from the standard\ntoolkits and SDKs, such as Numpy (ndarray), Win32 (independent device bitmaps), and others,\nthat is, with any array that uses *steps* (or *strides*) to compute the position of a pixel.\nDue to this compatibility, it is possible to make a Mat header for user-allocated data and process\nit in-place using OpenCV functions.\n\nThere are many different ways to create a Mat object. The most popular options are listed below:\n\n- Use the create(nrows, ncols, type) method or the similar Mat(nrows, ncols, type[, fillValue])\nconstructor. A new array of the specified size and type is allocated. type has the same meaning as\nin the cvCreateMat method. For example, CV_8UC1 means a 8-bit single-channel array, CV_32FC2\nmeans a 2-channel (complex) floating-point array, and so on.\n@code\n// make a 7x7 complex matrix filled with 1+3j.\nMat M(7,7,CV_32FC2,Scalar(1,3));\n// and now turn M to a 100x60 15-channel 8-bit matrix.\n// The old content will be deallocated\nM.create(100,60,CV_8UC(15));\n@endcode\nAs noted in the introduction to this chapter, create() allocates only a new array when the shape\nor type of the current array are different from the specified ones.\n\n- Create a multi-dimensional array:\n@code\n// create a 100x100x100 8-bit array\nint sz[] = {100, 100, 100};\nMat bigCube(3, sz, CV_8U, Scalar::all(0));\n@endcode\nIt passes the number of dimensions =1 to the Mat constructor but the created array will be\n2-dimensional with the number of columns set to 1. So, Mat::dims is always \\>= 2 (can also be 0\nwhen the array is empty).\n\n- Use a copy constructor or assignment operator where there can be an array or expression on the\nright side (see below). As noted in the introduction, the array assignment is an O(1) operation\nbecause it only copies the header and increases the reference counter. The Mat::clone() method can\nbe used to get a full (deep) copy of the array when you need it.\n\n- Construct a header for a part of another array. It can be a single row, single column, several\nrows, several columns, rectangular region in the array (called a *minor* in algebra) or a\ndiagonal. Such operations are also O(1) because the new header references the same data. You can\nactually modify a part of the array using this feature, for example:\n@code\n// add the 5-th row, multiplied by 3 to the 3rd row\nM.row(3) = M.row(3) + M.row(5)*3;\n// now copy the 7-th column to the 1-st column\n// M.col(1) = M.col(7); // this will not work\nMat M1 = M.col(1);\nM.col(7).copyTo(M1);\n// create a new 320x240 image\nMat img(Size(320,240),CV_8UC3);\n// select a ROI\nMat roi(img, Rect(10,10,100,100));\n// fill the ROI with (0,255,0) (which is green in RGB space);\n// the original 320x240 image will be modified\nroi = Scalar(0,255,0);\n@endcode\nDue to the additional datastart and dataend members, it is possible to compute a relative\nsub-array position in the main *container* array using locateROI():\n@code\nMat A = Mat::eye(10, 10, CV_32S);\n// extracts A columns, 1 (inclusive) to 3 (exclusive).\nMat B = A(Range::all(), Range(1, 3));\n// extracts B rows, 5 (inclusive) to 9 (exclusive).\n// that is, C \\~ A(Range(5, 9), Range(1, 3))\nMat C = B(Range(5, 9), Range::all());\nSize size; Point ofs;\nC.locateROI(size, ofs);\n// size will be (width=10,height=10) and the ofs will be (x=1, y=5)\n@endcode\nAs in case of whole matrices, if you need a deep copy, use the `clone()` method of the extracted\nsub-matrices.\n\n- Make a header for user-allocated data. It can be useful to do the following:\n-# Process \"foreign\" data using OpenCV (for example, when you implement a DirectShow\\* filter or\na processing module for gstreamer, and so on). For example:\n@code\nvoid process_video_frame(const unsigned char* pixels,\nint width, int height, int step)\n{\nMat img(height, width, CV_8UC3, pixels, step);\nGaussianBlur(img, img, Size(7,7), 1.5, 1.5);\n}\n@endcode\n-# Quickly initialize small matrices and/or get a super-fast element access.\n@code\ndouble m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};\nMat M = Mat(3, 3, CV_64F, m).inv();\n@endcode\n.\n\n- Use MATLAB-style array initializers, zeros(), ones(), eye(), for example:\n@code\n// create a double-precision identity matrix and add it to M.\nM += Mat::eye(M.rows, M.cols, CV_64F);\n@endcode\n\n- Use a comma-separated initializer:\n@code\n// create a 3x3 double-precision identity matrix\nMat M = (Mat_<double>(3,3) << 1, 0, 0, 0, 1, 0, 0, 0, 1);\n@endcode\nWith this approach, you first call a constructor of the Mat class with the proper parameters, and\nthen you just put `<< operator` followed by comma-separated values that can be constants,\nvariables, expressions, and so on. Also, note the extra parentheses required to avoid compilation\nerrors.\n\nOnce the array is created, it is automatically managed via a reference-counting mechanism. If the\narray header is built on top of user-allocated data, you should handle the data by yourself. The\narray data is deallocated when no one points to it. If you want to release the data pointed by a\narray header before the array destructor is called, use Mat::release().\n\nThe next important thing to learn about the array class is element access. This manual already\ndescribed how to compute an address of each array element. Normally, you are not required to use the\nformula directly in the code. If you know the array element type (which can be retrieved using the\nmethod Mat::type() ), you can access the element \\f$M_{ij}\\f$ of a 2-dimensional array as:\n@code\nM.at<double>(i,j) += 1.f;\n@endcode\nassuming that `M` is a double-precision floating-point array. There are several variants of the method\nat for a different number of dimensions.\n\nIf you need to process a whole row of a 2D array, the most efficient way is to get the pointer to\nthe row first, and then just use the plain C operator [] :\n@code\n// compute sum of positive matrix elements\n// (assuming that M is a double-precision matrix)\ndouble sum=0;\nfor(int i = 0; i < M.rows; i++)\n{\nconst double* Mi = M.ptr<double>(i);\nfor(int j = 0; j < M.cols; j++)\nsum += std::max(Mi[j], 0.);\n}\n@endcode\nSome operations, like the one above, do not actually depend on the array shape. They just process\nelements of an array one by one (or elements from multiple arrays that have the same coordinates,\nfor example, array addition). Such operations are called *element-wise*. It makes sense to check\nwhether all the input/output arrays are continuous, namely, have no gaps at the end of each row. If\nyes, process them as a long single row:\n@code\n// compute the sum of positive matrix elements, optimized variant\ndouble sum=0;\nint cols = M.cols, rows = M.rows;\nif(M.isContinuous())\n{\ncols *= rows;\nrows = 1;\n}\nfor(int i = 0; i < rows; i++)\n{\nconst double* Mi = M.ptr<double>(i);\nfor(int j = 0; j < cols; j++)\nsum += std::max(Mi[j], 0.);\n}\n@endcode\nIn case of the continuous matrix, the outer loop body is executed just once. So, the overhead is\nsmaller, which is especially noticeable in case of small matrices.\n\nFinally, there are STL-style iterators that are smart enough to skip gaps between successive rows:\n@code\n// compute sum of positive matrix elements, iterator-based variant\ndouble sum=0;\nMatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();\nfor(; it != it_end; ++it)\nsum += std::max(*it, 0.);\n@endcode\nThe matrix iterators are random-access iterators, so they can be passed to any STL algorithm,\nincluding std::sort().\n\n@note Matrix Expressions and arithmetic see MatExpr"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_Mat {
    #[doc = " includes several bit-fields:\n- the magic signature\n- continuity flag\n- depth\n- number of channels"]
    pub flags: ::std::os::raw::c_int,
    #[doc = "! the matrix dimensionality, >= 2"]
    pub dims: ::std::os::raw::c_int,
    #[doc = "! the number of rows and columns or (-1, -1) when the matrix has more than 2 dimensions"]
    pub rows: ::std::os::raw::c_int,
    #[doc = "! the number of rows and columns or (-1, -1) when the matrix has more than 2 dimensions"]
    pub cols: ::std::os::raw::c_int,
    #[doc = "! pointer to the data"]
    pub data: *mut uchar,
    #[doc = "! helper fields used in locateROI and adjustROI"]
    pub datastart: *const uchar,
    pub dataend: *const uchar,
    pub datalimit: *const uchar,
    #[doc = "! custom allocator"]
    pub allocator: *mut cv_MatAllocator,
    #[doc = "! interaction with UMat"]
    pub u: *mut cv_UMatData,
    pub size: cv_MatSize,
    pub step: cv_MatStep,
}
pub const cv_Mat_MAGIC_VAL: cv_Mat__bindgen_ty_1 = 1124007936;
pub const cv_Mat_AUTO_STEP: cv_Mat__bindgen_ty_1 = 0;
pub const cv_Mat_CONTINUOUS_FLAG: cv_Mat__bindgen_ty_1 = 16384;
pub const cv_Mat_SUBMATRIX_FLAG: cv_Mat__bindgen_ty_1 = 32768;
pub type cv_Mat__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const cv_Mat_MAGIC_MASK: cv_Mat__bindgen_ty_2 = 4294901760;
pub const cv_Mat_TYPE_MASK: cv_Mat__bindgen_ty_2 = 4095;
pub const cv_Mat_DEPTH_MASK: cv_Mat__bindgen_ty_2 = 7;
pub type cv_Mat__bindgen_ty_2 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_Mat"][::std::mem::size_of::<cv_Mat>() - 96usize];
    ["Alignment of cv_Mat"][::std::mem::align_of::<cv_Mat>() - 8usize];
    ["Offset of field: cv_Mat::flags"][::std::mem::offset_of!(cv_Mat, flags) - 0usize];
    ["Offset of field: cv_Mat::dims"][::std::mem::offset_of!(cv_Mat, dims) - 4usize];
    ["Offset of field: cv_Mat::rows"][::std::mem::offset_of!(cv_Mat, rows) - 8usize];
    ["Offset of field: cv_Mat::cols"][::std::mem::offset_of!(cv_Mat, cols) - 12usize];
    ["Offset of field: cv_Mat::data"][::std::mem::offset_of!(cv_Mat, data) - 16usize];
    ["Offset of field: cv_Mat::datastart"][::std::mem::offset_of!(cv_Mat, datastart) - 24usize];
    ["Offset of field: cv_Mat::dataend"][::std::mem::offset_of!(cv_Mat, dataend) - 32usize];
    ["Offset of field: cv_Mat::datalimit"][::std::mem::offset_of!(cv_Mat, datalimit) - 40usize];
    ["Offset of field: cv_Mat::allocator"][::std::mem::offset_of!(cv_Mat, allocator) - 48usize];
    ["Offset of field: cv_Mat::u"][::std::mem::offset_of!(cv_Mat, u) - 56usize];
    ["Offset of field: cv_Mat::size"][::std::mem::offset_of!(cv_Mat, size) - 64usize];
    ["Offset of field: cv_Mat::step"][::std::mem::offset_of!(cv_Mat, step) - 72usize];
};
unsafe extern "C" {
    #[doc = "! retrieve UMat from Mat"]
    #[link_name = "\u{1}_ZNK2cv3Mat7getUMatENS_10AccessFlagENS_14UMatUsageFlagsE"]
    pub fn cv_Mat_getUMat(
        this: *const cv_Mat,
        accessFlags: cv_AccessFlag,
        usageFlags: cv_UMatUsageFlags,
    ) -> cv_UMat;
}
unsafe extern "C" {
    #[doc = " @brief Extracts a diagonal from a matrix\n\nThe method makes a new header for the specified matrix diagonal. The new matrix is represented as a\nsingle-column matrix. Similarly to Mat::row and Mat::col, this is an O(1) operation.\n@param d index of the diagonal, with the following values:\n- `d=0` is the main diagonal.\n- `d<0` is a diagonal from the lower half. For example, d=-1 means the diagonal is set\nimmediately below the main one.\n- `d>0` is a diagonal from the upper half. For example, d=1 means the diagonal is set\nimmediately above the main one.\nFor example:\n@code\nMat m = (Mat_<int>(3,3) <<\n1,2,3,\n4,5,6,\n7,8,9);\nMat d0 = m.diag(0);\nMat d1 = m.diag(1);\nMat d_1 = m.diag(-1);\n@endcode\nThe resulting matrices are\n@code\nd0 =\n[1;\n5;\n9]\nd1 =\n[2;\n6]\nd_1 =\n[4;\n8]\n@endcode"]
    #[link_name = "\u{1}_ZNK2cv3Mat4diagEi"]
    pub fn cv_Mat_diag(this: *const cv_Mat, d: ::std::os::raw::c_int) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief creates a diagonal matrix\n\nThe method creates a square diagonal matrix from specified main diagonal.\n@param d One-dimensional matrix that represents the main diagonal."]
    #[link_name = "\u{1}_ZN2cv3Mat4diagERKS0_"]
    pub fn cv_Mat_diag1(d: *const cv_Mat) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Copies the matrix to another one.\n\nThe method copies the matrix data to another matrix. Before copying the data, the method invokes :\n@code\nm.create(this->size(), this->type());\n@endcode\nso that the destination matrix is reallocated if needed. While m.copyTo(m); works flawlessly, the\nfunction does not handle the case of a partial overlap between the source and the destination\nmatrices.\n\nWhen the operation mask is specified, if the Mat::create call shown above reallocates the matrix,\nthe newly allocated matrix is initialized with all zeros before copying the data.\n@param m Destination matrix. If it does not have a proper size or type before the operation, it is\nreallocated."]
    #[link_name = "\u{1}_ZNK2cv3Mat6copyToERKNS_12_OutputArrayE"]
    pub fn cv_Mat_copyTo(this: *const cv_Mat, m: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @overload\n@param m Destination matrix. If it does not have a proper size or type before the operation, it is\nreallocated.\n@param mask Operation mask of the same size as \\*this. Its non-zero elements indicate which matrix\nelements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels."]
    #[link_name = "\u{1}_ZNK2cv3Mat6copyToERKNS_12_OutputArrayERKNS_11_InputArrayE"]
    pub fn cv_Mat_copyTo1(this: *const cv_Mat, m: cv_OutputArray, mask: cv_InputArray);
}
unsafe extern "C" {
    #[doc = " @brief Converts an array to another data type with optional scaling.\n\nThe method converts source pixel values to the target data type. saturate_cast\\<\\> is applied at\nthe end to avoid possible overflows:\n\n\\f[m(x,y) = saturate \\_ cast<rType>( \\alpha (*this)(x,y) +  \\beta )\\f]\n@param m output matrix; if it does not have a proper size or type before the operation, it is\nreallocated.\n@param rtype desired output matrix type or, rather, the depth since the number of channels are the\nsame as the input has; if rtype is negative, the output matrix will have the same type as the input.\n@param alpha optional scale factor.\n@param beta optional delta added to the scaled values."]
    #[link_name = "\u{1}_ZNK2cv3Mat9convertToERKNS_12_OutputArrayEidd"]
    pub fn cv_Mat_convertTo(
        this: *const cv_Mat,
        m: cv_OutputArray,
        rtype: ::std::os::raw::c_int,
        alpha: f64,
        beta: f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Sets all or some of the array elements to the specified value.\n\nThis is an advanced variant of the Mat::operator=(const Scalar& s) operator.\n@param value Assigned scalar converted to the actual array type.\n@param mask Operation mask of the same size as \\*this. Its non-zero elements indicate which matrix\nelements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels"]
    #[link_name = "\u{1}_ZN2cv3Mat5setToERKNS_11_InputArrayES3_"]
    pub fn cv_Mat_setTo(
        this: *mut cv_Mat,
        value: cv_InputArray,
        mask: cv_InputArray,
    ) -> *mut cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Changes the shape and/or the number of channels of a 2D matrix without copying the data.\n\nThe method makes a new matrix header for \\*this elements. The new matrix may have a different size\nand/or different number of channels. Any combination is possible if:\n-   No extra elements are included into the new matrix and no elements are excluded. Consequently,\nthe product rows\\*cols\\*channels() must stay the same after the transformation.\n-   No data is copied. That is, this is an O(1) operation. Consequently, if you change the number of\nrows, or the operation changes the indices of elements row in some other way, the matrix must be\ncontinuous. See Mat::isContinuous .\n\nFor example, if there is a set of 3D points stored as an STL vector, and you want to represent the\npoints as a 3xN matrix, do the following:\n@code\nstd::vector<Point3f> vec;\n...\nMat pointMat = Mat(vec). // convert vector to Mat, O(1) operation\nreshape(1). // make Nx3 1-channel matrix out of Nx1 3-channel.\n// Also, an O(1) operation\nt(); // finally, transpose the Nx3 matrix.\n// This involves copying all the elements\n@endcode\n@param cn New number of channels. If the parameter is 0, the number of channels remains the same.\n@param rows New number of rows. If the parameter is 0, the number of rows remains the same."]
    #[link_name = "\u{1}_ZNK2cv3Mat7reshapeEii"]
    pub fn cv_Mat_reshape(
        this: *const cv_Mat,
        cn: ::std::os::raw::c_int,
        rows: ::std::os::raw::c_int,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZNK2cv3Mat7reshapeEiiPKi"]
    pub fn cv_Mat_reshape1(
        this: *const cv_Mat,
        cn: ::std::os::raw::c_int,
        newndims: ::std::os::raw::c_int,
        newsz: *const ::std::os::raw::c_int,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZNK2cv3Mat7reshapeEiRKSt6vectorIiSaIiEE"]
    pub fn cv_Mat_reshape2(
        this: *const cv_Mat,
        cn: ::std::os::raw::c_int,
        newshape: *const std_vector,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Transposes a matrix.\n\nThe method performs matrix transposition by means of matrix expressions. It does not perform the\nactual transposition but returns a temporary matrix transposition object that can be further used as\na part of more complex matrix expressions or can be assigned to a matrix:\n@code\nMat A1 = A + Mat::eye(A.size(), A.type())*lambda;\nMat C = A1.t()*A1; // compute (A + lambda*I)^t * (A + lamda*I)\n@endcode"]
    #[link_name = "\u{1}_ZNK2cv3Mat1tEv"]
    pub fn cv_Mat_t(this: *const cv_Mat) -> cv_MatExpr;
}
unsafe extern "C" {
    #[doc = " @brief Inverses a matrix.\n\nThe method performs a matrix inversion by means of matrix expressions. This means that a temporary\nmatrix inversion object is returned by the method and can be used further as a part of more complex\nmatrix expressions or can be assigned to a matrix.\n@param method Matrix inversion method. One of cv::DecompTypes"]
    #[link_name = "\u{1}_ZNK2cv3Mat3invEi"]
    pub fn cv_Mat_inv(this: *const cv_Mat, method: ::std::os::raw::c_int) -> cv_MatExpr;
}
unsafe extern "C" {
    #[doc = " @brief Performs an element-wise multiplication or division of the two matrices.\n\nThe method returns a temporary object encoding per-element array multiplication, with optional\nscale. Note that this is not a matrix multiplication that corresponds to a simpler \"\\*\" operator.\n\nExample:\n@code\nMat C = A.mul(5/B); // equivalent to divide(A, B, C, 5)\n@endcode\n@param m Another array of the same type and the same size as \\*this, or a matrix expression.\n@param scale Optional scale factor."]
    #[link_name = "\u{1}_ZNK2cv3Mat3mulERKNS_11_InputArrayEd"]
    pub fn cv_Mat_mul(this: *const cv_Mat, m: cv_InputArray, scale: f64) -> cv_MatExpr;
}
unsafe extern "C" {
    #[doc = " @brief Computes a cross-product of two 3-element vectors.\n\nThe method computes a cross-product of two 3-element vectors. The vectors must be 3-element\nfloating-point vectors of the same shape and size. The result is another 3-element vector of the\nsame shape and type as operands.\n@param m Another cross-product operand."]
    #[link_name = "\u{1}_ZNK2cv3Mat5crossERKNS_11_InputArrayE"]
    pub fn cv_Mat_cross(this: *const cv_Mat, m: cv_InputArray) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Computes a dot-product of two vectors.\n\nThe method computes a dot-product of two matrices. If the matrices are not single-column or\nsingle-row vectors, the top-to-bottom left-to-right scan ordering is used to treat them as 1D\nvectors. The vectors must have the same size and type. If the matrices have more than one channel,\nthe dot products from all the channels are summed together.\n@param m another dot-product operand."]
    #[link_name = "\u{1}_ZNK2cv3Mat3dotERKNS_11_InputArrayE"]
    pub fn cv_Mat_dot(this: *const cv_Mat, m: cv_InputArray) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Returns a zero array of the specified size and type.\n\nThe method returns a Matlab-style zero array initializer. It can be used to quickly form a constant\narray as a function parameter, part of a matrix expression, or as a matrix initializer:\n@code\nMat A;\nA = Mat::zeros(3, 3, CV_32F);\n@endcode\nIn the example above, a new matrix is allocated only if A is not a 3x3 floating-point matrix.\nOtherwise, the existing matrix A is filled with zeros.\n@param rows Number of rows.\n@param cols Number of columns.\n@param type Created matrix type."]
    #[link_name = "\u{1}_ZN2cv3Mat5zerosEiii"]
    pub fn cv_Mat_zeros(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_MatExpr;
}
unsafe extern "C" {
    #[doc = " @overload\n@param size Alternative to the matrix size specification Size(cols, rows) .\n@param type Created matrix type."]
    #[link_name = "\u{1}_ZN2cv3Mat5zerosENS_5Size_IiEEi"]
    pub fn cv_Mat_zeros1(size: cv_Size, type_: ::std::os::raw::c_int) -> cv_MatExpr;
}
unsafe extern "C" {
    #[doc = " @overload\n@param ndims Array dimensionality.\n@param sz Array of integers specifying the array shape.\n@param type Created matrix type."]
    #[link_name = "\u{1}_ZN2cv3Mat5zerosEiPKii"]
    pub fn cv_Mat_zeros2(
        ndims: ::std::os::raw::c_int,
        sz: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_MatExpr;
}
unsafe extern "C" {
    #[doc = " @brief Returns an array of all 1's of the specified size and type.\n\nThe method returns a Matlab-style 1's array initializer, similarly to Mat::zeros. Note that using\nthis method you can initialize an array with an arbitrary value, using the following Matlab idiom:\n@code\nMat A = Mat::ones(100, 100, CV_8U)*3; // make 100x100 matrix filled with 3.\n@endcode\nThe above operation does not form a 100x100 matrix of 1's and then multiply it by 3. Instead, it\njust remembers the scale factor (3 in this case) and use it when actually invoking the matrix\ninitializer.\n@note In case of multi-channels type, only the first channel will be initialized with 1's, the\nothers will be set to 0's.\n@param rows Number of rows.\n@param cols Number of columns.\n@param type Created matrix type."]
    #[link_name = "\u{1}_ZN2cv3Mat4onesEiii"]
    pub fn cv_Mat_ones(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_MatExpr;
}
unsafe extern "C" {
    #[doc = " @overload\n@param size Alternative to the matrix size specification Size(cols, rows) .\n@param type Created matrix type."]
    #[link_name = "\u{1}_ZN2cv3Mat4onesENS_5Size_IiEEi"]
    pub fn cv_Mat_ones1(size: cv_Size, type_: ::std::os::raw::c_int) -> cv_MatExpr;
}
unsafe extern "C" {
    #[doc = " @overload\n@param ndims Array dimensionality.\n@param sz Array of integers specifying the array shape.\n@param type Created matrix type."]
    #[link_name = "\u{1}_ZN2cv3Mat4onesEiPKii"]
    pub fn cv_Mat_ones2(
        ndims: ::std::os::raw::c_int,
        sz: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_MatExpr;
}
unsafe extern "C" {
    #[doc = " @brief Returns an identity matrix of the specified size and type.\n\nThe method returns a Matlab-style identity matrix initializer, similarly to Mat::zeros. Similarly to\nMat::ones, you can use a scale operation to create a scaled identity matrix efficiently:\n@code\n// make a 4x4 diagonal matrix with 0.1's on the diagonal.\nMat A = Mat::eye(4, 4, CV_32F)*0.1;\n@endcode\n@note In case of multi-channels type, identity matrix will be initialized only for the first channel,\nthe others will be set to 0's\n@param rows Number of rows.\n@param cols Number of columns.\n@param type Created matrix type."]
    #[link_name = "\u{1}_ZN2cv3Mat3eyeEiii"]
    pub fn cv_Mat_eye(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_MatExpr;
}
unsafe extern "C" {
    #[doc = " @overload\n@param size Alternative matrix size specification as Size(cols, rows) .\n@param type Created matrix type."]
    #[link_name = "\u{1}_ZN2cv3Mat3eyeENS_5Size_IiEEi"]
    pub fn cv_Mat_eye1(size: cv_Size, type_: ::std::os::raw::c_int) -> cv_MatExpr;
}
unsafe extern "C" {
    #[doc = " @overload\n@param ndims New array dimensionality.\n@param sizes Array of integers specifying a new array shape.\n@param type New matrix type."]
    #[link_name = "\u{1}_ZN2cv3Mat6createEiPKii"]
    pub fn cv_Mat_create(
        this: *mut cv_Mat,
        ndims: ::std::os::raw::c_int,
        sizes: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param sizes Array of integers specifying a new array shape.\n@param type New matrix type."]
    #[link_name = "\u{1}_ZN2cv3Mat6createERKSt6vectorIiSaIiEEi"]
    pub fn cv_Mat_create1(
        this: *mut cv_Mat,
        sizes: *const std_vector,
        type_: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = "! internal use function, consider to use 'release' method instead; deallocates the matrix data"]
    #[link_name = "\u{1}_ZN2cv3Mat10deallocateEv"]
    pub fn cv_Mat_deallocate(this: *mut cv_Mat);
}
unsafe extern "C" {
    #[doc = "! internal use function; properly re-allocates _size, _step arrays"]
    #[link_name = "\u{1}_ZN2cv3Mat8copySizeERKS0_"]
    pub fn cv_Mat_copySize(this: *mut cv_Mat, m: *const cv_Mat);
}
unsafe extern "C" {
    #[doc = " @brief Reserves space for the certain number of rows.\n\nThe method reserves space for sz rows. If the matrix already has enough space to store sz rows,\nnothing happens. If the matrix is reallocated, the first Mat::rows rows are preserved. The method\nemulates the corresponding method of the STL vector class.\n@param sz Number of rows."]
    #[link_name = "\u{1}_ZN2cv3Mat7reserveEm"]
    pub fn cv_Mat_reserve(this: *mut cv_Mat, sz: usize);
}
unsafe extern "C" {
    #[doc = " @brief Reserves space for the certain number of bytes.\n\nThe method reserves space for sz bytes. If the matrix already has enough space to store sz bytes,\nnothing happens. If matrix has to be reallocated its previous content could be lost.\n@param sz Number of bytes."]
    #[link_name = "\u{1}_ZN2cv3Mat13reserveBufferEm"]
    pub fn cv_Mat_reserveBuffer(this: *mut cv_Mat, sz: usize);
}
unsafe extern "C" {
    #[doc = " @brief Changes the number of matrix rows.\n\nThe methods change the number of matrix rows. If the matrix is reallocated, the first\nmin(Mat::rows, sz) rows are preserved. The methods emulate the corresponding methods of the STL\nvector class.\n@param sz New number of rows."]
    #[link_name = "\u{1}_ZN2cv3Mat6resizeEm"]
    pub fn cv_Mat_resize(this: *mut cv_Mat, sz: usize);
}
unsafe extern "C" {
    #[doc = " @overload\n@param sz New number of rows.\n@param s Value assigned to the newly added elements."]
    #[link_name = "\u{1}_ZN2cv3Mat6resizeEmRKNS_7Scalar_IdEE"]
    pub fn cv_Mat_resize1(this: *mut cv_Mat, sz: usize, s: *const cv_Scalar);
}
unsafe extern "C" {
    #[doc = "! internal function"]
    #[link_name = "\u{1}_ZN2cv3Mat10push_back_EPKv"]
    pub fn cv_Mat_push_back_(this: *mut cv_Mat, elem: *const ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " @overload\n@param m Added line(s)."]
    #[link_name = "\u{1}_ZN2cv3Mat9push_backERKS0_"]
    pub fn cv_Mat_push_back(this: *mut cv_Mat, m: *const cv_Mat);
}
unsafe extern "C" {
    #[doc = " @brief Removes elements from the bottom of the matrix.\n\nThe method removes one or more rows from the bottom of the matrix.\n@param nelems Number of removed rows. If it is greater than the total number of rows, an exception\nis thrown."]
    #[link_name = "\u{1}_ZN2cv3Mat8pop_backEm"]
    pub fn cv_Mat_pop_back(this: *mut cv_Mat, nelems: usize);
}
unsafe extern "C" {
    #[doc = " @brief Locates the matrix header within a parent matrix.\n\nAfter you extracted a submatrix from a matrix using Mat::row, Mat::col, Mat::rowRange,\nMat::colRange, and others, the resultant submatrix points just to the part of the original big\nmatrix. However, each submatrix contains information (represented by datastart and dataend\nfields) that helps reconstruct the original matrix size and the position of the extracted\nsubmatrix within the original matrix. The method locateROI does exactly that.\n@param wholeSize Output parameter that contains the size of the whole matrix containing *this*\nas a part.\n@param ofs Output parameter that contains an offset of *this* inside the whole matrix."]
    #[link_name = "\u{1}_ZNK2cv3Mat9locateROIERNS_5Size_IiEERNS_6Point_IiEE"]
    pub fn cv_Mat_locateROI(this: *const cv_Mat, wholeSize: *mut cv_Size, ofs: *mut cv_Point);
}
unsafe extern "C" {
    #[doc = " @brief Adjusts a submatrix size and position within the parent matrix.\n\nThe method is complimentary to Mat::locateROI . The typical use of these functions is to determine\nthe submatrix position within the parent matrix and then shift the position somehow. Typically, it\ncan be required for filtering operations when pixels outside of the ROI should be taken into\naccount. When all the method parameters are positive, the ROI needs to grow in all directions by the\nspecified amount, for example:\n@code\nA.adjustROI(2, 2, 2, 2);\n@endcode\nIn this example, the matrix size is increased by 4 elements in each direction. The matrix is shifted\nby 2 elements to the left and 2 elements up, which brings in all the necessary pixels for the\nfiltering with the 5x5 kernel.\n\nadjustROI forces the adjusted ROI to be inside of the parent matrix that is boundaries of the\nadjusted ROI are constrained by boundaries of the parent matrix. For example, if the submatrix A is\nlocated in the first row of a parent matrix and you called A.adjustROI(2, 2, 2, 2) then A will not\nbe increased in the upward direction.\n\nThe function is used internally by the OpenCV filtering functions, like filter2D , morphological\noperations, and so on.\n@param dtop Shift of the top submatrix boundary upwards.\n@param dbottom Shift of the bottom submatrix boundary downwards.\n@param dleft Shift of the left submatrix boundary to the left.\n@param dright Shift of the right submatrix boundary to the right.\n@sa copyMakeBorder"]
    #[link_name = "\u{1}_ZN2cv3Mat9adjustROIEiiii"]
    pub fn cv_Mat_adjustROI(
        this: *mut cv_Mat,
        dtop: ::std::os::raw::c_int,
        dbottom: ::std::os::raw::c_int,
        dleft: ::std::os::raw::c_int,
        dright: ::std::os::raw::c_int,
    ) -> *mut cv_Mat;
}
unsafe extern "C" {
    #[doc = " @param elemChannels Number of channels or number of columns the matrix should have.\n                     For a 2-D matrix, when the matrix has only 1 column, then it should have\n                     elemChannels channels; When the matrix has only 1 channel,\n                     then it should have elemChannels columns.\n                     For a 3-D matrix, it should have only one channel. Furthermore,\n                     if the number of planes is not one, then the number of rows\n                     within every plane has to be 1; if the number of rows within\n                     every plane is not 1, then the number of planes has to be 1.\n @param depth The depth the matrix should have. Set it to -1 when any depth is fine.\n @param requireContinuous Set it to true to require the matrix to be continuous\n @return -1 if the requirement is not satisfied.\n         Otherwise, it returns the number of elements in the matrix. Note\n         that an element may have multiple channels.\n\n The following code demonstrates its usage for a 2-d matrix:\n @snippet snippets/core_mat_checkVector.cpp example-2d\n\n The following code demonstrates its usage for a 3-d matrix:\n @snippet snippets/core_mat_checkVector.cpp example-3d"]
    #[link_name = "\u{1}_ZNK2cv3Mat11checkVectorEiib"]
    pub fn cv_Mat_checkVector(
        this: *const cv_Mat,
        elemChannels: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
        requireContinuous: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! and the standard allocator"]
    #[link_name = "\u{1}_ZN2cv3Mat15getStdAllocatorEv"]
    pub fn cv_Mat_getStdAllocator() -> *mut cv_MatAllocator;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3Mat19getDefaultAllocatorEv"]
    pub fn cv_Mat_getDefaultAllocator() -> *mut cv_MatAllocator;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3Mat19setDefaultAllocatorEPNS_12MatAllocatorE"]
    pub fn cv_Mat_setDefaultAllocator(allocator: *mut cv_MatAllocator);
}
unsafe extern "C" {
    #[doc = "! internal use method: updates the continuity flag"]
    #[link_name = "\u{1}_ZN2cv3Mat20updateContinuityFlagEv"]
    pub fn cv_Mat_updateContinuityFlag(this: *mut cv_Mat);
}
unsafe extern "C" {
    #[doc = " @overload\n@param ndims Array dimensionality.\n@param sizes Array of integers specifying an n-dimensional array shape.\n@param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or\nCV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.\n@param data Pointer to the user data. Matrix constructors that take data and step parameters do not\nallocate matrix data. Instead, they just initialize the matrix header that points to the specified\ndata, which means that no data is copied. This operation is very efficient and can be used to\nprocess external data using OpenCV functions. The external data is not automatically deallocated, so\nyou should take care of it.\n@param steps Array of ndims-1 steps in case of a multi-dimensional array (the last step is always\nset to the element size). If not specified, the matrix is assumed to be continuous."]
    #[link_name = "\u{1}_ZN2cv3MatC1EiPKiiPvPKm"]
    pub fn cv_Mat_Mat(
        this: *mut cv_Mat,
        ndims: ::std::os::raw::c_int,
        sizes: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        steps: *const usize,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param sizes Array of integers specifying an n-dimensional array shape.\n@param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or\nCV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.\n@param data Pointer to the user data. Matrix constructors that take data and step parameters do not\nallocate matrix data. Instead, they just initialize the matrix header that points to the specified\ndata, which means that no data is copied. This operation is very efficient and can be used to\nprocess external data using OpenCV functions. The external data is not automatically deallocated, so\nyou should take care of it.\n@param steps Array of ndims-1 steps in case of a multi-dimensional array (the last step is always\nset to the element size). If not specified, the matrix is assumed to be continuous."]
    #[link_name = "\u{1}_ZN2cv3MatC1ERKSt6vectorIiSaIiEEiPvPKm"]
    pub fn cv_Mat_Mat1(
        this: *mut cv_Mat,
        sizes: *const std_vector,
        type_: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        steps: *const usize,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param m Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied\nby these constructors. Instead, the header pointing to m data or its sub-array is constructed and\nassociated with it. The reference counter, if any, is incremented. So, when you modify the matrix\nformed using such a constructor, you also modify the corresponding elements of m . If you want to\nhave an independent copy of the sub-array, use Mat::clone() .\n@param rowRange Range of the m rows to take. As usual, the range start is inclusive and the range\nend is exclusive. Use Range::all() to take all the rows.\n@param colRange Range of the m columns to take. Use Range::all() to take all the columns."]
    #[link_name = "\u{1}_ZN2cv3MatC1ERKS0_RKNS_5RangeES5_"]
    pub fn cv_Mat_Mat2(
        this: *mut cv_Mat,
        m: *const cv_Mat,
        rowRange: *const cv_Range,
        colRange: *const cv_Range,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param m Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied\nby these constructors. Instead, the header pointing to m data or its sub-array is constructed and\nassociated with it. The reference counter, if any, is incremented. So, when you modify the matrix\nformed using such a constructor, you also modify the corresponding elements of m . If you want to\nhave an independent copy of the sub-array, use Mat::clone() .\n@param roi Region of interest."]
    #[link_name = "\u{1}_ZN2cv3MatC1ERKS0_RKNS_5Rect_IiEE"]
    pub fn cv_Mat_Mat3(this: *mut cv_Mat, m: *const cv_Mat, roi: *const cv_Rect);
}
unsafe extern "C" {
    #[doc = " @overload\n@param m Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied\nby these constructors. Instead, the header pointing to m data or its sub-array is constructed and\nassociated with it. The reference counter, if any, is incremented. So, when you modify the matrix\nformed using such a constructor, you also modify the corresponding elements of m . If you want to\nhave an independent copy of the sub-array, use Mat::clone() .\n@param ranges Array of selected ranges of m along each dimensionality."]
    #[link_name = "\u{1}_ZN2cv3MatC1ERKS0_PKNS_5RangeE"]
    pub fn cv_Mat_Mat4(this: *mut cv_Mat, m: *const cv_Mat, ranges: *const cv_Range);
}
unsafe extern "C" {
    #[doc = " @overload\n@param m Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied\nby these constructors. Instead, the header pointing to m data or its sub-array is constructed and\nassociated with it. The reference counter, if any, is incremented. So, when you modify the matrix\nformed using such a constructor, you also modify the corresponding elements of m . If you want to\nhave an independent copy of the sub-array, use Mat::clone() .\n@param ranges Array of selected ranges of m along each dimensionality."]
    #[link_name = "\u{1}_ZN2cv3MatC1ERKS0_RKSt6vectorINS_5RangeESaIS4_EE"]
    pub fn cv_Mat_Mat5(this: *mut cv_Mat, m: *const cv_Mat, ranges: *const std_vector);
}
impl cv_Mat {
    #[inline]
    pub unsafe fn getUMat(
        &self,
        accessFlags: cv_AccessFlag,
        usageFlags: cv_UMatUsageFlags,
    ) -> cv_UMat {
        cv_Mat_getUMat(self, accessFlags, usageFlags)
    }
    #[inline]
    pub unsafe fn diag(&self, d: ::std::os::raw::c_int) -> cv_Mat {
        cv_Mat_diag(self, d)
    }
    #[inline]
    pub unsafe fn diag1(d: *const cv_Mat) -> cv_Mat {
        cv_Mat_diag1(d)
    }
    #[inline]
    pub unsafe fn copyTo(&self, m: cv_OutputArray) {
        cv_Mat_copyTo(self, m)
    }
    #[inline]
    pub unsafe fn copyTo1(&self, m: cv_OutputArray, mask: cv_InputArray) {
        cv_Mat_copyTo1(self, m, mask)
    }
    #[inline]
    pub unsafe fn convertTo(
        &self,
        m: cv_OutputArray,
        rtype: ::std::os::raw::c_int,
        alpha: f64,
        beta: f64,
    ) {
        cv_Mat_convertTo(self, m, rtype, alpha, beta)
    }
    #[inline]
    pub unsafe fn setTo(&mut self, value: cv_InputArray, mask: cv_InputArray) -> *mut cv_Mat {
        cv_Mat_setTo(self, value, mask)
    }
    #[inline]
    pub unsafe fn reshape(&self, cn: ::std::os::raw::c_int, rows: ::std::os::raw::c_int) -> cv_Mat {
        cv_Mat_reshape(self, cn, rows)
    }
    #[inline]
    pub unsafe fn reshape1(
        &self,
        cn: ::std::os::raw::c_int,
        newndims: ::std::os::raw::c_int,
        newsz: *const ::std::os::raw::c_int,
    ) -> cv_Mat {
        cv_Mat_reshape1(self, cn, newndims, newsz)
    }
    #[inline]
    pub unsafe fn reshape2(
        &self,
        cn: ::std::os::raw::c_int,
        newshape: *const std_vector,
    ) -> cv_Mat {
        cv_Mat_reshape2(self, cn, newshape)
    }
    #[inline]
    pub unsafe fn t(&self) -> cv_MatExpr {
        cv_Mat_t(self)
    }
    #[inline]
    pub unsafe fn inv(&self, method: ::std::os::raw::c_int) -> cv_MatExpr {
        cv_Mat_inv(self, method)
    }
    #[inline]
    pub unsafe fn mul(&self, m: cv_InputArray, scale: f64) -> cv_MatExpr {
        cv_Mat_mul(self, m, scale)
    }
    #[inline]
    pub unsafe fn cross(&self, m: cv_InputArray) -> cv_Mat {
        cv_Mat_cross(self, m)
    }
    #[inline]
    pub unsafe fn dot(&self, m: cv_InputArray) -> f64 {
        cv_Mat_dot(self, m)
    }
    #[inline]
    pub unsafe fn zeros(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_MatExpr {
        cv_Mat_zeros(rows, cols, type_)
    }
    #[inline]
    pub unsafe fn zeros1(size: cv_Size, type_: ::std::os::raw::c_int) -> cv_MatExpr {
        cv_Mat_zeros1(size, type_)
    }
    #[inline]
    pub unsafe fn zeros2(
        ndims: ::std::os::raw::c_int,
        sz: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_MatExpr {
        cv_Mat_zeros2(ndims, sz, type_)
    }
    #[inline]
    pub unsafe fn ones(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_MatExpr {
        cv_Mat_ones(rows, cols, type_)
    }
    #[inline]
    pub unsafe fn ones1(size: cv_Size, type_: ::std::os::raw::c_int) -> cv_MatExpr {
        cv_Mat_ones1(size, type_)
    }
    #[inline]
    pub unsafe fn ones2(
        ndims: ::std::os::raw::c_int,
        sz: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_MatExpr {
        cv_Mat_ones2(ndims, sz, type_)
    }
    #[inline]
    pub unsafe fn eye(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_MatExpr {
        cv_Mat_eye(rows, cols, type_)
    }
    #[inline]
    pub unsafe fn eye1(size: cv_Size, type_: ::std::os::raw::c_int) -> cv_MatExpr {
        cv_Mat_eye1(size, type_)
    }
    #[inline]
    pub unsafe fn create(
        &mut self,
        ndims: ::std::os::raw::c_int,
        sizes: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) {
        cv_Mat_create(self, ndims, sizes, type_)
    }
    #[inline]
    pub unsafe fn create1(&mut self, sizes: *const std_vector, type_: ::std::os::raw::c_int) {
        cv_Mat_create1(self, sizes, type_)
    }
    #[inline]
    pub unsafe fn deallocate(&mut self) {
        cv_Mat_deallocate(self)
    }
    #[inline]
    pub unsafe fn copySize(&mut self, m: *const cv_Mat) {
        cv_Mat_copySize(self, m)
    }
    #[inline]
    pub unsafe fn reserve(&mut self, sz: usize) {
        cv_Mat_reserve(self, sz)
    }
    #[inline]
    pub unsafe fn reserveBuffer(&mut self, sz: usize) {
        cv_Mat_reserveBuffer(self, sz)
    }
    #[inline]
    pub unsafe fn resize(&mut self, sz: usize) {
        cv_Mat_resize(self, sz)
    }
    #[inline]
    pub unsafe fn resize1(&mut self, sz: usize, s: *const cv_Scalar) {
        cv_Mat_resize1(self, sz, s)
    }
    #[inline]
    pub unsafe fn push_back_(&mut self, elem: *const ::std::os::raw::c_void) {
        cv_Mat_push_back_(self, elem)
    }
    #[inline]
    pub unsafe fn push_back(&mut self, m: *const cv_Mat) {
        cv_Mat_push_back(self, m)
    }
    #[inline]
    pub unsafe fn pop_back(&mut self, nelems: usize) {
        cv_Mat_pop_back(self, nelems)
    }
    #[inline]
    pub unsafe fn locateROI(&self, wholeSize: *mut cv_Size, ofs: *mut cv_Point) {
        cv_Mat_locateROI(self, wholeSize, ofs)
    }
    #[inline]
    pub unsafe fn adjustROI(
        &mut self,
        dtop: ::std::os::raw::c_int,
        dbottom: ::std::os::raw::c_int,
        dleft: ::std::os::raw::c_int,
        dright: ::std::os::raw::c_int,
    ) -> *mut cv_Mat {
        cv_Mat_adjustROI(self, dtop, dbottom, dleft, dright)
    }
    #[inline]
    pub unsafe fn checkVector(
        &self,
        elemChannels: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
        requireContinuous: bool,
    ) -> ::std::os::raw::c_int {
        cv_Mat_checkVector(self, elemChannels, depth, requireContinuous)
    }
    #[inline]
    pub unsafe fn getStdAllocator() -> *mut cv_MatAllocator {
        cv_Mat_getStdAllocator()
    }
    #[inline]
    pub unsafe fn getDefaultAllocator() -> *mut cv_MatAllocator {
        cv_Mat_getDefaultAllocator()
    }
    #[inline]
    pub unsafe fn setDefaultAllocator(allocator: *mut cv_MatAllocator) {
        cv_Mat_setDefaultAllocator(allocator)
    }
    #[inline]
    pub unsafe fn updateContinuityFlag(&mut self) {
        cv_Mat_updateContinuityFlag(self)
    }
    #[inline]
    pub unsafe fn new(
        ndims: ::std::os::raw::c_int,
        sizes: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        steps: *const usize,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_Mat_Mat(__bindgen_tmp.as_mut_ptr(), ndims, sizes, type_, data, steps);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        sizes: *const std_vector,
        type_: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        steps: *const usize,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_Mat_Mat1(__bindgen_tmp.as_mut_ptr(), sizes, type_, data, steps);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(
        m: *const cv_Mat,
        rowRange: *const cv_Range,
        colRange: *const cv_Range,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_Mat_Mat2(__bindgen_tmp.as_mut_ptr(), m, rowRange, colRange);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(m: *const cv_Mat, roi: *const cv_Rect) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_Mat_Mat3(__bindgen_tmp.as_mut_ptr(), m, roi);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(m: *const cv_Mat, ranges: *const cv_Range) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_Mat_Mat4(__bindgen_tmp.as_mut_ptr(), m, ranges);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(m: *const cv_Mat, ranges: *const std_vector) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_Mat_Mat5(__bindgen_tmp.as_mut_ptr(), m, ranges);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief Template matrix class derived from Mat\n\n@code{.cpp}\ntemplate<typename _Tp> class Mat_ : public Mat\n{\npublic:\n// ... some specific methods\n//         and\n// no new extra fields\n};\n@endcode\nThe class `Mat_<_Tp>` is a *thin* template wrapper on top of the Mat class. It does not have any\nextra data fields. Nor this class nor Mat has any virtual methods. Thus, references or pointers to\nthese two classes can be freely but carefully converted one to another. For example:\n@code{.cpp}\n// create a 100x100 8-bit matrix\nMat M(100,100,CV_8U);\n// this will be compiled fine. no any data conversion will be done.\nMat_<float>& M1 = (Mat_<float>&)M;\n// the program is likely to crash at the statement below\nM1(99,99) = 1.f;\n@endcode\nWhile Mat is sufficient in most cases, Mat_ can be more convenient if you use a lot of element\naccess operations and if you know matrix type at the compilation time. Note that\n`Mat::at(int y,int x)` and `Mat_::operator()(int y,int x)` do absolutely the same\nand run at the same speed, but the latter is certainly shorter:\n@code{.cpp}\nMat_<double> M(20,20);\nfor(int i = 0; i < M.rows; i++)\nfor(int j = 0; j < M.cols; j++)\nM(i,j) = 1./(i+j+1);\nMat E, V;\neigen(M,E,V);\ncout << E.at<double>(0,0)/E.at<double>(M.rows-1,0);\n@endcode\nTo use Mat_ for multi-channel images/matrices, pass Vec as a Mat_ parameter:\n@code{.cpp}\n// allocate a 320x240 color image and fill it with green (in RGB space)\nMat_<Vec3b> img(240, 320, Vec3b(0,255,0));\n// now draw a diagonal white line\nfor(int i = 0; i < 100; i++)\nimg(i,i)=Vec3b(255,255,255);\n// and now scramble the 2nd (red) channel of each pixel\nfor(int i = 0; i < img.rows; i++)\nfor(int j = 0; j < img.cols; j++)\nimg(i,j)[2] ^= (uchar)(i ^ j);\n@endcode\nMat_ is fully compatible with C++11 range-based for loop. For example such loop\ncan be used to safely apply look-up table:\n@code{.cpp}\nvoid applyTable(Mat_<uchar>& I, const uchar* const table)\n{\nfor(auto& pixel : I)\n{\npixel = table[pixel];\n}\n}\n@endcode"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_Mat_ {
    pub _base: cv_Mat,
}
pub type cv_Mat__value_type<_Tp> = _Tp;
pub type cv_Mat__channel_type = cv_DataType;
#[doc = " @brief Matrix read-write iterator"]
pub type cv_Mat__iterator = cv_MatIterator_;
#[doc = " @brief Matrix read-only iterator"]
pub type cv_Mat__const_iterator = cv_MatConstIterator_;
#[doc = " @brief Template matrix class derived from Mat\n\n@code{.cpp}\ntemplate<typename _Tp> class Mat_ : public Mat\n{\npublic:\n// ... some specific methods\n//         and\n// no new extra fields\n};\n@endcode\nThe class `Mat_<_Tp>` is a *thin* template wrapper on top of the Mat class. It does not have any\nextra data fields. Nor this class nor Mat has any virtual methods. Thus, references or pointers to\nthese two classes can be freely but carefully converted one to another. For example:\n@code{.cpp}\n// create a 100x100 8-bit matrix\nMat M(100,100,CV_8U);\n// this will be compiled fine. no any data conversion will be done.\nMat_<float>& M1 = (Mat_<float>&)M;\n// the program is likely to crash at the statement below\nM1(99,99) = 1.f;\n@endcode\nWhile Mat is sufficient in most cases, Mat_ can be more convenient if you use a lot of element\naccess operations and if you know matrix type at the compilation time. Note that\n`Mat::at(int y,int x)` and `Mat_::operator()(int y,int x)` do absolutely the same\nand run at the same speed, but the latter is certainly shorter:\n@code{.cpp}\nMat_<double> M(20,20);\nfor(int i = 0; i < M.rows; i++)\nfor(int j = 0; j < M.cols; j++)\nM(i,j) = 1./(i+j+1);\nMat E, V;\neigen(M,E,V);\ncout << E.at<double>(0,0)/E.at<double>(M.rows-1,0);\n@endcode\nTo use Mat_ for multi-channel images/matrices, pass Vec as a Mat_ parameter:\n@code{.cpp}\n// allocate a 320x240 color image and fill it with green (in RGB space)\nMat_<Vec3b> img(240, 320, Vec3b(0,255,0));\n// now draw a diagonal white line\nfor(int i = 0; i < 100; i++)\nimg(i,i)=Vec3b(255,255,255);\n// and now scramble the 2nd (red) channel of each pixel\nfor(int i = 0; i < img.rows; i++)\nfor(int j = 0; j < img.cols; j++)\nimg(i,j)[2] ^= (uchar)(i ^ j);\n@endcode\nMat_ is fully compatible with C++11 range-based for loop. For example such loop\ncan be used to safely apply look-up table:\n@code{.cpp}\nvoid applyTable(Mat_<uchar>& I, const uchar* const table)\n{\nfor(auto& pixel : I)\n{\npixel = table[pixel];\n}\n}\n@endcode"]
pub type cv_Mat1b = cv_Mat_;
pub type cv_Mat2b = cv_Mat_;
pub type cv_Mat3b = cv_Mat_;
pub type cv_Mat4b = cv_Mat_;
pub type cv_Mat1s = cv_Mat_;
pub type cv_Mat2s = cv_Mat_;
pub type cv_Mat3s = cv_Mat_;
pub type cv_Mat4s = cv_Mat_;
pub type cv_Mat1w = cv_Mat_;
pub type cv_Mat2w = cv_Mat_;
pub type cv_Mat3w = cv_Mat_;
pub type cv_Mat4w = cv_Mat_;
#[doc = " @brief Template matrix class derived from Mat\n\n@code{.cpp}\ntemplate<typename _Tp> class Mat_ : public Mat\n{\npublic:\n// ... some specific methods\n//         and\n// no new extra fields\n};\n@endcode\nThe class `Mat_<_Tp>` is a *thin* template wrapper on top of the Mat class. It does not have any\nextra data fields. Nor this class nor Mat has any virtual methods. Thus, references or pointers to\nthese two classes can be freely but carefully converted one to another. For example:\n@code{.cpp}\n// create a 100x100 8-bit matrix\nMat M(100,100,CV_8U);\n// this will be compiled fine. no any data conversion will be done.\nMat_<float>& M1 = (Mat_<float>&)M;\n// the program is likely to crash at the statement below\nM1(99,99) = 1.f;\n@endcode\nWhile Mat is sufficient in most cases, Mat_ can be more convenient if you use a lot of element\naccess operations and if you know matrix type at the compilation time. Note that\n`Mat::at(int y,int x)` and `Mat_::operator()(int y,int x)` do absolutely the same\nand run at the same speed, but the latter is certainly shorter:\n@code{.cpp}\nMat_<double> M(20,20);\nfor(int i = 0; i < M.rows; i++)\nfor(int j = 0; j < M.cols; j++)\nM(i,j) = 1./(i+j+1);\nMat E, V;\neigen(M,E,V);\ncout << E.at<double>(0,0)/E.at<double>(M.rows-1,0);\n@endcode\nTo use Mat_ for multi-channel images/matrices, pass Vec as a Mat_ parameter:\n@code{.cpp}\n// allocate a 320x240 color image and fill it with green (in RGB space)\nMat_<Vec3b> img(240, 320, Vec3b(0,255,0));\n// now draw a diagonal white line\nfor(int i = 0; i < 100; i++)\nimg(i,i)=Vec3b(255,255,255);\n// and now scramble the 2nd (red) channel of each pixel\nfor(int i = 0; i < img.rows; i++)\nfor(int j = 0; j < img.cols; j++)\nimg(i,j)[2] ^= (uchar)(i ^ j);\n@endcode\nMat_ is fully compatible with C++11 range-based for loop. For example such loop\ncan be used to safely apply look-up table:\n@code{.cpp}\nvoid applyTable(Mat_<uchar>& I, const uchar* const table)\n{\nfor(auto& pixel : I)\n{\npixel = table[pixel];\n}\n}\n@endcode"]
pub type cv_Mat1i = cv_Mat_;
pub type cv_Mat2i = cv_Mat_;
pub type cv_Mat3i = cv_Mat_;
pub type cv_Mat4i = cv_Mat_;
#[doc = " @brief Template matrix class derived from Mat\n\n@code{.cpp}\ntemplate<typename _Tp> class Mat_ : public Mat\n{\npublic:\n// ... some specific methods\n//         and\n// no new extra fields\n};\n@endcode\nThe class `Mat_<_Tp>` is a *thin* template wrapper on top of the Mat class. It does not have any\nextra data fields. Nor this class nor Mat has any virtual methods. Thus, references or pointers to\nthese two classes can be freely but carefully converted one to another. For example:\n@code{.cpp}\n// create a 100x100 8-bit matrix\nMat M(100,100,CV_8U);\n// this will be compiled fine. no any data conversion will be done.\nMat_<float>& M1 = (Mat_<float>&)M;\n// the program is likely to crash at the statement below\nM1(99,99) = 1.f;\n@endcode\nWhile Mat is sufficient in most cases, Mat_ can be more convenient if you use a lot of element\naccess operations and if you know matrix type at the compilation time. Note that\n`Mat::at(int y,int x)` and `Mat_::operator()(int y,int x)` do absolutely the same\nand run at the same speed, but the latter is certainly shorter:\n@code{.cpp}\nMat_<double> M(20,20);\nfor(int i = 0; i < M.rows; i++)\nfor(int j = 0; j < M.cols; j++)\nM(i,j) = 1./(i+j+1);\nMat E, V;\neigen(M,E,V);\ncout << E.at<double>(0,0)/E.at<double>(M.rows-1,0);\n@endcode\nTo use Mat_ for multi-channel images/matrices, pass Vec as a Mat_ parameter:\n@code{.cpp}\n// allocate a 320x240 color image and fill it with green (in RGB space)\nMat_<Vec3b> img(240, 320, Vec3b(0,255,0));\n// now draw a diagonal white line\nfor(int i = 0; i < 100; i++)\nimg(i,i)=Vec3b(255,255,255);\n// and now scramble the 2nd (red) channel of each pixel\nfor(int i = 0; i < img.rows; i++)\nfor(int j = 0; j < img.cols; j++)\nimg(i,j)[2] ^= (uchar)(i ^ j);\n@endcode\nMat_ is fully compatible with C++11 range-based for loop. For example such loop\ncan be used to safely apply look-up table:\n@code{.cpp}\nvoid applyTable(Mat_<uchar>& I, const uchar* const table)\n{\nfor(auto& pixel : I)\n{\npixel = table[pixel];\n}\n}\n@endcode"]
pub type cv_Mat1f = cv_Mat_;
pub type cv_Mat2f = cv_Mat_;
pub type cv_Mat3f = cv_Mat_;
pub type cv_Mat4f = cv_Mat_;
#[doc = " @brief Template matrix class derived from Mat\n\n@code{.cpp}\ntemplate<typename _Tp> class Mat_ : public Mat\n{\npublic:\n// ... some specific methods\n//         and\n// no new extra fields\n};\n@endcode\nThe class `Mat_<_Tp>` is a *thin* template wrapper on top of the Mat class. It does not have any\nextra data fields. Nor this class nor Mat has any virtual methods. Thus, references or pointers to\nthese two classes can be freely but carefully converted one to another. For example:\n@code{.cpp}\n// create a 100x100 8-bit matrix\nMat M(100,100,CV_8U);\n// this will be compiled fine. no any data conversion will be done.\nMat_<float>& M1 = (Mat_<float>&)M;\n// the program is likely to crash at the statement below\nM1(99,99) = 1.f;\n@endcode\nWhile Mat is sufficient in most cases, Mat_ can be more convenient if you use a lot of element\naccess operations and if you know matrix type at the compilation time. Note that\n`Mat::at(int y,int x)` and `Mat_::operator()(int y,int x)` do absolutely the same\nand run at the same speed, but the latter is certainly shorter:\n@code{.cpp}\nMat_<double> M(20,20);\nfor(int i = 0; i < M.rows; i++)\nfor(int j = 0; j < M.cols; j++)\nM(i,j) = 1./(i+j+1);\nMat E, V;\neigen(M,E,V);\ncout << E.at<double>(0,0)/E.at<double>(M.rows-1,0);\n@endcode\nTo use Mat_ for multi-channel images/matrices, pass Vec as a Mat_ parameter:\n@code{.cpp}\n// allocate a 320x240 color image and fill it with green (in RGB space)\nMat_<Vec3b> img(240, 320, Vec3b(0,255,0));\n// now draw a diagonal white line\nfor(int i = 0; i < 100; i++)\nimg(i,i)=Vec3b(255,255,255);\n// and now scramble the 2nd (red) channel of each pixel\nfor(int i = 0; i < img.rows; i++)\nfor(int j = 0; j < img.cols; j++)\nimg(i,j)[2] ^= (uchar)(i ^ j);\n@endcode\nMat_ is fully compatible with C++11 range-based for loop. For example such loop\ncan be used to safely apply look-up table:\n@code{.cpp}\nvoid applyTable(Mat_<uchar>& I, const uchar* const table)\n{\nfor(auto& pixel : I)\n{\npixel = table[pixel];\n}\n}\n@endcode"]
pub type cv_Mat1d = cv_Mat_;
pub type cv_Mat2d = cv_Mat_;
pub type cv_Mat3d = cv_Mat_;
pub type cv_Mat4d = cv_Mat_;
#[doc = " @todo document"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_UMat {
    #[doc = " includes several bit-fields:\n- the magic signature\n- continuity flag\n- depth\n- number of channels"]
    pub flags: ::std::os::raw::c_int,
    #[doc = "! the matrix dimensionality, >= 2"]
    pub dims: ::std::os::raw::c_int,
    #[doc = "! the number of rows and columns or (-1, -1) when the matrix has more than 2 dimensions"]
    pub rows: ::std::os::raw::c_int,
    #[doc = "! the number of rows and columns or (-1, -1) when the matrix has more than 2 dimensions"]
    pub cols: ::std::os::raw::c_int,
    #[doc = "! custom allocator"]
    pub allocator: *mut cv_MatAllocator,
    pub usageFlags: cv_UMatUsageFlags,
    pub u: *mut cv_UMatData,
    pub offset: usize,
    pub size: cv_MatSize,
    pub step: cv_MatStep,
}
pub const cv_UMat_MAGIC_VAL: cv_UMat__bindgen_ty_1 = 1124007936;
pub const cv_UMat_AUTO_STEP: cv_UMat__bindgen_ty_1 = 0;
pub const cv_UMat_CONTINUOUS_FLAG: cv_UMat__bindgen_ty_1 = 16384;
pub const cv_UMat_SUBMATRIX_FLAG: cv_UMat__bindgen_ty_1 = 32768;
pub type cv_UMat__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const cv_UMat_MAGIC_MASK: cv_UMat__bindgen_ty_2 = 4294901760;
pub const cv_UMat_TYPE_MASK: cv_UMat__bindgen_ty_2 = 4095;
pub const cv_UMat_DEPTH_MASK: cv_UMat__bindgen_ty_2 = 7;
pub type cv_UMat__bindgen_ty_2 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_UMat"][::std::mem::size_of::<cv_UMat>() - 80usize];
    ["Alignment of cv_UMat"][::std::mem::align_of::<cv_UMat>() - 8usize];
    ["Offset of field: cv_UMat::flags"][::std::mem::offset_of!(cv_UMat, flags) - 0usize];
    ["Offset of field: cv_UMat::dims"][::std::mem::offset_of!(cv_UMat, dims) - 4usize];
    ["Offset of field: cv_UMat::rows"][::std::mem::offset_of!(cv_UMat, rows) - 8usize];
    ["Offset of field: cv_UMat::cols"][::std::mem::offset_of!(cv_UMat, cols) - 12usize];
    ["Offset of field: cv_UMat::allocator"][::std::mem::offset_of!(cv_UMat, allocator) - 16usize];
    ["Offset of field: cv_UMat::usageFlags"][::std::mem::offset_of!(cv_UMat, usageFlags) - 24usize];
    ["Offset of field: cv_UMat::u"][::std::mem::offset_of!(cv_UMat, u) - 32usize];
    ["Offset of field: cv_UMat::offset"][::std::mem::offset_of!(cv_UMat, offset) - 40usize];
    ["Offset of field: cv_UMat::size"][::std::mem::offset_of!(cv_UMat, size) - 48usize];
    ["Offset of field: cv_UMat::step"][::std::mem::offset_of!(cv_UMat, step) - 56usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv4UMat6getMatENS_10AccessFlagE"]
    pub fn cv_UMat_getMat(this: *const cv_UMat, flags: cv_AccessFlag) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = "! ... for the specified diagonal\n! (d=0 - the main diagonal,\n!  >0 - a diagonal from the upper half,\n!  <0 - a diagonal from the lower half)"]
    #[link_name = "\u{1}_ZNK2cv4UMat4diagEi"]
    pub fn cv_UMat_diag(this: *const cv_UMat, d: ::std::os::raw::c_int) -> cv_UMat;
}
unsafe extern "C" {
    #[doc = "! constructs a square diagonal matrix which main diagonal is vector \"d\""]
    #[link_name = "\u{1}_ZN2cv4UMat4diagERKS0_"]
    pub fn cv_UMat_diag1(d: *const cv_UMat) -> cv_UMat;
}
unsafe extern "C" {
    #[doc = "! copies the matrix content to \"m\"."]
    #[link_name = "\u{1}_ZNK2cv4UMat6copyToERKNS_12_OutputArrayE"]
    pub fn cv_UMat_copyTo(this: *const cv_UMat, m: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = "! copies those matrix elements to \"m\" that are marked with non-zero mask elements."]
    #[link_name = "\u{1}_ZNK2cv4UMat6copyToERKNS_12_OutputArrayERKNS_11_InputArrayE"]
    pub fn cv_UMat_copyTo1(this: *const cv_UMat, m: cv_OutputArray, mask: cv_InputArray);
}
unsafe extern "C" {
    #[doc = "! converts matrix to another datatype with optional scaling. See cvConvertScale."]
    #[link_name = "\u{1}_ZNK2cv4UMat9convertToERKNS_12_OutputArrayEidd"]
    pub fn cv_UMat_convertTo(
        this: *const cv_UMat,
        m: cv_OutputArray,
        rtype: ::std::os::raw::c_int,
        alpha: f64,
        beta: f64,
    );
}
unsafe extern "C" {
    #[doc = "! sets some of the matrix elements to s, according to the mask"]
    #[link_name = "\u{1}_ZN2cv4UMat5setToERKNS_11_InputArrayES3_"]
    pub fn cv_UMat_setTo(
        this: *mut cv_UMat,
        value: cv_InputArray,
        mask: cv_InputArray,
    ) -> *mut cv_UMat;
}
unsafe extern "C" {
    #[doc = "! creates alternative matrix header for the same data, with different"]
    #[link_name = "\u{1}_ZNK2cv4UMat7reshapeEii"]
    pub fn cv_UMat_reshape(
        this: *const cv_UMat,
        cn: ::std::os::raw::c_int,
        rows: ::std::os::raw::c_int,
    ) -> cv_UMat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv4UMat7reshapeEiiPKi"]
    pub fn cv_UMat_reshape1(
        this: *const cv_UMat,
        cn: ::std::os::raw::c_int,
        newndims: ::std::os::raw::c_int,
        newsz: *const ::std::os::raw::c_int,
    ) -> cv_UMat;
}
unsafe extern "C" {
    #[doc = "! matrix transposition by means of matrix expressions"]
    #[link_name = "\u{1}_ZNK2cv4UMat1tEv"]
    pub fn cv_UMat_t(this: *const cv_UMat) -> cv_UMat;
}
unsafe extern "C" {
    #[doc = "! matrix inversion by means of matrix expressions"]
    #[link_name = "\u{1}_ZNK2cv4UMat3invEi"]
    pub fn cv_UMat_inv(this: *const cv_UMat, method: ::std::os::raw::c_int) -> cv_UMat;
}
unsafe extern "C" {
    #[doc = "! per-element matrix multiplication by means of matrix expressions"]
    #[link_name = "\u{1}_ZNK2cv4UMat3mulERKNS_11_InputArrayEd"]
    pub fn cv_UMat_mul(this: *const cv_UMat, m: cv_InputArray, scale: f64) -> cv_UMat;
}
unsafe extern "C" {
    #[doc = "! computes dot-product"]
    #[link_name = "\u{1}_ZNK2cv4UMat3dotERKNS_11_InputArrayE"]
    pub fn cv_UMat_dot(this: *const cv_UMat, m: cv_InputArray) -> f64;
}
unsafe extern "C" {
    #[doc = "! Matlab-style matrix initialization"]
    #[link_name = "\u{1}_ZN2cv4UMat5zerosEiii"]
    pub fn cv_UMat_zeros(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_UMat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4UMat5zerosENS_5Size_IiEEi"]
    pub fn cv_UMat_zeros1(size: cv_Size, type_: ::std::os::raw::c_int) -> cv_UMat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4UMat5zerosEiPKii"]
    pub fn cv_UMat_zeros2(
        ndims: ::std::os::raw::c_int,
        sz: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_UMat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4UMat4onesEiii"]
    pub fn cv_UMat_ones(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_UMat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4UMat4onesENS_5Size_IiEEi"]
    pub fn cv_UMat_ones1(size: cv_Size, type_: ::std::os::raw::c_int) -> cv_UMat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4UMat4onesEiPKii"]
    pub fn cv_UMat_ones2(
        ndims: ::std::os::raw::c_int,
        sz: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_UMat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4UMat3eyeEiii"]
    pub fn cv_UMat_eye(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_UMat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4UMat3eyeENS_5Size_IiEEi"]
    pub fn cv_UMat_eye1(size: cv_Size, type_: ::std::os::raw::c_int) -> cv_UMat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4UMat6createEiPKiiNS_14UMatUsageFlagsE"]
    pub fn cv_UMat_create(
        this: *mut cv_UMat,
        ndims: ::std::os::raw::c_int,
        sizes: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        usageFlags: cv_UMatUsageFlags,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4UMat6createERKSt6vectorIiSaIiEEiNS_14UMatUsageFlagsE"]
    pub fn cv_UMat_create1(
        this: *mut cv_UMat,
        sizes: *const std_vector,
        type_: ::std::os::raw::c_int,
        usageFlags: cv_UMatUsageFlags,
    );
}
unsafe extern "C" {
    #[doc = "! deallocates the matrix data"]
    #[link_name = "\u{1}_ZN2cv4UMat10deallocateEv"]
    pub fn cv_UMat_deallocate(this: *mut cv_UMat);
}
unsafe extern "C" {
    #[doc = "! internal use function; properly re-allocates _size, _step arrays"]
    #[link_name = "\u{1}_ZN2cv4UMat8copySizeERKS0_"]
    pub fn cv_UMat_copySize(this: *mut cv_UMat, m: *const cv_UMat);
}
unsafe extern "C" {
    #[doc = "! locates matrix header within a parent matrix. See below"]
    #[link_name = "\u{1}_ZNK2cv4UMat9locateROIERNS_5Size_IiEERNS_6Point_IiEE"]
    pub fn cv_UMat_locateROI(this: *const cv_UMat, wholeSize: *mut cv_Size, ofs: *mut cv_Point);
}
unsafe extern "C" {
    #[doc = "! moves/resizes the current matrix ROI inside the parent matrix."]
    #[link_name = "\u{1}_ZN2cv4UMat9adjustROIEiiii"]
    pub fn cv_UMat_adjustROI(
        this: *mut cv_UMat,
        dtop: ::std::os::raw::c_int,
        dbottom: ::std::os::raw::c_int,
        dleft: ::std::os::raw::c_int,
        dright: ::std::os::raw::c_int,
    ) -> *mut cv_UMat;
}
unsafe extern "C" {
    #[doc = "! returns N if the matrix is 1-channel (N x ptdim) or ptdim-channel (1 x N) or (N x 1); negative number otherwise"]
    #[link_name = "\u{1}_ZNK2cv4UMat11checkVectorEiib"]
    pub fn cv_UMat_checkVector(
        this: *const cv_UMat,
        elemChannels: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
        requireContinuous: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Returns the OpenCL buffer handle on which UMat operates on.\nThe UMat instance should be kept alive during the use of the handle to prevent the buffer to be\nreturned to the OpenCV buffer pool."]
    #[link_name = "\u{1}_ZNK2cv4UMat6handleENS_10AccessFlagE"]
    pub fn cv_UMat_handle(
        this: *const cv_UMat,
        accessFlags: cv_AccessFlag,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv4UMat8ndoffsetEPm"]
    pub fn cv_UMat_ndoffset(this: *const cv_UMat, ofs: *mut usize);
}
unsafe extern "C" {
    #[doc = "! and the standard allocator"]
    #[link_name = "\u{1}_ZN2cv4UMat15getStdAllocatorEv"]
    pub fn cv_UMat_getStdAllocator() -> *mut cv_MatAllocator;
}
unsafe extern "C" {
    #[doc = "! internal use method: updates the continuity flag"]
    #[link_name = "\u{1}_ZN2cv4UMat20updateContinuityFlagEv"]
    pub fn cv_UMat_updateContinuityFlag(this: *mut cv_UMat);
}
unsafe extern "C" {
    #[doc = "! creates a matrix header for a part of the bigger matrix"]
    #[link_name = "\u{1}_ZN2cv4UMatC1ERKS0_RKNS_5RangeES5_"]
    pub fn cv_UMat_UMat(
        this: *mut cv_UMat,
        m: *const cv_UMat,
        rowRange: *const cv_Range,
        colRange: *const cv_Range,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4UMatC1ERKS0_RKNS_5Rect_IiEE"]
    pub fn cv_UMat_UMat1(this: *mut cv_UMat, m: *const cv_UMat, roi: *const cv_Rect);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4UMatC1ERKS0_PKNS_5RangeE"]
    pub fn cv_UMat_UMat2(this: *mut cv_UMat, m: *const cv_UMat, ranges: *const cv_Range);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4UMatC1ERKS0_RKSt6vectorINS_5RangeESaIS4_EE"]
    pub fn cv_UMat_UMat3(this: *mut cv_UMat, m: *const cv_UMat, ranges: *const std_vector);
}
unsafe extern "C" {
    #[doc = "! destructor - calls release()"]
    #[link_name = "\u{1}_ZN2cv4UMatD1Ev"]
    pub fn cv_UMat_UMat_destructor(this: *mut cv_UMat);
}
impl cv_UMat {
    #[inline]
    pub unsafe fn getMat(&self, flags: cv_AccessFlag) -> cv_Mat {
        cv_UMat_getMat(self, flags)
    }
    #[inline]
    pub unsafe fn diag(&self, d: ::std::os::raw::c_int) -> cv_UMat {
        cv_UMat_diag(self, d)
    }
    #[inline]
    pub unsafe fn diag1(d: *const cv_UMat) -> cv_UMat {
        cv_UMat_diag1(d)
    }
    #[inline]
    pub unsafe fn copyTo(&self, m: cv_OutputArray) {
        cv_UMat_copyTo(self, m)
    }
    #[inline]
    pub unsafe fn copyTo1(&self, m: cv_OutputArray, mask: cv_InputArray) {
        cv_UMat_copyTo1(self, m, mask)
    }
    #[inline]
    pub unsafe fn convertTo(
        &self,
        m: cv_OutputArray,
        rtype: ::std::os::raw::c_int,
        alpha: f64,
        beta: f64,
    ) {
        cv_UMat_convertTo(self, m, rtype, alpha, beta)
    }
    #[inline]
    pub unsafe fn setTo(&mut self, value: cv_InputArray, mask: cv_InputArray) -> *mut cv_UMat {
        cv_UMat_setTo(self, value, mask)
    }
    #[inline]
    pub unsafe fn reshape(
        &self,
        cn: ::std::os::raw::c_int,
        rows: ::std::os::raw::c_int,
    ) -> cv_UMat {
        cv_UMat_reshape(self, cn, rows)
    }
    #[inline]
    pub unsafe fn reshape1(
        &self,
        cn: ::std::os::raw::c_int,
        newndims: ::std::os::raw::c_int,
        newsz: *const ::std::os::raw::c_int,
    ) -> cv_UMat {
        cv_UMat_reshape1(self, cn, newndims, newsz)
    }
    #[inline]
    pub unsafe fn t(&self) -> cv_UMat {
        cv_UMat_t(self)
    }
    #[inline]
    pub unsafe fn inv(&self, method: ::std::os::raw::c_int) -> cv_UMat {
        cv_UMat_inv(self, method)
    }
    #[inline]
    pub unsafe fn mul(&self, m: cv_InputArray, scale: f64) -> cv_UMat {
        cv_UMat_mul(self, m, scale)
    }
    #[inline]
    pub unsafe fn dot(&self, m: cv_InputArray) -> f64 {
        cv_UMat_dot(self, m)
    }
    #[inline]
    pub unsafe fn zeros(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_UMat {
        cv_UMat_zeros(rows, cols, type_)
    }
    #[inline]
    pub unsafe fn zeros1(size: cv_Size, type_: ::std::os::raw::c_int) -> cv_UMat {
        cv_UMat_zeros1(size, type_)
    }
    #[inline]
    pub unsafe fn zeros2(
        ndims: ::std::os::raw::c_int,
        sz: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_UMat {
        cv_UMat_zeros2(ndims, sz, type_)
    }
    #[inline]
    pub unsafe fn ones(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_UMat {
        cv_UMat_ones(rows, cols, type_)
    }
    #[inline]
    pub unsafe fn ones1(size: cv_Size, type_: ::std::os::raw::c_int) -> cv_UMat {
        cv_UMat_ones1(size, type_)
    }
    #[inline]
    pub unsafe fn ones2(
        ndims: ::std::os::raw::c_int,
        sz: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_UMat {
        cv_UMat_ones2(ndims, sz, type_)
    }
    #[inline]
    pub unsafe fn eye(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> cv_UMat {
        cv_UMat_eye(rows, cols, type_)
    }
    #[inline]
    pub unsafe fn eye1(size: cv_Size, type_: ::std::os::raw::c_int) -> cv_UMat {
        cv_UMat_eye1(size, type_)
    }
    #[inline]
    pub unsafe fn create(
        &mut self,
        ndims: ::std::os::raw::c_int,
        sizes: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        usageFlags: cv_UMatUsageFlags,
    ) {
        cv_UMat_create(self, ndims, sizes, type_, usageFlags)
    }
    #[inline]
    pub unsafe fn create1(
        &mut self,
        sizes: *const std_vector,
        type_: ::std::os::raw::c_int,
        usageFlags: cv_UMatUsageFlags,
    ) {
        cv_UMat_create1(self, sizes, type_, usageFlags)
    }
    #[inline]
    pub unsafe fn deallocate(&mut self) {
        cv_UMat_deallocate(self)
    }
    #[inline]
    pub unsafe fn copySize(&mut self, m: *const cv_UMat) {
        cv_UMat_copySize(self, m)
    }
    #[inline]
    pub unsafe fn locateROI(&self, wholeSize: *mut cv_Size, ofs: *mut cv_Point) {
        cv_UMat_locateROI(self, wholeSize, ofs)
    }
    #[inline]
    pub unsafe fn adjustROI(
        &mut self,
        dtop: ::std::os::raw::c_int,
        dbottom: ::std::os::raw::c_int,
        dleft: ::std::os::raw::c_int,
        dright: ::std::os::raw::c_int,
    ) -> *mut cv_UMat {
        cv_UMat_adjustROI(self, dtop, dbottom, dleft, dright)
    }
    #[inline]
    pub unsafe fn checkVector(
        &self,
        elemChannels: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
        requireContinuous: bool,
    ) -> ::std::os::raw::c_int {
        cv_UMat_checkVector(self, elemChannels, depth, requireContinuous)
    }
    #[inline]
    pub unsafe fn handle(&self, accessFlags: cv_AccessFlag) -> *mut ::std::os::raw::c_void {
        cv_UMat_handle(self, accessFlags)
    }
    #[inline]
    pub unsafe fn ndoffset(&self, ofs: *mut usize) {
        cv_UMat_ndoffset(self, ofs)
    }
    #[inline]
    pub unsafe fn getStdAllocator() -> *mut cv_MatAllocator {
        cv_UMat_getStdAllocator()
    }
    #[inline]
    pub unsafe fn updateContinuityFlag(&mut self) {
        cv_UMat_updateContinuityFlag(self)
    }
    #[inline]
    pub unsafe fn new(
        m: *const cv_UMat,
        rowRange: *const cv_Range,
        colRange: *const cv_Range,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_UMat_UMat(__bindgen_tmp.as_mut_ptr(), m, rowRange, colRange);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(m: *const cv_UMat, roi: *const cv_Rect) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_UMat_UMat1(__bindgen_tmp.as_mut_ptr(), m, roi);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(m: *const cv_UMat, ranges: *const cv_Range) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_UMat_UMat2(__bindgen_tmp.as_mut_ptr(), m, ranges);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(m: *const cv_UMat, ranges: *const std_vector) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_UMat_UMat3(__bindgen_tmp.as_mut_ptr(), m, ranges);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cv_UMat_UMat_destructor(self)
    }
}
#[doc = " @brief The class SparseMat represents multi-dimensional sparse numerical arrays.\n\nSuch a sparse array can store elements of any type that Mat can store. *Sparse* means that only\nnon-zero elements are stored (though, as a result of operations on a sparse matrix, some of its\nstored elements can actually become 0. It is up to you to detect such elements and delete them\nusing SparseMat::erase ). The non-zero elements are stored in a hash table that grows when it is\nfilled so that the search time is O(1) in average (regardless of whether element is there or not).\nElements can be accessed using the following methods:\n-   Query operations (SparseMat::ptr and the higher-level SparseMat::ref, SparseMat::value and\nSparseMat::find), for example:\n@code\nconst int dims = 5;\nint size[5] = {10, 10, 10, 10, 10};\nSparseMat sparse_mat(dims, size, CV_32F);\nfor(int i = 0; i < 1000; i++)\n{\nint idx[dims];\nfor(int k = 0; k < dims; k++)\nidx[k] = rand() % size[k];\nsparse_mat.ref<float>(idx) += 1.f;\n}\ncout << \"nnz = \" << sparse_mat.nzcount() << endl;\n@endcode\n-   Sparse matrix iterators. They are similar to MatIterator but different from NAryMatIterator.\nThat is, the iteration loop is familiar to STL users:\n@code\n// prints elements of a sparse floating-point matrix\n// and the sum of elements.\nSparseMatConstIterator_<float>\nit = sparse_mat.begin<float>(),\nit_end = sparse_mat.end<float>();\ndouble s = 0;\nint dims = sparse_mat.dims();\nfor(; it != it_end; ++it)\n{\n// print element indices and the element value\nconst SparseMat::Node* n = it.node();\nprintf(\"(\");\nfor(int i = 0; i < dims; i++)\nprintf(\"%d%s\", n->idx[i], i < dims-1 ? \", \" : \")\");\nprintf(\": %g\\n\", it.value<float>());\ns += *it;\n}\nprintf(\"Element sum is %g\\n\", s);\n@endcode\nIf you run this loop, you will notice that elements are not enumerated in a logical order\n(lexicographical, and so on). They come in the same order as they are stored in the hash table\n(semi-randomly). You may collect pointers to the nodes and sort them to get the proper ordering.\nNote, however, that pointers to the nodes may become invalid when you add more elements to the\nmatrix. This may happen due to possible buffer reallocation.\n-   Combination of the above 2 methods when you need to process 2 or more sparse matrices\nsimultaneously. For example, this is how you can compute unnormalized cross-correlation of the 2\nfloating-point sparse matrices:\n@code\ndouble cross_corr(const SparseMat& a, const SparseMat& b)\n{\nconst SparseMat *_a = &a, *_b = &b;\n// if b contains less elements than a,\n// it is faster to iterate through b\nif(_a->nzcount() > _b->nzcount())\nstd::swap(_a, _b);\nSparseMatConstIterator_<float> it = _a->begin<float>(),\nit_end = _a->end<float>();\ndouble ccorr = 0;\nfor(; it != it_end; ++it)\n{\n// take the next element from the first matrix\nfloat avalue = *it;\nconst Node* anode = it.node();\n// and try to find an element with the same index in the second matrix.\n// since the hash value depends only on the element index,\n// reuse the hash value stored in the node\nfloat bvalue = _b->value<float>(anode->idx,&anode->hashval);\nccorr += avalue*bvalue;\n}\nreturn ccorr;\n}\n@endcode"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_SparseMat {
    pub flags: ::std::os::raw::c_int,
    pub hdr: *mut cv_SparseMat_Hdr,
}
#[doc = " @brief  Read-write Sparse Matrix Iterator\n\nThe class is similar to cv::SparseMatConstIterator,\nbut can be used for in-place modification of the matrix elements."]
pub type cv_SparseMat_iterator = cv_SparseMatIterator;
#[doc = "  @brief Read-Only Sparse Matrix Iterator.\n\nHere is how to use the iterator to compute the sum of floating-point sparse matrix elements:\n\n\\code\nSparseMatConstIterator it = m.begin(), it_end = m.end();\ndouble s = 0;\nCV_Assert( m.type() == CV_32F );\nfor( ; it != it_end; ++it )\ns += it.value<float>();\n\\endcode"]
pub type cv_SparseMat_const_iterator = cv_SparseMatConstIterator;
pub const cv_SparseMat_MAGIC_VAL: cv_SparseMat__bindgen_ty_1 = 1123876864;
pub const cv_SparseMat_MAX_DIM: cv_SparseMat__bindgen_ty_1 = 32;
pub const cv_SparseMat_HASH_SCALE: cv_SparseMat__bindgen_ty_1 = 1540483477;
pub const cv_SparseMat_HASH_BIT: cv_SparseMat__bindgen_ty_1 = 2147483648;
pub type cv_SparseMat__bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = "! the sparse matrix header"]
#[repr(C)]
pub struct cv_SparseMat_Hdr {
    pub refcount: ::std::os::raw::c_int,
    pub dims: ::std::os::raw::c_int,
    pub valueOffset: ::std::os::raw::c_int,
    pub nodeSize: usize,
    pub nodeCount: usize,
    pub freeList: usize,
    pub pool: std_vector,
    pub hashtab: std_vector,
    pub size: [::std::os::raw::c_int; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_SparseMat_Hdr"][::std::mem::size_of::<cv_SparseMat_Hdr>() - 216usize];
    ["Alignment of cv_SparseMat_Hdr"][::std::mem::align_of::<cv_SparseMat_Hdr>() - 8usize];
    ["Offset of field: cv_SparseMat_Hdr::refcount"]
        [::std::mem::offset_of!(cv_SparseMat_Hdr, refcount) - 0usize];
    ["Offset of field: cv_SparseMat_Hdr::dims"]
        [::std::mem::offset_of!(cv_SparseMat_Hdr, dims) - 4usize];
    ["Offset of field: cv_SparseMat_Hdr::valueOffset"]
        [::std::mem::offset_of!(cv_SparseMat_Hdr, valueOffset) - 8usize];
    ["Offset of field: cv_SparseMat_Hdr::nodeSize"]
        [::std::mem::offset_of!(cv_SparseMat_Hdr, nodeSize) - 16usize];
    ["Offset of field: cv_SparseMat_Hdr::nodeCount"]
        [::std::mem::offset_of!(cv_SparseMat_Hdr, nodeCount) - 24usize];
    ["Offset of field: cv_SparseMat_Hdr::freeList"]
        [::std::mem::offset_of!(cv_SparseMat_Hdr, freeList) - 32usize];
    ["Offset of field: cv_SparseMat_Hdr::pool"]
        [::std::mem::offset_of!(cv_SparseMat_Hdr, pool) - 40usize];
    ["Offset of field: cv_SparseMat_Hdr::hashtab"]
        [::std::mem::offset_of!(cv_SparseMat_Hdr, hashtab) - 64usize];
    ["Offset of field: cv_SparseMat_Hdr::size"]
        [::std::mem::offset_of!(cv_SparseMat_Hdr, size) - 88usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9SparseMat3Hdr5clearEv"]
    pub fn cv_SparseMat_Hdr_clear(this: *mut cv_SparseMat_Hdr);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9SparseMat3HdrC1EiPKii"]
    pub fn cv_SparseMat_Hdr_Hdr(
        this: *mut cv_SparseMat_Hdr,
        _dims: ::std::os::raw::c_int,
        _sizes: *const ::std::os::raw::c_int,
        _type: ::std::os::raw::c_int,
    );
}
impl cv_SparseMat_Hdr {
    #[inline]
    pub unsafe fn clear(&mut self) {
        cv_SparseMat_Hdr_clear(self)
    }
    #[inline]
    pub unsafe fn new(
        _dims: ::std::os::raw::c_int,
        _sizes: *const ::std::os::raw::c_int,
        _type: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_SparseMat_Hdr_Hdr(__bindgen_tmp.as_mut_ptr(), _dims, _sizes, _type);
        __bindgen_tmp.assume_init()
    }
}
#[doc = "! sparse matrix node - element of a hash table"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_SparseMat_Node {
    #[doc = "! hash value"]
    pub hashval: usize,
    #[doc = "! index of the next node in the same hash table entry"]
    pub next: usize,
    #[doc = "! index of the matrix element"]
    pub idx: [::std::os::raw::c_int; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_SparseMat_Node"][::std::mem::size_of::<cv_SparseMat_Node>() - 144usize];
    ["Alignment of cv_SparseMat_Node"][::std::mem::align_of::<cv_SparseMat_Node>() - 8usize];
    ["Offset of field: cv_SparseMat_Node::hashval"]
        [::std::mem::offset_of!(cv_SparseMat_Node, hashval) - 0usize];
    ["Offset of field: cv_SparseMat_Node::next"]
        [::std::mem::offset_of!(cv_SparseMat_Node, next) - 8usize];
    ["Offset of field: cv_SparseMat_Node::idx"]
        [::std::mem::offset_of!(cv_SparseMat_Node, idx) - 16usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_SparseMat"][::std::mem::size_of::<cv_SparseMat>() - 16usize];
    ["Alignment of cv_SparseMat"][::std::mem::align_of::<cv_SparseMat>() - 8usize];
    ["Offset of field: cv_SparseMat::flags"][::std::mem::offset_of!(cv_SparseMat, flags) - 0usize];
    ["Offset of field: cv_SparseMat::hdr"][::std::mem::offset_of!(cv_SparseMat, hdr) - 8usize];
};
unsafe extern "C" {
    #[doc = "! copies all the data to the destination matrix. All the previous content of m is erased"]
    #[link_name = "\u{1}_ZNK2cv9SparseMat6copyToERS0_"]
    pub fn cv_SparseMat_copyTo(this: *const cv_SparseMat, m: *mut cv_SparseMat);
}
unsafe extern "C" {
    #[doc = "! converts sparse matrix to dense matrix."]
    #[link_name = "\u{1}_ZNK2cv9SparseMat6copyToERNS_3MatE"]
    pub fn cv_SparseMat_copyTo1(this: *const cv_SparseMat, m: *mut cv_Mat);
}
unsafe extern "C" {
    #[doc = "! multiplies all the matrix elements by the specified scale factor alpha and converts the results to the specified data type"]
    #[link_name = "\u{1}_ZNK2cv9SparseMat9convertToERS0_id"]
    pub fn cv_SparseMat_convertTo(
        this: *const cv_SparseMat,
        m: *mut cv_SparseMat,
        rtype: ::std::os::raw::c_int,
        alpha: f64,
    );
}
unsafe extern "C" {
    #[doc = "! converts sparse matrix to dense n-dim matrix with optional type conversion and scaling.\n*!\n@param [out] m - output matrix; if it does not have a proper size or type before the operation,\nit is reallocated\n@param [in] rtype - desired output matrix type or, rather, the depth since the number of channels\nare the same as the input has; if rtype is negative, the output matrix will have the\nsame type as the input.\n@param [in] alpha - optional scale factor\n@param [in] beta - optional delta added to the scaled values\n*/"]
    #[link_name = "\u{1}_ZNK2cv9SparseMat9convertToERNS_3MatEidd"]
    pub fn cv_SparseMat_convertTo1(
        this: *const cv_SparseMat,
        m: *mut cv_Mat,
        rtype: ::std::os::raw::c_int,
        alpha: f64,
        beta: f64,
    );
}
unsafe extern "C" {
    #[doc = "! reallocates sparse matrix.\n*!\nIf the matrix already had the proper size and type,\nit is simply cleared with clear(), otherwise,\nthe old matrix is released (using release()) and the new one is allocated.\n*/"]
    #[link_name = "\u{1}_ZN2cv9SparseMat6createEiPKii"]
    pub fn cv_SparseMat_create(
        this: *mut cv_SparseMat,
        dims: ::std::os::raw::c_int,
        _sizes: *const ::std::os::raw::c_int,
        _type: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = "! sets all the sparse matrix elements to 0, which means clearing the hash table."]
    #[link_name = "\u{1}_ZN2cv9SparseMat5clearEv"]
    pub fn cv_SparseMat_clear(this: *mut cv_SparseMat);
}
unsafe extern "C" {
    #[doc = "!@{\n*!\nspecialized variants for 1D, 2D, 3D cases and the generic_type one for n-D case.\nreturn pointer to the matrix element.\n- if the element is there (it's non-zero), the pointer to it is returned\n- if it's not there and createMissing=false, NULL pointer is returned\n- if it's not there and createMissing=true, then the new element\nis created and initialized with 0. Pointer to it is returned\n- if the optional hashval pointer is not NULL, the element hash value is\nnot computed, but *hashval is taken instead.\n*/\n! returns pointer to the specified element (1D case)"]
    #[link_name = "\u{1}_ZN2cv9SparseMat3ptrEibPm"]
    pub fn cv_SparseMat_ptr(
        this: *mut cv_SparseMat,
        i0: ::std::os::raw::c_int,
        createMissing: bool,
        hashval: *mut usize,
    ) -> *mut uchar;
}
unsafe extern "C" {
    #[doc = "! returns pointer to the specified element (2D case)"]
    #[link_name = "\u{1}_ZN2cv9SparseMat3ptrEiibPm"]
    pub fn cv_SparseMat_ptr1(
        this: *mut cv_SparseMat,
        i0: ::std::os::raw::c_int,
        i1: ::std::os::raw::c_int,
        createMissing: bool,
        hashval: *mut usize,
    ) -> *mut uchar;
}
unsafe extern "C" {
    #[doc = "! returns pointer to the specified element (3D case)"]
    #[link_name = "\u{1}_ZN2cv9SparseMat3ptrEiiibPm"]
    pub fn cv_SparseMat_ptr2(
        this: *mut cv_SparseMat,
        i0: ::std::os::raw::c_int,
        i1: ::std::os::raw::c_int,
        i2: ::std::os::raw::c_int,
        createMissing: bool,
        hashval: *mut usize,
    ) -> *mut uchar;
}
unsafe extern "C" {
    #[doc = "! returns pointer to the specified element (nD case)"]
    #[link_name = "\u{1}_ZN2cv9SparseMat3ptrEPKibPm"]
    pub fn cv_SparseMat_ptr3(
        this: *mut cv_SparseMat,
        idx: *const ::std::os::raw::c_int,
        createMissing: bool,
        hashval: *mut usize,
    ) -> *mut uchar;
}
unsafe extern "C" {
    #[doc = "! erases the specified element (2D case)"]
    #[link_name = "\u{1}_ZN2cv9SparseMat5eraseEiiPm"]
    pub fn cv_SparseMat_erase(
        this: *mut cv_SparseMat,
        i0: ::std::os::raw::c_int,
        i1: ::std::os::raw::c_int,
        hashval: *mut usize,
    );
}
unsafe extern "C" {
    #[doc = "! erases the specified element (3D case)"]
    #[link_name = "\u{1}_ZN2cv9SparseMat5eraseEiiiPm"]
    pub fn cv_SparseMat_erase1(
        this: *mut cv_SparseMat,
        i0: ::std::os::raw::c_int,
        i1: ::std::os::raw::c_int,
        i2: ::std::os::raw::c_int,
        hashval: *mut usize,
    );
}
unsafe extern "C" {
    #[doc = "! erases the specified element (nD case)"]
    #[link_name = "\u{1}_ZN2cv9SparseMat5eraseEPKiPm"]
    pub fn cv_SparseMat_erase2(
        this: *mut cv_SparseMat,
        idx: *const ::std::os::raw::c_int,
        hashval: *mut usize,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9SparseMat7newNodeEPKim"]
    pub fn cv_SparseMat_newNode(
        this: *mut cv_SparseMat,
        idx: *const ::std::os::raw::c_int,
        hashval: usize,
    ) -> *mut uchar;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9SparseMat10removeNodeEmmm"]
    pub fn cv_SparseMat_removeNode(
        this: *mut cv_SparseMat,
        hidx: usize,
        nidx: usize,
        previdx: usize,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9SparseMat13resizeHashTabEm"]
    pub fn cv_SparseMat_resizeHashTab(this: *mut cv_SparseMat, newsize: usize);
}
unsafe extern "C" {
    #[doc = " @overload\n@param m Source matrix for copy constructor. If m is dense matrix (ocvMat) then it will be converted\nto sparse representation."]
    #[link_name = "\u{1}_ZN2cv9SparseMatC1ERKNS_3MatE"]
    pub fn cv_SparseMat_SparseMat(this: *mut cv_SparseMat, m: *const cv_Mat);
}
impl cv_SparseMat {
    #[inline]
    pub unsafe fn copyTo(&self, m: *mut cv_SparseMat) {
        cv_SparseMat_copyTo(self, m)
    }
    #[inline]
    pub unsafe fn copyTo1(&self, m: *mut cv_Mat) {
        cv_SparseMat_copyTo1(self, m)
    }
    #[inline]
    pub unsafe fn convertTo(&self, m: *mut cv_SparseMat, rtype: ::std::os::raw::c_int, alpha: f64) {
        cv_SparseMat_convertTo(self, m, rtype, alpha)
    }
    #[inline]
    pub unsafe fn convertTo1(
        &self,
        m: *mut cv_Mat,
        rtype: ::std::os::raw::c_int,
        alpha: f64,
        beta: f64,
    ) {
        cv_SparseMat_convertTo1(self, m, rtype, alpha, beta)
    }
    #[inline]
    pub unsafe fn create(
        &mut self,
        dims: ::std::os::raw::c_int,
        _sizes: *const ::std::os::raw::c_int,
        _type: ::std::os::raw::c_int,
    ) {
        cv_SparseMat_create(self, dims, _sizes, _type)
    }
    #[inline]
    pub unsafe fn clear(&mut self) {
        cv_SparseMat_clear(self)
    }
    #[inline]
    pub unsafe fn ptr(
        &mut self,
        i0: ::std::os::raw::c_int,
        createMissing: bool,
        hashval: *mut usize,
    ) -> *mut uchar {
        cv_SparseMat_ptr(self, i0, createMissing, hashval)
    }
    #[inline]
    pub unsafe fn ptr1(
        &mut self,
        i0: ::std::os::raw::c_int,
        i1: ::std::os::raw::c_int,
        createMissing: bool,
        hashval: *mut usize,
    ) -> *mut uchar {
        cv_SparseMat_ptr1(self, i0, i1, createMissing, hashval)
    }
    #[inline]
    pub unsafe fn ptr2(
        &mut self,
        i0: ::std::os::raw::c_int,
        i1: ::std::os::raw::c_int,
        i2: ::std::os::raw::c_int,
        createMissing: bool,
        hashval: *mut usize,
    ) -> *mut uchar {
        cv_SparseMat_ptr2(self, i0, i1, i2, createMissing, hashval)
    }
    #[inline]
    pub unsafe fn ptr3(
        &mut self,
        idx: *const ::std::os::raw::c_int,
        createMissing: bool,
        hashval: *mut usize,
    ) -> *mut uchar {
        cv_SparseMat_ptr3(self, idx, createMissing, hashval)
    }
    #[inline]
    pub unsafe fn erase(
        &mut self,
        i0: ::std::os::raw::c_int,
        i1: ::std::os::raw::c_int,
        hashval: *mut usize,
    ) {
        cv_SparseMat_erase(self, i0, i1, hashval)
    }
    #[inline]
    pub unsafe fn erase1(
        &mut self,
        i0: ::std::os::raw::c_int,
        i1: ::std::os::raw::c_int,
        i2: ::std::os::raw::c_int,
        hashval: *mut usize,
    ) {
        cv_SparseMat_erase1(self, i0, i1, i2, hashval)
    }
    #[inline]
    pub unsafe fn erase2(&mut self, idx: *const ::std::os::raw::c_int, hashval: *mut usize) {
        cv_SparseMat_erase2(self, idx, hashval)
    }
    #[inline]
    pub unsafe fn newNode(
        &mut self,
        idx: *const ::std::os::raw::c_int,
        hashval: usize,
    ) -> *mut uchar {
        cv_SparseMat_newNode(self, idx, hashval)
    }
    #[inline]
    pub unsafe fn removeNode(&mut self, hidx: usize, nidx: usize, previdx: usize) {
        cv_SparseMat_removeNode(self, hidx, nidx, previdx)
    }
    #[inline]
    pub unsafe fn resizeHashTab(&mut self, newsize: usize) {
        cv_SparseMat_resizeHashTab(self, newsize)
    }
    #[inline]
    pub unsafe fn new(m: *const cv_Mat) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_SparseMat_SparseMat(__bindgen_tmp.as_mut_ptr(), m);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief Template sparse n-dimensional array class derived from SparseMat\n\nSparseMat_ is a thin wrapper on top of SparseMat created in the same way as Mat_ . It simplifies\nnotation of some operations:\n@code\nint sz[] = {10, 20, 30};\nSparseMat_<double> M(3, sz);\n...\nM.ref(1, 2, 3) = M(4, 5, 6) + M(7, 8, 9);\n@endcode"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_SparseMat_ {
    pub _base: cv_SparseMat,
}
#[doc = " @brief  Template Read-Write Sparse Matrix Iterator Class.\n\nThis is the derived from cv::SparseMatConstIterator_ class that\nintroduces more convenient operator *() for accessing the current element."]
pub type cv_SparseMat__iterator = cv_SparseMatIterator_;
#[doc = " @brief  Template Read-Only Sparse Matrix Iterator Class.\n\nThis is the derived from SparseMatConstIterator class that\nintroduces more convenient operator *() for accessing the current element."]
pub type cv_SparseMat__const_iterator = cv_SparseMatConstIterator_;
#[doc = " MatConstIterator //////////////////////////////////"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_MatConstIterator {
    pub m: *const cv_Mat,
    pub elemSize: usize,
    pub ptr: *const uchar,
    pub sliceStart: *const uchar,
    pub sliceEnd: *const uchar,
}
pub type cv_MatConstIterator_value_type = *mut uchar;
pub type cv_MatConstIterator_difference_type = isize;
pub type cv_MatConstIterator_pointer = *mut *const uchar;
pub type cv_MatConstIterator_reference = *mut uchar;
pub type cv_MatConstIterator_iterator_category = std_random_access_iterator_tag;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_MatConstIterator"][::std::mem::size_of::<cv_MatConstIterator>() - 40usize];
    ["Alignment of cv_MatConstIterator"][::std::mem::align_of::<cv_MatConstIterator>() - 8usize];
    ["Offset of field: cv_MatConstIterator::m"]
        [::std::mem::offset_of!(cv_MatConstIterator, m) - 0usize];
    ["Offset of field: cv_MatConstIterator::elemSize"]
        [::std::mem::offset_of!(cv_MatConstIterator, elemSize) - 8usize];
    ["Offset of field: cv_MatConstIterator::ptr"]
        [::std::mem::offset_of!(cv_MatConstIterator, ptr) - 16usize];
    ["Offset of field: cv_MatConstIterator::sliceStart"]
        [::std::mem::offset_of!(cv_MatConstIterator, sliceStart) - 24usize];
    ["Offset of field: cv_MatConstIterator::sliceEnd"]
        [::std::mem::offset_of!(cv_MatConstIterator, sliceEnd) - 32usize];
};
unsafe extern "C" {
    #[doc = "! returns the current iterator position"]
    #[link_name = "\u{1}_ZNK2cv16MatConstIterator3posEv"]
    pub fn cv_MatConstIterator_pos(this: *const cv_MatConstIterator) -> cv_Point;
}
unsafe extern "C" {
    #[doc = "! returns the current iterator position"]
    #[link_name = "\u{1}_ZNK2cv16MatConstIterator3posEPi"]
    pub fn cv_MatConstIterator_pos1(
        this: *const cv_MatConstIterator,
        _idx: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv16MatConstIterator4lposEv"]
    pub fn cv_MatConstIterator_lpos(this: *const cv_MatConstIterator) -> isize;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv16MatConstIterator4seekElb"]
    pub fn cv_MatConstIterator_seek(this: *mut cv_MatConstIterator, ofs: isize, relative: bool);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv16MatConstIterator4seekEPKib"]
    pub fn cv_MatConstIterator_seek1(
        this: *mut cv_MatConstIterator,
        _idx: *const ::std::os::raw::c_int,
        relative: bool,
    );
}
unsafe extern "C" {
    #[doc = "! constructor that sets the iterator to the specified element of the matrix"]
    #[link_name = "\u{1}_ZN2cv16MatConstIteratorC1EPKNS_3MatEPKi"]
    pub fn cv_MatConstIterator_MatConstIterator(
        this: *mut cv_MatConstIterator,
        _m: *const cv_Mat,
        _idx: *const ::std::os::raw::c_int,
    );
}
impl cv_MatConstIterator {
    #[inline]
    pub unsafe fn pos(&self) -> cv_Point {
        cv_MatConstIterator_pos(self)
    }
    #[inline]
    pub unsafe fn pos1(&self, _idx: *mut ::std::os::raw::c_int) {
        cv_MatConstIterator_pos1(self, _idx)
    }
    #[inline]
    pub unsafe fn lpos(&self) -> isize {
        cv_MatConstIterator_lpos(self)
    }
    #[inline]
    pub unsafe fn seek(&mut self, ofs: isize, relative: bool) {
        cv_MatConstIterator_seek(self, ofs, relative)
    }
    #[inline]
    pub unsafe fn seek1(&mut self, _idx: *const ::std::os::raw::c_int, relative: bool) {
        cv_MatConstIterator_seek1(self, _idx, relative)
    }
    #[inline]
    pub unsafe fn new(_m: *const cv_Mat, _idx: *const ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_MatConstIterator_MatConstIterator(__bindgen_tmp.as_mut_ptr(), _m, _idx);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief Matrix read-only iterator"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_MatConstIterator_ {
    pub _base: cv_MatConstIterator,
}
pub type cv_MatConstIterator__value_type<_Tp> = _Tp;
pub type cv_MatConstIterator__difference_type = isize;
pub type cv_MatConstIterator__pointer<_Tp> = *const _Tp;
pub type cv_MatConstIterator__reference<_Tp> = *const _Tp;
pub type cv_MatConstIterator__iterator_category = std_random_access_iterator_tag;
#[doc = " @brief Matrix read-write iterator"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_MatIterator_ {
    pub _base: cv_MatConstIterator_,
}
pub type cv_MatIterator__pointer<_Tp> = *mut _Tp;
pub type cv_MatIterator__reference<_Tp> = *mut _Tp;
pub type cv_MatIterator__iterator_category = std_random_access_iterator_tag;
#[doc = "  @brief Read-Only Sparse Matrix Iterator.\n\nHere is how to use the iterator to compute the sum of floating-point sparse matrix elements:\n\n\\code\nSparseMatConstIterator it = m.begin(), it_end = m.end();\ndouble s = 0;\nCV_Assert( m.type() == CV_32F );\nfor( ; it != it_end; ++it )\ns += it.value<float>();\n\\endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_SparseMatConstIterator {
    pub m: *const cv_SparseMat,
    pub hashidx: usize,
    pub ptr: *mut uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_SparseMatConstIterator"]
        [::std::mem::size_of::<cv_SparseMatConstIterator>() - 24usize];
    ["Alignment of cv_SparseMatConstIterator"]
        [::std::mem::align_of::<cv_SparseMatConstIterator>() - 8usize];
    ["Offset of field: cv_SparseMatConstIterator::m"]
        [::std::mem::offset_of!(cv_SparseMatConstIterator, m) - 0usize];
    ["Offset of field: cv_SparseMatConstIterator::hashidx"]
        [::std::mem::offset_of!(cv_SparseMatConstIterator, hashidx) - 8usize];
    ["Offset of field: cv_SparseMatConstIterator::ptr"]
        [::std::mem::offset_of!(cv_SparseMatConstIterator, ptr) - 16usize];
};
unsafe extern "C" {
    #[doc = "! the full constructor setting the iterator to the first sparse matrix element"]
    #[link_name = "\u{1}_ZN2cv22SparseMatConstIteratorC1EPKNS_9SparseMatE"]
    pub fn cv_SparseMatConstIterator_SparseMatConstIterator(
        this: *mut cv_SparseMatConstIterator,
        _m: *const cv_SparseMat,
    );
}
impl cv_SparseMatConstIterator {
    #[inline]
    pub unsafe fn new(_m: *const cv_SparseMat) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_SparseMatConstIterator_SparseMatConstIterator(__bindgen_tmp.as_mut_ptr(), _m);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief  Read-write Sparse Matrix Iterator\n\nThe class is similar to cv::SparseMatConstIterator,\nbut can be used for in-place modification of the matrix elements."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_SparseMatIterator {
    pub _base: cv_SparseMatConstIterator,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_SparseMatIterator"][::std::mem::size_of::<cv_SparseMatIterator>() - 24usize];
    ["Alignment of cv_SparseMatIterator"][::std::mem::align_of::<cv_SparseMatIterator>() - 8usize];
};
unsafe extern "C" {
    #[doc = "! the full constructor setting the iterator to the specified sparse matrix element"]
    #[link_name = "\u{1}_ZN2cv17SparseMatIteratorC1EPNS_9SparseMatEPKi"]
    pub fn cv_SparseMatIterator_SparseMatIterator(
        this: *mut cv_SparseMatIterator,
        _m: *mut cv_SparseMat,
        idx: *const ::std::os::raw::c_int,
    );
}
impl cv_SparseMatIterator {
    #[inline]
    pub unsafe fn new(_m: *mut cv_SparseMat, idx: *const ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_SparseMatIterator_SparseMatIterator(__bindgen_tmp.as_mut_ptr(), _m, idx);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief  Template Read-Only Sparse Matrix Iterator Class.\n\nThis is the derived from SparseMatConstIterator class that\nintroduces more convenient operator *() for accessing the current element."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_SparseMatConstIterator_ {
    pub _base: cv_SparseMatConstIterator,
}
pub type cv_SparseMatConstIterator__iterator_category = std_forward_iterator_tag;
#[doc = " @brief  Template Read-Write Sparse Matrix Iterator Class.\n\nThis is the derived from cv::SparseMatConstIterator_ class that\nintroduces more convenient operator *() for accessing the current element."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_SparseMatIterator_ {
    pub _base: cv_SparseMatConstIterator_,
}
pub type cv_SparseMatIterator__iterator_category = std_forward_iterator_tag;
#[doc = " @brief n-ary multi-dimensional array iterator.\n\nUse the class to implement unary, binary, and, generally, n-ary element-wise operations on\nmulti-dimensional arrays. Some of the arguments of an n-ary function may be continuous arrays, some\nmay be not. It is possible to use conventional MatIterator 's for each array but incrementing all of\nthe iterators after each small operations may be a big overhead. In this case consider using\nNAryMatIterator to iterate through several matrices simultaneously as long as they have the same\ngeometry (dimensionality and all the dimension sizes are the same). On each iteration `it.planes[0]`,\n`it.planes[1]`,... will be the slices of the corresponding matrices.\n\nThe example below illustrates how you can compute a normalized and threshold 3D color histogram:\n@code\nvoid computeNormalizedColorHist(const Mat& image, Mat& hist, int N, double minProb)\n{\nconst int histSize[] = {N, N, N};\n\n// make sure that the histogram has a proper size and type\nhist.create(3, histSize, CV_32F);\n\n// and clear it\nhist = Scalar(0);\n\n// the loop below assumes that the image\n// is a 8-bit 3-channel. check it.\nCV_Assert(image.type() == CV_8UC3);\nMatConstIterator_<Vec3b> it = image.begin<Vec3b>(),\nit_end = image.end<Vec3b>();\nfor( ; it != it_end; ++it )\n{\nconst Vec3b& pix = *it;\nhist.at<float>(pix[0]*N/256, pix[1]*N/256, pix[2]*N/256) += 1.f;\n}\n\nminProb *= image.rows*image.cols;\n\n// initialize iterator (the style is different from STL).\n// after initialization the iterator will contain\n// the number of slices or planes the iterator will go through.\n// it simultaneously increments iterators for several matrices\n// supplied as a null terminated list of pointers\nconst Mat* arrays[] = {&hist, 0};\nMat planes[1];\nNAryMatIterator itNAry(arrays, planes, 1);\ndouble s = 0;\n// iterate through the matrix. on each iteration\n// itNAry.planes[i] (of type Mat) will be set to the current plane\n// of the i-th n-dim matrix passed to the iterator constructor.\nfor(int p = 0; p < itNAry.nplanes; p++, ++itNAry)\n{\nthreshold(itNAry.planes[0], itNAry.planes[0], minProb, 0, THRESH_TOZERO);\ns += sum(itNAry.planes[0])[0];\n}\n\ns = 1./s;\nitNAry = NAryMatIterator(arrays, planes, 1);\nfor(int p = 0; p < itNAry.nplanes; p++, ++itNAry)\nitNAry.planes[0] *= s;\n}\n@endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_NAryMatIterator {
    #[doc = "! the iterated arrays"]
    pub arrays: *mut *const cv_Mat,
    #[doc = "! the current planes"]
    pub planes: *mut cv_Mat,
    #[doc = "! data pointers"]
    pub ptrs: *mut *mut uchar,
    #[doc = "! the number of arrays"]
    pub narrays: ::std::os::raw::c_int,
    #[doc = "! the number of hyper-planes that the iterator steps through"]
    pub nplanes: usize,
    #[doc = "! the size of each segment (in elements)"]
    pub size: usize,
    pub iterdepth: ::std::os::raw::c_int,
    pub idx: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_NAryMatIterator"][::std::mem::size_of::<cv_NAryMatIterator>() - 64usize];
    ["Alignment of cv_NAryMatIterator"][::std::mem::align_of::<cv_NAryMatIterator>() - 8usize];
    ["Offset of field: cv_NAryMatIterator::arrays"]
        [::std::mem::offset_of!(cv_NAryMatIterator, arrays) - 0usize];
    ["Offset of field: cv_NAryMatIterator::planes"]
        [::std::mem::offset_of!(cv_NAryMatIterator, planes) - 8usize];
    ["Offset of field: cv_NAryMatIterator::ptrs"]
        [::std::mem::offset_of!(cv_NAryMatIterator, ptrs) - 16usize];
    ["Offset of field: cv_NAryMatIterator::narrays"]
        [::std::mem::offset_of!(cv_NAryMatIterator, narrays) - 24usize];
    ["Offset of field: cv_NAryMatIterator::nplanes"]
        [::std::mem::offset_of!(cv_NAryMatIterator, nplanes) - 32usize];
    ["Offset of field: cv_NAryMatIterator::size"]
        [::std::mem::offset_of!(cv_NAryMatIterator, size) - 40usize];
    ["Offset of field: cv_NAryMatIterator::iterdepth"]
        [::std::mem::offset_of!(cv_NAryMatIterator, iterdepth) - 48usize];
    ["Offset of field: cv_NAryMatIterator::idx"]
        [::std::mem::offset_of!(cv_NAryMatIterator, idx) - 56usize];
};
unsafe extern "C" {
    #[doc = "! the separate iterator initialization method"]
    #[link_name = "\u{1}_ZN2cv15NAryMatIterator4initEPPKNS_3MatEPS1_PPhi"]
    pub fn cv_NAryMatIterator_init(
        this: *mut cv_NAryMatIterator,
        arrays: *mut *const cv_Mat,
        planes: *mut cv_Mat,
        ptrs: *mut *mut uchar,
        narrays: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = "! the default constructor"]
    #[link_name = "\u{1}_ZN2cv15NAryMatIteratorC1Ev"]
    pub fn cv_NAryMatIterator_NAryMatIterator(this: *mut cv_NAryMatIterator);
}
unsafe extern "C" {
    #[doc = "! the full constructor taking arbitrary number of n-dim matrices"]
    #[link_name = "\u{1}_ZN2cv15NAryMatIteratorC1EPPKNS_3MatEPPhi"]
    pub fn cv_NAryMatIterator_NAryMatIterator1(
        this: *mut cv_NAryMatIterator,
        arrays: *mut *const cv_Mat,
        ptrs: *mut *mut uchar,
        narrays: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = "! the full constructor taking arbitrary number of n-dim matrices"]
    #[link_name = "\u{1}_ZN2cv15NAryMatIteratorC1EPPKNS_3MatEPS1_i"]
    pub fn cv_NAryMatIterator_NAryMatIterator2(
        this: *mut cv_NAryMatIterator,
        arrays: *mut *const cv_Mat,
        planes: *mut cv_Mat,
        narrays: ::std::os::raw::c_int,
    );
}
impl cv_NAryMatIterator {
    #[inline]
    pub unsafe fn init(
        &mut self,
        arrays: *mut *const cv_Mat,
        planes: *mut cv_Mat,
        ptrs: *mut *mut uchar,
        narrays: ::std::os::raw::c_int,
    ) {
        cv_NAryMatIterator_init(self, arrays, planes, ptrs, narrays)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_NAryMatIterator_NAryMatIterator(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        arrays: *mut *const cv_Mat,
        ptrs: *mut *mut uchar,
        narrays: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_NAryMatIterator_NAryMatIterator1(__bindgen_tmp.as_mut_ptr(), arrays, ptrs, narrays);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(
        arrays: *mut *const cv_Mat,
        planes: *mut cv_Mat,
        narrays: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_NAryMatIterator_NAryMatIterator2(__bindgen_tmp.as_mut_ptr(), arrays, planes, narrays);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct cv_MatOp__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Matrix Expressions /////////////////////////////////"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_MatOp {
    pub vtable_: *const cv_MatOp__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_MatOp"][::std::mem::size_of::<cv_MatOp>() - 8usize];
    ["Alignment of cv_MatOp"][::std::mem::align_of::<cv_MatOp>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5MatOpC2Ev"]
    pub fn cv_MatOp_MatOp(this: *mut cv_MatOp);
}
impl cv_MatOp {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_MatOp_MatOp(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5MatOpD1Ev"]
    pub fn cv_MatOp_MatOp_destructor(this: *mut cv_MatOp);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp11elementWiseERKNS_7MatExprE"]
    pub fn cv_MatOp_elementWise(this: *mut ::std::os::raw::c_void, expr: *const cv_MatExpr)
    -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp3roiERKNS_7MatExprERKNS_5RangeES6_RS1_"]
    pub fn cv_MatOp_roi(
        this: *mut ::std::os::raw::c_void,
        expr: *const cv_MatExpr,
        rowRange: *const cv_Range,
        colRange: *const cv_Range,
        res: *mut cv_MatExpr,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp4diagERKNS_7MatExprEiRS1_"]
    pub fn cv_MatOp_diag(
        this: *mut ::std::os::raw::c_void,
        expr: *const cv_MatExpr,
        d: ::std::os::raw::c_int,
        res: *mut cv_MatExpr,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp12augAssignAddERKNS_7MatExprERNS_3MatE"]
    pub fn cv_MatOp_augAssignAdd(
        this: *mut ::std::os::raw::c_void,
        expr: *const cv_MatExpr,
        m: *mut cv_Mat,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp17augAssignSubtractERKNS_7MatExprERNS_3MatE"]
    pub fn cv_MatOp_augAssignSubtract(
        this: *mut ::std::os::raw::c_void,
        expr: *const cv_MatExpr,
        m: *mut cv_Mat,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp17augAssignMultiplyERKNS_7MatExprERNS_3MatE"]
    pub fn cv_MatOp_augAssignMultiply(
        this: *mut ::std::os::raw::c_void,
        expr: *const cv_MatExpr,
        m: *mut cv_Mat,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp15augAssignDivideERKNS_7MatExprERNS_3MatE"]
    pub fn cv_MatOp_augAssignDivide(
        this: *mut ::std::os::raw::c_void,
        expr: *const cv_MatExpr,
        m: *mut cv_Mat,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp12augAssignAndERKNS_7MatExprERNS_3MatE"]
    pub fn cv_MatOp_augAssignAnd(
        this: *mut ::std::os::raw::c_void,
        expr: *const cv_MatExpr,
        m: *mut cv_Mat,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp11augAssignOrERKNS_7MatExprERNS_3MatE"]
    pub fn cv_MatOp_augAssignOr(
        this: *mut ::std::os::raw::c_void,
        expr: *const cv_MatExpr,
        m: *mut cv_Mat,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp12augAssignXorERKNS_7MatExprERNS_3MatE"]
    pub fn cv_MatOp_augAssignXor(
        this: *mut ::std::os::raw::c_void,
        expr: *const cv_MatExpr,
        m: *mut cv_Mat,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp3addERKNS_7MatExprES3_RS1_"]
    pub fn cv_MatOp_add(
        this: *mut ::std::os::raw::c_void,
        expr1: *const cv_MatExpr,
        expr2: *const cv_MatExpr,
        res: *mut cv_MatExpr,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp3addERKNS_7MatExprERKNS_7Scalar_IdEERS1_"]
    pub fn cv_MatOp_add1(
        this: *mut ::std::os::raw::c_void,
        expr1: *const cv_MatExpr,
        s: *const cv_Scalar,
        res: *mut cv_MatExpr,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp8subtractERKNS_7MatExprES3_RS1_"]
    pub fn cv_MatOp_subtract(
        this: *mut ::std::os::raw::c_void,
        expr1: *const cv_MatExpr,
        expr2: *const cv_MatExpr,
        res: *mut cv_MatExpr,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp8subtractERKNS_7Scalar_IdEERKNS_7MatExprERS5_"]
    pub fn cv_MatOp_subtract1(
        this: *mut ::std::os::raw::c_void,
        s: *const cv_Scalar,
        expr: *const cv_MatExpr,
        res: *mut cv_MatExpr,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp8multiplyERKNS_7MatExprES3_RS1_d"]
    pub fn cv_MatOp_multiply(
        this: *mut ::std::os::raw::c_void,
        expr1: *const cv_MatExpr,
        expr2: *const cv_MatExpr,
        res: *mut cv_MatExpr,
        scale: f64,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp8multiplyERKNS_7MatExprEdRS1_"]
    pub fn cv_MatOp_multiply1(
        this: *mut ::std::os::raw::c_void,
        expr1: *const cv_MatExpr,
        s: f64,
        res: *mut cv_MatExpr,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp6divideERKNS_7MatExprES3_RS1_d"]
    pub fn cv_MatOp_divide(
        this: *mut ::std::os::raw::c_void,
        expr1: *const cv_MatExpr,
        expr2: *const cv_MatExpr,
        res: *mut cv_MatExpr,
        scale: f64,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp6divideEdRKNS_7MatExprERS1_"]
    pub fn cv_MatOp_divide1(
        this: *mut ::std::os::raw::c_void,
        s: f64,
        expr: *const cv_MatExpr,
        res: *mut cv_MatExpr,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp3absERKNS_7MatExprERS1_"]
    pub fn cv_MatOp_abs(
        this: *mut ::std::os::raw::c_void,
        expr: *const cv_MatExpr,
        res: *mut cv_MatExpr,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp9transposeERKNS_7MatExprERS1_"]
    pub fn cv_MatOp_transpose(
        this: *mut ::std::os::raw::c_void,
        expr: *const cv_MatExpr,
        res: *mut cv_MatExpr,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp6matmulERKNS_7MatExprES3_RS1_"]
    pub fn cv_MatOp_matmul(
        this: *mut ::std::os::raw::c_void,
        expr1: *const cv_MatExpr,
        expr2: *const cv_MatExpr,
        res: *mut cv_MatExpr,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp6invertERKNS_7MatExprEiRS1_"]
    pub fn cv_MatOp_invert(
        this: *mut ::std::os::raw::c_void,
        expr: *const cv_MatExpr,
        method: ::std::os::raw::c_int,
        res: *mut cv_MatExpr,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp4sizeERKNS_7MatExprE"]
    pub fn cv_MatOp_size(this: *mut ::std::os::raw::c_void, expr: *const cv_MatExpr) -> cv_Size;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5MatOp4typeERKNS_7MatExprE"]
    pub fn cv_MatOp_type(
        this: *mut ::std::os::raw::c_void,
        expr: *const cv_MatExpr,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @brief Matrix expression representation\n@anchor MatrixExpressions\nThis is a list of implemented matrix operations that can be combined in arbitrary complex\nexpressions (here A, B stand for matrices ( Mat ), s for a scalar ( Scalar ), alpha for a\nreal-valued scalar ( double )):\n-   Addition, subtraction, negation: `A+B`, `A-B`, `A+s`, `A-s`, `s+A`, `s-A`, `-A`\n-   Scaling: `A*alpha`\n-   Per-element multiplication and division: `A.mul(B)`, `A/B`, `alpha/A`\n-   Matrix multiplication: `A*B`\n-   Transposition: `A.t()` (means A<sup>T</sup>)\n-   Matrix inversion and pseudo-inversion, solving linear systems and least-squares problems:\n`A.inv([method]) (~ A<sup>-1</sup>)`,   `A.inv([method])*B (~ X: AX=B)`\n-   Comparison: `A cmpop B`, `A cmpop alpha`, `alpha cmpop A`, where *cmpop* is one of\n`>`, `>=`, `==`, `!=`, `<=`, `<`. The result of comparison is an 8-bit single channel mask whose\nelements are set to 255 (if the particular element or pair of elements satisfy the condition) or\n0.\n-   Bitwise logical operations: `A logicop B`, `A logicop s`, `s logicop A`, `~A`, where *logicop* is one of\n`&`, `|`, `^`.\n-   Element-wise minimum and maximum: `min(A, B)`, `min(A, alpha)`, `max(A, B)`, `max(A, alpha)`\n-   Element-wise absolute value: `abs(A)`\n-   Cross-product, dot-product: `A.cross(B)`, `A.dot(B)`\n-   Any function of matrix or matrices and scalars that returns a matrix or a scalar, such as norm,\nmean, sum, countNonZero, trace, determinant, repeat, and others.\n-   Matrix initializers ( Mat::eye(), Mat::zeros(), Mat::ones() ), matrix comma-separated\ninitializers, matrix constructors and operators that extract sub-matrices (see Mat description).\n-   Mat_<destination_type>() constructors to cast the result to the proper type.\n@note Comma-separated initializers and probably some other operations may require additional\nexplicit Mat() or Mat_<T>() constructor calls to resolve a possible ambiguity.\n\nHere are examples of matrix expressions:\n@code\n// compute pseudo-inverse of A, equivalent to A.inv(DECOMP_SVD)\nSVD svd(A);\nMat pinvA = svd.vt.t()*Mat::diag(1./svd.w)*svd.u.t();\n\n// compute the new vector of parameters in the Levenberg-Marquardt algorithm\nx -= (A.t()*A + lambda*Mat::eye(A.cols,A.cols,A.type())).inv(DECOMP_CHOLESKY)*(A.t()*err);\n\n// sharpen image using \"unsharp mask\" algorithm\nMat blurred; double sigma = 1, threshold = 5, amount = 1;\nGaussianBlur(img, blurred, Size(), sigma, sigma);\nMat lowContrastMask = abs(img - blurred) < threshold;\nMat sharpened = img*(1+amount) + blurred*(-amount);\nimg.copyTo(sharpened, lowContrastMask);\n@endcode"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_MatExpr {
    pub op: *const cv_MatOp,
    pub flags: ::std::os::raw::c_int,
    pub a: cv_Mat,
    pub b: cv_Mat,
    pub c: cv_Mat,
    pub alpha: f64,
    pub beta: f64,
    pub s: cv_Scalar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_MatExpr"][::std::mem::size_of::<cv_MatExpr>() - 352usize];
    ["Alignment of cv_MatExpr"][::std::mem::align_of::<cv_MatExpr>() - 8usize];
    ["Offset of field: cv_MatExpr::op"][::std::mem::offset_of!(cv_MatExpr, op) - 0usize];
    ["Offset of field: cv_MatExpr::flags"][::std::mem::offset_of!(cv_MatExpr, flags) - 8usize];
    ["Offset of field: cv_MatExpr::a"][::std::mem::offset_of!(cv_MatExpr, a) - 16usize];
    ["Offset of field: cv_MatExpr::b"][::std::mem::offset_of!(cv_MatExpr, b) - 112usize];
    ["Offset of field: cv_MatExpr::c"][::std::mem::offset_of!(cv_MatExpr, c) - 208usize];
    ["Offset of field: cv_MatExpr::alpha"][::std::mem::offset_of!(cv_MatExpr, alpha) - 304usize];
    ["Offset of field: cv_MatExpr::beta"][::std::mem::offset_of!(cv_MatExpr, beta) - 312usize];
    ["Offset of field: cv_MatExpr::s"][::std::mem::offset_of!(cv_MatExpr, s) - 320usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv7MatExpr4sizeEv"]
    pub fn cv_MatExpr_size(this: *const cv_MatExpr) -> cv_Size;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv7MatExpr4typeEv"]
    pub fn cv_MatExpr_type(this: *const cv_MatExpr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv7MatExpr3rowEi"]
    pub fn cv_MatExpr_row(this: *const cv_MatExpr, y: ::std::os::raw::c_int) -> cv_MatExpr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv7MatExpr3colEi"]
    pub fn cv_MatExpr_col(this: *const cv_MatExpr, x: ::std::os::raw::c_int) -> cv_MatExpr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv7MatExpr4diagEi"]
    pub fn cv_MatExpr_diag(this: *const cv_MatExpr, d: ::std::os::raw::c_int) -> cv_MatExpr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv7MatExpr1tEv"]
    pub fn cv_MatExpr_t(this: *const cv_MatExpr) -> cv_MatExpr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv7MatExpr3invEi"]
    pub fn cv_MatExpr_inv(this: *const cv_MatExpr, method: ::std::os::raw::c_int) -> cv_MatExpr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv7MatExpr3mulERKS0_d"]
    pub fn cv_MatExpr_mul(this: *const cv_MatExpr, e: *const cv_MatExpr, scale: f64) -> cv_MatExpr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv7MatExpr3mulERKNS_3MatEd"]
    pub fn cv_MatExpr_mul1(this: *const cv_MatExpr, m: *const cv_Mat, scale: f64) -> cv_MatExpr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv7MatExpr5crossERKNS_3MatE"]
    pub fn cv_MatExpr_cross(this: *const cv_MatExpr, m: *const cv_Mat) -> cv_Mat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv7MatExpr3dotERKNS_3MatE"]
    pub fn cv_MatExpr_dot(this: *const cv_MatExpr, m: *const cv_Mat) -> f64;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv7MatExprC1ERKNS_3MatE"]
    pub fn cv_MatExpr_MatExpr(this: *mut cv_MatExpr, m: *const cv_Mat);
}
impl cv_MatExpr {
    #[inline]
    pub unsafe fn size(&self) -> cv_Size {
        cv_MatExpr_size(self)
    }
    #[inline]
    pub unsafe fn type_(&self) -> ::std::os::raw::c_int {
        cv_MatExpr_type(self)
    }
    #[inline]
    pub unsafe fn row(&self, y: ::std::os::raw::c_int) -> cv_MatExpr {
        cv_MatExpr_row(self, y)
    }
    #[inline]
    pub unsafe fn col(&self, x: ::std::os::raw::c_int) -> cv_MatExpr {
        cv_MatExpr_col(self, x)
    }
    #[inline]
    pub unsafe fn diag(&self, d: ::std::os::raw::c_int) -> cv_MatExpr {
        cv_MatExpr_diag(self, d)
    }
    #[inline]
    pub unsafe fn t(&self) -> cv_MatExpr {
        cv_MatExpr_t(self)
    }
    #[inline]
    pub unsafe fn inv(&self, method: ::std::os::raw::c_int) -> cv_MatExpr {
        cv_MatExpr_inv(self, method)
    }
    #[inline]
    pub unsafe fn mul(&self, e: *const cv_MatExpr, scale: f64) -> cv_MatExpr {
        cv_MatExpr_mul(self, e, scale)
    }
    #[inline]
    pub unsafe fn mul1(&self, m: *const cv_Mat, scale: f64) -> cv_MatExpr {
        cv_MatExpr_mul1(self, m, scale)
    }
    #[inline]
    pub unsafe fn cross(&self, m: *const cv_Mat) -> cv_Mat {
        cv_MatExpr_cross(self, m)
    }
    #[inline]
    pub unsafe fn dot(&self, m: *const cv_Mat) -> f64 {
        cv_MatExpr_dot(self, m)
    }
    #[inline]
    pub unsafe fn new(m: *const cv_Mat) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_MatExpr_MatExpr(__bindgen_tmp.as_mut_ptr(), m);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3minERKNS_3MatES2_"]
    pub fn cv_min(a: *const cv_Mat, b: *const cv_Mat) -> cv_MatExpr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3minERKNS_3MatEd"]
    pub fn cv_min1(a: *const cv_Mat, s: f64) -> cv_MatExpr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3minEdRKNS_3MatE"]
    pub fn cv_min2(s: f64, a: *const cv_Mat) -> cv_MatExpr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3maxERKNS_3MatES2_"]
    pub fn cv_max(a: *const cv_Mat, b: *const cv_Mat) -> cv_MatExpr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3maxERKNS_3MatEd"]
    pub fn cv_max1(a: *const cv_Mat, s: f64) -> cv_MatExpr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3maxEdRKNS_3MatE"]
    pub fn cv_max2(s: f64, a: *const cv_Mat) -> cv_MatExpr;
}
unsafe extern "C" {
    #[doc = " @brief Calculates an absolute value of each matrix element.\n\nabs is a meta-function that is expanded to one of absdiff or convertScaleAbs forms:\n- C = abs(A-B) is equivalent to `absdiff(A, B, C)`\n- C = abs(A) is equivalent to `absdiff(A, Scalar::all(0), C)`\n- C = `Mat_<Vec<uchar,n> >(abs(A*alpha + beta))` is equivalent to `convertScaleAbs(A, C, alpha,\nbeta)`\n\nThe output matrix has the same size and the same type as the input one except for the last case,\nwhere C is depth=CV_8U .\n@param m matrix.\n@sa @ref MatrixExpressions, absdiff, convertScaleAbs"]
    #[link_name = "\u{1}_ZN2cv3absERKNS_3MatE"]
    pub fn cv_abs(m: *const cv_Mat) -> cv_MatExpr;
}
unsafe extern "C" {
    #[doc = " @overload\n@param e matrix expression."]
    #[link_name = "\u{1}_ZN2cv3absERKNS_7MatExprE"]
    pub fn cv_abs1(e: *const cv_MatExpr) -> cv_MatExpr;
}
#[repr(C)]
pub struct cv_FileStorage__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief XML/YAML/JSON file storage class that encapsulates all the information necessary for writing or\nreading data to/from a file."]
#[repr(C)]
pub struct cv_FileStorage {
    pub vtable_: *const cv_FileStorage__bindgen_vtable,
    pub state: ::std::os::raw::c_int,
    pub elname: std_string,
    pub p: cv_Ptr,
}
#[doc = "!< value, open the file for reading"]
pub const cv_FileStorage_Mode_READ: cv_FileStorage_Mode = 0;
#[doc = "!< value, open the file for writing"]
pub const cv_FileStorage_Mode_WRITE: cv_FileStorage_Mode = 1;
#[doc = "!< value, open the file for appending"]
pub const cv_FileStorage_Mode_APPEND: cv_FileStorage_Mode = 2;
#[doc = "!< flag, read data from source or write data to the internal buffer (which is\n!< returned by FileStorage::release)"]
pub const cv_FileStorage_Mode_MEMORY: cv_FileStorage_Mode = 4;
#[doc = "!< mask for format flags"]
pub const cv_FileStorage_Mode_FORMAT_MASK: cv_FileStorage_Mode = 56;
#[doc = "!< flag, auto format"]
pub const cv_FileStorage_Mode_FORMAT_AUTO: cv_FileStorage_Mode = 0;
#[doc = "!< flag, XML format"]
pub const cv_FileStorage_Mode_FORMAT_XML: cv_FileStorage_Mode = 8;
#[doc = "!< flag, YAML format"]
pub const cv_FileStorage_Mode_FORMAT_YAML: cv_FileStorage_Mode = 16;
#[doc = "!< flag, JSON format"]
pub const cv_FileStorage_Mode_FORMAT_JSON: cv_FileStorage_Mode = 24;
#[doc = "!< flag, write rawdata in Base64 by default. (consider using WRITE_BASE64)"]
pub const cv_FileStorage_Mode_BASE64: cv_FileStorage_Mode = 64;
#[doc = "!< flag, enable both WRITE and BASE64"]
pub const cv_FileStorage_Mode_WRITE_BASE64: cv_FileStorage_Mode = 65;
#[doc = "! file storage mode"]
pub type cv_FileStorage_Mode = ::std::os::raw::c_uint;
pub const cv_FileStorage_State_UNDEFINED: cv_FileStorage_State = 0;
pub const cv_FileStorage_State_VALUE_EXPECTED: cv_FileStorage_State = 1;
pub const cv_FileStorage_State_NAME_EXPECTED: cv_FileStorage_State = 2;
pub const cv_FileStorage_State_INSIDE_MAP: cv_FileStorage_State = 4;
pub type cv_FileStorage_State = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_FileStorage_Impl {
    _unused: [u8; 0],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_FileStorage"][::std::mem::size_of::<cv_FileStorage>() - 64usize];
    ["Alignment of cv_FileStorage"][::std::mem::align_of::<cv_FileStorage>() - 8usize];
    ["Offset of field: cv_FileStorage::state"]
        [::std::mem::offset_of!(cv_FileStorage, state) - 8usize];
    ["Offset of field: cv_FileStorage::elname"]
        [::std::mem::offset_of!(cv_FileStorage, elname) - 16usize];
    ["Offset of field: cv_FileStorage::p"][::std::mem::offset_of!(cv_FileStorage, p) - 48usize];
};
unsafe extern "C" {
    #[doc = " @brief Returns the first element of the top-level mapping.\n@returns The first element of the top-level mapping."]
    #[link_name = "\u{1}_ZNK2cv11FileStorage20getFirstTopLevelNodeEv"]
    pub fn cv_FileStorage_getFirstTopLevelNode(this: *const cv_FileStorage) -> cv_FileNode;
}
unsafe extern "C" {
    #[doc = " @brief Returns the top-level mapping\n@param streamidx Zero-based index of the stream. In most cases there is only one stream in the file.\nHowever, YAML supports multiple streams and so there can be several.\n@returns The top-level mapping."]
    #[link_name = "\u{1}_ZNK2cv11FileStorage4rootEi"]
    pub fn cv_FileStorage_root(
        this: *const cv_FileStorage,
        streamidx: ::std::os::raw::c_int,
    ) -> cv_FileNode;
}
unsafe extern "C" {
    #[doc = " @brief Simplified writing API to use with bindings.\n @param name Name of the written object\n @param val Value of the written object"]
    #[link_name = "\u{1}_ZN2cv11FileStorage5writeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
    pub fn cv_FileStorage_write(
        this: *mut cv_FileStorage,
        name: *const cv_String,
        val: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv11FileStorage5writeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEd"]
    pub fn cv_FileStorage_write1(this: *mut cv_FileStorage, name: *const cv_String, val: f64);
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv11FileStorage5writeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
    pub fn cv_FileStorage_write2(
        this: *mut cv_FileStorage,
        name: *const cv_String,
        val: *const cv_String,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv11FileStorage5writeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_3MatE"]
    pub fn cv_FileStorage_write3(
        this: *mut cv_FileStorage,
        name: *const cv_String,
        val: *const cv_Mat,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv11FileStorage5writeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt6vectorIS6_SaIS6_EE"]
    pub fn cv_FileStorage_write4(
        this: *mut cv_FileStorage,
        name: *const cv_String,
        val: *const std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @brief Writes multiple numbers.\n\nWrites one or more numbers of the specified format to the currently written structure. Usually it is\nmore convenient to use operator `<<` instead of this method.\n@param fmt Specification of each array element, see @ref format_spec \"format specification\"\n@param vec Pointer to the written array.\n@param len Number of the uchar elements to write."]
    #[link_name = "\u{1}_ZN2cv11FileStorage8writeRawERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPKvm"]
    pub fn cv_FileStorage_writeRaw(
        this: *mut cv_FileStorage,
        fmt: *const cv_String,
        vec: *const ::std::os::raw::c_void,
        len: usize,
    );
}
unsafe extern "C" {
    #[doc = " @brief Writes a comment.\n\nThe function writes a comment into file storage. The comments are skipped when the storage is read.\n@param comment The written comment, single-line or multi-line\n@param append If true, the function tries to put the comment at the end of current line.\nElse if the comment is multi-line, or if it does not fit at the end of the current\nline, the comment starts a new line."]
    #[link_name = "\u{1}_ZN2cv11FileStorage12writeCommentERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb"]
    pub fn cv_FileStorage_writeComment(
        this: *mut cv_FileStorage,
        comment: *const cv_String,
        append: bool,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv11FileStorage16startWriteStructERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiS8_"]
    pub fn cv_FileStorage_startWriteStruct(
        this: *mut cv_FileStorage,
        name: *const cv_String,
        flags: ::std::os::raw::c_int,
        typeName: *const cv_String,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv11FileStorage14endWriteStructEv"]
    pub fn cv_FileStorage_endWriteStruct(this: *mut cv_FileStorage);
}
unsafe extern "C" {
    #[doc = " @brief Returns the normalized object name for the specified name of a file.\n@param filename Name of a file\n@returns The normalized object name."]
    #[link_name = "\u{1}_ZN2cv11FileStorage20getDefaultObjectNameERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_FileStorage_getDefaultObjectName(filename: *const cv_String) -> cv_String;
}
unsafe extern "C" {
    #[doc = " @brief Returns the current format.\n @returns The current format, see FileStorage::Mode"]
    #[link_name = "\u{1}_ZNK2cv11FileStorage9getFormatEv"]
    pub fn cv_FileStorage_getFormat(this: *const cv_FileStorage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief The constructors.\n\nThe full constructor opens the file. Alternatively you can use the default constructor and then\ncall FileStorage::open."]
    #[link_name = "\u{1}_ZN2cv11FileStorageC1Ev"]
    pub fn cv_FileStorage_FileStorage(this: *mut cv_FileStorage);
}
unsafe extern "C" {
    #[doc = " @overload\n@copydoc open()"]
    #[link_name = "\u{1}_ZN2cv11FileStorageC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiS8_"]
    pub fn cv_FileStorage_FileStorage1(
        this: *mut cv_FileStorage,
        filename: *const cv_String,
        flags: ::std::os::raw::c_int,
        encoding: *const cv_String,
    );
}
impl cv_FileStorage {
    #[inline]
    pub unsafe fn getFirstTopLevelNode(&self) -> cv_FileNode {
        cv_FileStorage_getFirstTopLevelNode(self)
    }
    #[inline]
    pub unsafe fn root(&self, streamidx: ::std::os::raw::c_int) -> cv_FileNode {
        cv_FileStorage_root(self, streamidx)
    }
    #[inline]
    pub unsafe fn write(&mut self, name: *const cv_String, val: ::std::os::raw::c_int) {
        cv_FileStorage_write(self, name, val)
    }
    #[inline]
    pub unsafe fn write1(&mut self, name: *const cv_String, val: f64) {
        cv_FileStorage_write1(self, name, val)
    }
    #[inline]
    pub unsafe fn write2(&mut self, name: *const cv_String, val: *const cv_String) {
        cv_FileStorage_write2(self, name, val)
    }
    #[inline]
    pub unsafe fn write3(&mut self, name: *const cv_String, val: *const cv_Mat) {
        cv_FileStorage_write3(self, name, val)
    }
    #[inline]
    pub unsafe fn write4(&mut self, name: *const cv_String, val: *const std_vector) {
        cv_FileStorage_write4(self, name, val)
    }
    #[inline]
    pub unsafe fn writeRaw(
        &mut self,
        fmt: *const cv_String,
        vec: *const ::std::os::raw::c_void,
        len: usize,
    ) {
        cv_FileStorage_writeRaw(self, fmt, vec, len)
    }
    #[inline]
    pub unsafe fn writeComment(&mut self, comment: *const cv_String, append: bool) {
        cv_FileStorage_writeComment(self, comment, append)
    }
    #[inline]
    pub unsafe fn startWriteStruct(
        &mut self,
        name: *const cv_String,
        flags: ::std::os::raw::c_int,
        typeName: *const cv_String,
    ) {
        cv_FileStorage_startWriteStruct(self, name, flags, typeName)
    }
    #[inline]
    pub unsafe fn endWriteStruct(&mut self) {
        cv_FileStorage_endWriteStruct(self)
    }
    #[inline]
    pub unsafe fn getDefaultObjectName(filename: *const cv_String) -> cv_String {
        cv_FileStorage_getDefaultObjectName(filename)
    }
    #[inline]
    pub unsafe fn getFormat(&self) -> ::std::os::raw::c_int {
        cv_FileStorage_getFormat(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_FileStorage_FileStorage(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        filename: *const cv_String,
        flags: ::std::os::raw::c_int,
        encoding: *const cv_String,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_FileStorage_FileStorage1(__bindgen_tmp.as_mut_ptr(), filename, flags, encoding);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[doc = "! the destructor. calls release()"]
    #[link_name = "\u{1}_ZN2cv11FileStorageD1Ev"]
    pub fn cv_FileStorage_FileStorage_destructor(this: *mut cv_FileStorage);
}
unsafe extern "C" {
    #[doc = " @brief Opens a file.\n\nSee description of parameters in FileStorage::FileStorage. The method calls FileStorage::release\nbefore opening the file.\n@param filename Name of the file to open or the text string to read the data from.\nExtension of the file (.xml, .yml/.yaml or .json) determines its format (XML, YAML or JSON\nrespectively). Also you can append .gz to work with compressed files, for example myHugeMatrix.xml.gz. If both\nFileStorage::WRITE and FileStorage::MEMORY flags are specified, source is used just to specify\nthe output file format (e.g. mydata.xml, .yml etc.). A file name can also contain parameters.\nYou can use this format, \"*?base64\" (e.g. \"file.json?base64\" (case sensitive)), as an alternative to\nFileStorage::BASE64 flag.\n@param flags Mode of operation. One of FileStorage::Mode\n@param encoding Encoding of the file. Note that UTF-16 XML encoding is not supported currently and\nyou should use 8-bit encoding instead of it."]
    #[link_name = "\u{1}_ZN2cv11FileStorage4openERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiS8_"]
    pub fn cv_FileStorage_open(
        this: *mut ::std::os::raw::c_void,
        filename: *const cv_String,
        flags: ::std::os::raw::c_int,
        encoding: *const cv_String,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Checks whether the file is opened.\n\n@returns true if the object is associated with the current file and false otherwise. It is a\ngood practice to call this method after you tried to open a file."]
    #[link_name = "\u{1}_ZNK2cv11FileStorage8isOpenedEv"]
    pub fn cv_FileStorage_isOpened(this: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Closes the file and releases all the memory buffers.\n\nCall this method after all I/O operations with the storage are finished."]
    #[link_name = "\u{1}_ZN2cv11FileStorage7releaseEv"]
    pub fn cv_FileStorage_release(this: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " @brief Closes the file and releases all the memory buffers.\n\nCall this method after all I/O operations with the storage are finished. If the storage was\nopened for writing data and FileStorage::WRITE was specified"]
    #[link_name = "\u{1}_ZN2cv11FileStorage19releaseAndGetStringB5cxx11Ev"]
    pub fn cv_FileStorage_releaseAndGetString(this: *mut ::std::os::raw::c_void) -> cv_String;
}
#[doc = " string class ////////////////////////////////"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_FileNode {
    pub fs: *const cv_FileStorage,
    pub blockIdx: usize,
    pub ofs: usize,
}
#[doc = "!< empty node"]
pub const cv_FileNode_NONE: cv_FileNode__bindgen_ty_1 = 0;
#[doc = "!< an integer"]
pub const cv_FileNode_INT: cv_FileNode__bindgen_ty_1 = 1;
#[doc = "!< floating-point number"]
pub const cv_FileNode_REAL: cv_FileNode__bindgen_ty_1 = 2;
#[doc = "!< synonym or REAL"]
pub const cv_FileNode_FLOAT: cv_FileNode__bindgen_ty_1 = 2;
#[doc = "!< text string in UTF-8 encoding"]
pub const cv_FileNode_STR: cv_FileNode__bindgen_ty_1 = 3;
#[doc = "!< synonym for STR"]
pub const cv_FileNode_STRING: cv_FileNode__bindgen_ty_1 = 3;
#[doc = "!< sequence"]
pub const cv_FileNode_SEQ: cv_FileNode__bindgen_ty_1 = 4;
#[doc = "!< mapping"]
pub const cv_FileNode_MAP: cv_FileNode__bindgen_ty_1 = 5;
pub const cv_FileNode_TYPE_MASK: cv_FileNode__bindgen_ty_1 = 7;
#[doc = "!< compact representation of a sequence or mapping. Used only by YAML writer"]
pub const cv_FileNode_FLOW: cv_FileNode__bindgen_ty_1 = 8;
#[doc = "!< if set, means that all the collection elements are numbers of the same type (real's or int's).\n!< UNIFORM is used only when reading FileStorage; FLOW is used only when writing. So they share the same bit"]
pub const cv_FileNode_UNIFORM: cv_FileNode__bindgen_ty_1 = 8;
#[doc = "!< empty structure (sequence or mapping)"]
pub const cv_FileNode_EMPTY: cv_FileNode__bindgen_ty_1 = 16;
#[doc = "!< the node has a name (i.e. it is element of a mapping)."]
pub const cv_FileNode_NAMED: cv_FileNode__bindgen_ty_1 = 32;
#[doc = "! type of the file storage node"]
pub type cv_FileNode__bindgen_ty_1 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_FileNode"][::std::mem::size_of::<cv_FileNode>() - 24usize];
    ["Alignment of cv_FileNode"][::std::mem::align_of::<cv_FileNode>() - 8usize];
    ["Offset of field: cv_FileNode::fs"][::std::mem::offset_of!(cv_FileNode, fs) - 0usize];
    ["Offset of field: cv_FileNode::blockIdx"]
        [::std::mem::offset_of!(cv_FileNode, blockIdx) - 8usize];
    ["Offset of field: cv_FileNode::ofs"][::std::mem::offset_of!(cv_FileNode, ofs) - 16usize];
};
unsafe extern "C" {
    #[doc = " @brief Returns keys of a mapping node.\n@returns Keys of a mapping node."]
    #[link_name = "\u{1}_ZNK2cv8FileNode4keysB5cxx11Ev"]
    pub fn cv_FileNode_keys(this: *const cv_FileNode) -> std_vector;
}
unsafe extern "C" {
    #[doc = " @brief Returns type of the node.\n@returns Type of the node. See FileNode::Type"]
    #[link_name = "\u{1}_ZNK2cv8FileNode4typeEv"]
    pub fn cv_FileNode_type(this: *const cv_FileNode) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! returns true if the node is empty"]
    #[link_name = "\u{1}_ZNK2cv8FileNode5emptyEv"]
    pub fn cv_FileNode_empty(this: *const cv_FileNode) -> bool;
}
unsafe extern "C" {
    #[doc = "! returns true if the node is a \"none\" object"]
    #[link_name = "\u{1}_ZNK2cv8FileNode6isNoneEv"]
    pub fn cv_FileNode_isNone(this: *const cv_FileNode) -> bool;
}
unsafe extern "C" {
    #[doc = "! returns true if the node is a sequence"]
    #[link_name = "\u{1}_ZNK2cv8FileNode5isSeqEv"]
    pub fn cv_FileNode_isSeq(this: *const cv_FileNode) -> bool;
}
unsafe extern "C" {
    #[doc = "! returns true if the node is a mapping"]
    #[link_name = "\u{1}_ZNK2cv8FileNode5isMapEv"]
    pub fn cv_FileNode_isMap(this: *const cv_FileNode) -> bool;
}
unsafe extern "C" {
    #[doc = "! returns true if the node is an integer"]
    #[link_name = "\u{1}_ZNK2cv8FileNode5isIntEv"]
    pub fn cv_FileNode_isInt(this: *const cv_FileNode) -> bool;
}
unsafe extern "C" {
    #[doc = "! returns true if the node is a floating-point number"]
    #[link_name = "\u{1}_ZNK2cv8FileNode6isRealEv"]
    pub fn cv_FileNode_isReal(this: *const cv_FileNode) -> bool;
}
unsafe extern "C" {
    #[doc = "! returns true if the node is a text string"]
    #[link_name = "\u{1}_ZNK2cv8FileNode8isStringEv"]
    pub fn cv_FileNode_isString(this: *const cv_FileNode) -> bool;
}
unsafe extern "C" {
    #[doc = "! returns true if the node has a name"]
    #[link_name = "\u{1}_ZNK2cv8FileNode7isNamedEv"]
    pub fn cv_FileNode_isNamed(this: *const cv_FileNode) -> bool;
}
unsafe extern "C" {
    #[doc = "! returns the node name or an empty string if the node is nameless"]
    #[link_name = "\u{1}_ZNK2cv8FileNode4nameB5cxx11Ev"]
    pub fn cv_FileNode_name(this: *const cv_FileNode) -> std_string;
}
unsafe extern "C" {
    #[doc = "! returns the number of elements in the node, if it is a sequence or mapping, or 1 otherwise."]
    #[link_name = "\u{1}_ZNK2cv8FileNode4sizeEv"]
    pub fn cv_FileNode_size(this: *const cv_FileNode) -> usize;
}
unsafe extern "C" {
    #[doc = "! returns raw size of the FileNode in bytes"]
    #[link_name = "\u{1}_ZNK2cv8FileNode7rawSizeEv"]
    pub fn cv_FileNode_rawSize(this: *const cv_FileNode) -> usize;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8FileNode5isMapEi"]
    pub fn cv_FileNode_isMap1(flags: ::std::os::raw::c_int) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8FileNode5isSeqEi"]
    pub fn cv_FileNode_isSeq1(flags: ::std::os::raw::c_int) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8FileNode12isCollectionEi"]
    pub fn cv_FileNode_isCollection(flags: ::std::os::raw::c_int) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8FileNode17isEmptyCollectionEi"]
    pub fn cv_FileNode_isEmptyCollection(flags: ::std::os::raw::c_int) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8FileNode6isFlowEi"]
    pub fn cv_FileNode_isFlow(flags: ::std::os::raw::c_int) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8FileNode3ptrEv"]
    pub fn cv_FileNode_ptr(this: *mut cv_FileNode) -> *mut uchar;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv8FileNode3ptrEv"]
    pub fn cv_FileNode_ptr1(this: *const cv_FileNode) -> *const uchar;
}
unsafe extern "C" {
    #[doc = "! returns iterator pointing to the first node element"]
    #[link_name = "\u{1}_ZNK2cv8FileNode5beginEv"]
    pub fn cv_FileNode_begin(this: *const cv_FileNode) -> cv_FileNodeIterator;
}
unsafe extern "C" {
    #[doc = "! returns iterator pointing to the element following the last node element"]
    #[link_name = "\u{1}_ZNK2cv8FileNode3endEv"]
    pub fn cv_FileNode_end(this: *const cv_FileNode) -> cv_FileNodeIterator;
}
unsafe extern "C" {
    #[doc = " @brief Reads node elements to the buffer with the specified format.\n\nUsually it is more convenient to use operator `>>` instead of this method.\n@param fmt Specification of each array element. See @ref format_spec \"format specification\"\n@param vec Pointer to the destination array.\n@param len Number of bytes to read (buffer size limit). If it is greater than number of\nremaining elements then all of them will be read."]
    #[link_name = "\u{1}_ZNK2cv8FileNode7readRawERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPvm"]
    pub fn cv_FileNode_readRaw(
        this: *const cv_FileNode,
        fmt: *const cv_String,
        vec: *mut ::std::os::raw::c_void,
        len: usize,
    );
}
unsafe extern "C" {
    #[doc = " Internal method used when reading FileStorage.\nSets the type (int, real or string) and value of the previously created node."]
    #[link_name = "\u{1}_ZN2cv8FileNode8setValueEiPKvi"]
    pub fn cv_FileNode_setValue(
        this: *mut cv_FileNode,
        type_: ::std::os::raw::c_int,
        value: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = "! Simplified reading API to use with bindings."]
    #[link_name = "\u{1}_ZNK2cv8FileNode4realEv"]
    pub fn cv_FileNode_real(this: *const cv_FileNode) -> f64;
}
unsafe extern "C" {
    #[doc = "! Simplified reading API to use with bindings."]
    #[link_name = "\u{1}_ZNK2cv8FileNode6stringB5cxx11Ev"]
    pub fn cv_FileNode_string(this: *const cv_FileNode) -> std_string;
}
unsafe extern "C" {
    #[doc = "! Simplified reading API to use with bindings."]
    #[link_name = "\u{1}_ZNK2cv8FileNode3matEv"]
    pub fn cv_FileNode_mat(this: *const cv_FileNode) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief The constructors.\n\nThese constructors are used to create a default file node, construct it from obsolete structures or\nfrom the another file node."]
    #[link_name = "\u{1}_ZN2cv8FileNodeC1Ev"]
    pub fn cv_FileNode_FileNode(this: *mut cv_FileNode);
}
unsafe extern "C" {
    #[doc = " @overload\n@param fs Pointer to the file storage structure.\n@param blockIdx Index of the memory block where the file node is stored\n@param ofs Offset in bytes from the beginning of the serialized storage"]
    #[link_name = "\u{1}_ZN2cv8FileNodeC1EPKNS_11FileStorageEmm"]
    pub fn cv_FileNode_FileNode1(
        this: *mut cv_FileNode,
        fs: *const cv_FileStorage,
        blockIdx: usize,
        ofs: usize,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param node File node to be used as initialization for the created file node."]
    #[link_name = "\u{1}_ZN2cv8FileNodeC1ERKS0_"]
    pub fn cv_FileNode_FileNode2(this: *mut cv_FileNode, node: *const cv_FileNode);
}
impl cv_FileNode {
    #[inline]
    pub unsafe fn keys(&self) -> std_vector {
        cv_FileNode_keys(self)
    }
    #[inline]
    pub unsafe fn type_(&self) -> ::std::os::raw::c_int {
        cv_FileNode_type(self)
    }
    #[inline]
    pub unsafe fn empty(&self) -> bool {
        cv_FileNode_empty(self)
    }
    #[inline]
    pub unsafe fn isNone(&self) -> bool {
        cv_FileNode_isNone(self)
    }
    #[inline]
    pub unsafe fn isSeq(&self) -> bool {
        cv_FileNode_isSeq(self)
    }
    #[inline]
    pub unsafe fn isMap(&self) -> bool {
        cv_FileNode_isMap(self)
    }
    #[inline]
    pub unsafe fn isInt(&self) -> bool {
        cv_FileNode_isInt(self)
    }
    #[inline]
    pub unsafe fn isReal(&self) -> bool {
        cv_FileNode_isReal(self)
    }
    #[inline]
    pub unsafe fn isString(&self) -> bool {
        cv_FileNode_isString(self)
    }
    #[inline]
    pub unsafe fn isNamed(&self) -> bool {
        cv_FileNode_isNamed(self)
    }
    #[inline]
    pub unsafe fn name(&self) -> std_string {
        cv_FileNode_name(self)
    }
    #[inline]
    pub unsafe fn size(&self) -> usize {
        cv_FileNode_size(self)
    }
    #[inline]
    pub unsafe fn rawSize(&self) -> usize {
        cv_FileNode_rawSize(self)
    }
    #[inline]
    pub unsafe fn isMap1(flags: ::std::os::raw::c_int) -> bool {
        cv_FileNode_isMap1(flags)
    }
    #[inline]
    pub unsafe fn isSeq1(flags: ::std::os::raw::c_int) -> bool {
        cv_FileNode_isSeq1(flags)
    }
    #[inline]
    pub unsafe fn isCollection(flags: ::std::os::raw::c_int) -> bool {
        cv_FileNode_isCollection(flags)
    }
    #[inline]
    pub unsafe fn isEmptyCollection(flags: ::std::os::raw::c_int) -> bool {
        cv_FileNode_isEmptyCollection(flags)
    }
    #[inline]
    pub unsafe fn isFlow(flags: ::std::os::raw::c_int) -> bool {
        cv_FileNode_isFlow(flags)
    }
    #[inline]
    pub unsafe fn ptr(&mut self) -> *mut uchar {
        cv_FileNode_ptr(self)
    }
    #[inline]
    pub unsafe fn ptr1(&self) -> *const uchar {
        cv_FileNode_ptr1(self)
    }
    #[inline]
    pub unsafe fn begin(&self) -> cv_FileNodeIterator {
        cv_FileNode_begin(self)
    }
    #[inline]
    pub unsafe fn end(&self) -> cv_FileNodeIterator {
        cv_FileNode_end(self)
    }
    #[inline]
    pub unsafe fn readRaw(
        &self,
        fmt: *const cv_String,
        vec: *mut ::std::os::raw::c_void,
        len: usize,
    ) {
        cv_FileNode_readRaw(self, fmt, vec, len)
    }
    #[inline]
    pub unsafe fn setValue(
        &mut self,
        type_: ::std::os::raw::c_int,
        value: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) {
        cv_FileNode_setValue(self, type_, value, len)
    }
    #[inline]
    pub unsafe fn real(&self) -> f64 {
        cv_FileNode_real(self)
    }
    #[inline]
    pub unsafe fn string(&self) -> std_string {
        cv_FileNode_string(self)
    }
    #[inline]
    pub unsafe fn mat(&self) -> cv_Mat {
        cv_FileNode_mat(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_FileNode_FileNode(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(fs: *const cv_FileStorage, blockIdx: usize, ofs: usize) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_FileNode_FileNode1(__bindgen_tmp.as_mut_ptr(), fs, blockIdx, ofs);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(node: *const cv_FileNode) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_FileNode_FileNode2(__bindgen_tmp.as_mut_ptr(), node);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief used to iterate through sequences and mappings.\n\nA standard STL notation, with node.begin(), node.end() denoting the beginning and the end of a\nsequence, stored in node. See the data reading sample in the beginning of the section."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_FileNodeIterator {
    pub fs: *const cv_FileStorage,
    pub blockIdx: usize,
    pub ofs: usize,
    pub blockSize: usize,
    pub nodeNElems: usize,
    pub idx: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_FileNodeIterator"][::std::mem::size_of::<cv_FileNodeIterator>() - 48usize];
    ["Alignment of cv_FileNodeIterator"][::std::mem::align_of::<cv_FileNodeIterator>() - 8usize];
    ["Offset of field: cv_FileNodeIterator::fs"]
        [::std::mem::offset_of!(cv_FileNodeIterator, fs) - 0usize];
    ["Offset of field: cv_FileNodeIterator::blockIdx"]
        [::std::mem::offset_of!(cv_FileNodeIterator, blockIdx) - 8usize];
    ["Offset of field: cv_FileNodeIterator::ofs"]
        [::std::mem::offset_of!(cv_FileNodeIterator, ofs) - 16usize];
    ["Offset of field: cv_FileNodeIterator::blockSize"]
        [::std::mem::offset_of!(cv_FileNodeIterator, blockSize) - 24usize];
    ["Offset of field: cv_FileNodeIterator::nodeNElems"]
        [::std::mem::offset_of!(cv_FileNodeIterator, nodeNElems) - 32usize];
    ["Offset of field: cv_FileNodeIterator::idx"]
        [::std::mem::offset_of!(cv_FileNodeIterator, idx) - 40usize];
};
unsafe extern "C" {
    #[doc = " @brief Reads node elements to the buffer with the specified format.\n\nUsually it is more convenient to use operator `>>` instead of this method.\n@param fmt Specification of each array element. See @ref format_spec \"format specification\"\n@param vec Pointer to the destination array.\n@param len Number of bytes to read (buffer size limit). If it is greater than number of\nremaining elements then all of them will be read."]
    #[link_name = "\u{1}_ZN2cv16FileNodeIterator7readRawERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPvm"]
    pub fn cv_FileNodeIterator_readRaw(
        this: *mut cv_FileNodeIterator,
        fmt: *const cv_String,
        vec: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> *mut cv_FileNodeIterator;
}
unsafe extern "C" {
    #[doc = "! returns the number of remaining (not read yet) elements"]
    #[link_name = "\u{1}_ZNK2cv16FileNodeIterator9remainingEv"]
    pub fn cv_FileNodeIterator_remaining(this: *const cv_FileNodeIterator) -> usize;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv16FileNodeIterator7equalToERKS0_"]
    pub fn cv_FileNodeIterator_equalTo(
        this: *const cv_FileNodeIterator,
        it: *const cv_FileNodeIterator,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief The constructors.\n\nThese constructors are used to create a default iterator, set it to specific element in a file node\nor construct it from another iterator."]
    #[link_name = "\u{1}_ZN2cv16FileNodeIteratorC1Ev"]
    pub fn cv_FileNodeIterator_FileNodeIterator(this: *mut cv_FileNodeIterator);
}
unsafe extern "C" {
    #[doc = " @overload\n@param node File node - the collection to iterate over;\nit can be a scalar (equivalent to 1-element collection) or \"none\" (equivalent to empty collection).\n@param seekEnd - true if iterator needs to be set after the last element of the node;\nthat is:\n node.begin() => FileNodeIterator(node, false)\n node.end() => FileNodeIterator(node, true)"]
    #[link_name = "\u{1}_ZN2cv16FileNodeIteratorC1ERKNS_8FileNodeEb"]
    pub fn cv_FileNodeIterator_FileNodeIterator1(
        this: *mut cv_FileNodeIterator,
        node: *const cv_FileNode,
        seekEnd: bool,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param it Iterator to be used as initialization for the created iterator."]
    #[link_name = "\u{1}_ZN2cv16FileNodeIteratorC1ERKS0_"]
    pub fn cv_FileNodeIterator_FileNodeIterator2(
        this: *mut cv_FileNodeIterator,
        it: *const cv_FileNodeIterator,
    );
}
impl cv_FileNodeIterator {
    #[inline]
    pub unsafe fn readRaw(
        &mut self,
        fmt: *const cv_String,
        vec: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> *mut cv_FileNodeIterator {
        cv_FileNodeIterator_readRaw(self, fmt, vec, len)
    }
    #[inline]
    pub unsafe fn remaining(&self) -> usize {
        cv_FileNodeIterator_remaining(self)
    }
    #[inline]
    pub unsafe fn equalTo(&self, it: *const cv_FileNodeIterator) -> bool {
        cv_FileNodeIterator_equalTo(self, it)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_FileNodeIterator_FileNodeIterator(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(node: *const cv_FileNode, seekEnd: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_FileNodeIterator_FileNodeIterator1(__bindgen_tmp.as_mut_ptr(), node, seekEnd);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(it: *const cv_FileNodeIterator) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_FileNodeIterator_FileNodeIterator2(__bindgen_tmp.as_mut_ptr(), it);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[doc = "! @relates cv::FileStorage\n! @{"]
    #[link_name = "\u{1}_ZN2cv5writeERNS_11FileStorageERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
    pub fn cv_write(fs: *mut cv_FileStorage, name: *const cv_String, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5writeERNS_11FileStorageERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEf"]
    pub fn cv_write1(fs: *mut cv_FileStorage, name: *const cv_String, value: f32);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5writeERNS_11FileStorageERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEd"]
    pub fn cv_write2(fs: *mut cv_FileStorage, name: *const cv_String, value: f64);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5writeERNS_11FileStorageERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_"]
    pub fn cv_write3(fs: *mut cv_FileStorage, name: *const cv_String, value: *const cv_String);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5writeERNS_11FileStorageERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_3MatE"]
    pub fn cv_write4(fs: *mut cv_FileStorage, name: *const cv_String, value: *const cv_Mat);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5writeERNS_11FileStorageERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_9SparseMatE"]
    pub fn cv_write5(fs: *mut cv_FileStorage, name: *const cv_String, value: *const cv_SparseMat);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5writeERNS_11FileStorageERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt6vectorINS_8KeyPointESaISB_EE"]
    pub fn cv_write6(fs: *mut cv_FileStorage, name: *const cv_String, value: *const std_vector);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5writeERNS_11FileStorageERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt6vectorINS_6DMatchESaISB_EE"]
    pub fn cv_write7(fs: *mut cv_FileStorage, name: *const cv_String, value: *const std_vector);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv11writeScalarERNS_11FileStorageEi"]
    pub fn cv_writeScalar(fs: *mut cv_FileStorage, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv11writeScalarERNS_11FileStorageEf"]
    pub fn cv_writeScalar1(fs: *mut cv_FileStorage, value: f32);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv11writeScalarERNS_11FileStorageEd"]
    pub fn cv_writeScalar2(fs: *mut cv_FileStorage, value: f64);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv11writeScalarERNS_11FileStorageERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_writeScalar3(fs: *mut cv_FileStorage, value: *const cv_String);
}
unsafe extern "C" {
    #[doc = "! @relates cv::FileNode\n! @{"]
    #[link_name = "\u{1}_ZN2cv4readERKNS_8FileNodeERii"]
    pub fn cv_read(
        node: *const cv_FileNode,
        value: *mut ::std::os::raw::c_int,
        default_value: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4readERKNS_8FileNodeERff"]
    pub fn cv_read1(node: *const cv_FileNode, value: *mut f32, default_value: f32);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4readERKNS_8FileNodeERdd"]
    pub fn cv_read2(node: *const cv_FileNode, value: *mut f64, default_value: f64);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4readERKNS_8FileNodeERNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKS8_"]
    pub fn cv_read3(
        node: *const cv_FileNode,
        value: *mut std_string,
        default_value: *const std_string,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4readERKNS_8FileNodeERNS_3MatERKS3_"]
    pub fn cv_read4(node: *const cv_FileNode, mat: *mut cv_Mat, default_mat: *const cv_Mat);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4readERKNS_8FileNodeERNS_9SparseMatERKS3_"]
    pub fn cv_read5(
        node: *const cv_FileNode,
        mat: *mut cv_SparseMat,
        default_mat: *const cv_SparseMat,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4readERKNS_8FileNodeERSt6vectorINS_8KeyPointESaIS4_EE"]
    pub fn cv_read6(node: *const cv_FileNode, keypoints: *mut std_vector);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4readERKNS_8FileNodeERSt6vectorINS_6DMatchESaIS4_EE"]
    pub fn cv_read7(node: *const cv_FileNode, matches: *mut std_vector);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4readERKNS_8FileNodeERNS_8KeyPointERKS3_"]
    pub fn cv_read8(
        node: *const cv_FileNode,
        value: *mut cv_KeyPoint,
        default_value: *const cv_KeyPoint,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4readERKNS_8FileNodeERNS_6DMatchERKS3_"]
    pub fn cv_read9(
        node: *const cv_FileNode,
        value: *mut cv_DMatch,
        default_value: *const cv_DMatch,
    );
}
#[doc = " @brief Class passed to an error.\n\nThis class encapsulates all or almost all necessary\ninformation about the error happened in the program. The exception is\nusually constructed and thrown implicitly via CV_Error and CV_Error_ macros.\n@see error"]
#[repr(C)]
pub struct cv_Exception {
    pub _base: std_exception,
    #[doc = "< the formatted error message"]
    pub msg: cv_String,
    #[doc = "< error code @see CVStatus"]
    pub code: ::std::os::raw::c_int,
    #[doc = "< error description"]
    pub err: cv_String,
    #[doc = "< function name. Available only when the compiler supports getting it"]
    pub func: cv_String,
    #[doc = "< source file name where the error has occurred"]
    pub file: cv_String,
    #[doc = "< line number in the source file where the error has occurred"]
    pub line: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_Exception"][::std::mem::size_of::<cv_Exception>() - 152usize];
    ["Alignment of cv_Exception"][::std::mem::align_of::<cv_Exception>() - 8usize];
    ["Offset of field: cv_Exception::msg"][::std::mem::offset_of!(cv_Exception, msg) - 8usize];
    ["Offset of field: cv_Exception::code"][::std::mem::offset_of!(cv_Exception, code) - 40usize];
    ["Offset of field: cv_Exception::err"][::std::mem::offset_of!(cv_Exception, err) - 48usize];
    ["Offset of field: cv_Exception::func"][::std::mem::offset_of!(cv_Exception, func) - 80usize];
    ["Offset of field: cv_Exception::file"][::std::mem::offset_of!(cv_Exception, file) - 112usize];
    ["Offset of field: cv_Exception::line"][::std::mem::offset_of!(cv_Exception, line) - 144usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9Exception13formatMessageEv"]
    pub fn cv_Exception_formatMessage(this: *mut cv_Exception);
}
unsafe extern "C" {
    #[doc = "Default constructor"]
    #[link_name = "\u{1}_ZN2cv9ExceptionC1Ev"]
    pub fn cv_Exception_Exception(this: *mut cv_Exception);
}
unsafe extern "C" {
    #[doc = "Full constructor. Normally the constructor is not called explicitly.\nInstead, the macros CV_Error(), CV_Error_() and CV_Assert() are used."]
    #[link_name = "\u{1}_ZN2cv9ExceptionC1EiRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_S8_i"]
    pub fn cv_Exception_Exception1(
        this: *mut cv_Exception,
        _code: ::std::os::raw::c_int,
        _err: *const cv_String,
        _func: *const cv_String,
        _file: *const cv_String,
        _line: ::std::os::raw::c_int,
    );
}
impl cv_Exception {
    #[inline]
    pub unsafe fn formatMessage(&mut self) {
        cv_Exception_formatMessage(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_Exception_Exception(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        _code: ::std::os::raw::c_int,
        _err: *const cv_String,
        _func: *const cv_String,
        _file: *const cv_String,
        _line: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_Exception_Exception1(__bindgen_tmp.as_mut_ptr(), _code, _err, _func, _file, _line);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9ExceptionD1Ev"]
    pub fn cv_Exception_Exception_destructor(this: *mut cv_Exception);
}
unsafe extern "C" {
    #[doc = "\\return the error description and the context as a text string."]
    #[link_name = "\u{1}_ZNK2cv9Exception4whatEv"]
    pub fn cv_Exception_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Signals an error and raises the exception.\n\nBy default the function prints information about the error to stderr,\nthen it either stops if cv::setBreakOnError() had been called before or raises the exception.\nIt is possible to alternate error processing by using #redirectError().\n@param exc the exception raisen.\n@deprecated drop this version"]
    #[link_name = "\u{1}_ZN2cv5errorERKNS_9ExceptionE"]
    pub fn cv_error1(exc: *const cv_Exception) -> !;
}
#[doc = "!< each matrix row is sorted independently"]
pub const cv_SortFlags_SORT_EVERY_ROW: cv_SortFlags = 0;
#[doc = "!< each matrix column is sorted\n!< independently; this flag and the previous one are\n!< mutually exclusive."]
pub const cv_SortFlags_SORT_EVERY_COLUMN: cv_SortFlags = 1;
#[doc = "!< each matrix row is sorted in the ascending\n!< order."]
pub const cv_SortFlags_SORT_ASCENDING: cv_SortFlags = 0;
#[doc = "!< each matrix row is sorted in the\n!< descending order; this flag and the previous one are also\n!< mutually exclusive."]
pub const cv_SortFlags_SORT_DESCENDING: cv_SortFlags = 16;
pub type cv_SortFlags = ::std::os::raw::c_uint;
#[doc = " The output covariance matrix is calculated as:\n\\f[\\texttt{scale}   \\cdot  [  \\texttt{vects}  [0]-  \\texttt{mean}  , \\texttt{vects}  [1]-  \\texttt{mean}  ,...]^T  \\cdot  [ \\texttt{vects}  [0]- \\texttt{mean}  , \\texttt{vects}  [1]- \\texttt{mean}  ,...],\\f]\nThe covariance matrix will be nsamples x nsamples. Such an unusual covariance matrix is used\nfor fast PCA of a set of very large vectors (see, for example, the EigenFaces technique for\nface recognition). Eigenvalues of this \"scrambled\" matrix match the eigenvalues of the true\ncovariance matrix. The \"true\" eigenvectors can be easily calculated from the eigenvectors of\nthe \"scrambled\" covariance matrix."]
pub const cv_CovarFlags_COVAR_SCRAMBLED: cv_CovarFlags = 0;
#[doc = "The output covariance matrix is calculated as:\n\\f[\\texttt{scale}   \\cdot  [  \\texttt{vects}  [0]-  \\texttt{mean}  , \\texttt{vects}  [1]-  \\texttt{mean}  ,...]  \\cdot  [ \\texttt{vects}  [0]- \\texttt{mean}  , \\texttt{vects}  [1]- \\texttt{mean}  ,...]^T,\\f]\ncovar will be a square matrix of the same size as the total number of elements in each input\nvector. One and only one of #COVAR_SCRAMBLED and #COVAR_NORMAL must be specified."]
pub const cv_CovarFlags_COVAR_NORMAL: cv_CovarFlags = 1;
#[doc = " If the flag is specified, the function does not calculate mean from\nthe input vectors but, instead, uses the passed mean vector. This is useful if mean has been\npre-calculated or known in advance, or if the covariance matrix is calculated by parts. In\nthis case, mean is not a mean vector of the input sub-set of vectors but rather the mean\nvector of the whole set."]
pub const cv_CovarFlags_COVAR_USE_AVG: cv_CovarFlags = 2;
#[doc = " If the flag is specified, the covariance matrix is scaled. In the\n\"normal\" mode, scale is 1./nsamples . In the \"scrambled\" mode, scale is the reciprocal of the\ntotal number of elements in each input vector. By default (if the flag is not specified), the\ncovariance matrix is not scaled ( scale=1 )."]
pub const cv_CovarFlags_COVAR_SCALE: cv_CovarFlags = 4;
#[doc = " If the flag is\nspecified, all the input vectors are stored as rows of the samples matrix. mean should be a\nsingle-row vector in this case."]
pub const cv_CovarFlags_COVAR_ROWS: cv_CovarFlags = 8;
#[doc = " If the flag is\nspecified, all the input vectors are stored as columns of the samples matrix. mean should be a\nsingle-column vector in this case."]
pub const cv_CovarFlags_COVAR_COLS: cv_CovarFlags = 16;
#[doc = "! Covariation flags"]
pub type cv_CovarFlags = ::std::os::raw::c_uint;
#[doc = " Select random initial centers in each attempt."]
pub const cv_KmeansFlags_KMEANS_RANDOM_CENTERS: cv_KmeansFlags = 0;
#[doc = " Use kmeans++ center initialization by Arthur and Vassilvitskii [Arthur2007]."]
pub const cv_KmeansFlags_KMEANS_PP_CENTERS: cv_KmeansFlags = 2;
#[doc = " During the first (and possibly the only) attempt, use the\nuser-supplied labels instead of computing them from the initial centers. For the second and\nfurther attempts, use the random or semi-random centers. Use one of KMEANS_\\*_CENTERS flag\nto specify the exact method."]
pub const cv_KmeansFlags_KMEANS_USE_INITIAL_LABELS: cv_KmeansFlags = 1;
#[doc = "! k-Means flags"]
pub type cv_KmeansFlags = ::std::os::raw::c_uint;
#[doc = "!< the output is the sum of all rows/columns of the matrix."]
pub const cv_ReduceTypes_REDUCE_SUM: cv_ReduceTypes = 0;
#[doc = "!< the output is the mean vector of all rows/columns of the matrix."]
pub const cv_ReduceTypes_REDUCE_AVG: cv_ReduceTypes = 1;
#[doc = "!< the output is the maximum (column/row-wise) of all rows/columns of the matrix."]
pub const cv_ReduceTypes_REDUCE_MAX: cv_ReduceTypes = 2;
#[doc = "!< the output is the minimum (column/row-wise) of all rows/columns of the matrix."]
pub const cv_ReduceTypes_REDUCE_MIN: cv_ReduceTypes = 3;
pub type cv_ReduceTypes = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Swaps two matrices"]
    #[link_name = "\u{1}_ZN2cv4swapERNS_3MatES1_"]
    pub fn cv_swap(a: *mut cv_Mat, b: *mut cv_Mat);
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv4swapERNS_4UMatES1_"]
    pub fn cv_swap1(a: *mut cv_UMat, b: *mut cv_UMat);
}
unsafe extern "C" {
    #[doc = " @brief Computes the source location of an extrapolated pixel.\n\nThe function computes and returns the coordinate of a donor pixel corresponding to the specified\nextrapolated pixel when using the specified extrapolation border mode. For example, if you use\ncv::BORDER_WRAP mode in the horizontal direction, cv::BORDER_REFLECT_101 in the vertical direction and\nwant to compute value of the \"virtual\" pixel Point(-5, 100) in a floating-point image img , it\nlooks like:\n@code{.cpp}\nfloat val = img.at<float>(borderInterpolate(100, img.rows, cv::BORDER_REFLECT_101),\nborderInterpolate(-5, img.cols, cv::BORDER_WRAP));\n@endcode\nNormally, the function is not called directly. It is used inside filtering functions and also in\ncopyMakeBorder.\n@param p 0-based coordinate of the extrapolated pixel along one of the axes, likely \\<0 or \\>= len\n@param len Length of the array along the corresponding axis.\n@param borderType Border type, one of the #BorderTypes, except for #BORDER_TRANSPARENT and\n#BORDER_ISOLATED . When borderType==#BORDER_CONSTANT , the function always returns -1, regardless\nof p and len.\n\n@sa copyMakeBorder"]
    #[link_name = "\u{1}_ZN2cv17borderInterpolateEiii"]
    pub fn cv_borderInterpolate(
        p: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
        borderType: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Forms a border around an image.\n\nThe function copies the source image into the middle of the destination image. The areas to the\nleft, to the right, above and below the copied source image will be filled with extrapolated\npixels. This is not what filtering functions based on it do (they extrapolate pixels on-fly), but\nwhat other more complex functions, including your own, may do to simplify image boundary handling.\n\nThe function supports the mode when src is already in the middle of dst . In this case, the\nfunction does not copy src itself but simply constructs the border, for example:\n\n@code{.cpp}\n// let border be the same in all directions\nint border=2;\n// constructs a larger image to fit both the image and the border\nMat gray_buf(rgb.rows + border*2, rgb.cols + border*2, rgb.depth());\n// select the middle part of it w/o copying data\nMat gray(gray_canvas, Rect(border, border, rgb.cols, rgb.rows));\n// convert image from RGB to grayscale\ncvtColor(rgb, gray, COLOR_RGB2GRAY);\n// form a border in-place\ncopyMakeBorder(gray, gray_buf, border, border,\nborder, border, BORDER_REPLICATE);\n// now do some custom filtering ...\n...\n@endcode\n@note When the source image is a part (ROI) of a bigger image, the function will try to use the\npixels outside of the ROI to form a border. To disable this feature and always do extrapolation, as\nif src was not a ROI, use borderType | #BORDER_ISOLATED.\n\n@param src Source image.\n@param dst Destination image of the same type as src and the size Size(src.cols+left+right,\nsrc.rows+top+bottom) .\n@param top the top pixels\n@param bottom the bottom pixels\n@param left the left pixels\n@param right Parameter specifying how many pixels in each direction from the source image rectangle\nto extrapolate. For example, top=1, bottom=1, left=1, right=1 mean that 1 pixel-wide border needs\nto be built.\n@param borderType Border type. See borderInterpolate for details.\n@param value Border value if borderType==BORDER_CONSTANT .\n\n@sa  borderInterpolate"]
    #[link_name = "\u{1}_ZN2cv14copyMakeBorderERKNS_11_InputArrayERKNS_12_OutputArrayEiiiiiRKNS_7Scalar_IdEE"]
    pub fn cv_copyMakeBorder(
        src: cv_InputArray,
        dst: cv_OutputArray,
        top: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
        left: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
        borderType: ::std::os::raw::c_int,
        value: *const cv_Scalar,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the per-element sum of two arrays or an array and a scalar.\n\nThe function add calculates:\n- Sum of two arrays when both input arrays have the same size and the same number of channels:\n\\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1}(I) +  \\texttt{src2}(I)) \\quad \\texttt{if mask}(I) \\ne0\\f]\n- Sum of an array and a scalar when src2 is constructed from Scalar or has the same number of\nelements as `src1.channels()`:\n\\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1}(I) +  \\texttt{src2} ) \\quad \\texttt{if mask}(I) \\ne0\\f]\n- Sum of a scalar and an array when src1 is constructed from Scalar or has the same number of\nelements as `src2.channels()`:\n\\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1} +  \\texttt{src2}(I) ) \\quad \\texttt{if mask}(I) \\ne0\\f]\nwhere `I` is a multi-dimensional index of array elements. In case of multi-channel arrays, each\nchannel is processed independently.\n\nThe first function in the list above can be replaced with matrix expressions:\n@code{.cpp}\ndst = src1 + src2;\ndst += src1; // equivalent to add(dst, src1, dst);\n@endcode\nThe input arrays and the output array can all have the same or different depths. For example, you\ncan add a 16-bit unsigned array to a 8-bit signed array and store the sum as a 32-bit\nfloating-point array. Depth of the output array is determined by the dtype parameter. In the second\nand third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can\nbe set to the default -1. In this case, the output array will have the same depth as the input\narray, be it src1, src2 or both.\n@note Saturation is not applied when the output array has the depth CV_32S. You may even get\nresult of an incorrect sign in the case of overflow.\n@param src1 first input array or a scalar.\n@param src2 second input array or a scalar.\n@param dst output array that has the same size and number of channels as the input array(s); the\ndepth is defined by dtype or src1/src2.\n@param mask optional operation mask - 8-bit single channel array, that specifies elements of the\noutput array to be changed.\n@param dtype optional depth of the output array (see the discussion below).\n@sa subtract, addWeighted, scaleAdd, Mat::convertTo"]
    #[link_name = "\u{1}_ZN2cv3addERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_i"]
    pub fn cv_add(
        src1: cv_InputArray,
        src2: cv_InputArray,
        dst: cv_OutputArray,
        mask: cv_InputArray,
        dtype: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the per-element difference between two arrays or array and a scalar.\n\nThe function subtract calculates:\n- Difference between two arrays, when both input arrays have the same size and the same number of\nchannels:\n\\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1}(I) -  \\texttt{src2}(I)) \\quad \\texttt{if mask}(I) \\ne0\\f]\n- Difference between an array and a scalar, when src2 is constructed from Scalar or has the same\nnumber of elements as `src1.channels()`:\n\\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1}(I) -  \\texttt{src2} ) \\quad \\texttt{if mask}(I) \\ne0\\f]\n- Difference between a scalar and an array, when src1 is constructed from Scalar or has the same\nnumber of elements as `src2.channels()`:\n\\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src1} -  \\texttt{src2}(I) ) \\quad \\texttt{if mask}(I) \\ne0\\f]\n- The reverse difference between a scalar and an array in the case of `SubRS`:\n\\f[\\texttt{dst}(I) =  \\texttt{saturate} ( \\texttt{src2} -  \\texttt{src1}(I) ) \\quad \\texttt{if mask}(I) \\ne0\\f]\nwhere I is a multi-dimensional index of array elements. In case of multi-channel arrays, each\nchannel is processed independently.\n\nThe first function in the list above can be replaced with matrix expressions:\n@code{.cpp}\ndst = src1 - src2;\ndst -= src1; // equivalent to subtract(dst, src1, dst);\n@endcode\nThe input arrays and the output array can all have the same or different depths. For example, you\ncan subtract to 8-bit unsigned arrays and store the difference in a 16-bit signed array. Depth of\nthe output array is determined by dtype parameter. In the second and third cases above, as well as\nin the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this\ncase the output array will have the same depth as the input array, be it src1, src2 or both.\n@note Saturation is not applied when the output array has the depth CV_32S. You may even get\nresult of an incorrect sign in the case of overflow.\n@param src1 first input array or a scalar.\n@param src2 second input array or a scalar.\n@param dst output array of the same size and the same number of channels as the input array.\n@param mask optional operation mask; this is an 8-bit single channel array that specifies elements\nof the output array to be changed.\n@param dtype optional depth of the output array\n@sa  add, addWeighted, scaleAdd, Mat::convertTo"]
    #[link_name = "\u{1}_ZN2cv8subtractERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_i"]
    pub fn cv_subtract(
        src1: cv_InputArray,
        src2: cv_InputArray,
        dst: cv_OutputArray,
        mask: cv_InputArray,
        dtype: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the per-element scaled product of two arrays.\n\nThe function multiply calculates the per-element product of two arrays:\n\n\\f[\\texttt{dst} (I)= \\texttt{saturate} ( \\texttt{scale} \\cdot \\texttt{src1} (I)  \\cdot \\texttt{src2} (I))\\f]\n\nThere is also a @ref MatrixExpressions -friendly variant of the first function. See Mat::mul .\n\nFor a not-per-element matrix product, see gemm .\n\n@note Saturation is not applied when the output array has the depth\nCV_32S. You may even get result of an incorrect sign in the case of\noverflow.\n@param src1 first input array.\n@param src2 second input array of the same size and the same type as src1.\n@param dst output array of the same size and type as src1.\n@param scale optional scale factor.\n@param dtype optional depth of the output array\n@sa add, subtract, divide, scaleAdd, addWeighted, accumulate, accumulateProduct, accumulateSquare,\nMat::convertTo"]
    #[link_name = "\u{1}_ZN2cv8multiplyERKNS_11_InputArrayES2_RKNS_12_OutputArrayEdi"]
    pub fn cv_multiply(
        src1: cv_InputArray,
        src2: cv_InputArray,
        dst: cv_OutputArray,
        scale: f64,
        dtype: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Performs per-element division of two arrays or a scalar by an array.\n\nThe function cv::divide divides one array by another:\n\\f[\\texttt{dst(I) = saturate(src1(I)*scale/src2(I))}\\f]\nor a scalar by an array when there is no src1 :\n\\f[\\texttt{dst(I) = saturate(scale/src2(I))}\\f]\n\nDifferent channels of multi-channel arrays are processed independently.\n\nFor integer types when src2(I) is zero, dst(I) will also be zero.\n\n@note In case of floating point data there is no special defined behavior for zero src2(I) values.\nRegular floating-point division is used.\nExpect correct IEEE-754 behaviour for floating-point data (with NaN, Inf result values).\n\n@note Saturation is not applied when the output array has the depth CV_32S. You may even get\nresult of an incorrect sign in the case of overflow.\n@param src1 first input array.\n@param src2 second input array of the same size and type as src1.\n@param scale scalar factor.\n@param dst output array of the same size and type as src2.\n@param dtype optional depth of the output array; if -1, dst will have depth src2.depth(), but in\ncase of an array-by-array division, you can only pass -1 when src1.depth()==src2.depth().\n@sa  multiply, add, subtract"]
    #[link_name = "\u{1}_ZN2cv6divideERKNS_11_InputArrayES2_RKNS_12_OutputArrayEdi"]
    pub fn cv_divide(
        src1: cv_InputArray,
        src2: cv_InputArray,
        dst: cv_OutputArray,
        scale: f64,
        dtype: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv6divideEdRKNS_11_InputArrayERKNS_12_OutputArrayEi"]
    pub fn cv_divide1(
        scale: f64,
        src2: cv_InputArray,
        dst: cv_OutputArray,
        dtype: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the sum of a scaled array and another array.\n\nThe function scaleAdd is one of the classical primitive linear algebra operations, known as DAXPY\nor SAXPY in [BLAS](http://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms). It calculates\nthe sum of a scaled array and another array:\n\\f[\\texttt{dst} (I)= \\texttt{scale} \\cdot \\texttt{src1} (I) +  \\texttt{src2} (I)\\f]\nThe function can also be emulated with a matrix expression, for example:\n@code{.cpp}\nMat A(3, 3, CV_64F);\n...\nA.row(0) = A.row(1)*2 + A.row(2);\n@endcode\n@param src1 first input array.\n@param alpha scale factor for the first array.\n@param src2 second input array of the same size and type as src1.\n@param dst output array of the same size and type as src1.\n@sa add, addWeighted, subtract, Mat::dot, Mat::convertTo"]
    #[link_name = "\u{1}_ZN2cv8scaleAddERKNS_11_InputArrayEdS2_RKNS_12_OutputArrayE"]
    pub fn cv_scaleAdd(src1: cv_InputArray, alpha: f64, src2: cv_InputArray, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief Calculates the weighted sum of two arrays.\n\nThe function addWeighted calculates the weighted sum of two arrays as follows:\n\\f[\\texttt{dst} (I)= \\texttt{saturate} ( \\texttt{src1} (I)* \\texttt{alpha} +  \\texttt{src2} (I)* \\texttt{beta} +  \\texttt{gamma} )\\f]\nwhere I is a multi-dimensional index of array elements. In case of multi-channel arrays, each\nchannel is processed independently.\nThe function can be replaced with a matrix expression:\n@code{.cpp}\ndst = src1*alpha + src2*beta + gamma;\n@endcode\n@note Saturation is not applied when the output array has the depth CV_32S. You may even get\nresult of an incorrect sign in the case of overflow.\n@param src1 first input array.\n@param alpha weight of the first array elements.\n@param src2 second input array of the same size and channel number as src1.\n@param beta weight of the second array elements.\n@param gamma scalar added to each sum.\n@param dst output array that has the same size and number of channels as the input arrays.\n@param dtype optional depth of the output array; when both input arrays have the same depth, dtype\ncan be set to -1, which will be equivalent to src1.depth().\n@sa  add, subtract, scaleAdd, Mat::convertTo"]
    #[link_name = "\u{1}_ZN2cv11addWeightedERKNS_11_InputArrayEdS2_ddRKNS_12_OutputArrayEi"]
    pub fn cv_addWeighted(
        src1: cv_InputArray,
        alpha: f64,
        src2: cv_InputArray,
        beta: f64,
        gamma: f64,
        dst: cv_OutputArray,
        dtype: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Scales, calculates absolute values, and converts the result to 8-bit.\n\nOn each element of the input array, the function convertScaleAbs\nperforms three operations sequentially: scaling, taking an absolute\nvalue, conversion to an unsigned 8-bit type:\n\\f[\\texttt{dst} (I)= \\texttt{saturate\\_cast<uchar>} (| \\texttt{src} (I)* \\texttt{alpha} +  \\texttt{beta} |)\\f]\nIn case of multi-channel arrays, the function processes each channel\nindependently. When the output is not 8-bit, the operation can be\nemulated by calling the Mat::convertTo method (or by using matrix\nexpressions) and then by calculating an absolute value of the result.\nFor example:\n@code{.cpp}\nMat_<float> A(30,30);\nrandu(A, Scalar(-100), Scalar(100));\nMat_<float> B = A*5 + 3;\nB = abs(B);\n// Mat_<float> B = abs(A*5+3) will also do the job,\n// but it will allocate a temporary matrix\n@endcode\n@param src input array.\n@param dst output array.\n@param alpha optional scale factor.\n@param beta optional delta added to the scaled values.\n@sa  Mat::convertTo, cv::abs(const Mat&)"]
    #[link_name = "\u{1}_ZN2cv15convertScaleAbsERKNS_11_InputArrayERKNS_12_OutputArrayEdd"]
    pub fn cv_convertScaleAbs(src: cv_InputArray, dst: cv_OutputArray, alpha: f64, beta: f64);
}
unsafe extern "C" {
    #[doc = " @brief Converts an array to half precision floating number.\n\nThis function converts FP32 (single precision floating point) from/to FP16 (half precision floating point). CV_16S format is used to represent FP16 data.\nThere are two use modes (src -> dst): CV_32F -> CV_16S and CV_16S -> CV_32F. The input array has to have type of CV_32F or\nCV_16S to represent the bit depth. If the input array is neither of them, the function will raise an error.\nThe format of half precision floating point is defined in IEEE 754-2008.\n\n@param src input array.\n@param dst output array."]
    #[link_name = "\u{1}_ZN2cv11convertFp16ERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_convertFp16(src: cv_InputArray, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief Performs a look-up table transform of an array.\n\nThe function LUT fills the output array with values from the look-up table. Indices of the entries\nare taken from the input array. That is, the function processes each element of src as follows:\n\\f[\\texttt{dst} (I)  \\leftarrow \\texttt{lut(src(I) + d)}\\f]\nwhere\n\\f[d =  \\fork{0}{if \\(\\texttt{src}\\) has depth \\(\\texttt{CV_8U}\\)}{128}{if \\(\\texttt{src}\\) has depth \\(\\texttt{CV_8S}\\)}\\f]\n@param src input array of 8-bit elements.\n@param lut look-up table of 256 elements; in case of multi-channel input array, the table should\neither have a single channel (in this case the same table is used for all channels) or the same\nnumber of channels as in the input array.\n@param dst output array of the same size and number of channels as src, and the same depth as lut.\n@sa  convertScaleAbs, Mat::convertTo"]
    #[link_name = "\u{1}_ZN2cv3LUTERKNS_11_InputArrayES2_RKNS_12_OutputArrayE"]
    pub fn cv_LUT(src: cv_InputArray, lut: cv_InputArray, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief Calculates the sum of array elements.\n\nThe function cv::sum calculates and returns the sum of array elements,\nindependently for each channel.\n@param src input array that must have from 1 to 4 channels.\n@sa  countNonZero, mean, meanStdDev, norm, minMaxLoc, reduce"]
    #[link_name = "\u{1}_ZN2cv3sumERKNS_11_InputArrayE"]
    pub fn cv_sum(src: cv_InputArray) -> cv_Scalar;
}
unsafe extern "C" {
    #[doc = " @brief Counts non-zero array elements.\n\nThe function returns the number of non-zero elements in src :\n\\f[\\sum _{I: \\; \\texttt{src} (I) \\ne0 } 1\\f]\n@param src single-channel array.\n@sa  mean, meanStdDev, norm, minMaxLoc, calcCovarMatrix"]
    #[link_name = "\u{1}_ZN2cv12countNonZeroERKNS_11_InputArrayE"]
    pub fn cv_countNonZero(src: cv_InputArray) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Returns the list of locations of non-zero pixels\n\nGiven a binary matrix (likely returned from an operation such\nas threshold(), compare(), >, ==, etc, return all of\nthe non-zero indices as a cv::Mat or std::vector<cv::Point> (x,y)\nFor example:\n@code{.cpp}\ncv::Mat binaryImage; // input, binary image\ncv::Mat locations;   // output, locations of non-zero pixels\ncv::findNonZero(binaryImage, locations);\n\n// access pixel coordinates\nPoint pnt = locations.at<Point>(i);\n@endcode\nor\n@code{.cpp}\ncv::Mat binaryImage; // input, binary image\nvector<Point> locations;   // output, locations of non-zero pixels\ncv::findNonZero(binaryImage, locations);\n\n// access pixel coordinates\nPoint pnt = locations[i];\n@endcode\n@param src single-channel array\n@param idx the output array, type of cv::Mat or std::vector<Point>, corresponding to non-zero indices in the input"]
    #[link_name = "\u{1}_ZN2cv11findNonZeroERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_findNonZero(src: cv_InputArray, idx: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief Calculates an average (mean) of array elements.\n\nThe function cv::mean calculates the mean value M of array elements,\nindependently for each channel, and return it:\n\\f[\\begin{array}{l} N =  \\sum _{I: \\; \\texttt{mask} (I) \\ne 0} 1 \\\\ M_c =  \\left ( \\sum _{I: \\; \\texttt{mask} (I) \\ne 0}{ \\texttt{mtx} (I)_c} \\right )/N \\end{array}\\f]\nWhen all the mask elements are 0's, the function returns Scalar::all(0)\n@param src input array that should have from 1 to 4 channels so that the result can be stored in\nScalar_ .\n@param mask optional operation mask.\n@sa  countNonZero, meanStdDev, norm, minMaxLoc"]
    #[link_name = "\u{1}_ZN2cv4meanERKNS_11_InputArrayES2_"]
    pub fn cv_mean(src: cv_InputArray, mask: cv_InputArray) -> cv_Scalar;
}
unsafe extern "C" {
    #[doc = " Calculates a mean and standard deviation of array elements.\n\nThe function cv::meanStdDev calculates the mean and the standard deviation M\nof array elements independently for each channel and returns it via the\noutput parameters:\n\\f[\\begin{array}{l} N =  \\sum _{I, \\texttt{mask} (I)  \\ne 0} 1 \\\\ \\texttt{mean} _c =  \\frac{\\sum_{ I: \\; \\texttt{mask}(I) \\ne 0} \\texttt{src} (I)_c}{N} \\\\ \\texttt{stddev} _c =  \\sqrt{\\frac{\\sum_{ I: \\; \\texttt{mask}(I) \\ne 0} \\left ( \\texttt{src} (I)_c -  \\texttt{mean} _c \\right )^2}{N}} \\end{array}\\f]\nWhen all the mask elements are 0's, the function returns\nmean=stddev=Scalar::all(0).\n@note The calculated standard deviation is only the diagonal of the\ncomplete normalized covariance matrix. If the full matrix is needed, you\ncan reshape the multi-channel array M x N to the single-channel array\nM\\*N x mtx.channels() (only possible when the matrix is continuous) and\nthen pass the matrix to calcCovarMatrix .\n@param src input array that should have from 1 to 4 channels so that the results can be stored in\nScalar_ 's.\n@param mean output parameter: calculated mean value.\n@param stddev output parameter: calculated standard deviation.\n@param mask optional operation mask.\n@sa  countNonZero, mean, norm, minMaxLoc, calcCovarMatrix"]
    #[link_name = "\u{1}_ZN2cv10meanStdDevERKNS_11_InputArrayERKNS_12_OutputArrayES5_S2_"]
    pub fn cv_meanStdDev(
        src: cv_InputArray,
        mean: cv_OutputArray,
        stddev: cv_OutputArray,
        mask: cv_InputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the  absolute norm of an array.\n\nThis version of #norm calculates the absolute norm of src1. The type of norm to calculate is specified using #NormTypes.\n\nAs example for one array consider the function \\f$r(x)= \\begin{pmatrix} x \\\\ 1-x \\end{pmatrix}, x \\in [-1;1]\\f$.\nThe \\f$ L_{1}, L_{2} \\f$ and \\f$ L_{\\infty} \\f$ norm for the sample value \\f$r(-1) = \\begin{pmatrix} -1 \\\\ 2 \\end{pmatrix}\\f$\nis calculated as follows\n\\f{align*}\n\\| r(-1) \\|_{L_1} &= |-1| + |2| = 3 \\\\\n\\| r(-1) \\|_{L_2} &= \\sqrt{(-1)^{2} + (2)^{2}} = \\sqrt{5} \\\\\n\\| r(-1) \\|_{L_\\infty} &= \\max(|-1|,|2|) = 2\n\\f}\nand for \\f$r(0.5) = \\begin{pmatrix} 0.5 \\\\ 0.5 \\end{pmatrix}\\f$ the calculation is\n\\f{align*}\n\\| r(0.5) \\|_{L_1} &= |0.5| + |0.5| = 1 \\\\\n\\| r(0.5) \\|_{L_2} &= \\sqrt{(0.5)^{2} + (0.5)^{2}} = \\sqrt{0.5} \\\\\n\\| r(0.5) \\|_{L_\\infty} &= \\max(|0.5|,|0.5|) = 0.5.\n\\f}\nThe following graphic shows all values for the three norm functions \\f$\\| r(x) \\|_{L_1}, \\| r(x) \\|_{L_2}\\f$ and \\f$\\| r(x) \\|_{L_\\infty}\\f$.\nIt is notable that the \\f$ L_{1} \\f$ norm forms the upper and the \\f$ L_{\\infty} \\f$ norm forms the lower border for the example function \\f$ r(x) \\f$.\n[Graphs for the different norm functions from the above example](pics/NormTypes_OneArray_1-2-INF.png)\n\nWhen the mask parameter is specified and it is not empty, the norm is\n\nIf normType is not specified, #NORM_L2 is used.\ncalculated only over the region specified by the mask.\n\nMulti-channel input arrays are treated as single-channel arrays, that is,\nthe results for all channels are combined.\n\nHamming norms can only be calculated with CV_8U depth arrays.\n\n@param src1 first input array.\n@param normType type of the norm (see #NormTypes).\n@param mask optional operation mask; it must have the same size as src1 and CV_8UC1 type."]
    #[link_name = "\u{1}_ZN2cv4normERKNS_11_InputArrayEiS2_"]
    pub fn cv_norm(
        src1: cv_InputArray,
        normType: ::std::os::raw::c_int,
        mask: cv_InputArray,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Calculates an absolute difference norm or a relative difference norm.\n\nThis version of cv::norm calculates the absolute difference norm\nor the relative difference norm of arrays src1 and src2.\nThe type of norm to calculate is specified using #NormTypes.\n\n@param src1 first input array.\n@param src2 second input array of the same size and the same type as src1.\n@param normType type of the norm (see #NormTypes).\n@param mask optional operation mask; it must have the same size as src1 and CV_8UC1 type."]
    #[link_name = "\u{1}_ZN2cv4normERKNS_11_InputArrayES2_iS2_"]
    pub fn cv_norm1(
        src1: cv_InputArray,
        src2: cv_InputArray,
        normType: ::std::os::raw::c_int,
        mask: cv_InputArray,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " @overload\n@param src first input array.\n@param normType type of the norm (see #NormTypes)."]
    #[link_name = "\u{1}_ZN2cv4normERKNS_9SparseMatEi"]
    pub fn cv_norm2(src: *const cv_SparseMat, normType: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Computes the Peak Signal-to-Noise Ratio (PSNR) image quality metric.\n\nThis function calculates the Peak Signal-to-Noise Ratio (PSNR) image quality metric in decibels (dB),\nbetween two input arrays src1 and src2. The arrays must have the same type.\n\nThe PSNR is calculated as follows:\n\n\\f[\n\\texttt{PSNR} = 10 \\cdot \\log_{10}{\\left( \\frac{R^2}{MSE} \\right) }\n\\f]\n\nwhere R is the maximum integer value of depth (e.g. 255 in the case of CV_8U data)\nand MSE is the mean squared error between the two arrays.\n\n@param src1 first input array.\n@param src2 second input array of the same size as src1.\n@param R the maximum pixel value (255 by default)\n"]
    #[link_name = "\u{1}_ZN2cv4PSNRERKNS_11_InputArrayES2_d"]
    pub fn cv_PSNR(src1: cv_InputArray, src2: cv_InputArray, R: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief naive nearest neighbor finder\n\nsee http://en.wikipedia.org/wiki/Nearest_neighbor_search\n@todo document"]
    #[link_name = "\u{1}_ZN2cv13batchDistanceERKNS_11_InputArrayES2_RKNS_12_OutputArrayEiS5_iiS2_ib"]
    pub fn cv_batchDistance(
        src1: cv_InputArray,
        src2: cv_InputArray,
        dist: cv_OutputArray,
        dtype: ::std::os::raw::c_int,
        nidx: cv_OutputArray,
        normType: ::std::os::raw::c_int,
        K: ::std::os::raw::c_int,
        mask: cv_InputArray,
        update: ::std::os::raw::c_int,
        crosscheck: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief Normalizes the norm or value range of an array.\n\nThe function cv::normalize normalizes scale and shift the input array elements so that\n\\f[\\| \\texttt{dst} \\| _{L_p}= \\texttt{alpha}\\f]\n(where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that\n\\f[\\min _I  \\texttt{dst} (I)= \\texttt{alpha} , \\, \\, \\max _I  \\texttt{dst} (I)= \\texttt{beta}\\f]\n\nwhen normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be\nnormalized. This means that the norm or min-n-max are calculated over the sub-array, and then this\nsub-array is modified to be normalized. If you want to only use the mask to calculate the norm or\nmin-max but modify the whole array, you can use norm and Mat::convertTo.\n\nIn case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this,\nthe range transformation for sparse matrices is not allowed since it can shift the zero level.\n\nPossible usage with some positive example data:\n@code{.cpp}\nvector<double> positiveData = { 2.0, 8.0, 10.0 };\nvector<double> normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;\n\n// Norm to probability (total count)\n// sum(numbers) = 20.0\n// 2.0      0.1     (2.0/20.0)\n// 8.0      0.4     (8.0/20.0)\n// 10.0     0.5     (10.0/20.0)\nnormalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1);\n\n// Norm to unit vector: ||positiveData|| = 1.0\n// 2.0      0.15\n// 8.0      0.62\n// 10.0     0.77\nnormalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2);\n\n// Norm to max element\n// 2.0      0.2     (2.0/10.0)\n// 8.0      0.8     (8.0/10.0)\n// 10.0     1.0     (10.0/10.0)\nnormalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF);\n\n// Norm to range [0.0;1.0]\n// 2.0      0.0     (shift to left border)\n// 8.0      0.75    (6.0/8.0)\n// 10.0     1.0     (shift to right border)\nnormalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX);\n@endcode\n\n@param src input array.\n@param dst output array of the same size as src .\n@param alpha norm value to normalize to or the lower range boundary in case of the range\nnormalization.\n@param beta upper range boundary in case of the range normalization; it is not used for the norm\nnormalization.\n@param norm_type normalization type (see cv::NormTypes).\n@param dtype when negative, the output array has the same type as src; otherwise, it has the same\nnumber of channels as src and the depth =CV_MAT_DEPTH(dtype).\n@param mask optional operation mask.\n@sa norm, Mat::convertTo, SparseMat::convertTo"]
    #[link_name = "\u{1}_ZN2cv9normalizeERKNS_11_InputArrayERKNS_17_InputOutputArrayEddiiS2_"]
    pub fn cv_normalize(
        src: cv_InputArray,
        dst: cv_InputOutputArray,
        alpha: f64,
        beta: f64,
        norm_type: ::std::os::raw::c_int,
        dtype: ::std::os::raw::c_int,
        mask: cv_InputArray,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param src input array.\n@param dst output array of the same size as src .\n@param alpha norm value to normalize to or the lower range boundary in case of the range\nnormalization.\n@param normType normalization type (see cv::NormTypes)."]
    #[link_name = "\u{1}_ZN2cv9normalizeERKNS_9SparseMatERS0_di"]
    pub fn cv_normalize1(
        src: *const cv_SparseMat,
        dst: *mut cv_SparseMat,
        alpha: f64,
        normType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Finds the global minimum and maximum in an array.\n\nThe function cv::minMaxLoc finds the minimum and maximum element values and their positions. The\nextremums are searched across the whole array or, if mask is not an empty array, in the specified\narray region.\n\nThe function do not work with multi-channel arrays. If you need to find minimum or maximum\nelements across all the channels, use Mat::reshape first to reinterpret the array as\nsingle-channel. Or you may extract the particular channel using either extractImageCOI , or\nmixChannels , or split .\n@param src input single-channel array.\n@param minVal pointer to the returned minimum value; NULL is used if not required.\n@param maxVal pointer to the returned maximum value; NULL is used if not required.\n@param minLoc pointer to the returned minimum location (in 2D case); NULL is used if not required.\n@param maxLoc pointer to the returned maximum location (in 2D case); NULL is used if not required.\n@param mask optional mask used to select a sub-array.\n@sa max, min, compare, inRange, extractImageCOI, mixChannels, split, Mat::reshape"]
    #[link_name = "\u{1}_ZN2cv9minMaxLocERKNS_11_InputArrayEPdS3_PNS_6Point_IiEES6_S2_"]
    pub fn cv_minMaxLoc(
        src: cv_InputArray,
        minVal: *mut f64,
        maxVal: *mut f64,
        minLoc: *mut cv_Point,
        maxLoc: *mut cv_Point,
        mask: cv_InputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Finds the global minimum and maximum in an array\n\nThe function cv::minMaxIdx finds the minimum and maximum element values and their positions. The\nextremums are searched across the whole array or, if mask is not an empty array, in the specified\narray region. The function does not work with multi-channel arrays. If you need to find minimum or\nmaximum elements across all the channels, use Mat::reshape first to reinterpret the array as\nsingle-channel. Or you may extract the particular channel using either extractImageCOI , or\nmixChannels , or split . In case of a sparse matrix, the minimum is found among non-zero elements\nonly.\n@note When minIdx is not NULL, it must have at least 2 elements (as well as maxIdx), even if src is\na single-row or single-column matrix. In OpenCV (following MATLAB) each array has at least 2\ndimensions, i.e. single-column matrix is Mx1 matrix (and therefore minIdx/maxIdx will be\n(i1,0)/(i2,0)) and single-row matrix is 1xN matrix (and therefore minIdx/maxIdx will be\n(0,j1)/(0,j2)).\n@param src input single-channel array.\n@param minVal pointer to the returned minimum value; NULL is used if not required.\n@param maxVal pointer to the returned maximum value; NULL is used if not required.\n@param minIdx pointer to the returned minimum location (in nD case); NULL is used if not required;\nOtherwise, it must point to an array of src.dims elements, the coordinates of the minimum element\nin each dimension are stored there sequentially.\n@param maxIdx pointer to the returned maximum location (in nD case). NULL is used if not required.\n@param mask specified array region"]
    #[link_name = "\u{1}_ZN2cv9minMaxIdxERKNS_11_InputArrayEPdS3_PiS4_S2_"]
    pub fn cv_minMaxIdx(
        src: cv_InputArray,
        minVal: *mut f64,
        maxVal: *mut f64,
        minIdx: *mut ::std::os::raw::c_int,
        maxIdx: *mut ::std::os::raw::c_int,
        mask: cv_InputArray,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param a input single-channel array.\n@param minVal pointer to the returned minimum value; NULL is used if not required.\n@param maxVal pointer to the returned maximum value; NULL is used if not required.\n@param minIdx pointer to the returned minimum location (in nD case); NULL is used if not required;\nOtherwise, it must point to an array of src.dims elements, the coordinates of the minimum element\nin each dimension are stored there sequentially.\n@param maxIdx pointer to the returned maximum location (in nD case). NULL is used if not required."]
    #[link_name = "\u{1}_ZN2cv9minMaxLocERKNS_9SparseMatEPdS3_PiS4_"]
    pub fn cv_minMaxLoc1(
        a: *const cv_SparseMat,
        minVal: *mut f64,
        maxVal: *mut f64,
        minIdx: *mut ::std::os::raw::c_int,
        maxIdx: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Reduces a matrix to a vector.\n\nThe function #reduce reduces the matrix to a vector by treating the matrix rows/columns as a set of\n1D vectors and performing the specified operation on the vectors until a single row/column is\nobtained. For example, the function can be used to compute horizontal and vertical projections of a\nraster image. In case of #REDUCE_MAX and #REDUCE_MIN , the output image should have the same type as the source one.\nIn case of #REDUCE_SUM and #REDUCE_AVG , the output may have a larger element bit-depth to preserve accuracy.\nAnd multi-channel arrays are also supported in these two reduction modes.\n\nThe following code demonstrates its usage for a single channel matrix.\n@snippet snippets/core_reduce.cpp example\n\nAnd the following code demonstrates its usage for a two-channel matrix.\n@snippet snippets/core_reduce.cpp example2\n\n@param src input 2D matrix.\n@param dst output vector. Its size and type is defined by dim and dtype parameters.\n@param dim dimension index along which the matrix is reduced. 0 means that the matrix is reduced to\na single row. 1 means that the matrix is reduced to a single column.\n@param rtype reduction operation that could be one of #ReduceTypes\n@param dtype when negative, the output vector will have the same type as the input matrix,\notherwise, its type will be CV_MAKE_TYPE(CV_MAT_DEPTH(dtype), src.channels()).\n@sa repeat"]
    #[link_name = "\u{1}_ZN2cv6reduceERKNS_11_InputArrayERKNS_12_OutputArrayEiii"]
    pub fn cv_reduce(
        src: cv_InputArray,
        dst: cv_OutputArray,
        dim: ::std::os::raw::c_int,
        rtype: ::std::os::raw::c_int,
        dtype: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Creates one multi-channel array out of several single-channel ones.\n\nThe function cv::merge merges several arrays to make a single multi-channel array. That is, each\nelement of the output array will be a concatenation of the elements of the input arrays, where\nelements of i-th input array are treated as mv[i].channels()-element vectors.\n\nThe function cv::split does the reverse operation. If you need to shuffle channels in some other\nadvanced way, use cv::mixChannels.\n\nThe following example shows how to merge 3 single channel matrices into a single 3-channel matrix.\n@snippet snippets/core_merge.cpp example\n\n@param mv input array of matrices to be merged; all the matrices in mv must have the same\nsize and the same depth.\n@param count number of input matrices when mv is a plain C array; it must be greater than zero.\n@param dst output array of the same size and the same depth as mv[0]; The number of channels will\nbe equal to the parameter count.\n@sa  mixChannels, split, Mat::reshape"]
    #[link_name = "\u{1}_ZN2cv5mergeEPKNS_3MatEmRKNS_12_OutputArrayE"]
    pub fn cv_merge(mv: *const cv_Mat, count: usize, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @overload\n@param mv input vector of matrices to be merged; all the matrices in mv must have the same\nsize and the same depth.\n@param dst output array of the same size and the same depth as mv[0]; The number of channels will\nbe the total number of channels in the matrix array."]
    #[link_name = "\u{1}_ZN2cv5mergeERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_merge1(mv: cv_InputArrayOfArrays, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief Divides a multi-channel array into several single-channel arrays.\n\nThe function cv::split splits a multi-channel array into separate single-channel arrays:\n\\f[\\texttt{mv} [c](I) =  \\texttt{src} (I)_c\\f]\nIf you need to extract a single channel or do some other sophisticated channel permutation, use\nmixChannels .\n\nThe following example demonstrates how to split a 3-channel matrix into 3 single channel matrices.\n@snippet snippets/core_split.cpp example\n\n@param src input multi-channel array.\n@param mvbegin output array; the number of arrays must match src.channels(); the arrays themselves are\nreallocated, if needed.\n@sa merge, mixChannels, cvtColor"]
    #[link_name = "\u{1}_ZN2cv5splitERKNS_3MatEPS0_"]
    pub fn cv_split(src: *const cv_Mat, mvbegin: *mut cv_Mat);
}
unsafe extern "C" {
    #[doc = " @overload\n@param m input multi-channel array.\n@param mv output vector of arrays; the arrays themselves are reallocated, if needed."]
    #[link_name = "\u{1}_ZN2cv5splitERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_split1(m: cv_InputArray, mv: cv_OutputArrayOfArrays);
}
unsafe extern "C" {
    #[doc = " @brief Copies specified channels from input arrays to the specified channels of\noutput arrays.\n\nThe function cv::mixChannels provides an advanced mechanism for shuffling image channels.\n\ncv::split,cv::merge,cv::extractChannel,cv::insertChannel and some forms of cv::cvtColor are partial cases of cv::mixChannels.\n\nIn the example below, the code splits a 4-channel BGRA image into a 3-channel BGR (with B and R\nchannels swapped) and a separate alpha-channel image:\n@code{.cpp}\nMat bgra( 100, 100, CV_8UC4, Scalar(255,0,0,255) );\nMat bgr( bgra.rows, bgra.cols, CV_8UC3 );\nMat alpha( bgra.rows, bgra.cols, CV_8UC1 );\n\n// forming an array of matrices is a quite efficient operation,\n// because the matrix data is not copied, only the headers\nMat out[] = { bgr, alpha };\n// bgra[0] -> bgr[2], bgra[1] -> bgr[1],\n// bgra[2] -> bgr[0], bgra[3] -> alpha[0]\nint from_to[] = { 0,2, 1,1, 2,0, 3,3 };\nmixChannels( &bgra, 1, out, 2, from_to, 4 );\n@endcode\n@note Unlike many other new-style C++ functions in OpenCV (see the introduction section and\nMat::create ), cv::mixChannels requires the output arrays to be pre-allocated before calling the\nfunction.\n@param src input array or vector of matrices; all of the matrices must have the same size and the\nsame depth.\n@param nsrcs number of matrices in `src`.\n@param dst output array or vector of matrices; all the matrices **must be allocated**; their size and\ndepth must be the same as in `src[0]`.\n@param ndsts number of matrices in `dst`.\n@param fromTo array of index pairs specifying which channels are copied and where; fromTo[k\\*2] is\na 0-based index of the input channel in src, fromTo[k\\*2+1] is an index of the output channel in\ndst; the continuous channel numbering is used: the first input image channels are indexed from 0 to\nsrc[0].channels()-1, the second input image channels are indexed from src[0].channels() to\nsrc[0].channels() + src[1].channels()-1, and so on, the same scheme is used for the output image\nchannels; as a special case, when fromTo[k\\*2] is negative, the corresponding output channel is\nfilled with zero .\n@param npairs number of index pairs in `fromTo`.\n@sa split, merge, extractChannel, insertChannel, cvtColor"]
    #[link_name = "\u{1}_ZN2cv11mixChannelsEPKNS_3MatEmPS0_mPKim"]
    pub fn cv_mixChannels(
        src: *const cv_Mat,
        nsrcs: usize,
        dst: *mut cv_Mat,
        ndsts: usize,
        fromTo: *const ::std::os::raw::c_int,
        npairs: usize,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param src input array or vector of matrices; all of the matrices must have the same size and the\nsame depth.\n@param dst output array or vector of matrices; all the matrices **must be allocated**; their size and\ndepth must be the same as in src[0].\n@param fromTo array of index pairs specifying which channels are copied and where; fromTo[k\\*2] is\na 0-based index of the input channel in src, fromTo[k\\*2+1] is an index of the output channel in\ndst; the continuous channel numbering is used: the first input image channels are indexed from 0 to\nsrc[0].channels()-1, the second input image channels are indexed from src[0].channels() to\nsrc[0].channels() + src[1].channels()-1, and so on, the same scheme is used for the output image\nchannels; as a special case, when fromTo[k\\*2] is negative, the corresponding output channel is\nfilled with zero .\n@param npairs number of index pairs in fromTo."]
    #[link_name = "\u{1}_ZN2cv11mixChannelsERKNS_11_InputArrayERKNS_17_InputOutputArrayEPKim"]
    pub fn cv_mixChannels1(
        src: cv_InputArrayOfArrays,
        dst: cv_InputOutputArrayOfArrays,
        fromTo: *const ::std::os::raw::c_int,
        npairs: usize,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param src input array or vector of matrices; all of the matrices must have the same size and the\nsame depth.\n@param dst output array or vector of matrices; all the matrices **must be allocated**; their size and\ndepth must be the same as in src[0].\n@param fromTo array of index pairs specifying which channels are copied and where; fromTo[k\\*2] is\na 0-based index of the input channel in src, fromTo[k\\*2+1] is an index of the output channel in\ndst; the continuous channel numbering is used: the first input image channels are indexed from 0 to\nsrc[0].channels()-1, the second input image channels are indexed from src[0].channels() to\nsrc[0].channels() + src[1].channels()-1, and so on, the same scheme is used for the output image\nchannels; as a special case, when fromTo[k\\*2] is negative, the corresponding output channel is\nfilled with zero ."]
    #[link_name = "\u{1}_ZN2cv11mixChannelsERKNS_11_InputArrayERKNS_17_InputOutputArrayERKSt6vectorIiSaIiEE"]
    pub fn cv_mixChannels2(
        src: cv_InputArrayOfArrays,
        dst: cv_InputOutputArrayOfArrays,
        fromTo: *const std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @brief Extracts a single channel from src (coi is 0-based index)\n@param src input array\n@param dst output array\n@param coi index of channel to extract\n@sa mixChannels, split"]
    #[link_name = "\u{1}_ZN2cv14extractChannelERKNS_11_InputArrayERKNS_12_OutputArrayEi"]
    pub fn cv_extractChannel(src: cv_InputArray, dst: cv_OutputArray, coi: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @brief Inserts a single channel to dst (coi is 0-based index)\n@param src input array\n@param dst output array\n@param coi index of channel for insertion\n@sa mixChannels, merge"]
    #[link_name = "\u{1}_ZN2cv13insertChannelERKNS_11_InputArrayERKNS_17_InputOutputArrayEi"]
    pub fn cv_insertChannel(
        src: cv_InputArray,
        dst: cv_InputOutputArray,
        coi: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Flips a 2D array around vertical, horizontal, or both axes.\n\nThe function cv::flip flips the array in one of three different ways (row\nand column indices are 0-based):\n\\f[\\texttt{dst} _{ij} =\n\\left\\{\n\\begin{array}{l l}\n\\texttt{src} _{\\texttt{src.rows}-i-1,j} & if\\;  \\texttt{flipCode} = 0 \\\\\n\\texttt{src} _{i, \\texttt{src.cols} -j-1} & if\\;  \\texttt{flipCode} > 0 \\\\\n\\texttt{src} _{ \\texttt{src.rows} -i-1, \\texttt{src.cols} -j-1} & if\\; \\texttt{flipCode} < 0 \\\\\n\\end{array}\n\\right.\\f]\nThe example scenarios of using the function are the following:\n   Vertical flipping of the image (flipCode == 0) to switch between\ntop-left and bottom-left image origin. This is a typical operation\nin video processing on Microsoft Windows\\* OS.\n   Horizontal flipping of the image with the subsequent horizontal\nshift and absolute difference calculation to check for a\nvertical-axis symmetry (flipCode \\> 0).\n   Simultaneous horizontal and vertical flipping of the image with\nthe subsequent shift and absolute difference calculation to check\nfor a central symmetry (flipCode \\< 0).\n   Reversing the order of point arrays (flipCode \\> 0 or\nflipCode == 0).\n@param src input array.\n@param dst output array of the same size and type as src.\n@param flipCode a flag to specify how to flip the array; 0 means\nflipping around the x-axis and positive value (for example, 1) means\nflipping around y-axis. Negative value (for example, -1) means flipping\naround both axes.\n@sa transpose , repeat , completeSymm"]
    #[link_name = "\u{1}_ZN2cv4flipERKNS_11_InputArrayERKNS_12_OutputArrayEi"]
    pub fn cv_flip(src: cv_InputArray, dst: cv_OutputArray, flipCode: ::std::os::raw::c_int);
}
#[doc = "!<Rotate 90 degrees clockwise"]
pub const cv_RotateFlags_ROTATE_90_CLOCKWISE: cv_RotateFlags = 0;
#[doc = "!<Rotate 180 degrees clockwise"]
pub const cv_RotateFlags_ROTATE_180: cv_RotateFlags = 1;
#[doc = "!<Rotate 270 degrees clockwise"]
pub const cv_RotateFlags_ROTATE_90_COUNTERCLOCKWISE: cv_RotateFlags = 2;
pub type cv_RotateFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Rotates a 2D array in multiples of 90 degrees.\nThe function cv::rotate rotates the array in one of three different ways:\n   Rotate by 90 degrees clockwise (rotateCode = ROTATE_90_CLOCKWISE).\n   Rotate by 180 degrees clockwise (rotateCode = ROTATE_180).\n   Rotate by 270 degrees clockwise (rotateCode = ROTATE_90_COUNTERCLOCKWISE).\n@param src input array.\n@param dst output array of the same type as src.  The size is the same with ROTATE_180,\nand the rows and cols are switched for ROTATE_90_CLOCKWISE and ROTATE_90_COUNTERCLOCKWISE.\n@param rotateCode an enum to specify how to rotate the array; see the enum #RotateFlags\n@sa transpose , repeat , completeSymm, flip, RotateFlags"]
    #[link_name = "\u{1}_ZN2cv6rotateERKNS_11_InputArrayERKNS_12_OutputArrayEi"]
    pub fn cv_rotate(src: cv_InputArray, dst: cv_OutputArray, rotateCode: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @brief Fills the output array with repeated copies of the input array.\n\nThe function cv::repeat duplicates the input array one or more times along each of the two axes:\n\\f[\\texttt{dst} _{ij}= \\texttt{src} _{i\\mod src.rows, \\; j\\mod src.cols }\\f]\nThe second variant of the function is more convenient to use with @ref MatrixExpressions.\n@param src input array to replicate.\n@param ny Flag to specify how many times the `src` is repeated along the\nvertical axis.\n@param nx Flag to specify how many times the `src` is repeated along the\nhorizontal axis.\n@param dst output array of the same type as `src`.\n@sa cv::reduce"]
    #[link_name = "\u{1}_ZN2cv6repeatERKNS_11_InputArrayEiiRKNS_12_OutputArrayE"]
    pub fn cv_repeat(
        src: cv_InputArray,
        ny: ::std::os::raw::c_int,
        nx: ::std::os::raw::c_int,
        dst: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param src input array to replicate.\n@param ny Flag to specify how many times the `src` is repeated along the\nvertical axis.\n@param nx Flag to specify how many times the `src` is repeated along the\nhorizontal axis."]
    #[link_name = "\u{1}_ZN2cv6repeatERKNS_3MatEii"]
    pub fn cv_repeat1(
        src: *const cv_Mat,
        ny: ::std::os::raw::c_int,
        nx: ::std::os::raw::c_int,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Applies horizontal concatenation to given matrices.\n\nThe function horizontally concatenates two or more cv::Mat matrices (with the same number of rows).\n@code{.cpp}\ncv::Mat matArray[] = { cv::Mat(4, 1, CV_8UC1, cv::Scalar(1)),\ncv::Mat(4, 1, CV_8UC1, cv::Scalar(2)),\ncv::Mat(4, 1, CV_8UC1, cv::Scalar(3)),};\n\ncv::Mat out;\ncv::hconcat( matArray, 3, out );\n//out:\n//[1, 2, 3;\n// 1, 2, 3;\n// 1, 2, 3;\n// 1, 2, 3]\n@endcode\n@param src input array or vector of matrices. all of the matrices must have the same number of rows and the same depth.\n@param nsrc number of matrices in src.\n@param dst output array. It has the same number of rows and depth as the src, and the sum of cols of the src.\n@sa cv::vconcat(const Mat*, size_t, OutputArray), @sa cv::vconcat(InputArrayOfArrays, OutputArray) and @sa cv::vconcat(InputArray, InputArray, OutputArray)"]
    #[link_name = "\u{1}_ZN2cv7hconcatEPKNS_3MatEmRKNS_12_OutputArrayE"]
    pub fn cv_hconcat(src: *const cv_Mat, nsrc: usize, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @overload\n@code{.cpp}\ncv::Mat_<float> A = (cv::Mat_<float>(3, 2) << 1, 4,\n2, 5,\n3, 6);\ncv::Mat_<float> B = (cv::Mat_<float>(3, 2) << 7, 10,\n8, 11,\n9, 12);\n\ncv::Mat C;\ncv::hconcat(A, B, C);\n//C:\n//[1, 4, 7, 10;\n// 2, 5, 8, 11;\n// 3, 6, 9, 12]\n@endcode\n@param src1 first input array to be considered for horizontal concatenation.\n@param src2 second input array to be considered for horizontal concatenation.\n@param dst output array. It has the same number of rows and depth as the src1 and src2, and the sum of cols of the src1 and src2."]
    #[link_name = "\u{1}_ZN2cv7hconcatERKNS_11_InputArrayES2_RKNS_12_OutputArrayE"]
    pub fn cv_hconcat1(src1: cv_InputArray, src2: cv_InputArray, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @overload\n@code{.cpp}\nstd::vector<cv::Mat> matrices = { cv::Mat(4, 1, CV_8UC1, cv::Scalar(1)),\ncv::Mat(4, 1, CV_8UC1, cv::Scalar(2)),\ncv::Mat(4, 1, CV_8UC1, cv::Scalar(3)),};\n\ncv::Mat out;\ncv::hconcat( matrices, out );\n//out:\n//[1, 2, 3;\n// 1, 2, 3;\n// 1, 2, 3;\n// 1, 2, 3]\n@endcode\n@param src input array or vector of matrices. all of the matrices must have the same number of rows and the same depth.\n@param dst output array. It has the same number of rows and depth as the src, and the sum of cols of the src.\nsame depth."]
    #[link_name = "\u{1}_ZN2cv7hconcatERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_hconcat2(src: cv_InputArrayOfArrays, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief Applies vertical concatenation to given matrices.\n\nThe function vertically concatenates two or more cv::Mat matrices (with the same number of cols).\n@code{.cpp}\ncv::Mat matArray[] = { cv::Mat(1, 4, CV_8UC1, cv::Scalar(1)),\ncv::Mat(1, 4, CV_8UC1, cv::Scalar(2)),\ncv::Mat(1, 4, CV_8UC1, cv::Scalar(3)),};\n\ncv::Mat out;\ncv::vconcat( matArray, 3, out );\n//out:\n//[1,   1,   1,   1;\n// 2,   2,   2,   2;\n// 3,   3,   3,   3]\n@endcode\n@param src input array or vector of matrices. all of the matrices must have the same number of cols and the same depth.\n@param nsrc number of matrices in src.\n@param dst output array. It has the same number of cols and depth as the src, and the sum of rows of the src.\n@sa cv::hconcat(const Mat*, size_t, OutputArray), @sa cv::hconcat(InputArrayOfArrays, OutputArray) and @sa cv::hconcat(InputArray, InputArray, OutputArray)"]
    #[link_name = "\u{1}_ZN2cv7vconcatEPKNS_3MatEmRKNS_12_OutputArrayE"]
    pub fn cv_vconcat(src: *const cv_Mat, nsrc: usize, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @overload\n@code{.cpp}\ncv::Mat_<float> A = (cv::Mat_<float>(3, 2) << 1, 7,\n2, 8,\n3, 9);\ncv::Mat_<float> B = (cv::Mat_<float>(3, 2) << 4, 10,\n5, 11,\n6, 12);\n\ncv::Mat C;\ncv::vconcat(A, B, C);\n//C:\n//[1, 7;\n// 2, 8;\n// 3, 9;\n// 4, 10;\n// 5, 11;\n// 6, 12]\n@endcode\n@param src1 first input array to be considered for vertical concatenation.\n@param src2 second input array to be considered for vertical concatenation.\n@param dst output array. It has the same number of cols and depth as the src1 and src2, and the sum of rows of the src1 and src2."]
    #[link_name = "\u{1}_ZN2cv7vconcatERKNS_11_InputArrayES2_RKNS_12_OutputArrayE"]
    pub fn cv_vconcat1(src1: cv_InputArray, src2: cv_InputArray, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @overload\n@code{.cpp}\nstd::vector<cv::Mat> matrices = { cv::Mat(1, 4, CV_8UC1, cv::Scalar(1)),\ncv::Mat(1, 4, CV_8UC1, cv::Scalar(2)),\ncv::Mat(1, 4, CV_8UC1, cv::Scalar(3)),};\n\ncv::Mat out;\ncv::vconcat( matrices, out );\n//out:\n//[1,   1,   1,   1;\n// 2,   2,   2,   2;\n// 3,   3,   3,   3]\n@endcode\n@param src input array or vector of matrices. all of the matrices must have the same number of cols and the same depth\n@param dst output array. It has the same number of cols and depth as the src, and the sum of rows of the src.\nsame depth."]
    #[link_name = "\u{1}_ZN2cv7vconcatERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_vconcat2(src: cv_InputArrayOfArrays, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief computes bitwise conjunction of the two arrays (dst = src1 & src2)\nCalculates the per-element bit-wise conjunction of two arrays or an\narray and a scalar.\n\nThe function cv::bitwise_and calculates the per-element bit-wise logical conjunction for:\n   Two arrays when src1 and src2 have the same size:\n\\f[\\texttt{dst} (I) =  \\texttt{src1} (I)  \\wedge \\texttt{src2} (I) \\quad \\texttt{if mask} (I) \\ne0\\f]\n   An array and a scalar when src2 is constructed from Scalar or has\nthe same number of elements as `src1.channels()`:\n\\f[\\texttt{dst} (I) =  \\texttt{src1} (I)  \\wedge \\texttt{src2} \\quad \\texttt{if mask} (I) \\ne0\\f]\n   A scalar and an array when src1 is constructed from Scalar or has\nthe same number of elements as `src2.channels()`:\n\\f[\\texttt{dst} (I) =  \\texttt{src1}  \\wedge \\texttt{src2} (I) \\quad \\texttt{if mask} (I) \\ne0\\f]\nIn case of floating-point arrays, their machine-specific bit\nrepresentations (usually IEEE754-compliant) are used for the operation.\nIn case of multi-channel arrays, each channel is processed\nindependently. In the second and third cases above, the scalar is first\nconverted to the array type.\n@param src1 first input array or a scalar.\n@param src2 second input array or a scalar.\n@param dst output array that has the same size and type as the input\narrays.\n@param mask optional operation mask, 8-bit single channel array, that\nspecifies elements of the output array to be changed."]
    #[link_name = "\u{1}_ZN2cv11bitwise_andERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_"]
    pub fn cv_bitwise_and(
        src1: cv_InputArray,
        src2: cv_InputArray,
        dst: cv_OutputArray,
        mask: cv_InputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the per-element bit-wise disjunction of two arrays or an\narray and a scalar.\n\nThe function cv::bitwise_or calculates the per-element bit-wise logical disjunction for:\n   Two arrays when src1 and src2 have the same size:\n\\f[\\texttt{dst} (I) =  \\texttt{src1} (I)  \\vee \\texttt{src2} (I) \\quad \\texttt{if mask} (I) \\ne0\\f]\n   An array and a scalar when src2 is constructed from Scalar or has\nthe same number of elements as `src1.channels()`:\n\\f[\\texttt{dst} (I) =  \\texttt{src1} (I)  \\vee \\texttt{src2} \\quad \\texttt{if mask} (I) \\ne0\\f]\n   A scalar and an array when src1 is constructed from Scalar or has\nthe same number of elements as `src2.channels()`:\n\\f[\\texttt{dst} (I) =  \\texttt{src1}  \\vee \\texttt{src2} (I) \\quad \\texttt{if mask} (I) \\ne0\\f]\nIn case of floating-point arrays, their machine-specific bit\nrepresentations (usually IEEE754-compliant) are used for the operation.\nIn case of multi-channel arrays, each channel is processed\nindependently. In the second and third cases above, the scalar is first\nconverted to the array type.\n@param src1 first input array or a scalar.\n@param src2 second input array or a scalar.\n@param dst output array that has the same size and type as the input\narrays.\n@param mask optional operation mask, 8-bit single channel array, that\nspecifies elements of the output array to be changed."]
    #[link_name = "\u{1}_ZN2cv10bitwise_orERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_"]
    pub fn cv_bitwise_or(
        src1: cv_InputArray,
        src2: cv_InputArray,
        dst: cv_OutputArray,
        mask: cv_InputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the per-element bit-wise \"exclusive or\" operation on two\narrays or an array and a scalar.\n\nThe function cv::bitwise_xor calculates the per-element bit-wise logical \"exclusive-or\"\noperation for:\n   Two arrays when src1 and src2 have the same size:\n\\f[\\texttt{dst} (I) =  \\texttt{src1} (I)  \\oplus \\texttt{src2} (I) \\quad \\texttt{if mask} (I) \\ne0\\f]\n   An array and a scalar when src2 is constructed from Scalar or has\nthe same number of elements as `src1.channels()`:\n\\f[\\texttt{dst} (I) =  \\texttt{src1} (I)  \\oplus \\texttt{src2} \\quad \\texttt{if mask} (I) \\ne0\\f]\n   A scalar and an array when src1 is constructed from Scalar or has\nthe same number of elements as `src2.channels()`:\n\\f[\\texttt{dst} (I) =  \\texttt{src1}  \\oplus \\texttt{src2} (I) \\quad \\texttt{if mask} (I) \\ne0\\f]\nIn case of floating-point arrays, their machine-specific bit\nrepresentations (usually IEEE754-compliant) are used for the operation.\nIn case of multi-channel arrays, each channel is processed\nindependently. In the 2nd and 3rd cases above, the scalar is first\nconverted to the array type.\n@param src1 first input array or a scalar.\n@param src2 second input array or a scalar.\n@param dst output array that has the same size and type as the input\narrays.\n@param mask optional operation mask, 8-bit single channel array, that\nspecifies elements of the output array to be changed."]
    #[link_name = "\u{1}_ZN2cv11bitwise_xorERKNS_11_InputArrayES2_RKNS_12_OutputArrayES2_"]
    pub fn cv_bitwise_xor(
        src1: cv_InputArray,
        src2: cv_InputArray,
        dst: cv_OutputArray,
        mask: cv_InputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief  Inverts every bit of an array.\n\nThe function cv::bitwise_not calculates per-element bit-wise inversion of the input\narray:\n\\f[\\texttt{dst} (I) =  \\neg \\texttt{src} (I)\\f]\nIn case of a floating-point input array, its machine-specific bit\nrepresentation (usually IEEE754-compliant) is used for the operation. In\ncase of multi-channel arrays, each channel is processed independently.\n@param src input array.\n@param dst output array that has the same size and type as the input\narray.\n@param mask optional operation mask, 8-bit single channel array, that\nspecifies elements of the output array to be changed."]
    #[link_name = "\u{1}_ZN2cv11bitwise_notERKNS_11_InputArrayERKNS_12_OutputArrayES2_"]
    pub fn cv_bitwise_not(src: cv_InputArray, dst: cv_OutputArray, mask: cv_InputArray);
}
unsafe extern "C" {
    #[doc = " @brief Calculates the per-element absolute difference between two arrays or between an array and a scalar.\n\nThe function cv::absdiff calculates:\n   Absolute difference between two arrays when they have the same\nsize and type:\n\\f[\\texttt{dst}(I) =  \\texttt{saturate} (| \\texttt{src1}(I) -  \\texttt{src2}(I)|)\\f]\n   Absolute difference between an array and a scalar when the second\narray is constructed from Scalar or has as many elements as the\nnumber of channels in `src1`:\n\\f[\\texttt{dst}(I) =  \\texttt{saturate} (| \\texttt{src1}(I) -  \\texttt{src2} |)\\f]\n   Absolute difference between a scalar and an array when the first\narray is constructed from Scalar or has as many elements as the\nnumber of channels in `src2`:\n\\f[\\texttt{dst}(I) =  \\texttt{saturate} (| \\texttt{src1} -  \\texttt{src2}(I) |)\\f]\nwhere I is a multi-dimensional index of array elements. In case of\nmulti-channel arrays, each channel is processed independently.\n@note Saturation is not applied when the arrays have the depth CV_32S.\nYou may even get a negative value in the case of overflow.\n@param src1 first input array or a scalar.\n@param src2 second input array or a scalar.\n@param dst output array that has the same size and type as input arrays.\n@sa cv::abs(const Mat&)"]
    #[link_name = "\u{1}_ZN2cv7absdiffERKNS_11_InputArrayES2_RKNS_12_OutputArrayE"]
    pub fn cv_absdiff(src1: cv_InputArray, src2: cv_InputArray, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief  This is an overloaded member function, provided for convenience (python)\nCopies the matrix to another one.\nWhen the operation mask is specified, if the Mat::create call shown above reallocates the matrix, the newly allocated matrix is initialized with all zeros before copying the data.\n@param src source matrix.\n@param dst Destination matrix. If it does not have a proper size or type before the operation, it is\nreallocated.\n@param mask Operation mask of the same size as \\*this. Its non-zero elements indicate which matrix\nelements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels."]
    #[link_name = "\u{1}_ZN2cv6copyToERKNS_11_InputArrayERKNS_12_OutputArrayES2_"]
    pub fn cv_copyTo(src: cv_InputArray, dst: cv_OutputArray, mask: cv_InputArray);
}
unsafe extern "C" {
    #[doc = " @brief  Checks if array elements lie between the elements of two other arrays.\n\nThe function checks the range as follows:\n-   For every element of a single-channel input array:\n\\f[\\texttt{dst} (I)= \\texttt{lowerb} (I)_0  \\leq \\texttt{src} (I)_0 \\leq  \\texttt{upperb} (I)_0\\f]\n-   For two-channel arrays:\n\\f[\\texttt{dst} (I)= \\texttt{lowerb} (I)_0  \\leq \\texttt{src} (I)_0 \\leq  \\texttt{upperb} (I)_0  \\land \\texttt{lowerb} (I)_1  \\leq \\texttt{src} (I)_1 \\leq  \\texttt{upperb} (I)_1\\f]\n-   and so forth.\n\nThat is, dst (I) is set to 255 (all 1 -bits) if src (I) is within the\nspecified 1D, 2D, 3D, ... box and 0 otherwise.\n\nWhen the lower and/or upper boundary parameters are scalars, the indexes\n(I) at lowerb and upperb in the above formulas should be omitted.\n@param src first input array.\n@param lowerb inclusive lower boundary array or a scalar.\n@param upperb inclusive upper boundary array or a scalar.\n@param dst output array of the same size as src and CV_8U type."]
    #[link_name = "\u{1}_ZN2cv7inRangeERKNS_11_InputArrayES2_S2_RKNS_12_OutputArrayE"]
    pub fn cv_inRange(
        src: cv_InputArray,
        lowerb: cv_InputArray,
        upperb: cv_InputArray,
        dst: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Performs the per-element comparison of two arrays or an array and scalar value.\n\nThe function compares:\n   Elements of two arrays when src1 and src2 have the same size:\n\\f[\\texttt{dst} (I) =  \\texttt{src1} (I)  \\,\\texttt{cmpop}\\, \\texttt{src2} (I)\\f]\n   Elements of src1 with a scalar src2 when src2 is constructed from\nScalar or has a single element:\n\\f[\\texttt{dst} (I) =  \\texttt{src1}(I) \\,\\texttt{cmpop}\\,  \\texttt{src2}\\f]\n   src1 with elements of src2 when src1 is constructed from Scalar or\nhas a single element:\n\\f[\\texttt{dst} (I) =  \\texttt{src1}  \\,\\texttt{cmpop}\\, \\texttt{src2} (I)\\f]\nWhen the comparison result is true, the corresponding element of output\narray is set to 255. The comparison operations can be replaced with the\nequivalent matrix expressions:\n@code{.cpp}\nMat dst1 = src1 >= src2;\nMat dst2 = src1 < 8;\n...\n@endcode\n@param src1 first input array or a scalar; when it is an array, it must have a single channel.\n@param src2 second input array or a scalar; when it is an array, it must have a single channel.\n@param dst output array of type ref CV_8U that has the same size and the same number of channels as\nthe input arrays.\n@param cmpop a flag, that specifies correspondence between the arrays (cv::CmpTypes)\n@sa checkRange, min, max, threshold"]
    #[link_name = "\u{1}_ZN2cv7compareERKNS_11_InputArrayES2_RKNS_12_OutputArrayEi"]
    pub fn cv_compare(
        src1: cv_InputArray,
        src2: cv_InputArray,
        dst: cv_OutputArray,
        cmpop: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates per-element minimum of two arrays or an array and a scalar.\n\nThe function cv::min calculates the per-element minimum of two arrays:\n\\f[\\texttt{dst} (I)= \\min ( \\texttt{src1} (I), \\texttt{src2} (I))\\f]\nor array and a scalar:\n\\f[\\texttt{dst} (I)= \\min ( \\texttt{src1} (I), \\texttt{value} )\\f]\n@param src1 first input array.\n@param src2 second input array of the same size and type as src1.\n@param dst output array of the same size and type as src1.\n@sa max, compare, inRange, minMaxLoc"]
    #[link_name = "\u{1}_ZN2cv3minERKNS_11_InputArrayES2_RKNS_12_OutputArrayE"]
    pub fn cv_min3(src1: cv_InputArray, src2: cv_InputArray, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @overload\nneeded to avoid conflicts with const _Tp& std::min(const _Tp&, const _Tp&, _Compare)"]
    #[link_name = "\u{1}_ZN2cv3minERKNS_3MatES2_RS0_"]
    pub fn cv_min4(src1: *const cv_Mat, src2: *const cv_Mat, dst: *mut cv_Mat);
}
unsafe extern "C" {
    #[doc = " @overload\nneeded to avoid conflicts with const _Tp& std::min(const _Tp&, const _Tp&, _Compare)"]
    #[link_name = "\u{1}_ZN2cv3minERKNS_4UMatES2_RS0_"]
    pub fn cv_min5(src1: *const cv_UMat, src2: *const cv_UMat, dst: *mut cv_UMat);
}
unsafe extern "C" {
    #[doc = " @brief Calculates per-element maximum of two arrays or an array and a scalar.\n\nThe function cv::max calculates the per-element maximum of two arrays:\n\\f[\\texttt{dst} (I)= \\max ( \\texttt{src1} (I), \\texttt{src2} (I))\\f]\nor array and a scalar:\n\\f[\\texttt{dst} (I)= \\max ( \\texttt{src1} (I), \\texttt{value} )\\f]\n@param src1 first input array.\n@param src2 second input array of the same size and type as src1 .\n@param dst output array of the same size and type as src1.\n@sa  min, compare, inRange, minMaxLoc, @ref MatrixExpressions"]
    #[link_name = "\u{1}_ZN2cv3maxERKNS_11_InputArrayES2_RKNS_12_OutputArrayE"]
    pub fn cv_max3(src1: cv_InputArray, src2: cv_InputArray, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @overload\nneeded to avoid conflicts with const _Tp& std::min(const _Tp&, const _Tp&, _Compare)"]
    #[link_name = "\u{1}_ZN2cv3maxERKNS_3MatES2_RS0_"]
    pub fn cv_max4(src1: *const cv_Mat, src2: *const cv_Mat, dst: *mut cv_Mat);
}
unsafe extern "C" {
    #[doc = " @overload\nneeded to avoid conflicts with const _Tp& std::min(const _Tp&, const _Tp&, _Compare)"]
    #[link_name = "\u{1}_ZN2cv3maxERKNS_4UMatES2_RS0_"]
    pub fn cv_max5(src1: *const cv_UMat, src2: *const cv_UMat, dst: *mut cv_UMat);
}
unsafe extern "C" {
    #[doc = " @brief Calculates a square root of array elements.\n\nThe function cv::sqrt calculates a square root of each input array element.\nIn case of multi-channel arrays, each channel is processed\nindependently. The accuracy is approximately the same as of the built-in\nstd::sqrt .\n@param src input floating-point array.\n@param dst output array of the same size and type as src."]
    #[link_name = "\u{1}_ZN2cv4sqrtERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_sqrt(src: cv_InputArray, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief Raises every array element to a power.\n\nThe function cv::pow raises every element of the input array to power :\n\\f[\\texttt{dst} (I) =  \\fork{\\texttt{src}(I)^{power}}{if \\(\\texttt{power}\\) is integer}{|\\texttt{src}(I)|^{power}}{otherwise}\\f]\n\nSo, for a non-integer power exponent, the absolute values of input array\nelements are used. However, it is possible to get true values for\nnegative values using some extra operations. In the example below,\ncomputing the 5th root of array src shows:\n@code{.cpp}\nMat mask = src < 0;\npow(src, 1./5, dst);\nsubtract(Scalar::all(0), dst, dst, mask);\n@endcode\nFor some values of power, such as integer values, 0.5 and -0.5,\nspecialized faster algorithms are used.\n\nSpecial values (NaN, Inf) are not handled.\n@param src input array.\n@param power exponent of power.\n@param dst output array of the same size and type as src.\n@sa sqrt, exp, log, cartToPolar, polarToCart"]
    #[link_name = "\u{1}_ZN2cv3powERKNS_11_InputArrayEdRKNS_12_OutputArrayE"]
    pub fn cv_pow(src: cv_InputArray, power: f64, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief Calculates the exponent of every array element.\n\nThe function cv::exp calculates the exponent of every element of the input\narray:\n\\f[\\texttt{dst} [I] = e^{ src(I) }\\f]\n\nThe maximum relative error is about 7e-6 for single-precision input and\nless than 1e-10 for double-precision input. Currently, the function\nconverts denormalized values to zeros on output. Special values (NaN,\nInf) are not handled.\n@param src input array.\n@param dst output array of the same size and type as src.\n@sa log , cartToPolar , polarToCart , phase , pow , sqrt , magnitude"]
    #[link_name = "\u{1}_ZN2cv3expERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_exp(src: cv_InputArray, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief Calculates the natural logarithm of every array element.\n\nThe function cv::log calculates the natural logarithm of every element of the input array:\n\\f[\\texttt{dst} (I) =  \\log (\\texttt{src}(I)) \\f]\n\nOutput on zero, negative and special (NaN, Inf) values is undefined.\n\n@param src input array.\n@param dst output array of the same size and type as src .\n@sa exp, cartToPolar, polarToCart, phase, pow, sqrt, magnitude"]
    #[link_name = "\u{1}_ZN2cv3logERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_log(src: cv_InputArray, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief Calculates x and y coordinates of 2D vectors from their magnitude and angle.\n\nThe function cv::polarToCart calculates the Cartesian coordinates of each 2D\nvector represented by the corresponding elements of magnitude and angle:\n\\f[\\begin{array}{l} \\texttt{x} (I) =  \\texttt{magnitude} (I) \\cos ( \\texttt{angle} (I)) \\\\ \\texttt{y} (I) =  \\texttt{magnitude} (I) \\sin ( \\texttt{angle} (I)) \\\\ \\end{array}\\f]\n\nThe relative accuracy of the estimated coordinates is about 1e-6.\n@param magnitude input floating-point array of magnitudes of 2D vectors;\nit can be an empty matrix (=Mat()), in this case, the function assumes\nthat all the magnitudes are =1; if it is not empty, it must have the\nsame size and type as angle.\n@param angle input floating-point array of angles of 2D vectors.\n@param x output array of x-coordinates of 2D vectors; it has the same\nsize and type as angle.\n@param y output array of y-coordinates of 2D vectors; it has the same\nsize and type as angle.\n@param angleInDegrees when true, the input angles are measured in\ndegrees, otherwise, they are measured in radians.\n@sa cartToPolar, magnitude, phase, exp, log, pow, sqrt"]
    #[link_name = "\u{1}_ZN2cv11polarToCartERKNS_11_InputArrayES2_RKNS_12_OutputArrayES5_b"]
    pub fn cv_polarToCart(
        magnitude: cv_InputArray,
        angle: cv_InputArray,
        x: cv_OutputArray,
        y: cv_OutputArray,
        angleInDegrees: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the magnitude and angle of 2D vectors.\n\nThe function cv::cartToPolar calculates either the magnitude, angle, or both\nfor every 2D vector (x(I),y(I)):\n\\f[\\begin{array}{l} \\texttt{magnitude} (I)= \\sqrt{\\texttt{x}(I)^2+\\texttt{y}(I)^2} , \\\\ \\texttt{angle} (I)= \\texttt{atan2} ( \\texttt{y} (I), \\texttt{x} (I))[ \\cdot180 / \\pi ] \\end{array}\\f]\n\nThe angles are calculated with accuracy about 0.3 degrees. For the point\n(0,0), the angle is set to 0.\n@param x array of x-coordinates; this must be a single-precision or\ndouble-precision floating-point array.\n@param y array of y-coordinates, that must have the same size and same type as x.\n@param magnitude output array of magnitudes of the same size and type as x.\n@param angle output array of angles that has the same size and type as\nx; the angles are measured in radians (from 0 to 2\\*Pi) or in degrees (0 to 360 degrees).\n@param angleInDegrees a flag, indicating whether the angles are measured\nin radians (which is by default), or in degrees.\n@sa Sobel, Scharr"]
    #[link_name = "\u{1}_ZN2cv11cartToPolarERKNS_11_InputArrayES2_RKNS_12_OutputArrayES5_b"]
    pub fn cv_cartToPolar(
        x: cv_InputArray,
        y: cv_InputArray,
        magnitude: cv_OutputArray,
        angle: cv_OutputArray,
        angleInDegrees: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the rotation angle of 2D vectors.\n\nThe function cv::phase calculates the rotation angle of each 2D vector that\nis formed from the corresponding elements of x and y :\n\\f[\\texttt{angle} (I) =  \\texttt{atan2} ( \\texttt{y} (I), \\texttt{x} (I))\\f]\n\nThe angle estimation accuracy is about 0.3 degrees. When x(I)=y(I)=0 ,\nthe corresponding angle(I) is set to 0.\n@param x input floating-point array of x-coordinates of 2D vectors.\n@param y input array of y-coordinates of 2D vectors; it must have the\nsame size and the same type as x.\n@param angle output array of vector angles; it has the same size and\nsame type as x .\n@param angleInDegrees when true, the function calculates the angle in\ndegrees, otherwise, they are measured in radians."]
    #[link_name = "\u{1}_ZN2cv5phaseERKNS_11_InputArrayES2_RKNS_12_OutputArrayEb"]
    pub fn cv_phase(
        x: cv_InputArray,
        y: cv_InputArray,
        angle: cv_OutputArray,
        angleInDegrees: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the magnitude of 2D vectors.\n\nThe function cv::magnitude calculates the magnitude of 2D vectors formed\nfrom the corresponding elements of x and y arrays:\n\\f[\\texttt{dst} (I) =  \\sqrt{\\texttt{x}(I)^2 + \\texttt{y}(I)^2}\\f]\n@param x floating-point array of x-coordinates of the vectors.\n@param y floating-point array of y-coordinates of the vectors; it must\nhave the same size as x.\n@param magnitude output array of the same size and type as x.\n@sa cartToPolar, polarToCart, phase, sqrt"]
    #[link_name = "\u{1}_ZN2cv9magnitudeERKNS_11_InputArrayES2_RKNS_12_OutputArrayE"]
    pub fn cv_magnitude(x: cv_InputArray, y: cv_InputArray, magnitude: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief Checks every element of an input array for invalid values.\n\nThe function cv::checkRange checks that every array element is neither NaN nor infinite. When minVal \\>\n-DBL_MAX and maxVal \\< DBL_MAX, the function also checks that each value is between minVal and\nmaxVal. In case of multi-channel arrays, each channel is processed independently. If some values\nare out of range, position of the first outlier is stored in pos (when pos != NULL). Then, the\nfunction either returns false (when quiet=true) or throws an exception.\n@param a input array.\n@param quiet a flag, indicating whether the functions quietly return false when the array elements\nare out of range or they throw an exception.\n@param pos optional output parameter, when not NULL, must be a pointer to array of src.dims\nelements.\n@param minVal inclusive lower boundary of valid values range.\n@param maxVal exclusive upper boundary of valid values range."]
    #[link_name = "\u{1}_ZN2cv10checkRangeERKNS_11_InputArrayEbPNS_6Point_IiEEdd"]
    pub fn cv_checkRange(
        a: cv_InputArray,
        quiet: bool,
        pos: *mut cv_Point,
        minVal: f64,
        maxVal: f64,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief converts NaN's to the given number"]
    #[link_name = "\u{1}_ZN2cv9patchNaNsERKNS_17_InputOutputArrayEd"]
    pub fn cv_patchNaNs(a: cv_InputOutputArray, val: f64);
}
unsafe extern "C" {
    #[doc = " @brief Performs generalized matrix multiplication.\n\nThe function cv::gemm performs generalized matrix multiplication similar to the\ngemm functions in BLAS level 3. For example,\n`gemm(src1, src2, alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T)`\ncorresponds to\n\\f[\\texttt{dst} =  \\texttt{alpha} \\cdot \\texttt{src1} ^T  \\cdot \\texttt{src2} +  \\texttt{beta} \\cdot \\texttt{src3} ^T\\f]\n\nIn case of complex (two-channel) data, performed a complex matrix\nmultiplication.\n\nThe function can be replaced with a matrix expression. For example, the\nabove call can be replaced with:\n@code{.cpp}\ndst = alpha*src1.t()*src2 + beta*src3.t();\n@endcode\n@param src1 first multiplied input matrix that could be real(CV_32FC1,\nCV_64FC1) or complex(CV_32FC2, CV_64FC2).\n@param src2 second multiplied input matrix of the same type as src1.\n@param alpha weight of the matrix product.\n@param src3 third optional delta matrix added to the matrix product; it\nshould have the same type as src1 and src2.\n@param beta weight of src3.\n@param dst output matrix; it has the proper size and the same type as\ninput matrices.\n@param flags operation flags (cv::GemmFlags)\n@sa mulTransposed , transform"]
    #[link_name = "\u{1}_ZN2cv4gemmERKNS_11_InputArrayES2_dS2_dRKNS_12_OutputArrayEi"]
    pub fn cv_gemm(
        src1: cv_InputArray,
        src2: cv_InputArray,
        alpha: f64,
        src3: cv_InputArray,
        beta: f64,
        dst: cv_OutputArray,
        flags: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the product of a matrix and its transposition.\n\nThe function cv::mulTransposed calculates the product of src and its\ntransposition:\n\\f[\\texttt{dst} = \\texttt{scale} ( \\texttt{src} - \\texttt{delta} )^T ( \\texttt{src} - \\texttt{delta} )\\f]\nif aTa=true , and\n\\f[\\texttt{dst} = \\texttt{scale} ( \\texttt{src} - \\texttt{delta} ) ( \\texttt{src} - \\texttt{delta} )^T\\f]\notherwise. The function is used to calculate the covariance matrix. With\nzero delta, it can be used as a faster substitute for general matrix\nproduct A\\*B when B=A'\n@param src input single-channel matrix. Note that unlike gemm, the\nfunction can multiply not only floating-point matrices.\n@param dst output square matrix.\n@param aTa Flag specifying the multiplication ordering. See the\ndescription below.\n@param delta Optional delta matrix subtracted from src before the\nmultiplication. When the matrix is empty ( delta=noArray() ), it is\nassumed to be zero, that is, nothing is subtracted. If it has the same\nsize as src , it is simply subtracted. Otherwise, it is \"repeated\" (see\nrepeat ) to cover the full src and then subtracted. Type of the delta\nmatrix, when it is not empty, must be the same as the type of created\noutput matrix. See the dtype parameter description below.\n@param scale Optional scale factor for the matrix product.\n@param dtype Optional type of the output matrix. When it is negative,\nthe output matrix will have the same type as src . Otherwise, it will be\ntype=CV_MAT_DEPTH(dtype) that should be either CV_32F or CV_64F .\n@sa calcCovarMatrix, gemm, repeat, reduce"]
    #[link_name = "\u{1}_ZN2cv13mulTransposedERKNS_11_InputArrayERKNS_12_OutputArrayEbS2_di"]
    pub fn cv_mulTransposed(
        src: cv_InputArray,
        dst: cv_OutputArray,
        aTa: bool,
        delta: cv_InputArray,
        scale: f64,
        dtype: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Transposes a matrix.\n\nThe function cv::transpose transposes the matrix src :\n\\f[\\texttt{dst} (i,j) =  \\texttt{src} (j,i)\\f]\n@note No complex conjugation is done in case of a complex matrix. It\nshould be done separately if needed.\n@param src input array.\n@param dst output array of the same type as src."]
    #[link_name = "\u{1}_ZN2cv9transposeERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_transpose(src: cv_InputArray, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief Performs the matrix transformation of every array element.\n\nThe function cv::transform performs the matrix transformation of every\nelement of the array src and stores the results in dst :\n\\f[\\texttt{dst} (I) =  \\texttt{m} \\cdot \\texttt{src} (I)\\f]\n(when m.cols=src.channels() ), or\n\\f[\\texttt{dst} (I) =  \\texttt{m} \\cdot [ \\texttt{src} (I); 1]\\f]\n(when m.cols=src.channels()+1 )\n\nEvery element of the N -channel array src is interpreted as N -element\nvector that is transformed using the M x N or M x (N+1) matrix m to\nM-element vector - the corresponding element of the output array dst .\n\nThe function may be used for geometrical transformation of\nN -dimensional points, arbitrary linear color space transformation (such\nas various kinds of RGB to YUV transforms), shuffling the image\nchannels, and so forth.\n@param src input array that must have as many channels (1 to 4) as\nm.cols or m.cols-1.\n@param dst output array of the same size and depth as src; it has as\nmany channels as m.rows.\n@param m transformation 2x2 or 2x3 floating-point matrix.\n@sa perspectiveTransform, getAffineTransform, estimateAffine2D, warpAffine, warpPerspective"]
    #[link_name = "\u{1}_ZN2cv9transformERKNS_11_InputArrayERKNS_12_OutputArrayES2_"]
    pub fn cv_transform(src: cv_InputArray, dst: cv_OutputArray, m: cv_InputArray);
}
unsafe extern "C" {
    #[doc = " @brief Performs the perspective matrix transformation of vectors.\n\nThe function cv::perspectiveTransform transforms every element of src by\ntreating it as a 2D or 3D vector, in the following way:\n\\f[(x, y, z)  \\rightarrow (x'/w, y'/w, z'/w)\\f]\nwhere\n\\f[(x', y', z', w') =  \\texttt{mat} \\cdot \\begin{bmatrix} x & y & z & 1  \\end{bmatrix}\\f]\nand\n\\f[w =  \\fork{w'}{if \\(w' \\ne 0\\)}{\\infty}{otherwise}\\f]\n\nHere a 3D vector transformation is shown. In case of a 2D vector\ntransformation, the z component is omitted.\n\n@note The function transforms a sparse set of 2D or 3D vectors. If you\nwant to transform an image using perspective transformation, use\nwarpPerspective . If you have an inverse problem, that is, you want to\ncompute the most probable perspective transformation out of several\npairs of corresponding points, you can use getPerspectiveTransform or\nfindHomography .\n@param src input two-channel or three-channel floating-point array; each\nelement is a 2D/3D vector to be transformed.\n@param dst output array of the same size and type as src.\n@param m 3x3 or 4x4 floating-point transformation matrix.\n@sa  transform, warpPerspective, getPerspectiveTransform, findHomography"]
    #[link_name = "\u{1}_ZN2cv20perspectiveTransformERKNS_11_InputArrayERKNS_12_OutputArrayES2_"]
    pub fn cv_perspectiveTransform(src: cv_InputArray, dst: cv_OutputArray, m: cv_InputArray);
}
unsafe extern "C" {
    #[doc = " @brief Copies the lower or the upper half of a square matrix to its another half.\n\nThe function cv::completeSymm copies the lower or the upper half of a square matrix to\nits another half. The matrix diagonal remains unchanged:\n- \\f$\\texttt{m}_{ij}=\\texttt{m}_{ji}\\f$ for \\f$i > j\\f$ if\nlowerToUpper=false\n- \\f$\\texttt{m}_{ij}=\\texttt{m}_{ji}\\f$ for \\f$i < j\\f$ if\nlowerToUpper=true\n\n@param m input-output floating-point square matrix.\n@param lowerToUpper operation flag; if true, the lower half is copied to\nthe upper half. Otherwise, the upper half is copied to the lower half.\n@sa flip, transpose"]
    #[link_name = "\u{1}_ZN2cv12completeSymmERKNS_17_InputOutputArrayEb"]
    pub fn cv_completeSymm(m: cv_InputOutputArray, lowerToUpper: bool);
}
unsafe extern "C" {
    #[doc = " @brief Initializes a scaled identity matrix.\n\nThe function cv::setIdentity initializes a scaled identity matrix:\n\\f[\\texttt{mtx} (i,j)= \\fork{\\texttt{value}}{ if \\(i=j\\)}{0}{otherwise}\\f]\n\nThe function can also be emulated using the matrix initializers and the\nmatrix expressions:\n@code\nMat A = Mat::eye(4, 3, CV_32F)*5;\n// A will be set to [[5, 0, 0], [0, 5, 0], [0, 0, 5], [0, 0, 0]]\n@endcode\n@param mtx matrix to initialize (not necessarily square).\n@param s value to assign to diagonal elements.\n@sa Mat::zeros, Mat::ones, Mat::setTo, Mat::operator="]
    #[link_name = "\u{1}_ZN2cv11setIdentityERKNS_17_InputOutputArrayERKNS_7Scalar_IdEE"]
    pub fn cv_setIdentity(mtx: cv_InputOutputArray, s: *const cv_Scalar);
}
unsafe extern "C" {
    #[doc = " @brief Returns the determinant of a square floating-point matrix.\n\nThe function cv::determinant calculates and returns the determinant of the\nspecified matrix. For small matrices ( mtx.cols=mtx.rows\\<=3 ), the\ndirect method is used. For larger matrices, the function uses LU\nfactorization with partial pivoting.\n\nFor symmetric positively-determined matrices, it is also possible to use\neigen decomposition to calculate the determinant.\n@param mtx input matrix that must have CV_32FC1 or CV_64FC1 type and\nsquare size.\n@sa trace, invert, solve, eigen, @ref MatrixExpressions"]
    #[link_name = "\u{1}_ZN2cv11determinantERKNS_11_InputArrayE"]
    pub fn cv_determinant(mtx: cv_InputArray) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Returns the trace of a matrix.\n\nThe function cv::trace returns the sum of the diagonal elements of the\nmatrix mtx .\n\\f[\\mathrm{tr} ( \\texttt{mtx} ) =  \\sum _i  \\texttt{mtx} (i,i)\\f]\n@param mtx input matrix."]
    #[link_name = "\u{1}_ZN2cv5traceERKNS_11_InputArrayE"]
    pub fn cv_trace(mtx: cv_InputArray) -> cv_Scalar;
}
unsafe extern "C" {
    #[doc = " @brief Finds the inverse or pseudo-inverse of a matrix.\n\nThe function cv::invert inverts the matrix src and stores the result in dst\n. When the matrix src is singular or non-square, the function calculates\nthe pseudo-inverse matrix (the dst matrix) so that norm(src\\*dst - I) is\nminimal, where I is an identity matrix.\n\nIn case of the #DECOMP_LU method, the function returns non-zero value if\nthe inverse has been successfully calculated and 0 if src is singular.\n\nIn case of the #DECOMP_SVD method, the function returns the inverse\ncondition number of src (the ratio of the smallest singular value to the\nlargest singular value) and 0 if src is singular. The SVD method\ncalculates a pseudo-inverse matrix if src is singular.\n\nSimilarly to #DECOMP_LU, the method #DECOMP_CHOLESKY works only with\nnon-singular square matrices that should also be symmetrical and\npositively defined. In this case, the function stores the inverted\nmatrix in dst and returns non-zero. Otherwise, it returns 0.\n\n@param src input floating-point M x N matrix.\n@param dst output matrix of N x M size and the same type as src.\n@param flags inversion method (cv::DecompTypes)\n@sa solve, SVD"]
    #[link_name = "\u{1}_ZN2cv6invertERKNS_11_InputArrayERKNS_12_OutputArrayEi"]
    pub fn cv_invert(src: cv_InputArray, dst: cv_OutputArray, flags: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Solves one or more linear systems or least-squares problems.\n\nThe function cv::solve solves a linear system or least-squares problem (the\nlatter is possible with SVD or QR methods, or by specifying the flag\n#DECOMP_NORMAL ):\n\\f[\\texttt{dst} =  \\arg \\min _X \\| \\texttt{src1} \\cdot \\texttt{X} -  \\texttt{src2} \\|\\f]\n\nIf #DECOMP_LU or #DECOMP_CHOLESKY method is used, the function returns 1\nif src1 (or \\f$\\texttt{src1}^T\\texttt{src1}\\f$ ) is non-singular. Otherwise,\nit returns 0. In the latter case, dst is not valid. Other methods find a\npseudo-solution in case of a singular left-hand side part.\n\n@note If you want to find a unity-norm solution of an under-defined\nsingular system \\f$\\texttt{src1}\\cdot\\texttt{dst}=0\\f$ , the function solve\nwill not do the work. Use SVD::solveZ instead.\n\n@param src1 input matrix on the left-hand side of the system.\n@param src2 input matrix on the right-hand side of the system.\n@param dst output solution.\n@param flags solution (matrix inversion) method (#DecompTypes)\n@sa invert, SVD, eigen"]
    #[link_name = "\u{1}_ZN2cv5solveERKNS_11_InputArrayES2_RKNS_12_OutputArrayEi"]
    pub fn cv_solve(
        src1: cv_InputArray,
        src2: cv_InputArray,
        dst: cv_OutputArray,
        flags: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Sorts each row or each column of a matrix.\n\nThe function cv::sort sorts each matrix row or each matrix column in\nascending or descending order. So you should pass two operation flags to\nget desired behaviour. If you want to sort matrix rows or columns\nlexicographically, you can use STL std::sort generic function with the\nproper comparison predicate.\n\n@param src input single-channel array.\n@param dst output array of the same size and type as src.\n@param flags operation flags, a combination of #SortFlags\n@sa sortIdx, randShuffle"]
    #[link_name = "\u{1}_ZN2cv4sortERKNS_11_InputArrayERKNS_12_OutputArrayEi"]
    pub fn cv_sort(src: cv_InputArray, dst: cv_OutputArray, flags: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @brief Sorts each row or each column of a matrix.\n\nThe function cv::sortIdx sorts each matrix row or each matrix column in the\nascending or descending order. So you should pass two operation flags to\nget desired behaviour. Instead of reordering the elements themselves, it\nstores the indices of sorted elements in the output array. For example:\n@code\nMat A = Mat::eye(3,3,CV_32F), B;\nsortIdx(A, B, SORT_EVERY_ROW + SORT_ASCENDING);\n// B will probably contain\n// (because of equal elements in A some permutations are possible):\n// [[1, 2, 0], [0, 2, 1], [0, 1, 2]]\n@endcode\n@param src input single-channel array.\n@param dst output integer array of the same size as src.\n@param flags operation flags that could be a combination of cv::SortFlags\n@sa sort, randShuffle"]
    #[link_name = "\u{1}_ZN2cv7sortIdxERKNS_11_InputArrayERKNS_12_OutputArrayEi"]
    pub fn cv_sortIdx(src: cv_InputArray, dst: cv_OutputArray, flags: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @brief Finds the real roots of a cubic equation.\n\nThe function solveCubic finds the real roots of a cubic equation:\n-   if coeffs is a 4-element vector:\n\\f[\\texttt{coeffs} [0] x^3 +  \\texttt{coeffs} [1] x^2 +  \\texttt{coeffs} [2] x +  \\texttt{coeffs} [3] = 0\\f]\n-   if coeffs is a 3-element vector:\n\\f[x^3 +  \\texttt{coeffs} [0] x^2 +  \\texttt{coeffs} [1] x +  \\texttt{coeffs} [2] = 0\\f]\n\nThe roots are stored in the roots array.\n@param coeffs equation coefficients, an array of 3 or 4 elements.\n@param roots output array of real roots that has 1 or 3 elements.\n@return number of real roots. It can be 0, 1 or 2."]
    #[link_name = "\u{1}_ZN2cv10solveCubicERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_solveCubic(coeffs: cv_InputArray, roots: cv_OutputArray) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Finds the real or complex roots of a polynomial equation.\n\nThe function cv::solvePoly finds real and complex roots of a polynomial equation:\n\\f[\\texttt{coeffs} [n] x^{n} +  \\texttt{coeffs} [n-1] x^{n-1} + ... +  \\texttt{coeffs} [1] x +  \\texttt{coeffs} [0] = 0\\f]\n@param coeffs array of polynomial coefficients.\n@param roots output (complex) array of roots.\n@param maxIters maximum number of iterations the algorithm does."]
    #[link_name = "\u{1}_ZN2cv9solvePolyERKNS_11_InputArrayERKNS_12_OutputArrayEi"]
    pub fn cv_solvePoly(
        coeffs: cv_InputArray,
        roots: cv_OutputArray,
        maxIters: ::std::os::raw::c_int,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Calculates eigenvalues and eigenvectors of a symmetric matrix.\n\nThe function cv::eigen calculates just eigenvalues, or eigenvalues and eigenvectors of the symmetric\nmatrix src:\n@code\nsrc*eigenvectors.row(i).t() = eigenvalues.at<srcType>(i)*eigenvectors.row(i).t()\n@endcode\n\n@note Use cv::eigenNonSymmetric for calculation of real eigenvalues and eigenvectors of non-symmetric matrix.\n\n@param src input matrix that must have CV_32FC1 or CV_64FC1 type, square size and be symmetrical\n(src ^T^ == src).\n@param eigenvalues output vector of eigenvalues of the same type as src; the eigenvalues are stored\nin the descending order.\n@param eigenvectors output matrix of eigenvectors; it has the same size and type as src; the\neigenvectors are stored as subsequent matrix rows, in the same order as the corresponding\neigenvalues.\n@sa eigenNonSymmetric, completeSymm , PCA"]
    #[link_name = "\u{1}_ZN2cv5eigenERKNS_11_InputArrayERKNS_12_OutputArrayES5_"]
    pub fn cv_eigen(
        src: cv_InputArray,
        eigenvalues: cv_OutputArray,
        eigenvectors: cv_OutputArray,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Calculates eigenvalues and eigenvectors of a non-symmetric matrix (real eigenvalues only).\n\n@note Assumes real eigenvalues.\n\nThe function calculates eigenvalues and eigenvectors (optional) of the square matrix src:\n@code\nsrc*eigenvectors.row(i).t() = eigenvalues.at<srcType>(i)*eigenvectors.row(i).t()\n@endcode\n\n@param src input matrix (CV_32FC1 or CV_64FC1 type).\n@param eigenvalues output vector of eigenvalues (type is the same type as src).\n@param eigenvectors output matrix of eigenvectors (type is the same type as src). The eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding eigenvalues.\n@sa eigen"]
    #[link_name = "\u{1}_ZN2cv17eigenNonSymmetricERKNS_11_InputArrayERKNS_12_OutputArrayES5_"]
    pub fn cv_eigenNonSymmetric(
        src: cv_InputArray,
        eigenvalues: cv_OutputArray,
        eigenvectors: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the covariance matrix of a set of vectors.\n\nThe function cv::calcCovarMatrix calculates the covariance matrix and, optionally, the mean vector of\nthe set of input vectors.\n@param samples samples stored as separate matrices\n@param nsamples number of samples\n@param covar output covariance matrix of the type ctype and square size.\n@param mean input or output (depending on the flags) array as the average value of the input vectors.\n@param flags operation flags as a combination of #CovarFlags\n@param ctype type of the matrixl; it equals 'CV_64F' by default.\n@sa PCA, mulTransposed, Mahalanobis\n@todo InputArrayOfArrays"]
    #[link_name = "\u{1}_ZN2cv15calcCovarMatrixEPKNS_3MatEiRS0_S3_ii"]
    pub fn cv_calcCovarMatrix(
        samples: *const cv_Mat,
        nsamples: ::std::os::raw::c_int,
        covar: *mut cv_Mat,
        mean: *mut cv_Mat,
        flags: ::std::os::raw::c_int,
        ctype: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@note use #COVAR_ROWS or #COVAR_COLS flag\n@param samples samples stored as rows/columns of a single matrix.\n@param covar output covariance matrix of the type ctype and square size.\n@param mean input or output (depending on the flags) array as the average value of the input vectors.\n@param flags operation flags as a combination of #CovarFlags\n@param ctype type of the matrixl; it equals 'CV_64F' by default."]
    #[link_name = "\u{1}_ZN2cv15calcCovarMatrixERKNS_11_InputArrayERKNS_12_OutputArrayERKNS_17_InputOutputArrayEii"]
    pub fn cv_calcCovarMatrix1(
        samples: cv_InputArray,
        covar: cv_OutputArray,
        mean: cv_InputOutputArray,
        flags: ::std::os::raw::c_int,
        ctype: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " wrap PCA::operator()"]
    #[link_name = "\u{1}_ZN2cv10PCAComputeERKNS_11_InputArrayERKNS_17_InputOutputArrayERKNS_12_OutputArrayEi"]
    pub fn cv_PCACompute(
        data: cv_InputArray,
        mean: cv_InputOutputArray,
        eigenvectors: cv_OutputArray,
        maxComponents: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " wrap PCA::operator() and add eigenvalues output parameter"]
    #[link_name = "\u{1}_ZN2cv10PCAComputeERKNS_11_InputArrayERKNS_17_InputOutputArrayERKNS_12_OutputArrayES8_i"]
    pub fn cv_PCACompute1(
        data: cv_InputArray,
        mean: cv_InputOutputArray,
        eigenvectors: cv_OutputArray,
        eigenvalues: cv_OutputArray,
        maxComponents: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " wrap PCA::operator()"]
    #[link_name = "\u{1}_ZN2cv10PCAComputeERKNS_11_InputArrayERKNS_17_InputOutputArrayERKNS_12_OutputArrayEd"]
    pub fn cv_PCACompute2(
        data: cv_InputArray,
        mean: cv_InputOutputArray,
        eigenvectors: cv_OutputArray,
        retainedVariance: f64,
    );
}
unsafe extern "C" {
    #[doc = " wrap PCA::operator() and add eigenvalues output parameter"]
    #[link_name = "\u{1}_ZN2cv10PCAComputeERKNS_11_InputArrayERKNS_17_InputOutputArrayERKNS_12_OutputArrayES8_d"]
    pub fn cv_PCACompute3(
        data: cv_InputArray,
        mean: cv_InputOutputArray,
        eigenvectors: cv_OutputArray,
        eigenvalues: cv_OutputArray,
        retainedVariance: f64,
    );
}
unsafe extern "C" {
    #[doc = " wrap PCA::project"]
    #[link_name = "\u{1}_ZN2cv10PCAProjectERKNS_11_InputArrayES2_S2_RKNS_12_OutputArrayE"]
    pub fn cv_PCAProject(
        data: cv_InputArray,
        mean: cv_InputArray,
        eigenvectors: cv_InputArray,
        result: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " wrap PCA::backProject"]
    #[link_name = "\u{1}_ZN2cv14PCABackProjectERKNS_11_InputArrayES2_S2_RKNS_12_OutputArrayE"]
    pub fn cv_PCABackProject(
        data: cv_InputArray,
        mean: cv_InputArray,
        eigenvectors: cv_InputArray,
        result: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " wrap SVD::compute"]
    #[link_name = "\u{1}_ZN2cv8SVDecompERKNS_11_InputArrayERKNS_12_OutputArrayES5_S5_i"]
    pub fn cv_SVDecomp(
        src: cv_InputArray,
        w: cv_OutputArray,
        u: cv_OutputArray,
        vt: cv_OutputArray,
        flags: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " wrap SVD::backSubst"]
    #[link_name = "\u{1}_ZN2cv11SVBackSubstERKNS_11_InputArrayES2_S2_S2_RKNS_12_OutputArrayE"]
    pub fn cv_SVBackSubst(
        w: cv_InputArray,
        u: cv_InputArray,
        vt: cv_InputArray,
        rhs: cv_InputArray,
        dst: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the Mahalanobis distance between two vectors.\n\nThe function cv::Mahalanobis calculates and returns the weighted distance between two vectors:\n\\f[d( \\texttt{vec1} , \\texttt{vec2} )= \\sqrt{\\sum_{i,j}{\\texttt{icovar(i,j)}\\cdot(\\texttt{vec1}(I)-\\texttt{vec2}(I))\\cdot(\\texttt{vec1(j)}-\\texttt{vec2(j)})} }\\f]\nThe covariance matrix may be calculated using the #calcCovarMatrix function and then inverted using\nthe invert function (preferably using the #DECOMP_SVD method, as the most accurate).\n@param v1 first 1D input vector.\n@param v2 second 1D input vector.\n@param icovar inverse covariance matrix."]
    #[link_name = "\u{1}_ZN2cv11MahalanobisERKNS_11_InputArrayES2_S2_"]
    pub fn cv_Mahalanobis(v1: cv_InputArray, v2: cv_InputArray, icovar: cv_InputArray) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Performs a forward or inverse Discrete Fourier transform of a 1D or 2D floating-point array.\n\nThe function cv::dft performs one of the following:\n-   Forward the Fourier transform of a 1D vector of N elements:\n\\f[Y = F^{(N)}  \\cdot X,\\f]\nwhere \\f$F^{(N)}_{jk}=\\exp(-2\\pi i j k/N)\\f$ and \\f$i=\\sqrt{-1}\\f$\n-   Inverse the Fourier transform of a 1D vector of N elements:\n\\f[\\begin{array}{l} X'=  \\left (F^{(N)} \\right )^{-1}  \\cdot Y =  \\left (F^{(N)} \\right )^*  \\cdot y  \\\\ X = (1/N)  \\cdot X, \\end{array}\\f]\nwhere \\f$F^*=\\left(\\textrm{Re}(F^{(N)})-\\textrm{Im}(F^{(N)})\\right)^T\\f$\n-   Forward the 2D Fourier transform of a M x N matrix:\n\\f[Y = F^{(M)}  \\cdot X  \\cdot F^{(N)}\\f]\n-   Inverse the 2D Fourier transform of a M x N matrix:\n\\f[\\begin{array}{l} X'=  \\left (F^{(M)} \\right )^*  \\cdot Y  \\cdot \\left (F^{(N)} \\right )^* \\\\ X =  \\frac{1}{M \\cdot N} \\cdot X' \\end{array}\\f]\n\nIn case of real (single-channel) data, the output spectrum of the forward Fourier transform or input\nspectrum of the inverse Fourier transform can be represented in a packed format called *CCS*\n(complex-conjugate-symmetrical). It was borrowed from IPL (Intel\\* Image Processing Library). Here\nis how 2D *CCS* spectrum looks:\n\\f[\\begin{bmatrix} Re Y_{0,0} & Re Y_{0,1} & Im Y_{0,1} & Re Y_{0,2} & Im Y_{0,2} &  \\cdots & Re Y_{0,N/2-1} & Im Y_{0,N/2-1} & Re Y_{0,N/2}  \\\\ Re Y_{1,0} & Re Y_{1,1} & Im Y_{1,1} & Re Y_{1,2} & Im Y_{1,2} &  \\cdots & Re Y_{1,N/2-1} & Im Y_{1,N/2-1} & Re Y_{1,N/2}  \\\\ Im Y_{1,0} & Re Y_{2,1} & Im Y_{2,1} & Re Y_{2,2} & Im Y_{2,2} &  \\cdots & Re Y_{2,N/2-1} & Im Y_{2,N/2-1} & Im Y_{1,N/2}  \\\\ \\hdotsfor{9} \\\\ Re Y_{M/2-1,0} &  Re Y_{M-3,1}  & Im Y_{M-3,1} &  \\hdotsfor{3} & Re Y_{M-3,N/2-1} & Im Y_{M-3,N/2-1}& Re Y_{M/2-1,N/2}  \\\\ Im Y_{M/2-1,0} &  Re Y_{M-2,1}  & Im Y_{M-2,1} &  \\hdotsfor{3} & Re Y_{M-2,N/2-1} & Im Y_{M-2,N/2-1}& Im Y_{M/2-1,N/2}  \\\\ Re Y_{M/2,0}  &  Re Y_{M-1,1} &  Im Y_{M-1,1} &  \\hdotsfor{3} & Re Y_{M-1,N/2-1} & Im Y_{M-1,N/2-1}& Re Y_{M/2,N/2} \\end{bmatrix}\\f]\n\nIn case of 1D transform of a real vector, the output looks like the first row of the matrix above.\n\nSo, the function chooses an operation mode depending on the flags and size of the input array:\n-   If #DFT_ROWS is set or the input array has a single row or single column, the function\nperforms a 1D forward or inverse transform of each row of a matrix when #DFT_ROWS is set.\nOtherwise, it performs a 2D transform.\n-   If the input array is real and #DFT_INVERSE is not set, the function performs a forward 1D or\n2D transform:\n-   When #DFT_COMPLEX_OUTPUT is set, the output is a complex matrix of the same size as\ninput.\n-   When #DFT_COMPLEX_OUTPUT is not set, the output is a real matrix of the same size as\ninput. In case of 2D transform, it uses the packed format as shown above. In case of a\nsingle 1D transform, it looks like the first row of the matrix above. In case of\nmultiple 1D transforms (when using the #DFT_ROWS flag), each row of the output matrix\nlooks like the first row of the matrix above.\n-   If the input array is complex and either #DFT_INVERSE or #DFT_REAL_OUTPUT are not set, the\noutput is a complex array of the same size as input. The function performs a forward or\ninverse 1D or 2D transform of the whole input array or each row of the input array\nindependently, depending on the flags DFT_INVERSE and DFT_ROWS.\n-   When #DFT_INVERSE is set and the input array is real, or it is complex but #DFT_REAL_OUTPUT\nis set, the output is a real array of the same size as input. The function performs a 1D or 2D\ninverse transformation of the whole input array or each individual row, depending on the flags\n#DFT_INVERSE and #DFT_ROWS.\n\nIf #DFT_SCALE is set, the scaling is done after the transformation.\n\nUnlike dct , the function supports arrays of arbitrary size. But only those arrays are processed\nefficiently, whose sizes can be factorized in a product of small prime numbers (2, 3, and 5 in the\ncurrent implementation). Such an efficient DFT size can be calculated using the getOptimalDFTSize\nmethod.\n\nThe sample below illustrates how to calculate a DFT-based convolution of two 2D real arrays:\n@code\nvoid convolveDFT(InputArray A, InputArray B, OutputArray C)\n{\n// reallocate the output array if needed\nC.create(abs(A.rows - B.rows)+1, abs(A.cols - B.cols)+1, A.type());\nSize dftSize;\n// calculate the size of DFT transform\ndftSize.width = getOptimalDFTSize(A.cols + B.cols - 1);\ndftSize.height = getOptimalDFTSize(A.rows + B.rows - 1);\n\n// allocate temporary buffers and initialize them with 0's\nMat tempA(dftSize, A.type(), Scalar::all(0));\nMat tempB(dftSize, B.type(), Scalar::all(0));\n\n// copy A and B to the top-left corners of tempA and tempB, respectively\nMat roiA(tempA, Rect(0,0,A.cols,A.rows));\nA.copyTo(roiA);\nMat roiB(tempB, Rect(0,0,B.cols,B.rows));\nB.copyTo(roiB);\n\n// now transform the padded A & B in-place;\n// use \"nonzeroRows\" hint for faster processing\ndft(tempA, tempA, 0, A.rows);\ndft(tempB, tempB, 0, B.rows);\n\n// multiply the spectrums;\n// the function handles packed spectrum representations well\nmulSpectrums(tempA, tempB, tempA);\n\n// transform the product back from the frequency domain.\n// Even though all the result rows will be non-zero,\n// you need only the first C.rows of them, and thus you\n// pass nonzeroRows == C.rows\ndft(tempA, tempA, DFT_INVERSE + DFT_SCALE, C.rows);\n\n// now copy the result back to C.\ntempA(Rect(0, 0, C.cols, C.rows)).copyTo(C);\n\n// all the temporary buffers will be deallocated automatically\n}\n@endcode\nTo optimize this sample, consider the following approaches:\n-   Since nonzeroRows != 0 is passed to the forward transform calls and since A and B are copied to\nthe top-left corners of tempA and tempB, respectively, it is not necessary to clear the whole\ntempA and tempB. It is only necessary to clear the tempA.cols - A.cols ( tempB.cols - B.cols)\nrightmost columns of the matrices.\n-   This DFT-based convolution does not have to be applied to the whole big arrays, especially if B\nis significantly smaller than A or vice versa. Instead, you can calculate convolution by parts.\nTo do this, you need to split the output array C into multiple tiles. For each tile, estimate\nwhich parts of A and B are required to calculate convolution in this tile. If the tiles in C are\ntoo small, the speed will decrease a lot because of repeated work. In the ultimate case, when\neach tile in C is a single pixel, the algorithm becomes equivalent to the naive convolution\nalgorithm. If the tiles are too big, the temporary arrays tempA and tempB become too big and\nthere is also a slowdown because of bad cache locality. So, there is an optimal tile size\nsomewhere in the middle.\n-   If different tiles in C can be calculated in parallel and, thus, the convolution is done by\nparts, the loop can be threaded.\n\nAll of the above improvements have been implemented in #matchTemplate and #filter2D . Therefore, by\nusing them, you can get the performance even better than with the above theoretically optimal\nimplementation. Though, those two functions actually calculate cross-correlation, not convolution,\nso you need to \"flip\" the second convolution operand B vertically and horizontally using flip .\n@note\n-   An example using the discrete fourier transform can be found at\nopencv_source_code/samples/cpp/dft.cpp\n-   (Python) An example using the dft functionality to perform Wiener deconvolution can be found\nat opencv_source/samples/python/deconvolution.py\n-   (Python) An example rearranging the quadrants of a Fourier image can be found at\nopencv_source/samples/python/dft.py\n@param src input array that could be real or complex.\n@param dst output array whose size and type depends on the flags .\n@param flags transformation flags, representing a combination of the #DftFlags\n@param nonzeroRows when the parameter is not zero, the function assumes that only the first\nnonzeroRows rows of the input array (#DFT_INVERSE is not set) or only the first nonzeroRows of the\noutput array (#DFT_INVERSE is set) contain non-zeros, thus, the function can handle the rest of the\nrows more efficiently and save some time; this technique is very useful for calculating array\ncross-correlation or convolution using DFT.\n@sa dct , getOptimalDFTSize , mulSpectrums, filter2D , matchTemplate , flip , cartToPolar ,\nmagnitude , phase"]
    #[link_name = "\u{1}_ZN2cv3dftERKNS_11_InputArrayERKNS_12_OutputArrayEii"]
    pub fn cv_dft(
        src: cv_InputArray,
        dst: cv_OutputArray,
        flags: ::std::os::raw::c_int,
        nonzeroRows: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.\n\nidft(src, dst, flags) is equivalent to dft(src, dst, flags | #DFT_INVERSE) .\n@note None of dft and idft scales the result by default. So, you should pass #DFT_SCALE to one of\ndft or idft explicitly to make these transforms mutually inverse.\n@sa dft, dct, idct, mulSpectrums, getOptimalDFTSize\n@param src input floating-point real or complex array.\n@param dst output array whose size and type depend on the flags.\n@param flags operation flags (see dft and #DftFlags).\n@param nonzeroRows number of dst rows to process; the rest of the rows have undefined content (see\nthe convolution sample in dft description."]
    #[link_name = "\u{1}_ZN2cv4idftERKNS_11_InputArrayERKNS_12_OutputArrayEii"]
    pub fn cv_idft(
        src: cv_InputArray,
        dst: cv_OutputArray,
        flags: ::std::os::raw::c_int,
        nonzeroRows: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Performs a forward or inverse discrete Cosine transform of 1D or 2D array.\n\nThe function cv::dct performs a forward or inverse discrete Cosine transform (DCT) of a 1D or 2D\nfloating-point array:\n-   Forward Cosine transform of a 1D vector of N elements:\n\\f[Y = C^{(N)}  \\cdot X\\f]\nwhere\n\\f[C^{(N)}_{jk}= \\sqrt{\\alpha_j/N} \\cos \\left ( \\frac{\\pi(2k+1)j}{2N} \\right )\\f]\nand\n\\f$\\alpha_0=1\\f$, \\f$\\alpha_j=2\\f$ for *j \\> 0*.\n-   Inverse Cosine transform of a 1D vector of N elements:\n\\f[X =  \\left (C^{(N)} \\right )^{-1}  \\cdot Y =  \\left (C^{(N)} \\right )^T  \\cdot Y\\f]\n(since \\f$C^{(N)}\\f$ is an orthogonal matrix, \\f$C^{(N)} \\cdot \\left(C^{(N)}\\right)^T = I\\f$ )\n-   Forward 2D Cosine transform of M x N matrix:\n\\f[Y = C^{(N)}  \\cdot X  \\cdot \\left (C^{(N)} \\right )^T\\f]\n-   Inverse 2D Cosine transform of M x N matrix:\n\\f[X =  \\left (C^{(N)} \\right )^T  \\cdot X  \\cdot C^{(N)}\\f]\n\nThe function chooses the mode of operation by looking at the flags and size of the input array:\n-   If (flags & #DCT_INVERSE) == 0 , the function does a forward 1D or 2D transform. Otherwise, it\nis an inverse 1D or 2D transform.\n-   If (flags & #DCT_ROWS) != 0 , the function performs a 1D transform of each row.\n-   If the array is a single column or a single row, the function performs a 1D transform.\n-   If none of the above is true, the function performs a 2D transform.\n\n@note Currently dct supports even-size arrays (2, 4, 6 ...). For data analysis and approximation, you\ncan pad the array when necessary.\nAlso, the function performance depends very much, and not monotonically, on the array size (see\ngetOptimalDFTSize ). In the current implementation DCT of a vector of size N is calculated via DFT\nof a vector of size N/2 . Thus, the optimal DCT size N1 \\>= N can be calculated as:\n@code\nsize_t getOptimalDCTSize(size_t N) { return 2*getOptimalDFTSize((N+1)/2); }\nN1 = getOptimalDCTSize(N);\n@endcode\n@param src input floating-point array.\n@param dst output array of the same size and type as src .\n@param flags transformation flags as a combination of cv::DftFlags (DCT_*)\n@sa dft , getOptimalDFTSize , idct"]
    #[link_name = "\u{1}_ZN2cv3dctERKNS_11_InputArrayERKNS_12_OutputArrayEi"]
    pub fn cv_dct(src: cv_InputArray, dst: cv_OutputArray, flags: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @brief Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.\n\nidct(src, dst, flags) is equivalent to dct(src, dst, flags | DCT_INVERSE).\n@param src input floating-point single-channel array.\n@param dst output array of the same size and type as src.\n@param flags operation flags.\n@sa  dct, dft, idft, getOptimalDFTSize"]
    #[link_name = "\u{1}_ZN2cv4idctERKNS_11_InputArrayERKNS_12_OutputArrayEi"]
    pub fn cv_idct(src: cv_InputArray, dst: cv_OutputArray, flags: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @brief Performs the per-element multiplication of two Fourier spectrums.\n\nThe function cv::mulSpectrums performs the per-element multiplication of the two CCS-packed or complex\nmatrices that are results of a real or complex Fourier transform.\n\nThe function, together with dft and idft , may be used to calculate convolution (pass conjB=false )\nor correlation (pass conjB=true ) of two arrays rapidly. When the arrays are complex, they are\nsimply multiplied (per element) with an optional conjugation of the second-array elements. When the\narrays are real, they are assumed to be CCS-packed (see dft for details).\n@param a first input array.\n@param b second input array of the same size and type as src1 .\n@param c output array of the same size and type as src1 .\n@param flags operation flags; currently, the only supported flag is cv::DFT_ROWS, which indicates that\neach row of src1 and src2 is an independent 1D Fourier spectrum. If you do not want to use this flag, then simply add a `0` as value.\n@param conjB optional flag that conjugates the second input array before the multiplication (true)\nor not (false)."]
    #[link_name = "\u{1}_ZN2cv12mulSpectrumsERKNS_11_InputArrayES2_RKNS_12_OutputArrayEib"]
    pub fn cv_mulSpectrums(
        a: cv_InputArray,
        b: cv_InputArray,
        c: cv_OutputArray,
        flags: ::std::os::raw::c_int,
        conjB: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief Returns the optimal DFT size for a given vector size.\n\nDFT performance is not a monotonic function of a vector size. Therefore, when you calculate\nconvolution of two arrays or perform the spectral analysis of an array, it usually makes sense to\npad the input data with zeros to get a bit larger array that can be transformed much faster than the\noriginal one. Arrays whose size is a power-of-two (2, 4, 8, 16, 32, ...) are the fastest to process.\nThough, the arrays whose size is a product of 2's, 3's, and 5's (for example, 300 = 5\\*5\\*3\\*2\\*2)\nare also processed quite efficiently.\n\nThe function cv::getOptimalDFTSize returns the minimum number N that is greater than or equal to vecsize\nso that the DFT of a vector of size N can be processed efficiently. In the current implementation N\n= 2 ^p^ \\* 3 ^q^ \\* 5 ^r^ for some integer p, q, r.\n\nThe function returns a negative number if vecsize is too large (very close to INT_MAX ).\n\nWhile the function cannot be used directly to estimate the optimal vector size for DCT transform\n(since the current DCT implementation supports only even-size vectors), it can be easily processed\nas getOptimalDFTSize((vecsize+1)/2)\\*2.\n@param vecsize vector size.\n@sa dft , dct , idft , idct , mulSpectrums"]
    #[link_name = "\u{1}_ZN2cv17getOptimalDFTSizeEi"]
    pub fn cv_getOptimalDFTSize(vecsize: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Returns the default random number generator.\n\nThe function cv::theRNG returns the default random number generator. For each thread, there is a\nseparate random number generator, so you can use the function safely in multi-thread environments.\nIf you just need to get a single random number using this generator or initialize an array, you can\nuse randu or randn instead. But if you are going to generate many random numbers inside a loop, it\nis much faster to use this function to retrieve the generator and then use RNG::operator _Tp() .\n@sa RNG, randu, randn"]
    #[link_name = "\u{1}_ZN2cv6theRNGEv"]
    pub fn cv_theRNG() -> *mut cv_RNG;
}
unsafe extern "C" {
    #[doc = " @brief Sets state of default random number generator.\n\nThe function cv::setRNGSeed sets state of default random number generator to custom value.\n@param seed new state for default random number generator\n@sa RNG, randu, randn"]
    #[link_name = "\u{1}_ZN2cv10setRNGSeedEi"]
    pub fn cv_setRNGSeed(seed: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @brief Generates a single uniformly-distributed random number or an array of random numbers.\n\nNon-template variant of the function fills the matrix dst with uniformly-distributed\nrandom numbers from the specified range:\n\\f[\\texttt{low} _c  \\leq \\texttt{dst} (I)_c <  \\texttt{high} _c\\f]\n@param dst output array of random numbers; the array must be pre-allocated.\n@param low inclusive lower boundary of the generated random numbers.\n@param high exclusive upper boundary of the generated random numbers.\n@sa RNG, randn, theRNG"]
    #[link_name = "\u{1}_ZN2cv5randuERKNS_17_InputOutputArrayERKNS_11_InputArrayES5_"]
    pub fn cv_randu(dst: cv_InputOutputArray, low: cv_InputArray, high: cv_InputArray);
}
unsafe extern "C" {
    #[doc = " @brief Fills the array with normally distributed random numbers.\n\nThe function cv::randn fills the matrix dst with normally distributed random numbers with the specified\nmean vector and the standard deviation matrix. The generated random numbers are clipped to fit the\nvalue range of the output array data type.\n@param dst output array of random numbers; the array must be pre-allocated and have 1 to 4 channels.\n@param mean mean value (expectation) of the generated random numbers.\n@param stddev standard deviation of the generated random numbers; it can be either a vector (in\nwhich case a diagonal standard deviation matrix is assumed) or a square matrix.\n@sa RNG, randu"]
    #[link_name = "\u{1}_ZN2cv5randnERKNS_17_InputOutputArrayERKNS_11_InputArrayES5_"]
    pub fn cv_randn(dst: cv_InputOutputArray, mean: cv_InputArray, stddev: cv_InputArray);
}
unsafe extern "C" {
    #[doc = " @brief Shuffles the array elements randomly.\n\nThe function cv::randShuffle shuffles the specified 1D array by randomly choosing pairs of elements and\nswapping them. The number of such swap operations will be dst.rows\\*dst.cols\\*iterFactor .\n@param dst input/output numerical 1D array.\n@param iterFactor scale factor that determines the number of random swap operations (see the details\nbelow).\n@param rng optional random number generator used for shuffling; if it is zero, theRNG () is used\ninstead.\n@sa RNG, sort"]
    #[link_name = "\u{1}_ZN2cv11randShuffleERKNS_17_InputOutputArrayEdPNS_3RNGE"]
    pub fn cv_randShuffle(dst: cv_InputOutputArray, iterFactor: f64, rng: *mut cv_RNG);
}
#[doc = " @brief Principal Component Analysis\n\nThe class is used to calculate a special basis for a set of vectors. The\nbasis will consist of eigenvectors of the covariance matrix calculated\nfrom the input set of vectors. The class %PCA can also transform\nvectors to/from the new coordinate space defined by the basis. Usually,\nin this new coordinate system, each vector from the original set (and\nany linear combination of such vectors) can be quite accurately\napproximated by taking its first few components, corresponding to the\neigenvectors of the largest eigenvalues of the covariance matrix.\nGeometrically it means that you calculate a projection of the vector to\na subspace formed by a few eigenvectors corresponding to the dominant\neigenvalues of the covariance matrix. And usually such a projection is\nvery close to the original vector. So, you can represent the original\nvector from a high-dimensional space with a much shorter vector\nconsisting of the projected vector's coordinates in the subspace. Such a\ntransformation is also known as Karhunen-Loeve Transform, or KLT.\nSee http://en.wikipedia.org/wiki/Principal_component_analysis\n\nThe sample below is the function that takes two matrices. The first\nfunction stores a set of vectors (a row per vector) that is used to\ncalculate PCA. The second function stores another \"test\" set of vectors\n(a row per vector). First, these vectors are compressed with PCA, then\nreconstructed back, and then the reconstruction error norm is computed\nand printed for each vector. :\n\n@code{.cpp}\nusing namespace cv;\n\nPCA compressPCA(const Mat& pcaset, int maxComponents,\nconst Mat& testset, Mat& compressed)\n{\nPCA pca(pcaset, // pass the data\nMat(), // we do not have a pre-computed mean vector,\n// so let the PCA engine to compute it\nPCA::DATA_AS_ROW, // indicate that the vectors\n// are stored as matrix rows\n// (use PCA::DATA_AS_COL if the vectors are\n// the matrix columns)\nmaxComponents // specify, how many principal components to retain\n);\n// if there is no test data, just return the computed basis, ready-to-use\nif( !testset.data )\nreturn pca;\nCV_Assert( testset.cols == pcaset.cols );\n\ncompressed.create(testset.rows, maxComponents, testset.type());\n\nMat reconstructed;\nfor( int i = 0; i < testset.rows; i++ )\n{\nMat vec = testset.row(i), coeffs = compressed.row(i), reconstructed;\n// compress the vector, the result will be stored\n// in the i-th row of the output matrix\npca.project(vec, coeffs);\n// and then reconstruct it\npca.backProject(coeffs, reconstructed);\n// and measure the error\nprintf(\"%d. diff = %g\\n\", i, norm(vec, reconstructed, NORM_L2));\n}\nreturn pca;\n}\n@endcode\n@sa calcCovarMatrix, mulTransposed, SVD, dft, dct"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_PCA {
    #[doc = "!< eigenvectors of the covariation matrix"]
    pub eigenvectors: cv_Mat,
    #[doc = "!< eigenvalues of the covariation matrix"]
    pub eigenvalues: cv_Mat,
    #[doc = "!< mean value subtracted before the projection and added after the back projection"]
    pub mean: cv_Mat,
}
#[doc = "!< indicates that the input samples are stored as matrix rows"]
pub const cv_PCA_Flags_DATA_AS_ROW: cv_PCA_Flags = 0;
#[doc = "!< indicates that the input samples are stored as matrix columns"]
pub const cv_PCA_Flags_DATA_AS_COL: cv_PCA_Flags = 1;
pub const cv_PCA_Flags_USE_AVG: cv_PCA_Flags = 2;
pub type cv_PCA_Flags = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_PCA"][::std::mem::size_of::<cv_PCA>() - 288usize];
    ["Alignment of cv_PCA"][::std::mem::align_of::<cv_PCA>() - 8usize];
    ["Offset of field: cv_PCA::eigenvectors"]
        [::std::mem::offset_of!(cv_PCA, eigenvectors) - 0usize];
    ["Offset of field: cv_PCA::eigenvalues"][::std::mem::offset_of!(cv_PCA, eigenvalues) - 96usize];
    ["Offset of field: cv_PCA::mean"][::std::mem::offset_of!(cv_PCA, mean) - 192usize];
};
unsafe extern "C" {
    #[doc = " @brief Projects vector(s) to the principal component subspace.\n\nThe methods project one or more vectors to the principal component\nsubspace, where each vector projection is represented by coefficients in\nthe principal component basis. The first form of the method returns the\nmatrix that the second form writes to the result. So the first form can\nbe used as a part of expression while the second form can be more\nefficient in a processing loop.\n@param vec input vector(s); must have the same dimensionality and the\nsame layout as the input data used at %PCA phase, that is, if\nDATA_AS_ROW are specified, then `vec.cols==data.cols`\n(vector dimensionality) and `vec.rows` is the number of vectors to\nproject, and the same is true for the PCA::DATA_AS_COL case."]
    #[link_name = "\u{1}_ZNK2cv3PCA7projectERKNS_11_InputArrayE"]
    pub fn cv_PCA_project(this: *const cv_PCA, vec: cv_InputArray) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @overload\n@param vec input vector(s); must have the same dimensionality and the\nsame layout as the input data used at PCA phase, that is, if\nDATA_AS_ROW are specified, then `vec.cols==data.cols`\n(vector dimensionality) and `vec.rows` is the number of vectors to\nproject, and the same is true for the PCA::DATA_AS_COL case.\n@param result output vectors; in case of PCA::DATA_AS_COL, the\noutput matrix has as many columns as the number of input vectors, this\nmeans that `result.cols==vec.cols` and the number of rows match the\nnumber of principal components (for example, `maxComponents` parameter\npassed to the constructor)."]
    #[link_name = "\u{1}_ZNK2cv3PCA7projectERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_PCA_project1(this: *const cv_PCA, vec: cv_InputArray, result: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief Reconstructs vectors from their PC projections.\n\nThe methods are inverse operations to PCA::project. They take PC\ncoordinates of projected vectors and reconstruct the original vectors.\nUnless all the principal components have been retained, the\nreconstructed vectors are different from the originals. But typically,\nthe difference is small if the number of components is large enough (but\nstill much smaller than the original vector dimensionality). As a\nresult, PCA is used.\n@param vec coordinates of the vectors in the principal component\nsubspace, the layout and size are the same as of PCA::project output\nvectors."]
    #[link_name = "\u{1}_ZNK2cv3PCA11backProjectERKNS_11_InputArrayE"]
    pub fn cv_PCA_backProject(this: *const cv_PCA, vec: cv_InputArray) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @overload\n@param vec coordinates of the vectors in the principal component\nsubspace, the layout and size are the same as of PCA::project output\nvectors.\n@param result reconstructed vectors; the layout and size are the same as\nof PCA::project input vectors."]
    #[link_name = "\u{1}_ZNK2cv3PCA11backProjectERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_PCA_backProject1(this: *const cv_PCA, vec: cv_InputArray, result: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief write PCA objects\n\nWrites @ref eigenvalues @ref eigenvectors and @ref mean to specified FileStorage"]
    #[link_name = "\u{1}_ZNK2cv3PCA5writeERNS_11FileStorageE"]
    pub fn cv_PCA_write(this: *const cv_PCA, fs: *mut cv_FileStorage);
}
unsafe extern "C" {
    #[doc = " @brief load PCA objects\n\nLoads @ref eigenvalues @ref eigenvectors and @ref mean from specified FileNode"]
    #[link_name = "\u{1}_ZN2cv3PCA4readERKNS_8FileNodeE"]
    pub fn cv_PCA_read(this: *mut cv_PCA, fn_: *const cv_FileNode);
}
unsafe extern "C" {
    #[doc = " @brief default constructor\n\nThe default constructor initializes an empty %PCA structure. The other\nconstructors initialize the structure and call PCA::operator()()."]
    #[link_name = "\u{1}_ZN2cv3PCAC1Ev"]
    pub fn cv_PCA_PCA(this: *mut cv_PCA);
}
unsafe extern "C" {
    #[doc = " @overload\n@param data input samples stored as matrix rows or matrix columns.\n@param mean optional mean value; if the matrix is empty (@c noArray()),\nthe mean is computed from the data.\n@param flags operation flags; currently the parameter is only used to\nspecify the data layout (PCA::Flags)\n@param maxComponents maximum number of components that %PCA should\nretain; by default, all the components are retained."]
    #[link_name = "\u{1}_ZN2cv3PCAC1ERKNS_11_InputArrayES3_ii"]
    pub fn cv_PCA_PCA1(
        this: *mut cv_PCA,
        data: cv_InputArray,
        mean: cv_InputArray,
        flags: ::std::os::raw::c_int,
        maxComponents: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param data input samples stored as matrix rows or matrix columns.\n@param mean optional mean value; if the matrix is empty (noArray()),\nthe mean is computed from the data.\n@param flags operation flags; currently the parameter is only used to\nspecify the data layout (PCA::Flags)\n@param retainedVariance Percentage of variance that PCA should retain.\nUsing this parameter will let the PCA decided how many components to\nretain but it will always keep at least 2."]
    #[link_name = "\u{1}_ZN2cv3PCAC1ERKNS_11_InputArrayES3_id"]
    pub fn cv_PCA_PCA2(
        this: *mut cv_PCA,
        data: cv_InputArray,
        mean: cv_InputArray,
        flags: ::std::os::raw::c_int,
        retainedVariance: f64,
    );
}
impl cv_PCA {
    #[inline]
    pub unsafe fn project(&self, vec: cv_InputArray) -> cv_Mat {
        cv_PCA_project(self, vec)
    }
    #[inline]
    pub unsafe fn project1(&self, vec: cv_InputArray, result: cv_OutputArray) {
        cv_PCA_project1(self, vec, result)
    }
    #[inline]
    pub unsafe fn backProject(&self, vec: cv_InputArray) -> cv_Mat {
        cv_PCA_backProject(self, vec)
    }
    #[inline]
    pub unsafe fn backProject1(&self, vec: cv_InputArray, result: cv_OutputArray) {
        cv_PCA_backProject1(self, vec, result)
    }
    #[inline]
    pub unsafe fn write(&self, fs: *mut cv_FileStorage) {
        cv_PCA_write(self, fs)
    }
    #[inline]
    pub unsafe fn read(&mut self, fn_: *const cv_FileNode) {
        cv_PCA_read(self, fn_)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_PCA_PCA(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        data: cv_InputArray,
        mean: cv_InputArray,
        flags: ::std::os::raw::c_int,
        maxComponents: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_PCA_PCA1(__bindgen_tmp.as_mut_ptr(), data, mean, flags, maxComponents);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(
        data: cv_InputArray,
        mean: cv_InputArray,
        flags: ::std::os::raw::c_int,
        retainedVariance: f64,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_PCA_PCA2(
            __bindgen_tmp.as_mut_ptr(),
            data,
            mean,
            flags,
            retainedVariance,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = "@brief Linear Discriminant Analysis\n@todo document this class"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_LDA {
    pub _num_components: ::std::os::raw::c_int,
    pub _eigenvectors: cv_Mat,
    pub _eigenvalues: cv_Mat,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_LDA"][::std::mem::size_of::<cv_LDA>() - 200usize];
    ["Alignment of cv_LDA"][::std::mem::align_of::<cv_LDA>() - 8usize];
    ["Offset of field: cv_LDA::_num_components"]
        [::std::mem::offset_of!(cv_LDA, _num_components) - 0usize];
    ["Offset of field: cv_LDA::_eigenvectors"]
        [::std::mem::offset_of!(cv_LDA, _eigenvectors) - 8usize];
    ["Offset of field: cv_LDA::_eigenvalues"]
        [::std::mem::offset_of!(cv_LDA, _eigenvalues) - 104usize];
};
unsafe extern "C" {
    #[doc = " Serializes this object to a given filename."]
    #[link_name = "\u{1}_ZNK2cv3LDA4saveERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_LDA_save(this: *const cv_LDA, filename: *const cv_String);
}
unsafe extern "C" {
    #[doc = " Deserializes this object from a given filename."]
    #[link_name = "\u{1}_ZN2cv3LDA4loadERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_LDA_load(this: *mut cv_LDA, filename: *const cv_String);
}
unsafe extern "C" {
    #[doc = " Serializes this object to a given cv::FileStorage."]
    #[link_name = "\u{1}_ZNK2cv3LDA4saveERNS_11FileStorageE"]
    pub fn cv_LDA_save1(this: *const cv_LDA, fs: *mut cv_FileStorage);
}
unsafe extern "C" {
    #[doc = " Deserializes this object from a given cv::FileStorage."]
    #[link_name = "\u{1}_ZN2cv3LDA4loadERKNS_11FileStorageE"]
    pub fn cv_LDA_load1(this: *mut cv_LDA, node: *const cv_FileStorage);
}
unsafe extern "C" {
    #[doc = " Compute the discriminants for data in src (row aligned) and labels."]
    #[link_name = "\u{1}_ZN2cv3LDA7computeERKNS_11_InputArrayES3_"]
    pub fn cv_LDA_compute(this: *mut cv_LDA, src: cv_InputArrayOfArrays, labels: cv_InputArray);
}
unsafe extern "C" {
    #[doc = " Projects samples into the LDA subspace.\nsrc may be one or more row aligned samples."]
    #[link_name = "\u{1}_ZN2cv3LDA7projectERKNS_11_InputArrayE"]
    pub fn cv_LDA_project(this: *mut cv_LDA, src: cv_InputArray) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " Reconstructs projections from the LDA subspace.\nsrc may be one or more row aligned projections."]
    #[link_name = "\u{1}_ZN2cv3LDA11reconstructERKNS_11_InputArrayE"]
    pub fn cv_LDA_reconstruct(this: *mut cv_LDA, src: cv_InputArray) -> cv_Mat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3LDA15subspaceProjectERKNS_11_InputArrayES3_S3_"]
    pub fn cv_LDA_subspaceProject(
        W: cv_InputArray,
        mean: cv_InputArray,
        src: cv_InputArray,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3LDA19subspaceReconstructERKNS_11_InputArrayES3_S3_"]
    pub fn cv_LDA_subspaceReconstruct(
        W: cv_InputArray,
        mean: cv_InputArray,
        src: cv_InputArray,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3LDA3ldaERKNS_11_InputArrayES3_"]
    pub fn cv_LDA_lda(this: *mut cv_LDA, src: cv_InputArrayOfArrays, labels: cv_InputArray);
}
unsafe extern "C" {
    #[doc = " @brief constructor\nInitializes a LDA with num_components (default 0)."]
    #[link_name = "\u{1}_ZN2cv3LDAC1Ei"]
    pub fn cv_LDA_LDA(this: *mut cv_LDA, num_components: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Initializes and performs a Discriminant Analysis with Fisher's\nOptimization Criterion on given data in src and corresponding labels\nin labels. If 0 (or less) number of components are given, they are\nautomatically determined for given data in computation."]
    #[link_name = "\u{1}_ZN2cv3LDAC1ERKNS_11_InputArrayES3_i"]
    pub fn cv_LDA_LDA1(
        this: *mut cv_LDA,
        src: cv_InputArrayOfArrays,
        labels: cv_InputArray,
        num_components: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " destructor"]
    #[link_name = "\u{1}_ZN2cv3LDAD1Ev"]
    pub fn cv_LDA_LDA_destructor(this: *mut cv_LDA);
}
impl cv_LDA {
    #[inline]
    pub unsafe fn save(&self, filename: *const cv_String) {
        cv_LDA_save(self, filename)
    }
    #[inline]
    pub unsafe fn load(&mut self, filename: *const cv_String) {
        cv_LDA_load(self, filename)
    }
    #[inline]
    pub unsafe fn save1(&self, fs: *mut cv_FileStorage) {
        cv_LDA_save1(self, fs)
    }
    #[inline]
    pub unsafe fn load1(&mut self, node: *const cv_FileStorage) {
        cv_LDA_load1(self, node)
    }
    #[inline]
    pub unsafe fn compute(&mut self, src: cv_InputArrayOfArrays, labels: cv_InputArray) {
        cv_LDA_compute(self, src, labels)
    }
    #[inline]
    pub unsafe fn project(&mut self, src: cv_InputArray) -> cv_Mat {
        cv_LDA_project(self, src)
    }
    #[inline]
    pub unsafe fn reconstruct(&mut self, src: cv_InputArray) -> cv_Mat {
        cv_LDA_reconstruct(self, src)
    }
    #[inline]
    pub unsafe fn subspaceProject(
        W: cv_InputArray,
        mean: cv_InputArray,
        src: cv_InputArray,
    ) -> cv_Mat {
        cv_LDA_subspaceProject(W, mean, src)
    }
    #[inline]
    pub unsafe fn subspaceReconstruct(
        W: cv_InputArray,
        mean: cv_InputArray,
        src: cv_InputArray,
    ) -> cv_Mat {
        cv_LDA_subspaceReconstruct(W, mean, src)
    }
    #[inline]
    pub unsafe fn lda(&mut self, src: cv_InputArrayOfArrays, labels: cv_InputArray) {
        cv_LDA_lda(self, src, labels)
    }
    #[inline]
    pub unsafe fn new(num_components: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_LDA_LDA(__bindgen_tmp.as_mut_ptr(), num_components);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        src: cv_InputArrayOfArrays,
        labels: cv_InputArray,
        num_components: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_LDA_LDA1(__bindgen_tmp.as_mut_ptr(), src, labels, num_components);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cv_LDA_LDA_destructor(self)
    }
}
#[doc = " @brief Singular Value Decomposition\n\nClass for computing Singular Value Decomposition of a floating-point\nmatrix. The Singular Value Decomposition is used to solve least-square\nproblems, under-determined linear systems, invert matrices, compute\ncondition numbers, and so on.\n\nIf you want to compute a condition number of a matrix or an absolute value of\nits determinant, you do not need `u` and `vt`. You can pass\nflags=SVD::NO_UV|... . Another flag SVD::FULL_UV indicates that full-size u\nand vt must be computed, which is not necessary most of the time.\n\n@sa invert, solve, eigen, determinant"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_SVD {
    pub u: cv_Mat,
    pub w: cv_Mat,
    pub vt: cv_Mat,
}
#[doc = " allow the algorithm to modify the decomposed matrix; it can save space and speed up\nprocessing. currently ignored."]
pub const cv_SVD_Flags_MODIFY_A: cv_SVD_Flags = 1;
#[doc = " indicates that only a vector of singular values `w` is to be processed, while u and vt\nwill be set to empty matrices"]
pub const cv_SVD_Flags_NO_UV: cv_SVD_Flags = 2;
#[doc = " when the matrix is not square, by default the algorithm produces u and vt matrices of\nsufficiently large size for the further A reconstruction; if, however, FULL_UV flag is\nspecified, u and vt will be full-size square orthogonal matrices."]
pub const cv_SVD_Flags_FULL_UV: cv_SVD_Flags = 4;
pub type cv_SVD_Flags = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_SVD"][::std::mem::size_of::<cv_SVD>() - 288usize];
    ["Alignment of cv_SVD"][::std::mem::align_of::<cv_SVD>() - 8usize];
    ["Offset of field: cv_SVD::u"][::std::mem::offset_of!(cv_SVD, u) - 0usize];
    ["Offset of field: cv_SVD::w"][::std::mem::offset_of!(cv_SVD, w) - 96usize];
    ["Offset of field: cv_SVD::vt"][::std::mem::offset_of!(cv_SVD, vt) - 192usize];
};
unsafe extern "C" {
    #[doc = " @brief decomposes matrix and stores the results to user-provided matrices\n\nThe methods/functions perform SVD of matrix. Unlike SVD::SVD constructor\nand SVD::operator(), they store the results to the user-provided\nmatrices:\n\n@code{.cpp}\nMat A, w, u, vt;\nSVD::compute(A, w, u, vt);\n@endcode\n\n@param src decomposed matrix. The depth has to be CV_32F or CV_64F.\n@param w calculated singular values\n@param u calculated left singular vectors\n@param vt transposed matrix of right singular vectors\n@param flags operation flags - see SVD::Flags."]
    #[link_name = "\u{1}_ZN2cv3SVD7computeERKNS_11_InputArrayERKNS_12_OutputArrayES6_S6_i"]
    pub fn cv_SVD_compute(
        src: cv_InputArray,
        w: cv_OutputArray,
        u: cv_OutputArray,
        vt: cv_OutputArray,
        flags: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @overload\ncomputes singular values of a matrix\n@param src decomposed matrix. The depth has to be CV_32F or CV_64F.\n@param w calculated singular values\n@param flags operation flags - see SVD::Flags."]
    #[link_name = "\u{1}_ZN2cv3SVD7computeERKNS_11_InputArrayERKNS_12_OutputArrayEi"]
    pub fn cv_SVD_compute1(src: cv_InputArray, w: cv_OutputArray, flags: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @brief performs back substitution"]
    #[link_name = "\u{1}_ZN2cv3SVD9backSubstERKNS_11_InputArrayES3_S3_S3_RKNS_12_OutputArrayE"]
    pub fn cv_SVD_backSubst(
        w: cv_InputArray,
        u: cv_InputArray,
        vt: cv_InputArray,
        rhs: cv_InputArray,
        dst: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief performs a singular value back substitution.\n\nThe method calculates a back substitution for the specified right-hand\nside:\n\n\\f[\\texttt{x} =  \\texttt{vt} ^T  \\cdot diag( \\texttt{w} )^{-1}  \\cdot \\texttt{u} ^T  \\cdot \\texttt{rhs} \\sim \\texttt{A} ^{-1}  \\cdot \\texttt{rhs}\\f]\n\nUsing this technique you can either get a very accurate solution of the\nconvenient linear system, or the best (in the least-squares terms)\npseudo-solution of an overdetermined linear system.\n\n@param rhs right-hand side of a linear system (u\\*w\\*v')\\*dst = rhs to\nbe solved, where A has been previously decomposed.\n\n@param dst found solution of the system.\n\n@note Explicit SVD with the further back substitution only makes sense\nif you need to solve many linear systems with the same left-hand side\n(for example, src ). If all you need is to solve a single system\n(possibly with multiple rhs immediately available), simply call solve\nadd pass #DECOMP_SVD there. It does absolutely the same thing."]
    #[link_name = "\u{1}_ZNK2cv3SVD9backSubstERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_SVD_backSubst1(this: *const cv_SVD, rhs: cv_InputArray, dst: cv_OutputArray);
}
impl cv_SVD {
    #[inline]
    pub unsafe fn compute(
        src: cv_InputArray,
        w: cv_OutputArray,
        u: cv_OutputArray,
        vt: cv_OutputArray,
        flags: ::std::os::raw::c_int,
    ) {
        cv_SVD_compute(src, w, u, vt, flags)
    }
    #[inline]
    pub unsafe fn compute1(src: cv_InputArray, w: cv_OutputArray, flags: ::std::os::raw::c_int) {
        cv_SVD_compute1(src, w, flags)
    }
    #[inline]
    pub unsafe fn backSubst(
        w: cv_InputArray,
        u: cv_InputArray,
        vt: cv_InputArray,
        rhs: cv_InputArray,
        dst: cv_OutputArray,
    ) {
        cv_SVD_backSubst(w, u, vt, rhs, dst)
    }
    #[inline]
    pub unsafe fn backSubst1(&self, rhs: cv_InputArray, dst: cv_OutputArray) {
        cv_SVD_backSubst1(self, rhs, dst)
    }
}
#[doc = " @brief Random Number Generator\n\nRandom number generator. It encapsulates the state (currently, a 64-bit\ninteger) and has methods to return scalar random values and to fill\narrays with random values. Currently it supports uniform and Gaussian\n(normal) distributions. The generator uses Multiply-With-Carry\nalgorithm, introduced by G. Marsaglia (\n<http://en.wikipedia.org/wiki/Multiply-with-carry> ).\nGaussian-distribution random numbers are generated using the Ziggurat\nalgorithm ( <http://en.wikipedia.org/wiki/Ziggurat_algorithm> ),\nintroduced by G. Marsaglia and W. W. Tsang."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_RNG {
    pub state: uint64,
}
pub const cv_RNG_UNIFORM: cv_RNG__bindgen_ty_1 = 0;
pub const cv_RNG_NORMAL: cv_RNG__bindgen_ty_1 = 1;
pub type cv_RNG__bindgen_ty_1 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_RNG"][::std::mem::size_of::<cv_RNG>() - 8usize];
    ["Alignment of cv_RNG"][::std::mem::align_of::<cv_RNG>() - 8usize];
    ["Offset of field: cv_RNG::state"][::std::mem::offset_of!(cv_RNG, state) - 0usize];
};
unsafe extern "C" {
    #[doc = " @brief Fills arrays with random numbers.\n\n@param mat 2D or N-dimensional matrix; currently matrices with more than\n4 channels are not supported by the methods, use Mat::reshape as a\npossible workaround.\n@param distType distribution type, RNG::UNIFORM or RNG::NORMAL.\n@param a first distribution parameter; in case of the uniform\ndistribution, this is an inclusive lower boundary, in case of the normal\ndistribution, this is a mean value.\n@param b second distribution parameter; in case of the uniform\ndistribution, this is a non-inclusive upper boundary, in case of the\nnormal distribution, this is a standard deviation (diagonal of the\nstandard deviation matrix or the full standard deviation matrix).\n@param saturateRange pre-saturation flag; for uniform distribution only;\nif true, the method will first convert a and b to the acceptable value\nrange (according to the mat datatype) and then will generate uniformly\ndistributed random numbers within the range [saturate(a), saturate(b)),\nif saturateRange=false, the method will generate uniformly distributed\nrandom numbers in the original range [a, b) and then will saturate them,\nit means, for example, that\n<tt>theRNG().fill(mat_8u, RNG::UNIFORM, -DBL_MAX, DBL_MAX)</tt> will likely\nproduce array mostly filled with 0's and 255's, since the range (0, 255)\nis significantly smaller than [-DBL_MAX, DBL_MAX).\n\nEach of the methods fills the matrix with the random values from the\nspecified distribution. As the new numbers are generated, the RNG state\nis updated accordingly. In case of multiple-channel images, every\nchannel is filled independently, which means that RNG cannot generate\nsamples from the multi-dimensional Gaussian distribution with\nnon-diagonal covariance matrix directly. To do that, the method\ngenerates samples from multi-dimensional standard Gaussian distribution\nwith zero mean and identity covariation matrix, and then transforms them\nusing transform to get samples from the specified Gaussian distribution."]
    #[link_name = "\u{1}_ZN2cv3RNG4fillERKNS_17_InputOutputArrayEiRKNS_11_InputArrayES6_b"]
    pub fn cv_RNG_fill(
        this: *mut cv_RNG,
        mat: cv_InputOutputArray,
        distType: ::std::os::raw::c_int,
        a: cv_InputArray,
        b: cv_InputArray,
        saturateRange: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief Returns the next random number sampled from the Gaussian distribution\n@param sigma standard deviation of the distribution.\n\nThe method transforms the state using the MWC algorithm and returns the\nnext random number from the Gaussian distribution N(0,sigma) . That is,\nthe mean value of the returned random numbers is zero and the standard\ndeviation is the specified sigma ."]
    #[link_name = "\u{1}_ZN2cv3RNG8gaussianEd"]
    pub fn cv_RNG_gaussian(this: *mut cv_RNG, sigma: f64) -> f64;
}
impl cv_RNG {
    #[inline]
    pub unsafe fn fill(
        &mut self,
        mat: cv_InputOutputArray,
        distType: ::std::os::raw::c_int,
        a: cv_InputArray,
        b: cv_InputArray,
        saturateRange: bool,
    ) {
        cv_RNG_fill(self, mat, distType, a, b, saturateRange)
    }
    #[inline]
    pub unsafe fn gaussian(&mut self, sigma: f64) -> f64 {
        cv_RNG_gaussian(self, sigma)
    }
}
#[doc = " @brief Mersenne Twister random number generator\n\nInspired by http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/CODES/mt19937ar.c\n@todo document"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_RNG_MT19937 {
    pub state: [::std::os::raw::c_uint; 624usize],
    pub mti: ::std::os::raw::c_int,
}
pub const cv_RNG_MT19937_PeriodParameters_N: cv_RNG_MT19937_PeriodParameters = 624;
pub const cv_RNG_MT19937_PeriodParameters_M: cv_RNG_MT19937_PeriodParameters = 397;
pub type cv_RNG_MT19937_PeriodParameters = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_RNG_MT19937"][::std::mem::size_of::<cv_RNG_MT19937>() - 2500usize];
    ["Alignment of cv_RNG_MT19937"][::std::mem::align_of::<cv_RNG_MT19937>() - 4usize];
    ["Offset of field: cv_RNG_MT19937::state"]
        [::std::mem::offset_of!(cv_RNG_MT19937, state) - 0usize];
    ["Offset of field: cv_RNG_MT19937::mti"]
        [::std::mem::offset_of!(cv_RNG_MT19937, mti) - 2496usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv11RNG_MT199374seedEj"]
    pub fn cv_RNG_MT19937_seed(this: *mut cv_RNG_MT19937, s: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv11RNG_MT199374nextEv"]
    pub fn cv_RNG_MT19937_next(this: *mut cv_RNG_MT19937) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " @brief returns uniformly distributed integer random number from [a,b) range"]
    #[link_name = "\u{1}_ZN2cv11RNG_MT199377uniformEii"]
    pub fn cv_RNG_MT19937_uniform(
        this: *mut cv_RNG_MT19937,
        a: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief returns uniformly distributed floating-point random number from [a,b) range"]
    #[link_name = "\u{1}_ZN2cv11RNG_MT199377uniformEff"]
    pub fn cv_RNG_MT19937_uniform1(this: *mut cv_RNG_MT19937, a: f32, b: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " @brief returns uniformly distributed double-precision floating-point random number from [a,b) range"]
    #[link_name = "\u{1}_ZN2cv11RNG_MT199377uniformEdd"]
    pub fn cv_RNG_MT19937_uniform2(this: *mut cv_RNG_MT19937, a: f64, b: f64) -> f64;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv11RNG_MT19937C1Ev"]
    pub fn cv_RNG_MT19937_RNG_MT19937(this: *mut cv_RNG_MT19937);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv11RNG_MT19937C1Ej"]
    pub fn cv_RNG_MT19937_RNG_MT199371(this: *mut cv_RNG_MT19937, s: ::std::os::raw::c_uint);
}
impl cv_RNG_MT19937 {
    #[inline]
    pub unsafe fn seed(&mut self, s: ::std::os::raw::c_uint) {
        cv_RNG_MT19937_seed(self, s)
    }
    #[inline]
    pub unsafe fn next(&mut self) -> ::std::os::raw::c_uint {
        cv_RNG_MT19937_next(self)
    }
    #[inline]
    pub unsafe fn uniform(
        &mut self,
        a: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        cv_RNG_MT19937_uniform(self, a, b)
    }
    #[inline]
    pub unsafe fn uniform1(&mut self, a: f32, b: f32) -> f32 {
        cv_RNG_MT19937_uniform1(self, a, b)
    }
    #[inline]
    pub unsafe fn uniform2(&mut self, a: f64, b: f64) -> f64 {
        cv_RNG_MT19937_uniform2(self, a, b)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_RNG_MT19937_RNG_MT19937(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(s: ::std::os::raw::c_uint) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_RNG_MT19937_RNG_MT199371(__bindgen_tmp.as_mut_ptr(), s);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[doc = " @brief Finds centers of clusters and groups input samples around the clusters.\n\nThe function kmeans implements a k-means algorithm that finds the centers of cluster_count clusters\nand groups the input samples around the clusters. As an output, \\f$\\texttt{bestLabels}_i\\f$ contains a\n0-based cluster index for the sample stored in the \\f$i^{th}\\f$ row of the samples matrix.\n\n@note\n-   (Python) An example on K-means clustering can be found at\nopencv_source_code/samples/python/kmeans.py\n@param data Data for clustering. An array of N-Dimensional points with float coordinates is needed.\nExamples of this array can be:\n-   Mat points(count, 2, CV_32F);\n-   Mat points(count, 1, CV_32FC2);\n-   Mat points(1, count, CV_32FC2);\n-   std::vector\\<cv::Point2f\\> points(sampleCount);\n@param K Number of clusters to split the set by.\n@param bestLabels Input/output integer array that stores the cluster indices for every sample.\n@param criteria The algorithm termination criteria, that is, the maximum number of iterations and/or\nthe desired accuracy. The accuracy is specified as criteria.epsilon. As soon as each of the cluster\ncenters moves by less than criteria.epsilon on some iteration, the algorithm stops.\n@param attempts Flag to specify the number of times the algorithm is executed using different\ninitial labellings. The algorithm returns the labels that yield the best compactness (see the last\nfunction parameter).\n@param flags Flag that can take values of cv::KmeansFlags\n@param centers Output matrix of the cluster centers, one row per each cluster center.\n@return The function returns the compactness measure that is computed as\n\\f[\\sum _i  \\| \\texttt{samples} _i -  \\texttt{centers} _{ \\texttt{labels} _i} \\| ^2\\f]\nafter every attempt. The best (minimum) value is chosen and the corresponding labels and the\ncompactness value are returned by the function. Basically, you can use only the core of the\nfunction, set the number of attempts to 1, initialize labels each time using a custom algorithm,\npass them with the ( flags = #KMEANS_USE_INITIAL_LABELS ) flag, and then choose the best\n(most-compact) clustering."]
    #[link_name = "\u{1}_ZN2cv6kmeansERKNS_11_InputArrayEiRKNS_17_InputOutputArrayENS_12TermCriteriaEiiRKNS_12_OutputArrayE"]
    pub fn cv_kmeans(
        data: cv_InputArray,
        K: ::std::os::raw::c_int,
        bestLabels: cv_InputOutputArray,
        criteria: cv_TermCriteria,
        attempts: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        centers: cv_OutputArray,
    ) -> f64;
}
#[repr(C)]
pub struct cv_Formatted__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @todo document"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_Formatted {
    pub vtable_: *const cv_Formatted__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_Formatted"][::std::mem::size_of::<cv_Formatted>() - 8usize];
    ["Alignment of cv_Formatted"][::std::mem::align_of::<cv_Formatted>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9FormattedD1Ev"]
    pub fn cv_Formatted_Formatted_destructor(this: *mut cv_Formatted);
}
#[repr(C)]
pub struct cv_Formatter__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @todo document"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_Formatter {
    pub vtable_: *const cv_Formatter__bindgen_vtable,
}
pub const cv_Formatter_FormatType_FMT_DEFAULT: cv_Formatter_FormatType = 0;
pub const cv_Formatter_FormatType_FMT_MATLAB: cv_Formatter_FormatType = 1;
pub const cv_Formatter_FormatType_FMT_CSV: cv_Formatter_FormatType = 2;
pub const cv_Formatter_FormatType_FMT_PYTHON: cv_Formatter_FormatType = 3;
pub const cv_Formatter_FormatType_FMT_NUMPY: cv_Formatter_FormatType = 4;
pub const cv_Formatter_FormatType_FMT_C: cv_Formatter_FormatType = 5;
pub type cv_Formatter_FormatType = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_Formatter"][::std::mem::size_of::<cv_Formatter>() - 8usize];
    ["Alignment of cv_Formatter"][::std::mem::align_of::<cv_Formatter>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9Formatter3getENS0_10FormatTypeE"]
    pub fn cv_Formatter_get(fmt: cv_Formatter_FormatType) -> cv_Ptr;
}
impl cv_Formatter {
    #[inline]
    pub unsafe fn get(fmt: cv_Formatter_FormatType) -> cv_Ptr {
        cv_Formatter_get(fmt)
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9FormatterD1Ev"]
    pub fn cv_Formatter_Formatter_destructor(this: *mut cv_Formatter);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_ParamType {
    pub _address: u8,
}
#[repr(C)]
pub struct cv_Algorithm__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Algorithm ////////////////////////////////////"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_Algorithm {
    pub vtable_: *const cv_Algorithm__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_Algorithm"][::std::mem::size_of::<cv_Algorithm>() - 8usize];
    ["Alignment of cv_Algorithm"][::std::mem::align_of::<cv_Algorithm>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief simplified API for language bindings\n @overload"]
    #[link_name = "\u{1}_ZNK2cv9Algorithm5writeERKNS_3PtrINS_11FileStorageEEERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_Algorithm_write(this: *const cv_Algorithm, fs: *const cv_Ptr, name: *const cv_String);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv9Algorithm11writeFormatERNS_11FileStorageE"]
    pub fn cv_Algorithm_writeFormat(this: *const cv_Algorithm, fs: *mut cv_FileStorage);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9AlgorithmC1Ev"]
    pub fn cv_Algorithm_Algorithm(this: *mut cv_Algorithm);
}
impl cv_Algorithm {
    #[inline]
    pub unsafe fn write(&self, fs: *const cv_Ptr, name: *const cv_String) {
        cv_Algorithm_write(self, fs, name)
    }
    #[inline]
    pub unsafe fn writeFormat(&self, fs: *mut cv_FileStorage) {
        cv_Algorithm_writeFormat(self, fs)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_Algorithm_Algorithm(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9AlgorithmD1Ev"]
    pub fn cv_Algorithm_Algorithm_destructor(this: *mut cv_Algorithm);
}
unsafe extern "C" {
    #[doc = " Saves the algorithm to a file.\nIn order to make this method work, the derived class must implement Algorithm::write(FileStorage& fs)."]
    #[link_name = "\u{1}_ZNK2cv9Algorithm4saveERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_Algorithm_save(this: *mut ::std::os::raw::c_void, filename: *const cv_String);
}
unsafe extern "C" {
    #[doc = " Returns the algorithm string identifier.\nThis string is used as top level xml/yml node tag when the object is saved to a file or string."]
    #[link_name = "\u{1}_ZNK2cv9Algorithm14getDefaultNameB5cxx11Ev"]
    pub fn cv_Algorithm_getDefaultName(this: *mut ::std::os::raw::c_void) -> cv_String;
}
pub const cv_Param_INT: cv_Param = 0;
pub const cv_Param_BOOLEAN: cv_Param = 1;
pub const cv_Param_REAL: cv_Param = 2;
pub const cv_Param_STRING: cv_Param = 3;
pub const cv_Param_MAT: cv_Param = 4;
pub const cv_Param_MAT_VECTOR: cv_Param = 5;
pub const cv_Param_ALGORITHM: cv_Param = 6;
pub const cv_Param_FLOAT: cv_Param = 7;
pub const cv_Param_UNSIGNED_INT: cv_Param = 8;
pub const cv_Param_UINT64: cv_Param = 9;
pub const cv_Param_UCHAR: cv_Param = 11;
pub const cv_Param_SCALAR: cv_Param = 12;
pub type cv_Param = ::std::os::raw::c_int;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_ParamType_open0_bool__void_close0"]
        [::std::mem::size_of::<cv_ParamType>() - 1usize];
    ["Align of template specialization: cv_ParamType_open0_bool__void_close0"]
        [::std::mem::align_of::<cv_ParamType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_ParamType_open0_int_void_close0"]
        [::std::mem::size_of::<cv_ParamType>() - 1usize];
    ["Align of template specialization: cv_ParamType_open0_int_void_close0"]
        [::std::mem::align_of::<cv_ParamType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_ParamType_open0_double_void_close0"]
        [::std::mem::size_of::<cv_ParamType>() - 1usize];
    ["Align of template specialization: cv_ParamType_open0_double_void_close0"]
        [::std::mem::align_of::<cv_ParamType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cv_ParamType_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_void_close0",
    ][::std::mem::size_of::<cv_ParamType>() - 1usize];
    [
        "Align of template specialization: cv_ParamType_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_void_close0",
    ][::std::mem::align_of::<cv_ParamType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_ParamType_open0_cv_Mat_void_close0"]
        [::std::mem::size_of::<cv_ParamType>() - 1usize];
    ["Align of template specialization: cv_ParamType_open0_cv_Mat_void_close0"]
        [::std::mem::align_of::<cv_ParamType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cv_ParamType_open0_std_vector_open1_cv_Mat_std_allocator_open2_cv_Mat_close2_close1_void_close0",
    ][::std::mem::size_of::<cv_ParamType>() - 1usize];
    [
        "Align of template specialization: cv_ParamType_open0_std_vector_open1_cv_Mat_std_allocator_open2_cv_Mat_close2_close1_void_close0",
    ][::std::mem::align_of::<cv_ParamType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_ParamType_open0_cv_Algorithm_void_close0"]
        [::std::mem::size_of::<cv_ParamType>() - 1usize];
    ["Align of template specialization: cv_ParamType_open0_cv_Algorithm_void_close0"]
        [::std::mem::align_of::<cv_ParamType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_ParamType_open0_float_void_close0"]
        [::std::mem::size_of::<cv_ParamType>() - 1usize];
    ["Align of template specialization: cv_ParamType_open0_float_void_close0"]
        [::std::mem::align_of::<cv_ParamType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_ParamType_open0_unsigned_int_void_close0"]
        [::std::mem::size_of::<cv_ParamType>() - 1usize];
    ["Align of template specialization: cv_ParamType_open0_unsigned_int_void_close0"]
        [::std::mem::align_of::<cv_ParamType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_ParamType_open0_unsigned_long_void_close0"]
        [::std::mem::size_of::<cv_ParamType>() - 1usize];
    ["Align of template specialization: cv_ParamType_open0_unsigned_long_void_close0"]
        [::std::mem::align_of::<cv_ParamType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_ParamType_open0_unsigned_char_void_close0"]
        [::std::mem::size_of::<cv_ParamType>() - 1usize];
    ["Align of template specialization: cv_ParamType_open0_unsigned_char_void_close0"]
        [::std::mem::align_of::<cv_ParamType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cv_ParamType_open0_cv_Scalar__open1_double_close1_void_close0",
    ][::std::mem::size_of::<cv_ParamType>() - 1usize];
    [
        "Align of template specialization: cv_ParamType_open0_cv_Scalar__open1_double_close1_void_close0",
    ][::std::mem::align_of::<cv_ParamType>() - 1usize];
};
unsafe extern "C" {
    #[doc = " @brief Returns a text string formatted using the printf-like expression.\n\nThe function acts like sprintf but forms and returns an STL string. It can be used to form an error\nmessage in the Exception constructor.\n@param fmt printf-compatible formatting specifiers.\n\nNote**:\n|Type|Specifier|\n|-|-|\n|`const char*`|`%s`|\n|`char`|`%c`|\n|`float` / `double`|`%f`,`%g`|\n|`int`, `long`, `long long`|`%d`, `%ld`, ``%lld`|\n|`unsigned`, `unsigned long`, `unsigned long long`|`%u`, `%lu`, `%llu`|\n|`uint64` -> `uintmax_t`, `int64` -> `intmax_t`|`%ju`, `%jd`|\n|`size_t`|`%zu`|"]
    #[link_name = "\u{1}_ZN2cv6formatB5cxx11EPKcz"]
    pub fn cv_format(fmt: *const ::std::os::raw::c_char, ...) -> cv_String;
}
pub type cv_AutoBuffer_value_type<_Tp> = _Tp;
unsafe extern "C" {
    #[doc = "  @brief Sets/resets the break-on-error mode.\n\nWhen the break-on-error mode is set, the default error handler issues a hardware exception, which\ncan make debugging more convenient.\n\n\\return the previous state"]
    #[link_name = "\u{1}_ZN2cv15setBreakOnErrorEb"]
    pub fn cv_setBreakOnError(flag: bool) -> bool;
}
pub type cv_ErrorCallback = ::std::option::Option<
    unsafe extern "C" fn(
        status: ::std::os::raw::c_int,
        func_name: *const ::std::os::raw::c_char,
        err_msg: *const ::std::os::raw::c_char,
        file_name: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " @brief Sets the new error handler and the optional user data.\n\nThe function sets the new error handler, called from cv::error().\n\n\\param errCallback the new error handler. If NULL, the default error handler is used.\n\\param userdata the optional user data pointer, passed to the callback.\n\\param prevUserdata the optional output parameter where the previous user data pointer is stored\n\n\\return the previous error handler"]
    #[link_name = "\u{1}_ZN2cv13redirectErrorEPFiiPKcS1_S1_iPvES2_PS2_"]
    pub fn cv_redirectError(
        errCallback: cv_ErrorCallback,
        userdata: *mut ::std::os::raw::c_void,
        prevUserdata: *mut *mut ::std::os::raw::c_void,
    ) -> cv_ErrorCallback;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8tempfileB5cxx11EPKc"]
    pub fn cv_tempfile(suffix: *const ::std::os::raw::c_char) -> cv_String;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv4globENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERSt6vectorIS5_SaIS5_EEb"]
    pub fn cv_glob(pattern: cv_String, result: *mut std_vector, recursive: bool);
}
unsafe extern "C" {
    #[doc = " @brief OpenCV will try to set the number of threads for the next parallel region.\n\nIf threads == 0, OpenCV will disable threading optimizations and run all it's functions\nsequentially. Passing threads \\< 0 will reset threads number to system default. This function must\nbe called outside of parallel region.\n\nOpenCV will try to run its functions with specified threads number, but some behaviour differs from\nframework:\n-   `TBB` - User-defined parallel constructions will run with the same threads number, if\nanother is not specified. If later on user creates his own scheduler, OpenCV will use it.\n-   `OpenMP` - No special defined behaviour.\n-   `Concurrency` - If threads == 1, OpenCV will disable threading optimizations and run its\nfunctions sequentially.\n-   `GCD` - Supports only values \\<= 0.\n-   `C=` - No special defined behaviour.\n@param nthreads Number of threads used by OpenCV.\n@sa getNumThreads, getThreadNum"]
    #[link_name = "\u{1}_ZN2cv13setNumThreadsEi"]
    pub fn cv_setNumThreads(nthreads: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @brief Returns the number of threads used by OpenCV for parallel regions.\n\nAlways returns 1 if OpenCV is built without threading support.\n\nThe exact meaning of return value depends on the threading framework used by OpenCV library:\n- `TBB` - The number of threads, that OpenCV will try to use for parallel regions. If there is\nany tbb::thread_scheduler_init in user code conflicting with OpenCV, then function returns\ndefault number of threads used by TBB library.\n- `OpenMP` - An upper bound on the number of threads that could be used to form a new team.\n- `Concurrency` - The number of threads, that OpenCV will try to use for parallel regions.\n- `GCD` - Unsupported; returns the GCD thread pool limit (512) for compatibility.\n- `C=` - The number of threads, that OpenCV will try to use for parallel regions, if before\ncalled setNumThreads with threads \\> 0, otherwise returns the number of logical CPUs,\navailable for the process.\n@sa setNumThreads, getThreadNum"]
    #[link_name = "\u{1}_ZN2cv13getNumThreadsEv"]
    pub fn cv_getNumThreads() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Returns the index of the currently executed thread within the current parallel region. Always\nreturns 0 if called outside of parallel region.\n\n@deprecated Current implementation doesn't corresponding to this documentation.\n\nThe exact meaning of the return value depends on the threading framework used by OpenCV library:\n- `TBB` - Unsupported with current 4.1 TBB release. Maybe will be supported in future.\n- `OpenMP` - The thread number, within the current team, of the calling thread.\n- `Concurrency` - An ID for the virtual processor that the current context is executing on (0\nfor master thread and unique number for others, but not necessary 1,2,3,...).\n- `GCD` - System calling thread's ID. Never returns 0 inside parallel region.\n- `C=` - The index of the current parallel task.\n@sa setNumThreads, getNumThreads"]
    #[link_name = "\u{1}_ZN2cv12getThreadNumEv"]
    pub fn cv_getThreadNum() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Returns full configuration time cmake output.\n\nReturned value is raw cmake output including version control system revision, compiler version,\ncompiler flags, enabled modules and third party libraries, etc. Output format depends on target\narchitecture."]
    #[link_name = "\u{1}_ZN2cv19getBuildInformationB5cxx11Ev"]
    pub fn cv_getBuildInformation() -> *const cv_String;
}
unsafe extern "C" {
    #[doc = " @brief Returns library version string\n\nFor example \"3.4.1-dev\".\n\n@sa getMajorVersion, getMinorVersion, getRevisionVersion"]
    #[link_name = "\u{1}_ZN2cv16getVersionStringB5cxx11Ev"]
    pub fn cv_getVersionString() -> cv_String;
}
unsafe extern "C" {
    #[doc = " @brief Returns major library version"]
    #[link_name = "\u{1}_ZN2cv15getVersionMajorEv"]
    pub fn cv_getVersionMajor() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Returns minor library version"]
    #[link_name = "\u{1}_ZN2cv15getVersionMinorEv"]
    pub fn cv_getVersionMinor() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Returns revision field of the library version"]
    #[link_name = "\u{1}_ZN2cv18getVersionRevisionEv"]
    pub fn cv_getVersionRevision() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Returns the number of ticks.\n\nThe function returns the number of ticks after the certain event (for example, when the machine was\nturned on). It can be used to initialize RNG or to measure a function execution time by reading the\ntick count before and after the function call.\n@sa getTickFrequency, TickMeter"]
    #[link_name = "\u{1}_ZN2cv12getTickCountEv"]
    pub fn cv_getTickCount() -> int64;
}
unsafe extern "C" {
    #[doc = " @brief Returns the number of ticks per second.\n\nThe function returns the number of ticks per second. That is, the following code computes the\nexecution time in seconds:\n@code\ndouble t = (double)getTickCount();\n// do something ...\nt = ((double)getTickCount() - t)/getTickFrequency();\n@endcode\n@sa getTickCount, TickMeter"]
    #[link_name = "\u{1}_ZN2cv16getTickFrequencyEv"]
    pub fn cv_getTickFrequency() -> f64;
}
#[doc = " @brief a Class to measure passing time.\n\nThe class computes passing time by counting the number of ticks per second. That is, the following code computes the\nexecution time in seconds:\n@code\nTickMeter tm;\ntm.start();\n// do something ...\ntm.stop();\nstd::cout << tm.getTimeSec();\n@endcode\n\nIt is also possible to compute the average time over multiple runs:\n@code\nTickMeter tm;\nfor (int i = 0; i < 100; i++)\n{\ntm.start();\n// do something ...\ntm.stop();\n}\ndouble average_time = tm.getTimeSec() / tm.getCounter();\nstd::cout << \"Average time in second per iteration is: \" << average_time << std::endl;\n@endcode\n@sa getTickCount, getTickFrequency"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_TickMeter {
    pub counter: int64,
    pub sumTime: int64,
    pub startTime: int64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_TickMeter"][::std::mem::size_of::<cv_TickMeter>() - 24usize];
    ["Alignment of cv_TickMeter"][::std::mem::align_of::<cv_TickMeter>() - 8usize];
    ["Offset of field: cv_TickMeter::counter"]
        [::std::mem::offset_of!(cv_TickMeter, counter) - 0usize];
    ["Offset of field: cv_TickMeter::sumTime"]
        [::std::mem::offset_of!(cv_TickMeter, sumTime) - 8usize];
    ["Offset of field: cv_TickMeter::startTime"]
        [::std::mem::offset_of!(cv_TickMeter, startTime) - 16usize];
};
unsafe extern "C" {
    #[doc = " @brief Returns the number of CPU ticks.\n\nThe function returns the current number of CPU ticks on some architectures (such as x86, x64,\nPowerPC). On other platforms the function is equivalent to getTickCount. It can also be used for\nvery accurate time measurements, as well as for RNG initialization. Note that in case of multi-CPU\nsystems a thread, from which getCPUTickCount is called, can be suspended and resumed at another CPU\nwith its own counter. So, theoretically (and practically) the subsequent calls to the function do\nnot necessary return the monotonously increasing values. Also, since a modern CPU varies the CPU\nfrequency depending on the load, the number of CPU clocks spent in some code cannot be directly\nconverted to time units. Therefore, getTickCount is generally a preferable solution for measuring\nexecution time."]
    #[link_name = "\u{1}_ZN2cv15getCPUTickCountEv"]
    pub fn cv_getCPUTickCount() -> int64;
}
unsafe extern "C" {
    #[doc = " @brief Returns true if the specified feature is supported by the host hardware.\n\nThe function returns true if the host hardware supports the specified feature. When user calls\nsetUseOptimized(false), the subsequent calls to checkHardwareSupport() will return false until\nsetUseOptimized(true) is called. This way user can dynamically switch on and off the optimized code\nin OpenCV.\n@param feature The feature of interest, one of cv::CpuFeatures"]
    #[link_name = "\u{1}_ZN2cv20checkHardwareSupportEi"]
    pub fn cv_checkHardwareSupport(feature: ::std::os::raw::c_int) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Returns feature name by ID\n\nReturns empty string if feature is not defined"]
    #[link_name = "\u{1}_ZN2cv22getHardwareFeatureNameB5cxx11Ei"]
    pub fn cv_getHardwareFeatureName(feature: ::std::os::raw::c_int) -> cv_String;
}
unsafe extern "C" {
    #[doc = " @brief Returns list of CPU features enabled during compilation.\n\nReturned value is a string containing space separated list of CPU features with following markers:\n\n- no markers - baseline features\n- prefix `*` - features enabled in dispatcher\n- suffix `?` - features enabled but not available in HW\n\nExample: `SSE SSE2 SSE3 *SSE4.1 *SSE4.2 *FP16 *AVX *AVX2 *AVX512-SKX?`"]
    #[link_name = "\u{1}_ZN2cv18getCPUFeaturesLineB5cxx11Ev"]
    pub fn cv_getCPUFeaturesLine() -> std_string;
}
unsafe extern "C" {
    #[doc = " @brief Returns the number of logical CPUs available for the process."]
    #[link_name = "\u{1}_ZN2cv15getNumberOfCPUsEv"]
    pub fn cv_getNumberOfCPUs() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Enables or disables the optimized code.\n\nThe function can be used to dynamically turn on and off optimized dispatched code (code that uses SSE4.2, AVX/AVX2,\nand other instructions on the platforms that support it). It sets a global flag that is further\nchecked by OpenCV functions. Since the flag is not checked in the inner OpenCV loops, it is only\nsafe to call the function on the very top level in your application where you can be sure that no\nother OpenCV function is currently executed.\n\nBy default, the optimized code is enabled unless you disable it in CMake. The current status can be\nretrieved using useOptimized.\n@param onoff The boolean flag specifying whether the optimized code should be used (onoff=true)\nor not (onoff=false)."]
    #[link_name = "\u{1}_ZN2cv15setUseOptimizedEb"]
    pub fn cv_setUseOptimized(onoff: bool);
}
unsafe extern "C" {
    #[doc = " @brief Returns the status of optimized code usage.\n\nThe function returns true if the optimized code is enabled. Otherwise, it returns false."]
    #[link_name = "\u{1}_ZN2cv12useOptimizedEv"]
    pub fn cv_useOptimized() -> bool;
}
#[repr(C)]
pub struct cv_ParallelLoopBody__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief Base class for parallel data processors"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_ParallelLoopBody {
    pub vtable_: *const cv_ParallelLoopBody__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ParallelLoopBody"][::std::mem::size_of::<cv_ParallelLoopBody>() - 8usize];
    ["Alignment of cv_ParallelLoopBody"][::std::mem::align_of::<cv_ParallelLoopBody>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv16ParallelLoopBodyD1Ev"]
    pub fn cv_ParallelLoopBody_ParallelLoopBody_destructor(this: *mut cv_ParallelLoopBody);
}
unsafe extern "C" {
    #[doc = " @brief Parallel data processor"]
    #[link_name = "\u{1}_ZN2cv13parallel_for_ERKNS_5RangeERKNS_16ParallelLoopBodyEd"]
    pub fn cv_parallel_for_(
        range: *const cv_Range,
        body: *const cv_ParallelLoopBody,
        nstripes: f64,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_ParallelLoopBodyLambdaWrapper {
    pub _base: cv_ParallelLoopBody,
    pub m_functor: __BindgenOpaqueArray<u64, 4usize>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ParallelLoopBodyLambdaWrapper"]
        [::std::mem::size_of::<cv_ParallelLoopBodyLambdaWrapper>() - 40usize];
    ["Alignment of cv_ParallelLoopBodyLambdaWrapper"]
        [::std::mem::align_of::<cv_ParallelLoopBodyLambdaWrapper>() - 8usize];
    ["Offset of field: cv_ParallelLoopBodyLambdaWrapper::m_functor"]
        [::std::mem::offset_of!(cv_ParallelLoopBodyLambdaWrapper, m_functor) - 8usize];
};
pub type cv_Mutex = std_recursive_mutex;
pub type cv_AutoLock = std_lock_guard<cv_Mutex>;
#[doc = " @brief Designed for command line parsing\n\nThe sample below demonstrates how to use CommandLineParser:\n@code\nCommandLineParser parser(argc, argv, keys);\nparser.about(\"Application name v1.0.0\");\n\nif (parser.has(\"help\"))\n{\nparser.printMessage();\nreturn 0;\n}\n\nint N = parser.get<int>(\"N\");\ndouble fps = parser.get<double>(\"fps\");\nString path = parser.get<String>(\"path\");\n\nuse_time_stamp = parser.has(\"timestamp\");\n\nString img1 = parser.get<String>(0);\nString img2 = parser.get<String>(1);\n\nint repeat = parser.get<int>(2);\n\nif (!parser.check())\n{\nparser.printErrors();\nreturn 0;\n}\n@endcode\n\n### Keys syntax\n\nThe keys parameter is a string containing several blocks, each one is enclosed in curly braces and\ndescribes one argument. Each argument contains three parts separated by the `|` symbol:\n\n-# argument names is a space-separated list of option synonyms (to mark argument as positional, prefix it with the `@` symbol)\n-# default value will be used if the argument was not provided (can be empty)\n-# help message (can be empty)\n\nFor example:\n\n@code{.cpp}\nconst String keys =\n\"{help h usage ? |      | print this message   }\"\n\"{@image1        |      | image1 for compare   }\"\n\"{@image2        |<none>| image2 for compare   }\"\n\"{@repeat        |1     | number               }\"\n\"{path           |.     | path to file         }\"\n\"{fps            | -1.0 | fps for output video }\"\n\"{N count        |100   | count of objects     }\"\n\"{ts timestamp   |      | use time stamp       }\"\n;\n}\n@endcode\n\nNote that there are no default values for `help` and `timestamp` so we can check their presence using the `has()` method.\nArguments with default values are considered to be always present. Use the `get()` method in these cases to check their\nactual value instead.\n\nString keys like `get<String>(\"@image1\")` return the empty string `\"\"` by default - even with an empty default value.\nUse the special `<none>` default value to enforce that the returned string must not be empty. (like in `get<String>(\"@image2\")`)\n\n### Usage\n\nFor the described keys:\n\n@code{.sh}\n# Good call (3 positional parameters: image1, image2 and repeat; N is 200, ts is true)\n$ ./app -N=200 1.png 2.jpg 19 -ts\n\n# Bad call\n$ ./app -fps=aaa\nERRORS:\nParameter 'fps': can not convert: [aaa] to [double]\n@endcode"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_CommandLineParser {
    pub impl_: *mut cv_CommandLineParser_Impl,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_CommandLineParser_Impl {
    _unused: [u8; 0],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_CommandLineParser"][::std::mem::size_of::<cv_CommandLineParser>() - 8usize];
    ["Alignment of cv_CommandLineParser"][::std::mem::align_of::<cv_CommandLineParser>() - 8usize];
    ["Offset of field: cv_CommandLineParser::impl_"]
        [::std::mem::offset_of!(cv_CommandLineParser, impl_) - 0usize];
};
unsafe extern "C" {
    #[doc = " @brief Returns application path\n\nThis method returns the path to the executable from the command line (`argv[0]`).\n\nFor example, if the application has been started with such a command:\n@code{.sh}\n$ ./bin/my-executable\n@endcode\nthis method will return `./bin`."]
    #[link_name = "\u{1}_ZNK2cv17CommandLineParser20getPathToApplicationB5cxx11Ev"]
    pub fn cv_CommandLineParser_getPathToApplication(
        this: *const cv_CommandLineParser,
    ) -> cv_String;
}
unsafe extern "C" {
    #[doc = " @brief Check if field was provided in the command line\n\n@param name argument name to check"]
    #[link_name = "\u{1}_ZNK2cv17CommandLineParser3hasERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_CommandLineParser_has(
        this: *const cv_CommandLineParser,
        name: *const cv_String,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Check for parsing errors\n\nReturns false if error occurred while accessing the parameters (bad conversion, missing arguments,\netc.). Call @ref printErrors to print error messages list."]
    #[link_name = "\u{1}_ZNK2cv17CommandLineParser5checkEv"]
    pub fn cv_CommandLineParser_check(this: *const cv_CommandLineParser) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Set the about message\n\nThe about message will be shown when @ref printMessage is called, right before arguments table."]
    #[link_name = "\u{1}_ZN2cv17CommandLineParser5aboutERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_CommandLineParser_about(this: *mut cv_CommandLineParser, message: *const cv_String);
}
unsafe extern "C" {
    #[doc = " @brief Print help message\n\nThis method will print standard help message containing the about message and arguments description.\n\n@sa about"]
    #[link_name = "\u{1}_ZNK2cv17CommandLineParser12printMessageEv"]
    pub fn cv_CommandLineParser_printMessage(this: *const cv_CommandLineParser);
}
unsafe extern "C" {
    #[doc = " @brief Print list of errors occurred\n\n@sa check"]
    #[link_name = "\u{1}_ZNK2cv17CommandLineParser11printErrorsEv"]
    pub fn cv_CommandLineParser_printErrors(this: *const cv_CommandLineParser);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv17CommandLineParser9getByNameERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEbNS_5ParamEPv"]
    pub fn cv_CommandLineParser_getByName(
        this: *const cv_CommandLineParser,
        name: *const cv_String,
        space_delete: bool,
        type_: cv_Param,
        dst: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv17CommandLineParser10getByIndexEibNS_5ParamEPv"]
    pub fn cv_CommandLineParser_getByIndex(
        this: *const cv_CommandLineParser,
        index: ::std::os::raw::c_int,
        space_delete: bool,
        type_: cv_Param,
        dst: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " @brief Constructor\n\nInitializes command line parser object\n\n@param argc number of command line arguments (from main())\n@param argv array of command line arguments (from main())\n@param keys string describing acceptable command line parameters (see class description for syntax)"]
    #[link_name = "\u{1}_ZN2cv17CommandLineParserC1EiPKPKcRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_CommandLineParser_CommandLineParser(
        this: *mut cv_CommandLineParser,
        argc: ::std::os::raw::c_int,
        argv: *const *const ::std::os::raw::c_char,
        keys: *const cv_String,
    );
}
unsafe extern "C" {
    #[doc = " @brief Copy constructor"]
    #[link_name = "\u{1}_ZN2cv17CommandLineParserC1ERKS0_"]
    pub fn cv_CommandLineParser_CommandLineParser1(
        this: *mut cv_CommandLineParser,
        parser: *const cv_CommandLineParser,
    );
}
unsafe extern "C" {
    #[doc = " @brief Destructor"]
    #[link_name = "\u{1}_ZN2cv17CommandLineParserD1Ev"]
    pub fn cv_CommandLineParser_CommandLineParser_destructor(this: *mut cv_CommandLineParser);
}
impl cv_CommandLineParser {
    #[inline]
    pub unsafe fn getPathToApplication(&self) -> cv_String {
        cv_CommandLineParser_getPathToApplication(self)
    }
    #[inline]
    pub unsafe fn has(&self, name: *const cv_String) -> bool {
        cv_CommandLineParser_has(self, name)
    }
    #[inline]
    pub unsafe fn check(&self) -> bool {
        cv_CommandLineParser_check(self)
    }
    #[inline]
    pub unsafe fn about(&mut self, message: *const cv_String) {
        cv_CommandLineParser_about(self, message)
    }
    #[inline]
    pub unsafe fn printMessage(&self) {
        cv_CommandLineParser_printMessage(self)
    }
    #[inline]
    pub unsafe fn printErrors(&self) {
        cv_CommandLineParser_printErrors(self)
    }
    #[inline]
    pub unsafe fn getByName(
        &self,
        name: *const cv_String,
        space_delete: bool,
        type_: cv_Param,
        dst: *mut ::std::os::raw::c_void,
    ) {
        cv_CommandLineParser_getByName(self, name, space_delete, type_, dst)
    }
    #[inline]
    pub unsafe fn getByIndex(
        &self,
        index: ::std::os::raw::c_int,
        space_delete: bool,
        type_: cv_Param,
        dst: *mut ::std::os::raw::c_void,
    ) {
        cv_CommandLineParser_getByIndex(self, index, space_delete, type_, dst)
    }
    #[inline]
    pub unsafe fn new(
        argc: ::std::os::raw::c_int,
        argv: *const *const ::std::os::raw::c_char,
        keys: *const cv_String,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_CommandLineParser_CommandLineParser(__bindgen_tmp.as_mut_ptr(), argc, argv, keys);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(parser: *const cv_CommandLineParser) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_CommandLineParser_CommandLineParser1(__bindgen_tmp.as_mut_ptr(), parser);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cv_CommandLineParser_CommandLineParser_destructor(self)
    }
}
#[doc = "! @endcond"]
#[repr(C)]
pub struct cv_Node<OBJECT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<OBJECT>>,
    pub m_payload: OBJECT,
    pub m_pParent: *mut cv_Node<OBJECT>,
    pub m_childs: std_vector,
}
unsafe extern "C" {
    #[doc = " @brief Try to find requested data file\n\nSearch directories:\n\n1. Directories passed via `addSamplesDataSearchPath()`\n2. OPENCV_SAMPLES_DATA_PATH_HINT environment variable\n3. OPENCV_SAMPLES_DATA_PATH environment variable\nIf parameter value is not empty and nothing is found then stop searching.\n4. Detects build/install path based on:\na. current working directory (CWD)\nb. and/or binary module location (opencv_core/opencv_world, doesn't work with static linkage)\n5. Scan `<source>/{,data,samples/data}` directories if build directory is detected or the current directory is in source tree.\n6. Scan `<install>/share/OpenCV` directory if install directory is detected.\n\n@see cv::utils::findDataFile\n\n@param relative_path Relative path to data file\n@param required Specify \"file not found\" handling.\nIf true, function prints information message and raises cv::Exception.\nIf false, function returns empty result\n@param silentMode Disables messages\n@return Returns path (absolute or relative to the current directory) or empty string if file is not found"]
    #[link_name = "\u{1}_ZN2cv7samples8findFileERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEbb"]
    pub fn cv_samples_findFile(
        relative_path: *const cv_String,
        required: bool,
        silentMode: bool,
    ) -> cv_String;
}
unsafe extern "C" {
    #[doc = " @brief Override search data path by adding new search location\n\nUse this only to override default behavior\nPassed paths are used in LIFO order.\n\n@param path Path to used samples data"]
    #[link_name = "\u{1}_ZN2cv7samples24addSamplesDataSearchPathERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_samples_addSamplesDataSearchPath(path: *const cv_String);
}
unsafe extern "C" {
    #[doc = " @brief Append samples search data sub directory\n\nGeneral usage is to add OpenCV modules name (`<opencv_contrib>/modules/<name>/samples/data` -> `<name>/samples/data` + `modules/<name>/samples/data`).\nPassed subdirectories are used in LIFO order.\n\n@param subdir samples data sub directory"]
    #[link_name = "\u{1}_ZN2cv7samples32addSamplesDataSearchSubDirectoryERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_samples_addSamplesDataSearchSubDirectory(subdir: *const cv_String);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5utils11getThreadIDEv"]
    pub fn cv_utils_getThreadID() -> ::std::os::raw::c_int;
}
#[doc = " @brief Basic interface for all solvers"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_MinProblemSolver {
    pub _base: cv_Algorithm,
}
#[repr(C)]
pub struct cv_MinProblemSolver_Function__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief Represents function being optimized"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_MinProblemSolver_Function {
    pub vtable_: *const cv_MinProblemSolver_Function__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_MinProblemSolver_Function"]
        [::std::mem::size_of::<cv_MinProblemSolver_Function>() - 8usize];
    ["Alignment of cv_MinProblemSolver_Function"]
        [::std::mem::align_of::<cv_MinProblemSolver_Function>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_MinProblemSolver"][::std::mem::size_of::<cv_MinProblemSolver>() - 8usize];
    ["Alignment of cv_MinProblemSolver"][::std::mem::align_of::<cv_MinProblemSolver>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv16MinProblemSolver8Function14getGradientEpsEv"]
    pub fn cv_MinProblemSolver_Function_getGradientEps(this: *mut ::std::os::raw::c_void) -> f64;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv16MinProblemSolver8Function11getGradientEPKdPd"]
    pub fn cv_MinProblemSolver_Function_getGradient(
        this: *mut ::std::os::raw::c_void,
        x: *const f64,
        grad: *mut f64,
    );
}
#[doc = " @brief This class is used to perform the non-linear non-constrained minimization of a function,\n\ndefined on an `n`-dimensional Euclidean space, using the **Nelder-Mead method**, also known as\ndownhill simplex method**. The basic idea about the method can be obtained from\n<http://en.wikipedia.org/wiki/Nelder-Mead_method>.\n\nIt should be noted, that this method, although deterministic, is rather a heuristic and therefore\nmay converge to a local minima, not necessary a global one. It is iterative optimization technique,\nwhich at each step uses an information about the values of a function evaluated only at `n+1`\npoints, arranged as a *simplex* in `n`-dimensional space (hence the second name of the method). At\neach step new point is chosen to evaluate function at, obtained value is compared with previous\nones and based on this information simplex changes it's shape , slowly moving to the local minimum.\nThus this method is using *only* function values to make decision, on contrary to, say, Nonlinear\nConjugate Gradient method (which is also implemented in optim).\n\nAlgorithm stops when the number of function evaluations done exceeds termcrit.maxCount, when the\nfunction values at the vertices of simplex are within termcrit.epsilon range or simplex becomes so\nsmall that it can enclosed in a box with termcrit.epsilon sides, whatever comes first, for some\ndefined by user positive integer termcrit.maxCount and positive non-integer termcrit.epsilon.\n\n@note DownhillSolver is a derivative of the abstract interface\ncv::MinProblemSolver, which in turn is derived from the Algorithm interface and is used to\nencapsulate the functionality, common to all non-linear optimization algorithms in the optim\nmodule.\n\n@note term criteria should meet following condition:\n@code\ntermcrit.type == (TermCriteria::MAX_ITER + TermCriteria::EPS) && termcrit.epsilon > 0 && termcrit.maxCount > 0\n@endcode"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_DownhillSolver {
    pub _base: cv_MinProblemSolver,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_DownhillSolver"][::std::mem::size_of::<cv_DownhillSolver>() - 8usize];
    ["Alignment of cv_DownhillSolver"][::std::mem::align_of::<cv_DownhillSolver>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief This function returns the reference to the ready-to-use DownhillSolver object.\n\nAll the parameters are optional, so this procedure can be called even without parameters at\nall. In this case, the default values will be used. As default value for terminal criteria are\nthe only sensible ones, MinProblemSolver::setFunction() and DownhillSolver::setInitStep()\nshould be called upon the obtained object, if the respective parameters were not given to\ncreate(). Otherwise, the two ways (give parameters to createDownhillSolver() or miss them out\nand call the MinProblemSolver::setFunction() and DownhillSolver::setInitStep()) are absolutely\nequivalent (and will drop the same errors in the same way, should invalid input be detected).\n@param f Pointer to the function that will be minimized, similarly to the one you submit via\nMinProblemSolver::setFunction.\n@param initStep Initial step, that will be used to construct the initial simplex, similarly to the one\nyou submit via MinProblemSolver::setInitStep.\n@param termcrit Terminal criteria to the algorithm, similarly to the one you submit via\nMinProblemSolver::setTermCriteria."]
    #[link_name = "\u{1}_ZN2cv14DownhillSolver6createERKNS_3PtrINS_16MinProblemSolver8FunctionEEERKNS_11_InputArrayENS_12TermCriteriaE"]
    pub fn cv_DownhillSolver_create(
        f: *const cv_Ptr,
        initStep: cv_InputArray,
        termcrit: cv_TermCriteria,
    ) -> cv_Ptr;
}
impl cv_DownhillSolver {
    #[inline]
    pub unsafe fn create(
        f: *const cv_Ptr,
        initStep: cv_InputArray,
        termcrit: cv_TermCriteria,
    ) -> cv_Ptr {
        cv_DownhillSolver_create(f, initStep, termcrit)
    }
}
#[doc = " @brief This class is used to perform the non-linear non-constrained minimization of a function\nwith known gradient,\n\ndefined on an *n*-dimensional Euclidean space, using the **Nonlinear Conjugate Gradient method**.\nThe implementation was done based on the beautifully clear explanatory article [An Introduction to\nthe Conjugate Gradient Method Without the Agonizing\nPain](http://www.cs.cmu.edu/~quake-papers/painless-conjugate-gradient.pdf) by Jonathan Richard\nShewchuk. The method can be seen as an adaptation of a standard Conjugate Gradient method (see, for\nexample <http://en.wikipedia.org/wiki/Conjugate_gradient_method>) for numerically solving the\nsystems of linear equations.\n\nIt should be noted, that this method, although deterministic, is rather a heuristic method and\ntherefore may converge to a local minima, not necessary a global one. What is even more disastrous,\nmost of its behaviour is ruled by gradient, therefore it essentially cannot distinguish between\nlocal minima and maxima. Therefore, if it starts sufficiently near to the local maximum, it may\nconverge to it. Another obvious restriction is that it should be possible to compute the gradient of\na function at any point, thus it is preferable to have analytic expression for gradient and\ncomputational burden should be born by the user.\n\nThe latter responsibility is accomplished via the getGradient method of a\nMinProblemSolver::Function interface (which represents function being optimized). This method takes\npoint a point in *n*-dimensional space (first argument represents the array of coordinates of that\npoint) and compute its gradient (it should be stored in the second argument as an array).\n\n@note class ConjGradSolver thus does not add any new methods to the basic MinProblemSolver interface.\n\n@note term criteria should meet following condition:\n@code\ntermcrit.type == (TermCriteria::MAX_ITER + TermCriteria::EPS) && termcrit.epsilon > 0 && termcrit.maxCount > 0\n// or\ntermcrit.type == TermCriteria::MAX_ITER) && termcrit.maxCount > 0\n@endcode"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_ConjGradSolver {
    pub _base: cv_MinProblemSolver,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ConjGradSolver"][::std::mem::size_of::<cv_ConjGradSolver>() - 8usize];
    ["Alignment of cv_ConjGradSolver"][::std::mem::align_of::<cv_ConjGradSolver>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief This function returns the reference to the ready-to-use ConjGradSolver object.\n\nAll the parameters are optional, so this procedure can be called even without parameters at\nall. In this case, the default values will be used. As default value for terminal criteria are\nthe only sensible ones, MinProblemSolver::setFunction() should be called upon the obtained\nobject, if the function was not given to create(). Otherwise, the two ways (submit it to\ncreate() or miss it out and call the MinProblemSolver::setFunction()) are absolutely equivalent\n(and will drop the same errors in the same way, should invalid input be detected).\n@param f Pointer to the function that will be minimized, similarly to the one you submit via\nMinProblemSolver::setFunction.\n@param termcrit Terminal criteria to the algorithm, similarly to the one you submit via\nMinProblemSolver::setTermCriteria."]
    #[link_name = "\u{1}_ZN2cv14ConjGradSolver6createERKNS_3PtrINS_16MinProblemSolver8FunctionEEENS_12TermCriteriaE"]
    pub fn cv_ConjGradSolver_create(f: *const cv_Ptr, termcrit: cv_TermCriteria) -> cv_Ptr;
}
impl cv_ConjGradSolver {
    #[inline]
    pub unsafe fn create(f: *const cv_Ptr, termcrit: cv_TermCriteria) -> cv_Ptr {
        cv_ConjGradSolver_create(f, termcrit)
    }
}
#[doc = "!< problem is unbounded (target function can achieve arbitrary high values)"]
pub const cv_SolveLPResult_SOLVELP_UNBOUNDED: cv_SolveLPResult = -2;
#[doc = "!< problem is unfeasible (there are no points that satisfy all the constraints imposed)"]
pub const cv_SolveLPResult_SOLVELP_UNFEASIBLE: cv_SolveLPResult = -1;
#[doc = "!< there is only one maximum for target function"]
pub const cv_SolveLPResult_SOLVELP_SINGLE: cv_SolveLPResult = 0;
#[doc = "!< there are multiple maxima for target function - the arbitrary one is returned"]
pub const cv_SolveLPResult_SOLVELP_MULTI: cv_SolveLPResult = 1;
#[doc = "! return codes for cv::solveLP() function"]
pub type cv_SolveLPResult = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = " @brief Solve given (non-integer) linear programming problem using the Simplex Algorithm (Simplex Method).\n\nWhat we mean here by \"linear programming problem\" (or LP problem, for short) can be formulated as:\n\n\\f[\\mbox{Maximize } c\\cdot x\\\\\n\\mbox{Subject to:}\\\\\nAx\\leq b\\\\\nx\\geq 0\\f]\n\nWhere \\f$c\\f$ is fixed `1`-by-`n` row-vector, \\f$A\\f$ is fixed `m`-by-`n` matrix, \\f$b\\f$ is fixed `m`-by-`1`\ncolumn vector and \\f$x\\f$ is an arbitrary `n`-by-`1` column vector, which satisfies the constraints.\n\nSimplex algorithm is one of many algorithms that are designed to handle this sort of problems\nefficiently. Although it is not optimal in theoretical sense (there exist algorithms that can solve\nany problem written as above in polynomial time, while simplex method degenerates to exponential\ntime for some special cases), it is well-studied, easy to implement and is shown to work well for\nreal-life purposes.\n\nThe particular implementation is taken almost verbatim from **Introduction to Algorithms, third\nedition** by T. H. Cormen, C. E. Leiserson, R. L. Rivest and Clifford Stein. In particular, the\nBland's rule <http://en.wikipedia.org/wiki/Bland%27s_rule> is used to prevent cycling.\n\n@param Func This row-vector corresponds to \\f$c\\f$ in the LP problem formulation (see above). It should\ncontain 32- or 64-bit floating point numbers. As a convenience, column-vector may be also submitted,\nin the latter case it is understood to correspond to \\f$c^T\\f$.\n@param Constr `m`-by-`n+1` matrix, whose rightmost column corresponds to \\f$b\\f$ in formulation above\nand the remaining to \\f$A\\f$. It should contain 32- or 64-bit floating point numbers.\n@param z The solution will be returned here as a column-vector - it corresponds to \\f$c\\f$ in the\nformulation above. It will contain 64-bit floating point numbers.\n@return One of cv::SolveLPResult"]
    #[link_name = "\u{1}_ZN2cv7solveLPERKNS_11_InputArrayES2_RKNS_12_OutputArrayE"]
    pub fn cv_solveLP(
        Func: cv_InputArray,
        Constr: cv_InputArray,
        z: cv_OutputArray,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if use of OpenVX is possible"]
    #[link_name = "\u{1}_ZN2cv10haveOpenVXEv"]
    pub fn cv_haveOpenVX() -> bool;
}
unsafe extern "C" {
    #[doc = " Check if use of OpenVX is enabled"]
    #[link_name = "\u{1}_ZN2cv9useOpenVXEv"]
    pub fn cv_useOpenVX() -> bool;
}
unsafe extern "C" {
    #[doc = " Enable/disable use of OpenVX"]
    #[link_name = "\u{1}_ZN2cv12setUseOpenVXEb"]
    pub fn cv_setUseOpenVX(flag: bool);
}
pub const cv_flann_FlannIndexType_FLANN_INDEX_TYPE_8U: cv_flann_FlannIndexType = 0;
pub const cv_flann_FlannIndexType_FLANN_INDEX_TYPE_8S: cv_flann_FlannIndexType = 1;
pub const cv_flann_FlannIndexType_FLANN_INDEX_TYPE_16U: cv_flann_FlannIndexType = 2;
pub const cv_flann_FlannIndexType_FLANN_INDEX_TYPE_16S: cv_flann_FlannIndexType = 3;
pub const cv_flann_FlannIndexType_FLANN_INDEX_TYPE_32S: cv_flann_FlannIndexType = 4;
pub const cv_flann_FlannIndexType_FLANN_INDEX_TYPE_32F: cv_flann_FlannIndexType = 5;
pub const cv_flann_FlannIndexType_FLANN_INDEX_TYPE_64F: cv_flann_FlannIndexType = 6;
pub const cv_flann_FlannIndexType_FLANN_INDEX_TYPE_STRING: cv_flann_FlannIndexType = 7;
pub const cv_flann_FlannIndexType_FLANN_INDEX_TYPE_BOOL: cv_flann_FlannIndexType = 8;
pub const cv_flann_FlannIndexType_FLANN_INDEX_TYPE_ALGORITHM: cv_flann_FlannIndexType = 9;
pub const cv_flann_FlannIndexType_LAST_VALUE_FLANN_INDEX_TYPE: cv_flann_FlannIndexType = 9;
pub type cv_flann_FlannIndexType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct cv_flann_IndexParams {
    pub params: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_flann_IndexParams"][::std::mem::size_of::<cv_flann_IndexParams>() - 8usize];
    ["Alignment of cv_flann_IndexParams"][::std::mem::align_of::<cv_flann_IndexParams>() - 8usize];
    ["Offset of field: cv_flann_IndexParams::params"]
        [::std::mem::offset_of!(cv_flann_IndexParams, params) - 0usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5flann11IndexParams9getStringERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_"]
    pub fn cv_flann_IndexParams_getString(
        this: *const cv_flann_IndexParams,
        key: *const cv_String,
        defaultVal: *const cv_String,
    ) -> cv_String;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5flann11IndexParams6getIntERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
    pub fn cv_flann_IndexParams_getInt(
        this: *const cv_flann_IndexParams,
        key: *const cv_String,
        defaultVal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5flann11IndexParams9getDoubleERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEd"]
    pub fn cv_flann_IndexParams_getDouble(
        this: *const cv_flann_IndexParams,
        key: *const cv_String,
        defaultVal: f64,
    ) -> f64;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann11IndexParams9setStringERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_"]
    pub fn cv_flann_IndexParams_setString(
        this: *mut cv_flann_IndexParams,
        key: *const cv_String,
        value: *const cv_String,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann11IndexParams6setIntERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
    pub fn cv_flann_IndexParams_setInt(
        this: *mut cv_flann_IndexParams,
        key: *const cv_String,
        value: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann11IndexParams9setDoubleERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEd"]
    pub fn cv_flann_IndexParams_setDouble(
        this: *mut cv_flann_IndexParams,
        key: *const cv_String,
        value: f64,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann11IndexParams8setFloatERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEf"]
    pub fn cv_flann_IndexParams_setFloat(
        this: *mut cv_flann_IndexParams,
        key: *const cv_String,
        value: f32,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann11IndexParams7setBoolERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb"]
    pub fn cv_flann_IndexParams_setBool(
        this: *mut cv_flann_IndexParams,
        key: *const cv_String,
        value: bool,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann11IndexParams12setAlgorithmEi"]
    pub fn cv_flann_IndexParams_setAlgorithm(
        this: *mut cv_flann_IndexParams,
        value: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5flann11IndexParams6getAllERSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS8_EERS2_INS0_14FlannIndexTypeESaISC_EESB_RS2_IdSaIdEE"]
    pub fn cv_flann_IndexParams_getAll(
        this: *const cv_flann_IndexParams,
        names: *mut std_vector,
        types: *mut std_vector,
        strValues: *mut std_vector,
        numValues: *mut std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann11IndexParamsC1Ev"]
    pub fn cv_flann_IndexParams_IndexParams(this: *mut cv_flann_IndexParams);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann11IndexParamsD1Ev"]
    pub fn cv_flann_IndexParams_IndexParams_destructor(this: *mut cv_flann_IndexParams);
}
impl cv_flann_IndexParams {
    #[inline]
    pub unsafe fn getString(
        &self,
        key: *const cv_String,
        defaultVal: *const cv_String,
    ) -> cv_String {
        cv_flann_IndexParams_getString(self, key, defaultVal)
    }
    #[inline]
    pub unsafe fn getInt(
        &self,
        key: *const cv_String,
        defaultVal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        cv_flann_IndexParams_getInt(self, key, defaultVal)
    }
    #[inline]
    pub unsafe fn getDouble(&self, key: *const cv_String, defaultVal: f64) -> f64 {
        cv_flann_IndexParams_getDouble(self, key, defaultVal)
    }
    #[inline]
    pub unsafe fn setString(&mut self, key: *const cv_String, value: *const cv_String) {
        cv_flann_IndexParams_setString(self, key, value)
    }
    #[inline]
    pub unsafe fn setInt(&mut self, key: *const cv_String, value: ::std::os::raw::c_int) {
        cv_flann_IndexParams_setInt(self, key, value)
    }
    #[inline]
    pub unsafe fn setDouble(&mut self, key: *const cv_String, value: f64) {
        cv_flann_IndexParams_setDouble(self, key, value)
    }
    #[inline]
    pub unsafe fn setFloat(&mut self, key: *const cv_String, value: f32) {
        cv_flann_IndexParams_setFloat(self, key, value)
    }
    #[inline]
    pub unsafe fn setBool(&mut self, key: *const cv_String, value: bool) {
        cv_flann_IndexParams_setBool(self, key, value)
    }
    #[inline]
    pub unsafe fn setAlgorithm(&mut self, value: ::std::os::raw::c_int) {
        cv_flann_IndexParams_setAlgorithm(self, value)
    }
    #[inline]
    pub unsafe fn getAll(
        &self,
        names: *mut std_vector,
        types: *mut std_vector,
        strValues: *mut std_vector,
        numValues: *mut std_vector,
    ) {
        cv_flann_IndexParams_getAll(self, names, types, strValues, numValues)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_flann_IndexParams_IndexParams(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cv_flann_IndexParams_IndexParams_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_flann_KDTreeIndexParams {
    pub _base: cv_flann_IndexParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_flann_KDTreeIndexParams"]
        [::std::mem::size_of::<cv_flann_KDTreeIndexParams>() - 8usize];
    ["Alignment of cv_flann_KDTreeIndexParams"]
        [::std::mem::align_of::<cv_flann_KDTreeIndexParams>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann17KDTreeIndexParamsC1Ei"]
    pub fn cv_flann_KDTreeIndexParams_KDTreeIndexParams(
        this: *mut cv_flann_KDTreeIndexParams,
        trees: ::std::os::raw::c_int,
    );
}
impl cv_flann_KDTreeIndexParams {
    #[inline]
    pub unsafe fn new(trees: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_flann_KDTreeIndexParams_KDTreeIndexParams(__bindgen_tmp.as_mut_ptr(), trees);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_flann_LinearIndexParams {
    pub _base: cv_flann_IndexParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_flann_LinearIndexParams"]
        [::std::mem::size_of::<cv_flann_LinearIndexParams>() - 8usize];
    ["Alignment of cv_flann_LinearIndexParams"]
        [::std::mem::align_of::<cv_flann_LinearIndexParams>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann17LinearIndexParamsC1Ev"]
    pub fn cv_flann_LinearIndexParams_LinearIndexParams(this: *mut cv_flann_LinearIndexParams);
}
impl cv_flann_LinearIndexParams {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_flann_LinearIndexParams_LinearIndexParams(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_flann_CompositeIndexParams {
    pub _base: cv_flann_IndexParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_flann_CompositeIndexParams"]
        [::std::mem::size_of::<cv_flann_CompositeIndexParams>() - 8usize];
    ["Alignment of cv_flann_CompositeIndexParams"]
        [::std::mem::align_of::<cv_flann_CompositeIndexParams>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann20CompositeIndexParamsC1EiiiN7cvflann20flann_centers_init_tEf"]
    pub fn cv_flann_CompositeIndexParams_CompositeIndexParams(
        this: *mut cv_flann_CompositeIndexParams,
        trees: ::std::os::raw::c_int,
        branching: ::std::os::raw::c_int,
        iterations: ::std::os::raw::c_int,
        centers_init: cvflann_flann_centers_init_t,
        cb_index: f32,
    );
}
impl cv_flann_CompositeIndexParams {
    #[inline]
    pub unsafe fn new(
        trees: ::std::os::raw::c_int,
        branching: ::std::os::raw::c_int,
        iterations: ::std::os::raw::c_int,
        centers_init: cvflann_flann_centers_init_t,
        cb_index: f32,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_flann_CompositeIndexParams_CompositeIndexParams(
            __bindgen_tmp.as_mut_ptr(),
            trees,
            branching,
            iterations,
            centers_init,
            cb_index,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_flann_AutotunedIndexParams {
    pub _base: cv_flann_IndexParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_flann_AutotunedIndexParams"]
        [::std::mem::size_of::<cv_flann_AutotunedIndexParams>() - 8usize];
    ["Alignment of cv_flann_AutotunedIndexParams"]
        [::std::mem::align_of::<cv_flann_AutotunedIndexParams>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann20AutotunedIndexParamsC1Effff"]
    pub fn cv_flann_AutotunedIndexParams_AutotunedIndexParams(
        this: *mut cv_flann_AutotunedIndexParams,
        target_precision: f32,
        build_weight: f32,
        memory_weight: f32,
        sample_fraction: f32,
    );
}
impl cv_flann_AutotunedIndexParams {
    #[inline]
    pub unsafe fn new(
        target_precision: f32,
        build_weight: f32,
        memory_weight: f32,
        sample_fraction: f32,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_flann_AutotunedIndexParams_AutotunedIndexParams(
            __bindgen_tmp.as_mut_ptr(),
            target_precision,
            build_weight,
            memory_weight,
            sample_fraction,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_flann_HierarchicalClusteringIndexParams {
    pub _base: cv_flann_IndexParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_flann_HierarchicalClusteringIndexParams"]
        [::std::mem::size_of::<cv_flann_HierarchicalClusteringIndexParams>() - 8usize];
    ["Alignment of cv_flann_HierarchicalClusteringIndexParams"]
        [::std::mem::align_of::<cv_flann_HierarchicalClusteringIndexParams>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann33HierarchicalClusteringIndexParamsC1EiN7cvflann20flann_centers_init_tEii"]
    pub fn cv_flann_HierarchicalClusteringIndexParams_HierarchicalClusteringIndexParams(
        this: *mut cv_flann_HierarchicalClusteringIndexParams,
        branching: ::std::os::raw::c_int,
        centers_init: cvflann_flann_centers_init_t,
        trees: ::std::os::raw::c_int,
        leaf_size: ::std::os::raw::c_int,
    );
}
impl cv_flann_HierarchicalClusteringIndexParams {
    #[inline]
    pub unsafe fn new(
        branching: ::std::os::raw::c_int,
        centers_init: cvflann_flann_centers_init_t,
        trees: ::std::os::raw::c_int,
        leaf_size: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_flann_HierarchicalClusteringIndexParams_HierarchicalClusteringIndexParams(
            __bindgen_tmp.as_mut_ptr(),
            branching,
            centers_init,
            trees,
            leaf_size,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_flann_KMeansIndexParams {
    pub _base: cv_flann_IndexParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_flann_KMeansIndexParams"]
        [::std::mem::size_of::<cv_flann_KMeansIndexParams>() - 8usize];
    ["Alignment of cv_flann_KMeansIndexParams"]
        [::std::mem::align_of::<cv_flann_KMeansIndexParams>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann17KMeansIndexParamsC1EiiN7cvflann20flann_centers_init_tEf"]
    pub fn cv_flann_KMeansIndexParams_KMeansIndexParams(
        this: *mut cv_flann_KMeansIndexParams,
        branching: ::std::os::raw::c_int,
        iterations: ::std::os::raw::c_int,
        centers_init: cvflann_flann_centers_init_t,
        cb_index: f32,
    );
}
impl cv_flann_KMeansIndexParams {
    #[inline]
    pub unsafe fn new(
        branching: ::std::os::raw::c_int,
        iterations: ::std::os::raw::c_int,
        centers_init: cvflann_flann_centers_init_t,
        cb_index: f32,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_flann_KMeansIndexParams_KMeansIndexParams(
            __bindgen_tmp.as_mut_ptr(),
            branching,
            iterations,
            centers_init,
            cb_index,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_flann_LshIndexParams {
    pub _base: cv_flann_IndexParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_flann_LshIndexParams"][::std::mem::size_of::<cv_flann_LshIndexParams>() - 8usize];
    ["Alignment of cv_flann_LshIndexParams"]
        [::std::mem::align_of::<cv_flann_LshIndexParams>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann14LshIndexParamsC1Eiii"]
    pub fn cv_flann_LshIndexParams_LshIndexParams(
        this: *mut cv_flann_LshIndexParams,
        table_number: ::std::os::raw::c_int,
        key_size: ::std::os::raw::c_int,
        multi_probe_level: ::std::os::raw::c_int,
    );
}
impl cv_flann_LshIndexParams {
    #[inline]
    pub unsafe fn new(
        table_number: ::std::os::raw::c_int,
        key_size: ::std::os::raw::c_int,
        multi_probe_level: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_flann_LshIndexParams_LshIndexParams(
            __bindgen_tmp.as_mut_ptr(),
            table_number,
            key_size,
            multi_probe_level,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_flann_SavedIndexParams {
    pub _base: cv_flann_IndexParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_flann_SavedIndexParams"]
        [::std::mem::size_of::<cv_flann_SavedIndexParams>() - 8usize];
    ["Alignment of cv_flann_SavedIndexParams"]
        [::std::mem::align_of::<cv_flann_SavedIndexParams>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann16SavedIndexParamsC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_flann_SavedIndexParams_SavedIndexParams(
        this: *mut cv_flann_SavedIndexParams,
        filename: *const cv_String,
    );
}
impl cv_flann_SavedIndexParams {
    #[inline]
    pub unsafe fn new(filename: *const cv_String) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_flann_SavedIndexParams_SavedIndexParams(__bindgen_tmp.as_mut_ptr(), filename);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_flann_SearchParams {
    pub _base: cv_flann_IndexParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_flann_SearchParams"][::std::mem::size_of::<cv_flann_SearchParams>() - 8usize];
    ["Alignment of cv_flann_SearchParams"]
        [::std::mem::align_of::<cv_flann_SearchParams>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann12SearchParamsC1Eifb"]
    pub fn cv_flann_SearchParams_SearchParams(
        this: *mut cv_flann_SearchParams,
        checks: ::std::os::raw::c_int,
        eps: f32,
        sorted: bool,
    );
}
impl cv_flann_SearchParams {
    #[inline]
    pub unsafe fn new(checks: ::std::os::raw::c_int, eps: f32, sorted: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_flann_SearchParams_SearchParams(__bindgen_tmp.as_mut_ptr(), checks, eps, sorted);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct cv_flann_Index__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct cv_flann_Index {
    pub vtable_: *const cv_flann_Index__bindgen_vtable,
    pub distType: cvflann_flann_distance_t,
    pub algo: cvflann_flann_algorithm_t,
    pub featureType: ::std::os::raw::c_int,
    pub index: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_flann_Index"][::std::mem::size_of::<cv_flann_Index>() - 32usize];
    ["Alignment of cv_flann_Index"][::std::mem::align_of::<cv_flann_Index>() - 8usize];
    ["Offset of field: cv_flann_Index::distType"]
        [::std::mem::offset_of!(cv_flann_Index, distType) - 8usize];
    ["Offset of field: cv_flann_Index::algo"]
        [::std::mem::offset_of!(cv_flann_Index, algo) - 12usize];
    ["Offset of field: cv_flann_Index::featureType"]
        [::std::mem::offset_of!(cv_flann_Index, featureType) - 16usize];
    ["Offset of field: cv_flann_Index::index"]
        [::std::mem::offset_of!(cv_flann_Index, index) - 24usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5flann5Index11getDistanceEv"]
    pub fn cv_flann_Index_getDistance(this: *const cv_flann_Index) -> cvflann_flann_distance_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5flann5Index12getAlgorithmEv"]
    pub fn cv_flann_Index_getAlgorithm(this: *const cv_flann_Index) -> cvflann_flann_algorithm_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann5IndexC1Ev"]
    pub fn cv_flann_Index_Index(this: *mut cv_flann_Index);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann5IndexC1ERKNS_11_InputArrayERKNS0_11IndexParamsEN7cvflann16flann_distance_tE"]
    pub fn cv_flann_Index_Index1(
        this: *mut cv_flann_Index,
        features: cv_InputArray,
        params: *const cv_flann_IndexParams,
        distType: cvflann_flann_distance_t,
    );
}
impl cv_flann_Index {
    #[inline]
    pub unsafe fn getDistance(&self) -> cvflann_flann_distance_t {
        cv_flann_Index_getDistance(self)
    }
    #[inline]
    pub unsafe fn getAlgorithm(&self) -> cvflann_flann_algorithm_t {
        cv_flann_Index_getAlgorithm(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_flann_Index_Index(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        features: cv_InputArray,
        params: *const cv_flann_IndexParams,
        distType: cvflann_flann_distance_t,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_flann_Index_Index1(__bindgen_tmp.as_mut_ptr(), features, params, distType);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann5IndexD1Ev"]
    pub fn cv_flann_Index_Index_destructor(this: *mut cv_flann_Index);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann5Index5buildERKNS_11_InputArrayERKNS0_11IndexParamsEN7cvflann16flann_distance_tE"]
    pub fn cv_flann_Index_build(
        this: *mut ::std::os::raw::c_void,
        features: cv_InputArray,
        params: *const cv_flann_IndexParams,
        distType: cvflann_flann_distance_t,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann5Index9knnSearchERKNS_11_InputArrayERKNS_12_OutputArrayES7_iRKNS0_12SearchParamsE"]
    pub fn cv_flann_Index_knnSearch(
        this: *mut ::std::os::raw::c_void,
        query: cv_InputArray,
        indices: cv_OutputArray,
        dists: cv_OutputArray,
        knn: ::std::os::raw::c_int,
        params: *const cv_flann_SearchParams,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann5Index12radiusSearchERKNS_11_InputArrayERKNS_12_OutputArrayES7_diRKNS0_12SearchParamsE"]
    pub fn cv_flann_Index_radiusSearch(
        this: *mut ::std::os::raw::c_void,
        query: cv_InputArray,
        indices: cv_OutputArray,
        dists: cv_OutputArray,
        radius: f64,
        maxResults: ::std::os::raw::c_int,
        params: *const cv_flann_SearchParams,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv5flann5Index4saveERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_flann_Index_save(this: *mut ::std::os::raw::c_void, filename: *const cv_String);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann5Index4loadERKNS_11_InputArrayERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_flann_Index_load(
        this: *mut ::std::os::raw::c_void,
        features: cv_InputArray,
        filename: *const cv_String,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv5flann5Index7releaseEv"]
    pub fn cv_flann_Index_release(this: *mut ::std::os::raw::c_void);
}
#[doc = "! @addtogroup flann\n! @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_flann_CvType {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_flann_CvType_open0_unsigned_char_close0"]
        [::std::mem::size_of::<cv_flann_CvType>() - 1usize];
    ["Align of template specialization: cv_flann_CvType_open0_unsigned_char_close0"]
        [::std::mem::align_of::<cv_flann_CvType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_flann_CvType_open0_char_close0"]
        [::std::mem::size_of::<cv_flann_CvType>() - 1usize];
    ["Align of template specialization: cv_flann_CvType_open0_char_close0"]
        [::std::mem::align_of::<cv_flann_CvType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_flann_CvType_open0_unsigned_short_close0"]
        [::std::mem::size_of::<cv_flann_CvType>() - 1usize];
    ["Align of template specialization: cv_flann_CvType_open0_unsigned_short_close0"]
        [::std::mem::align_of::<cv_flann_CvType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_flann_CvType_open0_short_close0"]
        [::std::mem::size_of::<cv_flann_CvType>() - 1usize];
    ["Align of template specialization: cv_flann_CvType_open0_short_close0"]
        [::std::mem::align_of::<cv_flann_CvType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_flann_CvType_open0_int_close0"]
        [::std::mem::size_of::<cv_flann_CvType>() - 1usize];
    ["Align of template specialization: cv_flann_CvType_open0_int_close0"]
        [::std::mem::align_of::<cv_flann_CvType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_flann_CvType_open0_float_close0"]
        [::std::mem::size_of::<cv_flann_CvType>() - 1usize];
    ["Align of template specialization: cv_flann_CvType_open0_float_close0"]
        [::std::mem::align_of::<cv_flann_CvType>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_flann_CvType_open0_double_close0"]
        [::std::mem::size_of::<cv_flann_CvType>() - 1usize];
    ["Align of template specialization: cv_flann_CvType_open0_double_close0"]
        [::std::mem::align_of::<cv_flann_CvType>() - 1usize];
};
#[doc = " @brief The FLANN nearest neighbor index class. This class is templated with the type of elements for which\nthe index is built.\n\n`Distance` functor specifies the metric to be used to calculate the distance between two points.\nThere are several `Distance` functors that are readily available:\n\ncv::cvflann::L2_Simple - Squared Euclidean distance functor.\nThis is the simpler, unrolled version. This is preferable for very low dimensionality data (eg 3D points)\n\ncv::flann::L2 - Squared Euclidean distance functor, optimized version.\n\ncv::flann::L1 - Manhattan distance functor, optimized version.\n\ncv::flann::MinkowskiDistance -  The Minkowsky distance functor.\nThis is highly optimised with loop unrolling.\nThe computation of squared root at the end is omitted for efficiency.\n\ncv::flann::MaxDistance - The max distance functor. It computes the\nmaximum distance between two vectors. This distance is not a valid kdtree distance, it's not\ndimensionwise additive.\n\ncv::flann::HammingLUT -  %Hamming distance functor. It counts the bit\ndifferences between two strings using a lookup table implementation.\n\ncv::flann::Hamming - %Hamming distance functor. Population count is\nperformed using library calls, if available. Lookup table implementation is used as a fallback.\n\ncv::flann::Hamming2 - %Hamming distance functor. Population count is\nimplemented in 12 arithmetic operations (one of which is multiplication).\n\ncv::flann::HistIntersectionDistance - The histogram\nintersection distance functor.\n\ncv::flann::HellingerDistance - The Hellinger distance functor.\n\ncv::flann::ChiSquareDistance - The chi-square distance functor.\n\ncv::flann::KL_Divergence - The Kullback-Leibler divergence functor.\n\nAlthough the provided implementations cover a vast range of cases, it is also possible to use\na custom implementation. The distance functor is a class whose `operator()` computes the distance\nbetween two features. If the distance is also a kd-tree compatible distance, it should also provide an\n`accum_dist()` method that computes the distance between individual feature dimensions.\n\nIn addition to `operator()` and `accum_dist()`, a distance functor should also define the\n`ElementType` and the `ResultType` as the types of the elements it operates on and the type of the\nresult it computes. If a distance functor can be used as a kd-tree distance (meaning that the full\ndistance between a pair of features can be accumulated from the partial distances between the\nindividual dimensions) a typedef `is_kdtree_distance` should be present inside the distance functor.\nIf the distance is not a kd-tree distance, but it's a distance in a vector space (the individual\ndimensions of the elements it operates on can be accessed independently) a typedef\n`is_vector_space_distance` should be defined inside the functor. If neither typedef is defined, the\ndistance is assumed to be a metric distance and will only be used with indexes operating on\ngeneric metric distances."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_flann_GenericIndex {
    pub nnIndex: *mut cvflann_Index,
    pub _dataset: cv_Mat,
}
pub type cv_flann_GenericIndex_ElementType = __BindgenOpaqueArray<u8, 0usize>;
pub type cv_flann_GenericIndex_DistanceType = __BindgenOpaqueArray<u8, 0usize>;
#[doc = " @deprecated Use GenericIndex class instead"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_flann_Index_ {
    pub nnIndex_L2: *mut cvflann_Index,
    pub nnIndex_L1: *mut cvflann_Index,
}
pub type cv_flann_Index__ElementType = cvflann_L2;
pub type cv_flann_Index__DistanceType = cvflann_L2;
#[doc = " @brief A class filters a vector of keypoints.\n\nBecause now it is difficult to provide a convenient interface for all usage scenarios of the\nkeypoints filter class, it has only several needed by now static methods."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_KeyPointsFilter {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_KeyPointsFilter"][::std::mem::size_of::<cv_KeyPointsFilter>() - 1usize];
    ["Alignment of cv_KeyPointsFilter"][::std::mem::align_of::<cv_KeyPointsFilter>() - 1usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv15KeyPointsFilter16runByImageBorderERSt6vectorINS_8KeyPointESaIS2_EENS_5Size_IiEEi"]
    pub fn cv_KeyPointsFilter_runByImageBorder(
        keypoints: *mut std_vector,
        imageSize: cv_Size,
        borderSize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv15KeyPointsFilter17runByKeypointSizeERSt6vectorINS_8KeyPointESaIS2_EEff"]
    pub fn cv_KeyPointsFilter_runByKeypointSize(
        keypoints: *mut std_vector,
        minSize: f32,
        maxSize: f32,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv15KeyPointsFilter15runByPixelsMaskERSt6vectorINS_8KeyPointESaIS2_EERKNS_3MatE"]
    pub fn cv_KeyPointsFilter_runByPixelsMask(keypoints: *mut std_vector, mask: *const cv_Mat);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv15KeyPointsFilter16removeDuplicatedERSt6vectorINS_8KeyPointESaIS2_EE"]
    pub fn cv_KeyPointsFilter_removeDuplicated(keypoints: *mut std_vector);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv15KeyPointsFilter22removeDuplicatedSortedERSt6vectorINS_8KeyPointESaIS2_EE"]
    pub fn cv_KeyPointsFilter_removeDuplicatedSorted(keypoints: *mut std_vector);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv15KeyPointsFilter10retainBestERSt6vectorINS_8KeyPointESaIS2_EEi"]
    pub fn cv_KeyPointsFilter_retainBest(
        keypoints: *mut std_vector,
        npoints: ::std::os::raw::c_int,
    );
}
impl cv_KeyPointsFilter {
    #[inline]
    pub unsafe fn runByImageBorder(
        keypoints: *mut std_vector,
        imageSize: cv_Size,
        borderSize: ::std::os::raw::c_int,
    ) {
        cv_KeyPointsFilter_runByImageBorder(keypoints, imageSize, borderSize)
    }
    #[inline]
    pub unsafe fn runByKeypointSize(keypoints: *mut std_vector, minSize: f32, maxSize: f32) {
        cv_KeyPointsFilter_runByKeypointSize(keypoints, minSize, maxSize)
    }
    #[inline]
    pub unsafe fn runByPixelsMask(keypoints: *mut std_vector, mask: *const cv_Mat) {
        cv_KeyPointsFilter_runByPixelsMask(keypoints, mask)
    }
    #[inline]
    pub unsafe fn removeDuplicated(keypoints: *mut std_vector) {
        cv_KeyPointsFilter_removeDuplicated(keypoints)
    }
    #[inline]
    pub unsafe fn removeDuplicatedSorted(keypoints: *mut std_vector) {
        cv_KeyPointsFilter_removeDuplicatedSorted(keypoints)
    }
    #[inline]
    pub unsafe fn retainBest(keypoints: *mut std_vector, npoints: ::std::os::raw::c_int) {
        cv_KeyPointsFilter_retainBest(keypoints, npoints)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_Feature2D {
    pub __bindgen_padding_0: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_Feature2D"][::std::mem::size_of::<cv_Feature2D>() - 8usize];
    ["Alignment of cv_Feature2D"][::std::mem::align_of::<cv_Feature2D>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv9Feature2D5writeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_Feature2D_write(this: *const cv_Feature2D, fileName: *const cv_String);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9Feature2D4readERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_Feature2D_read(this: *mut cv_Feature2D, fileName: *const cv_String);
}
impl cv_Feature2D {
    #[inline]
    pub unsafe fn write(&self, fileName: *const cv_String) {
        cv_Feature2D_write(self, fileName)
    }
    #[inline]
    pub unsafe fn read(&mut self, fileName: *const cv_String) {
        cv_Feature2D_read(self, fileName)
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9Feature2DD1Ev"]
    pub fn cv_Feature2D_Feature2D_destructor(this: *mut cv_Feature2D);
}
unsafe extern "C" {
    #[doc = " @brief Detects keypoints in an image (first variant) or image set (second variant).\n\n@param image Image.\n@param keypoints The detected keypoints. In the second variant of the method keypoints[i] is a set\nof keypoints detected in images[i] .\n@param mask Mask specifying where to look for keypoints (optional). It must be a 8-bit integer\nmatrix with non-zero values in the region of interest."]
    #[link_name = "\u{1}_ZN2cv9Feature2D6detectERKNS_11_InputArrayERSt6vectorINS_8KeyPointESaIS5_EES3_"]
    pub fn cv_Feature2D_detect(
        this: *mut ::std::os::raw::c_void,
        image: cv_InputArray,
        keypoints: *mut std_vector,
        mask: cv_InputArray,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param images Image set.\n@param keypoints The detected keypoints. In the second variant of the method keypoints[i] is a set\nof keypoints detected in images[i] .\n@param masks Masks for each input image specifying where to look for keypoints (optional).\nmasks[i] is a mask for images[i]."]
    #[link_name = "\u{1}_ZN2cv9Feature2D6detectERKNS_11_InputArrayERSt6vectorIS4_INS_8KeyPointESaIS5_EESaIS7_EES3_"]
    pub fn cv_Feature2D_detect1(
        this: *mut ::std::os::raw::c_void,
        images: cv_InputArrayOfArrays,
        keypoints: *mut std_vector,
        masks: cv_InputArrayOfArrays,
    );
}
unsafe extern "C" {
    #[doc = " @brief Computes the descriptors for a set of keypoints detected in an image (first variant) or image set\n(second variant).\n\n@param image Image.\n@param keypoints Input collection of keypoints. Keypoints for which a descriptor cannot be\ncomputed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint\nwith several dominant orientations (for each orientation).\n@param descriptors Computed descriptors. In the second variant of the method descriptors[i] are\ndescriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the\ndescriptor for keypoint j-th keypoint."]
    #[link_name = "\u{1}_ZN2cv9Feature2D7computeERKNS_11_InputArrayERSt6vectorINS_8KeyPointESaIS5_EERKNS_12_OutputArrayE"]
    pub fn cv_Feature2D_compute(
        this: *mut ::std::os::raw::c_void,
        image: cv_InputArray,
        keypoints: *mut std_vector,
        descriptors: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n\n@param images Image set.\n@param keypoints Input collection of keypoints. Keypoints for which a descriptor cannot be\ncomputed are removed. Sometimes new keypoints can be added, for example: SIFT duplicates keypoint\nwith several dominant orientations (for each orientation).\n@param descriptors Computed descriptors. In the second variant of the method descriptors[i] are\ndescriptors computed for a keypoints[i]. Row j is the keypoints (or keypoints[i]) is the\ndescriptor for keypoint j-th keypoint."]
    #[link_name = "\u{1}_ZN2cv9Feature2D7computeERKNS_11_InputArrayERSt6vectorIS4_INS_8KeyPointESaIS5_EESaIS7_EERKNS_12_OutputArrayE"]
    pub fn cv_Feature2D_compute1(
        this: *mut ::std::os::raw::c_void,
        images: cv_InputArrayOfArrays,
        keypoints: *mut std_vector,
        descriptors: cv_OutputArrayOfArrays,
    );
}
unsafe extern "C" {
    #[doc = " Detects keypoints and computes the descriptors"]
    #[link_name = "\u{1}_ZN2cv9Feature2D16detectAndComputeERKNS_11_InputArrayES3_RSt6vectorINS_8KeyPointESaIS5_EERKNS_12_OutputArrayEb"]
    pub fn cv_Feature2D_detectAndCompute(
        this: *mut ::std::os::raw::c_void,
        image: cv_InputArray,
        mask: cv_InputArray,
        keypoints: *mut std_vector,
        descriptors: cv_OutputArray,
        useProvidedKeypoints: bool,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv9Feature2D14descriptorSizeEv"]
    pub fn cv_Feature2D_descriptorSize(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv9Feature2D14descriptorTypeEv"]
    pub fn cv_Feature2D_descriptorType(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv9Feature2D11defaultNormEv"]
    pub fn cv_Feature2D_defaultNorm(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZTv0_n40_NK2cv9Feature2D5writeERNS_11FileStorageE"]
    pub fn cv_Feature2D_write1(this: *mut ::std::os::raw::c_void, arg1: *mut cv_FileStorage);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZTv0_n48_N2cv9Feature2D4readERKNS_8FileNodeE"]
    pub fn cv_Feature2D_read1(this: *mut ::std::os::raw::c_void, arg1: *const cv_FileNode);
}
unsafe extern "C" {
    #[doc = "! Return true if detector object is empty"]
    #[link_name = "\u{1}_ZTv0_n56_NK2cv9Feature2D5emptyEv"]
    pub fn cv_Feature2D_empty(this: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZTv0_n72_NK2cv9Feature2D14getDefaultNameB5cxx11Ev"]
    pub fn cv_Feature2D_getDefaultName(this: *mut ::std::os::raw::c_void) -> cv_String;
}
#[doc = " Feature detectors in OpenCV have wrappers with a common interface that enables you to easily switch\nbetween different algorithms solving the same problem. All objects that implement keypoint detectors\ninherit the FeatureDetector interface."]
pub type cv_FeatureDetector = cv_Feature2D;
#[doc = " Extractors of keypoint descriptors in OpenCV have wrappers with a common interface that enables you\nto easily switch between different algorithms solving the same problem. This section is devoted to\ncomputing descriptors represented as vectors in a multidimensional space. All objects that implement\nthe vector descriptor extractors inherit the DescriptorExtractor interface."]
pub type cv_DescriptorExtractor = cv_Feature2D;
#[doc = " @brief Class implementing the BRISK keypoint detector and descriptor extractor, described in @cite LCS11 ."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_BRISK {
    pub _base: cv_Feature2D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_BRISK"][::std::mem::size_of::<cv_BRISK>() - 8usize];
    ["Alignment of cv_BRISK"][::std::mem::align_of::<cv_BRISK>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief The BRISK constructor\n\n@param thresh AGAST detection threshold score.\n@param octaves detection octaves. Use 0 to do single scale.\n@param patternScale apply this scale to the pattern used for sampling the neighbourhood of a\nkeypoint."]
    #[link_name = "\u{1}_ZN2cv5BRISK6createEiif"]
    pub fn cv_BRISK_create(
        thresh: ::std::os::raw::c_int,
        octaves: ::std::os::raw::c_int,
        patternScale: f32,
    ) -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief The BRISK constructor for a custom pattern\n\n@param radiusList defines the radii (in pixels) where the samples around a keypoint are taken (for\nkeypoint scale 1).\n@param numberList defines the number of sampling points on the sampling circle. Must be the same\nsize as radiusList..\n@param dMax threshold for the short pairings used for descriptor formation (in pixels for keypoint\nscale 1).\n@param dMin threshold for the long pairings used for orientation determination (in pixels for\nkeypoint scale 1).\n@param indexChange index remapping of the bits."]
    #[link_name = "\u{1}_ZN2cv5BRISK6createERKSt6vectorIfSaIfEERKS1_IiSaIiEEffS9_"]
    pub fn cv_BRISK_create1(
        radiusList: *const std_vector,
        numberList: *const std_vector,
        dMax: f32,
        dMin: f32,
        indexChange: *const std_vector,
    ) -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief The BRISK constructor for a custom pattern, detection threshold and octaves\n\n@param thresh AGAST detection threshold score.\n@param octaves detection octaves. Use 0 to do single scale.\n@param radiusList defines the radii (in pixels) where the samples around a keypoint are taken (for\nkeypoint scale 1).\n@param numberList defines the number of sampling points on the sampling circle. Must be the same\nsize as radiusList..\n@param dMax threshold for the short pairings used for descriptor formation (in pixels for keypoint\nscale 1).\n@param dMin threshold for the long pairings used for orientation determination (in pixels for\nkeypoint scale 1).\n@param indexChange index remapping of the bits."]
    #[link_name = "\u{1}_ZN2cv5BRISK6createEiiRKSt6vectorIfSaIfEERKS1_IiSaIiEEffS9_"]
    pub fn cv_BRISK_create2(
        thresh: ::std::os::raw::c_int,
        octaves: ::std::os::raw::c_int,
        radiusList: *const std_vector,
        numberList: *const std_vector,
        dMax: f32,
        dMin: f32,
        indexChange: *const std_vector,
    ) -> cv_Ptr;
}
impl cv_BRISK {
    #[inline]
    pub unsafe fn create(
        thresh: ::std::os::raw::c_int,
        octaves: ::std::os::raw::c_int,
        patternScale: f32,
    ) -> cv_Ptr {
        cv_BRISK_create(thresh, octaves, patternScale)
    }
    #[inline]
    pub unsafe fn create1(
        radiusList: *const std_vector,
        numberList: *const std_vector,
        dMax: f32,
        dMin: f32,
        indexChange: *const std_vector,
    ) -> cv_Ptr {
        cv_BRISK_create1(radiusList, numberList, dMax, dMin, indexChange)
    }
    #[inline]
    pub unsafe fn create2(
        thresh: ::std::os::raw::c_int,
        octaves: ::std::os::raw::c_int,
        radiusList: *const std_vector,
        numberList: *const std_vector,
        dMax: f32,
        dMin: f32,
        indexChange: *const std_vector,
    ) -> cv_Ptr {
        cv_BRISK_create2(
            thresh,
            octaves,
            radiusList,
            numberList,
            dMax,
            dMin,
            indexChange,
        )
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZTv0_n72_NK2cv5BRISK14getDefaultNameB5cxx11Ev"]
    pub fn cv_BRISK_getDefaultName(this: *mut ::std::os::raw::c_void) -> cv_String;
}
#[doc = " @brief Class implementing the ORB (*oriented BRIEF*) keypoint detector and descriptor extractor\n\ndescribed in @cite RRKB11 . The algorithm uses FAST in pyramids to detect stable keypoints, selects\nthe strongest features using FAST or Harris response, finds their orientation using first-order\nmoments and computes the descriptors using BRIEF (where the coordinates of random point pairs (or\nk-tuples) are rotated according to the measured orientation)."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_ORB {
    pub _base: cv_Feature2D,
}
pub const cv_ORB_ScoreType_HARRIS_SCORE: cv_ORB_ScoreType = 0;
pub const cv_ORB_ScoreType_FAST_SCORE: cv_ORB_ScoreType = 1;
pub type cv_ORB_ScoreType = ::std::os::raw::c_uint;
pub const cv_ORB_kBytes: ::std::os::raw::c_int = 32;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ORB"][::std::mem::size_of::<cv_ORB>() - 8usize];
    ["Alignment of cv_ORB"][::std::mem::align_of::<cv_ORB>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief The ORB constructor\n\n@param nfeatures The maximum number of features to retain.\n@param scaleFactor Pyramid decimation ratio, greater than 1. scaleFactor==2 means the classical\npyramid, where each next level has 4x less pixels than the previous, but such a big scale factor\nwill degrade feature matching scores dramatically. On the other hand, too close to 1 scale factor\nwill mean that to cover certain scale range you will need more pyramid levels and so the speed\nwill suffer.\n@param nlevels The number of pyramid levels. The smallest level will have linear size equal to\ninput_image_linear_size/pow(scaleFactor, nlevels - firstLevel).\n@param edgeThreshold This is size of the border where the features are not detected. It should\nroughly match the patchSize parameter.\n@param firstLevel The level of pyramid to put source image to. Previous layers are filled\nwith upscaled source image.\n@param WTA_K The number of points that produce each element of the oriented BRIEF descriptor. The\ndefault value 2 means the BRIEF where we take a random point pair and compare their brightnesses,\nso we get 0/1 response. Other possible values are 3 and 4. For example, 3 means that we take 3\nrandom points (of course, those point coordinates are random, but they are generated from the\npre-defined seed, so each element of BRIEF descriptor is computed deterministically from the pixel\nrectangle), find point of maximum brightness and output index of the winner (0, 1 or 2). Such\noutput will occupy 2 bits, and therefore it will need a special variant of Hamming distance,\ndenoted as NORM_HAMMING2 (2 bits per bin). When WTA_K=4, we take 4 random points to compute each\nbin (that will also occupy 2 bits with possible values 0, 1, 2 or 3).\n@param scoreType The default HARRIS_SCORE means that Harris algorithm is used to rank features\n(the score is written to KeyPoint::score and is used to retain best nfeatures features);\nFAST_SCORE is alternative value of the parameter that produces slightly less stable keypoints,\nbut it is a little faster to compute.\n@param patchSize size of the patch used by the oriented BRIEF descriptor. Of course, on smaller\npyramid layers the perceived image area covered by a feature will be larger.\n@param fastThreshold the fast threshold"]
    #[link_name = "\u{1}_ZN2cv3ORB6createEifiiiiNS0_9ScoreTypeEii"]
    pub fn cv_ORB_create(
        nfeatures: ::std::os::raw::c_int,
        scaleFactor: f32,
        nlevels: ::std::os::raw::c_int,
        edgeThreshold: ::std::os::raw::c_int,
        firstLevel: ::std::os::raw::c_int,
        WTA_K: ::std::os::raw::c_int,
        scoreType: cv_ORB_ScoreType,
        patchSize: ::std::os::raw::c_int,
        fastThreshold: ::std::os::raw::c_int,
    ) -> cv_Ptr;
}
impl cv_ORB {
    #[inline]
    pub unsafe fn create(
        nfeatures: ::std::os::raw::c_int,
        scaleFactor: f32,
        nlevels: ::std::os::raw::c_int,
        edgeThreshold: ::std::os::raw::c_int,
        firstLevel: ::std::os::raw::c_int,
        WTA_K: ::std::os::raw::c_int,
        scoreType: cv_ORB_ScoreType,
        patchSize: ::std::os::raw::c_int,
        fastThreshold: ::std::os::raw::c_int,
    ) -> cv_Ptr {
        cv_ORB_create(
            nfeatures,
            scaleFactor,
            nlevels,
            edgeThreshold,
            firstLevel,
            WTA_K,
            scoreType,
            patchSize,
            fastThreshold,
        )
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZTv0_n72_NK2cv3ORB14getDefaultNameB5cxx11Ev"]
    pub fn cv_ORB_getDefaultName(this: *mut ::std::os::raw::c_void) -> cv_String;
}
#[doc = " @brief Maximally stable extremal region extractor\n\nThe class encapsulates all the parameters of the %MSER extraction algorithm (see [wiki\narticle](http://en.wikipedia.org/wiki/Maximally_stable_extremal_regions)).\n\n- there are two different implementation of %MSER: one for grey image, one for color image\n\n- the grey image algorithm is taken from: @cite nister2008linear ;  the paper claims to be faster\nthan union-find method; it actually get 1.5~2m/s on my centrino L7200 1.2GHz laptop.\n\n- the color image algorithm is taken from: @cite forssen2007maximally ; it should be much slower\nthan grey image method ( 3~4 times ); the chi_table.h file is taken directly from paper's source\ncode which is distributed under GPL.\n\n- (Python) A complete example showing the use of the %MSER detector can be found at samples/python/mser.py"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_MSER {
    pub _base: cv_Feature2D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_MSER"][::std::mem::size_of::<cv_MSER>() - 8usize];
    ["Alignment of cv_MSER"][::std::mem::align_of::<cv_MSER>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Full consturctor for %MSER detector\n\n@param _delta it compares \\f$(size_{i}-size_{i-delta})/size_{i-delta}\\f$\n@param _min_area prune the area which smaller than minArea\n@param _max_area prune the area which bigger than maxArea\n@param _max_variation prune the area have similar size to its children\n@param _min_diversity for color image, trace back to cut off mser with diversity less than min_diversity\n@param _max_evolution  for color image, the evolution steps\n@param _area_threshold for color image, the area threshold to cause re-initialize\n@param _min_margin for color image, ignore too small margin\n@param _edge_blur_size for color image, the aperture size for edge blur"]
    #[link_name = "\u{1}_ZN2cv4MSER6createEiiiddiddi"]
    pub fn cv_MSER_create(
        _delta: ::std::os::raw::c_int,
        _min_area: ::std::os::raw::c_int,
        _max_area: ::std::os::raw::c_int,
        _max_variation: f64,
        _min_diversity: f64,
        _max_evolution: ::std::os::raw::c_int,
        _area_threshold: f64,
        _min_margin: f64,
        _edge_blur_size: ::std::os::raw::c_int,
    ) -> cv_Ptr;
}
impl cv_MSER {
    #[inline]
    pub unsafe fn create(
        _delta: ::std::os::raw::c_int,
        _min_area: ::std::os::raw::c_int,
        _max_area: ::std::os::raw::c_int,
        _max_variation: f64,
        _min_diversity: f64,
        _max_evolution: ::std::os::raw::c_int,
        _area_threshold: f64,
        _min_margin: f64,
        _edge_blur_size: ::std::os::raw::c_int,
    ) -> cv_Ptr {
        cv_MSER_create(
            _delta,
            _min_area,
            _max_area,
            _max_variation,
            _min_diversity,
            _max_evolution,
            _area_threshold,
            _min_margin,
            _edge_blur_size,
        )
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZTv0_n72_NK2cv4MSER14getDefaultNameB5cxx11Ev"]
    pub fn cv_MSER_getDefaultName(this: *mut ::std::os::raw::c_void) -> cv_String;
}
#[doc = " @brief Wrapping class for feature detection using the FAST method. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_FastFeatureDetector {
    pub _base: cv_Feature2D,
}
pub const cv_FastFeatureDetector_DetectorType_TYPE_5_8: cv_FastFeatureDetector_DetectorType = 0;
pub const cv_FastFeatureDetector_DetectorType_TYPE_7_12: cv_FastFeatureDetector_DetectorType = 1;
pub const cv_FastFeatureDetector_DetectorType_TYPE_9_16: cv_FastFeatureDetector_DetectorType = 2;
pub type cv_FastFeatureDetector_DetectorType = ::std::os::raw::c_uint;
pub const cv_FastFeatureDetector_THRESHOLD: cv_FastFeatureDetector__bindgen_ty_1 = 10000;
pub const cv_FastFeatureDetector_NONMAX_SUPPRESSION: cv_FastFeatureDetector__bindgen_ty_1 = 10001;
pub const cv_FastFeatureDetector_FAST_N: cv_FastFeatureDetector__bindgen_ty_1 = 10002;
pub type cv_FastFeatureDetector__bindgen_ty_1 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_FastFeatureDetector"][::std::mem::size_of::<cv_FastFeatureDetector>() - 8usize];
    ["Alignment of cv_FastFeatureDetector"]
        [::std::mem::align_of::<cv_FastFeatureDetector>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv19FastFeatureDetector6createEibNS0_12DetectorTypeE"]
    pub fn cv_FastFeatureDetector_create(
        threshold: ::std::os::raw::c_int,
        nonmaxSuppression: bool,
        type_: cv_FastFeatureDetector_DetectorType,
    ) -> cv_Ptr;
}
impl cv_FastFeatureDetector {
    #[inline]
    pub unsafe fn create(
        threshold: ::std::os::raw::c_int,
        nonmaxSuppression: bool,
        type_: cv_FastFeatureDetector_DetectorType,
    ) -> cv_Ptr {
        cv_FastFeatureDetector_create(threshold, nonmaxSuppression, type_)
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZTv0_n72_NK2cv19FastFeatureDetector14getDefaultNameB5cxx11Ev"]
    pub fn cv_FastFeatureDetector_getDefaultName(this: *mut ::std::os::raw::c_void) -> cv_String;
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv4FASTERKNS_11_InputArrayERSt6vectorINS_8KeyPointESaIS4_EEib"]
    pub fn cv_FAST(
        image: cv_InputArray,
        keypoints: *mut std_vector,
        threshold: ::std::os::raw::c_int,
        nonmaxSuppression: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief Detects corners using the FAST algorithm\n\n@param image grayscale image where keypoints (corners) are detected.\n@param keypoints keypoints detected on the image.\n@param threshold threshold on difference between intensity of the central pixel and pixels of a\ncircle around this pixel.\n@param nonmaxSuppression if true, non-maximum suppression is applied to detected corners\n(keypoints).\n@param type one of the three neighborhoods as defined in the paper:\nFastFeatureDetector::TYPE_9_16, FastFeatureDetector::TYPE_7_12,\nFastFeatureDetector::TYPE_5_8\n\nDetects corners using the FAST algorithm by @cite Rosten06 .\n\n@note In Python API, types are given as cv.FAST_FEATURE_DETECTOR_TYPE_5_8,\ncv.FAST_FEATURE_DETECTOR_TYPE_7_12 and cv.FAST_FEATURE_DETECTOR_TYPE_9_16. For corner\ndetection, use cv.FAST.detect() method."]
    #[link_name = "\u{1}_ZN2cv4FASTERKNS_11_InputArrayERSt6vectorINS_8KeyPointESaIS4_EEibNS_19FastFeatureDetector12DetectorTypeE"]
    pub fn cv_FAST1(
        image: cv_InputArray,
        keypoints: *mut std_vector,
        threshold: ::std::os::raw::c_int,
        nonmaxSuppression: bool,
        type_: cv_FastFeatureDetector_DetectorType,
    );
}
#[doc = " @brief Wrapping class for feature detection using the AGAST method. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_AgastFeatureDetector {
    pub _base: cv_Feature2D,
}
pub const cv_AgastFeatureDetector_DetectorType_AGAST_5_8: cv_AgastFeatureDetector_DetectorType = 0;
pub const cv_AgastFeatureDetector_DetectorType_AGAST_7_12d: cv_AgastFeatureDetector_DetectorType =
    1;
pub const cv_AgastFeatureDetector_DetectorType_AGAST_7_12s: cv_AgastFeatureDetector_DetectorType =
    2;
pub const cv_AgastFeatureDetector_DetectorType_OAST_9_16: cv_AgastFeatureDetector_DetectorType = 3;
pub type cv_AgastFeatureDetector_DetectorType = ::std::os::raw::c_uint;
pub const cv_AgastFeatureDetector_THRESHOLD: cv_AgastFeatureDetector__bindgen_ty_1 = 10000;
pub const cv_AgastFeatureDetector_NONMAX_SUPPRESSION: cv_AgastFeatureDetector__bindgen_ty_1 = 10001;
pub type cv_AgastFeatureDetector__bindgen_ty_1 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_AgastFeatureDetector"][::std::mem::size_of::<cv_AgastFeatureDetector>() - 8usize];
    ["Alignment of cv_AgastFeatureDetector"]
        [::std::mem::align_of::<cv_AgastFeatureDetector>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv20AgastFeatureDetector6createEibNS0_12DetectorTypeE"]
    pub fn cv_AgastFeatureDetector_create(
        threshold: ::std::os::raw::c_int,
        nonmaxSuppression: bool,
        type_: cv_AgastFeatureDetector_DetectorType,
    ) -> cv_Ptr;
}
impl cv_AgastFeatureDetector {
    #[inline]
    pub unsafe fn create(
        threshold: ::std::os::raw::c_int,
        nonmaxSuppression: bool,
        type_: cv_AgastFeatureDetector_DetectorType,
    ) -> cv_Ptr {
        cv_AgastFeatureDetector_create(threshold, nonmaxSuppression, type_)
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZTv0_n72_NK2cv20AgastFeatureDetector14getDefaultNameB5cxx11Ev"]
    pub fn cv_AgastFeatureDetector_getDefaultName(this: *mut ::std::os::raw::c_void) -> cv_String;
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv5AGASTERKNS_11_InputArrayERSt6vectorINS_8KeyPointESaIS4_EEib"]
    pub fn cv_AGAST(
        image: cv_InputArray,
        keypoints: *mut std_vector,
        threshold: ::std::os::raw::c_int,
        nonmaxSuppression: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief Detects corners using the AGAST algorithm\n\n@param image grayscale image where keypoints (corners) are detected.\n@param keypoints keypoints detected on the image.\n@param threshold threshold on difference between intensity of the central pixel and pixels of a\ncircle around this pixel.\n@param nonmaxSuppression if true, non-maximum suppression is applied to detected corners\n(keypoints).\n@param type one of the four neighborhoods as defined in the paper:\nAgastFeatureDetector::AGAST_5_8, AgastFeatureDetector::AGAST_7_12d,\nAgastFeatureDetector::AGAST_7_12s, AgastFeatureDetector::OAST_9_16\n\nFor non-Intel platforms, there is a tree optimised variant of AGAST with same numerical results.\nThe 32-bit binary tree tables were generated automatically from original code using perl script.\nThe perl script and examples of tree generation are placed in features2d/doc folder.\nDetects corners using the AGAST algorithm by @cite mair2010_agast .\n"]
    #[link_name = "\u{1}_ZN2cv5AGASTERKNS_11_InputArrayERSt6vectorINS_8KeyPointESaIS4_EEibNS_20AgastFeatureDetector12DetectorTypeE"]
    pub fn cv_AGAST1(
        image: cv_InputArray,
        keypoints: *mut std_vector,
        threshold: ::std::os::raw::c_int,
        nonmaxSuppression: bool,
        type_: cv_AgastFeatureDetector_DetectorType,
    );
}
#[doc = " @brief Wrapping class for feature detection using the goodFeaturesToTrack function. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_GFTTDetector {
    pub _base: cv_Feature2D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_GFTTDetector"][::std::mem::size_of::<cv_GFTTDetector>() - 8usize];
    ["Alignment of cv_GFTTDetector"][::std::mem::align_of::<cv_GFTTDetector>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv12GFTTDetector6createEiddibd"]
    pub fn cv_GFTTDetector_create(
        maxCorners: ::std::os::raw::c_int,
        qualityLevel: f64,
        minDistance: f64,
        blockSize: ::std::os::raw::c_int,
        useHarrisDetector: bool,
        k: f64,
    ) -> cv_Ptr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv12GFTTDetector6createEiddiibd"]
    pub fn cv_GFTTDetector_create1(
        maxCorners: ::std::os::raw::c_int,
        qualityLevel: f64,
        minDistance: f64,
        blockSize: ::std::os::raw::c_int,
        gradiantSize: ::std::os::raw::c_int,
        useHarrisDetector: bool,
        k: f64,
    ) -> cv_Ptr;
}
impl cv_GFTTDetector {
    #[inline]
    pub unsafe fn create(
        maxCorners: ::std::os::raw::c_int,
        qualityLevel: f64,
        minDistance: f64,
        blockSize: ::std::os::raw::c_int,
        useHarrisDetector: bool,
        k: f64,
    ) -> cv_Ptr {
        cv_GFTTDetector_create(
            maxCorners,
            qualityLevel,
            minDistance,
            blockSize,
            useHarrisDetector,
            k,
        )
    }
    #[inline]
    pub unsafe fn create1(
        maxCorners: ::std::os::raw::c_int,
        qualityLevel: f64,
        minDistance: f64,
        blockSize: ::std::os::raw::c_int,
        gradiantSize: ::std::os::raw::c_int,
        useHarrisDetector: bool,
        k: f64,
    ) -> cv_Ptr {
        cv_GFTTDetector_create1(
            maxCorners,
            qualityLevel,
            minDistance,
            blockSize,
            gradiantSize,
            useHarrisDetector,
            k,
        )
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZTv0_n72_NK2cv12GFTTDetector14getDefaultNameB5cxx11Ev"]
    pub fn cv_GFTTDetector_getDefaultName(this: *mut ::std::os::raw::c_void) -> cv_String;
}
#[doc = " @brief Class for extracting blobs from an image. :\n\nThe class implements a simple algorithm for extracting blobs from an image:\n\n1.  Convert the source image to binary images by applying thresholding with several thresholds from\nminThreshold (inclusive) to maxThreshold (exclusive) with distance thresholdStep between\nneighboring thresholds.\n2.  Extract connected components from every binary image by findContours and calculate their\ncenters.\n3.  Group centers from several binary images by their coordinates. Close centers form one group that\ncorresponds to one blob, which is controlled by the minDistBetweenBlobs parameter.\n4.  From the groups, estimate final centers of blobs and their radiuses and return as locations and\nsizes of keypoints.\n\nThis class performs several filtrations of returned blobs. You should set filterBy\\* to true/false\nto turn on/off corresponding filtration. Available filtrations:\n\n-   **By color**. This filter compares the intensity of a binary image at the center of a blob to\nblobColor. If they differ, the blob is filtered out. Use blobColor = 0 to extract dark blobs\nand blobColor = 255 to extract light blobs.\n-   **By area**. Extracted blobs have an area between minArea (inclusive) and maxArea (exclusive).\n-   **By circularity**. Extracted blobs have circularity\n(\\f$\\frac{4*\\pi*Area}{perimeter * perimeter}\\f$) between minCircularity (inclusive) and\nmaxCircularity (exclusive).\n-   **By ratio of the minimum inertia to maximum inertia**. Extracted blobs have this ratio\nbetween minInertiaRatio (inclusive) and maxInertiaRatio (exclusive).\n-   **By convexity**. Extracted blobs have convexity (area / area of blob convex hull) between\nminConvexity (inclusive) and maxConvexity (exclusive).\n\nDefault values of parameters are tuned to extract dark circular blobs."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_SimpleBlobDetector {
    pub _base: cv_Feature2D,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_SimpleBlobDetector_Params {
    pub thresholdStep: f32,
    pub minThreshold: f32,
    pub maxThreshold: f32,
    pub minRepeatability: usize,
    pub minDistBetweenBlobs: f32,
    pub filterByColor: bool,
    pub blobColor: uchar,
    pub filterByArea: bool,
    pub minArea: f32,
    pub maxArea: f32,
    pub filterByCircularity: bool,
    pub minCircularity: f32,
    pub maxCircularity: f32,
    pub filterByInertia: bool,
    pub minInertiaRatio: f32,
    pub maxInertiaRatio: f32,
    pub filterByConvexity: bool,
    pub minConvexity: f32,
    pub maxConvexity: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_SimpleBlobDetector_Params"]
        [::std::mem::size_of::<cv_SimpleBlobDetector_Params>() - 80usize];
    ["Alignment of cv_SimpleBlobDetector_Params"]
        [::std::mem::align_of::<cv_SimpleBlobDetector_Params>() - 8usize];
    ["Offset of field: cv_SimpleBlobDetector_Params::thresholdStep"]
        [::std::mem::offset_of!(cv_SimpleBlobDetector_Params, thresholdStep) - 0usize];
    ["Offset of field: cv_SimpleBlobDetector_Params::minThreshold"]
        [::std::mem::offset_of!(cv_SimpleBlobDetector_Params, minThreshold) - 4usize];
    ["Offset of field: cv_SimpleBlobDetector_Params::maxThreshold"]
        [::std::mem::offset_of!(cv_SimpleBlobDetector_Params, maxThreshold) - 8usize];
    ["Offset of field: cv_SimpleBlobDetector_Params::minRepeatability"]
        [::std::mem::offset_of!(cv_SimpleBlobDetector_Params, minRepeatability) - 16usize];
    ["Offset of field: cv_SimpleBlobDetector_Params::minDistBetweenBlobs"]
        [::std::mem::offset_of!(cv_SimpleBlobDetector_Params, minDistBetweenBlobs) - 24usize];
    ["Offset of field: cv_SimpleBlobDetector_Params::filterByColor"]
        [::std::mem::offset_of!(cv_SimpleBlobDetector_Params, filterByColor) - 28usize];
    ["Offset of field: cv_SimpleBlobDetector_Params::blobColor"]
        [::std::mem::offset_of!(cv_SimpleBlobDetector_Params, blobColor) - 29usize];
    ["Offset of field: cv_SimpleBlobDetector_Params::filterByArea"]
        [::std::mem::offset_of!(cv_SimpleBlobDetector_Params, filterByArea) - 30usize];
    ["Offset of field: cv_SimpleBlobDetector_Params::minArea"]
        [::std::mem::offset_of!(cv_SimpleBlobDetector_Params, minArea) - 32usize];
    ["Offset of field: cv_SimpleBlobDetector_Params::maxArea"]
        [::std::mem::offset_of!(cv_SimpleBlobDetector_Params, maxArea) - 36usize];
    ["Offset of field: cv_SimpleBlobDetector_Params::filterByCircularity"]
        [::std::mem::offset_of!(cv_SimpleBlobDetector_Params, filterByCircularity) - 40usize];
    ["Offset of field: cv_SimpleBlobDetector_Params::minCircularity"]
        [::std::mem::offset_of!(cv_SimpleBlobDetector_Params, minCircularity) - 44usize];
    ["Offset of field: cv_SimpleBlobDetector_Params::maxCircularity"]
        [::std::mem::offset_of!(cv_SimpleBlobDetector_Params, maxCircularity) - 48usize];
    ["Offset of field: cv_SimpleBlobDetector_Params::filterByInertia"]
        [::std::mem::offset_of!(cv_SimpleBlobDetector_Params, filterByInertia) - 52usize];
    ["Offset of field: cv_SimpleBlobDetector_Params::minInertiaRatio"]
        [::std::mem::offset_of!(cv_SimpleBlobDetector_Params, minInertiaRatio) - 56usize];
    ["Offset of field: cv_SimpleBlobDetector_Params::maxInertiaRatio"]
        [::std::mem::offset_of!(cv_SimpleBlobDetector_Params, maxInertiaRatio) - 60usize];
    ["Offset of field: cv_SimpleBlobDetector_Params::filterByConvexity"]
        [::std::mem::offset_of!(cv_SimpleBlobDetector_Params, filterByConvexity) - 64usize];
    ["Offset of field: cv_SimpleBlobDetector_Params::minConvexity"]
        [::std::mem::offset_of!(cv_SimpleBlobDetector_Params, minConvexity) - 68usize];
    ["Offset of field: cv_SimpleBlobDetector_Params::maxConvexity"]
        [::std::mem::offset_of!(cv_SimpleBlobDetector_Params, maxConvexity) - 72usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv18SimpleBlobDetector6Params4readERKNS_8FileNodeE"]
    pub fn cv_SimpleBlobDetector_Params_read(
        this: *mut cv_SimpleBlobDetector_Params,
        fn_: *const cv_FileNode,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv18SimpleBlobDetector6Params5writeERNS_11FileStorageE"]
    pub fn cv_SimpleBlobDetector_Params_write(
        this: *const cv_SimpleBlobDetector_Params,
        fs: *mut cv_FileStorage,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv18SimpleBlobDetector6ParamsC1Ev"]
    pub fn cv_SimpleBlobDetector_Params_Params(this: *mut cv_SimpleBlobDetector_Params);
}
impl cv_SimpleBlobDetector_Params {
    #[inline]
    pub unsafe fn read(&mut self, fn_: *const cv_FileNode) {
        cv_SimpleBlobDetector_Params_read(self, fn_)
    }
    #[inline]
    pub unsafe fn write(&self, fs: *mut cv_FileStorage) {
        cv_SimpleBlobDetector_Params_write(self, fs)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_SimpleBlobDetector_Params_Params(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_SimpleBlobDetector"][::std::mem::size_of::<cv_SimpleBlobDetector>() - 8usize];
    ["Alignment of cv_SimpleBlobDetector"]
        [::std::mem::align_of::<cv_SimpleBlobDetector>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv18SimpleBlobDetector6createERKNS0_6ParamsE"]
    pub fn cv_SimpleBlobDetector_create(parameters: *const cv_SimpleBlobDetector_Params) -> cv_Ptr;
}
impl cv_SimpleBlobDetector {
    #[inline]
    pub unsafe fn create(parameters: *const cv_SimpleBlobDetector_Params) -> cv_Ptr {
        cv_SimpleBlobDetector_create(parameters)
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZTv0_n72_NK2cv18SimpleBlobDetector14getDefaultNameB5cxx11Ev"]
    pub fn cv_SimpleBlobDetector_getDefaultName(this: *mut ::std::os::raw::c_void) -> cv_String;
}
#[doc = " @brief Class implementing the KAZE keypoint detector and descriptor extractor, described in @cite ABD12 .\n\n@note AKAZE descriptor can only be used with KAZE or AKAZE keypoints .. [ABD12] KAZE Features. Pablo\nF. Alcantarilla, Adrien Bartoli and Andrew J. Davison. In European Conference on Computer Vision\n(ECCV), Fiorenze, Italy, October 2012."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_KAZE {
    pub _base: cv_Feature2D,
}
pub const cv_KAZE_DiffusivityType_DIFF_PM_G1: cv_KAZE_DiffusivityType = 0;
pub const cv_KAZE_DiffusivityType_DIFF_PM_G2: cv_KAZE_DiffusivityType = 1;
pub const cv_KAZE_DiffusivityType_DIFF_WEICKERT: cv_KAZE_DiffusivityType = 2;
pub const cv_KAZE_DiffusivityType_DIFF_CHARBONNIER: cv_KAZE_DiffusivityType = 3;
pub type cv_KAZE_DiffusivityType = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_KAZE"][::std::mem::size_of::<cv_KAZE>() - 8usize];
    ["Alignment of cv_KAZE"][::std::mem::align_of::<cv_KAZE>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief The KAZE constructor\n\n@param extended Set to enable extraction of extended (128-byte) descriptor.\n@param upright Set to enable use of upright descriptors (non rotation-invariant).\n@param threshold Detector response threshold to accept point\n@param nOctaves Maximum octave evolution of the image\n@param nOctaveLayers Default number of sublevels per scale level\n@param diffusivity Diffusivity type. DIFF_PM_G1, DIFF_PM_G2, DIFF_WEICKERT or\nDIFF_CHARBONNIER"]
    #[link_name = "\u{1}_ZN2cv4KAZE6createEbbfiiNS0_15DiffusivityTypeE"]
    pub fn cv_KAZE_create(
        extended: bool,
        upright: bool,
        threshold: f32,
        nOctaves: ::std::os::raw::c_int,
        nOctaveLayers: ::std::os::raw::c_int,
        diffusivity: cv_KAZE_DiffusivityType,
    ) -> cv_Ptr;
}
impl cv_KAZE {
    #[inline]
    pub unsafe fn create(
        extended: bool,
        upright: bool,
        threshold: f32,
        nOctaves: ::std::os::raw::c_int,
        nOctaveLayers: ::std::os::raw::c_int,
        diffusivity: cv_KAZE_DiffusivityType,
    ) -> cv_Ptr {
        cv_KAZE_create(
            extended,
            upright,
            threshold,
            nOctaves,
            nOctaveLayers,
            diffusivity,
        )
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZTv0_n72_NK2cv4KAZE14getDefaultNameB5cxx11Ev"]
    pub fn cv_KAZE_getDefaultName(this: *mut ::std::os::raw::c_void) -> cv_String;
}
#[doc = " @brief Class implementing the AKAZE keypoint detector and descriptor extractor, described in @cite ANB13.\n\n@details AKAZE descriptors can only be used with KAZE or AKAZE keypoints. This class is thread-safe.\n\n@note When you need descriptors use Feature2D::detectAndCompute, which\nprovides better performance. When using Feature2D::detect followed by\nFeature2D::compute scale space pyramid is computed twice.\n\n@note AKAZE implements T-API. When image is passed as UMat some parts of the algorithm\nwill use OpenCL.\n\n@note [ANB13] Fast Explicit Diffusion for Accelerated Features in Nonlinear\nScale Spaces. Pablo F. Alcantarilla, Jess Nuevo and Adrien Bartoli. In\nBritish Machine Vision Conference (BMVC), Bristol, UK, September 2013."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_AKAZE {
    pub _base: cv_Feature2D,
}
#[doc = "< Upright descriptors, not invariant to rotation"]
pub const cv_AKAZE_DescriptorType_DESCRIPTOR_KAZE_UPRIGHT: cv_AKAZE_DescriptorType = 2;
pub const cv_AKAZE_DescriptorType_DESCRIPTOR_KAZE: cv_AKAZE_DescriptorType = 3;
#[doc = "< Upright descriptors, not invariant to rotation"]
pub const cv_AKAZE_DescriptorType_DESCRIPTOR_MLDB_UPRIGHT: cv_AKAZE_DescriptorType = 4;
pub const cv_AKAZE_DescriptorType_DESCRIPTOR_MLDB: cv_AKAZE_DescriptorType = 5;
pub type cv_AKAZE_DescriptorType = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_AKAZE"][::std::mem::size_of::<cv_AKAZE>() - 8usize];
    ["Alignment of cv_AKAZE"][::std::mem::align_of::<cv_AKAZE>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief The AKAZE constructor\n\n@param descriptor_type Type of the extracted descriptor: DESCRIPTOR_KAZE,\nDESCRIPTOR_KAZE_UPRIGHT, DESCRIPTOR_MLDB or DESCRIPTOR_MLDB_UPRIGHT.\n@param descriptor_size Size of the descriptor in bits. 0 -\\> Full size\n@param descriptor_channels Number of channels in the descriptor (1, 2, 3)\n@param threshold Detector response threshold to accept point\n@param nOctaves Maximum octave evolution of the image\n@param nOctaveLayers Default number of sublevels per scale level\n@param diffusivity Diffusivity type. DIFF_PM_G1, DIFF_PM_G2, DIFF_WEICKERT or\nDIFF_CHARBONNIER"]
    #[link_name = "\u{1}_ZN2cv5AKAZE6createENS0_14DescriptorTypeEiifiiNS_4KAZE15DiffusivityTypeE"]
    pub fn cv_AKAZE_create(
        descriptor_type: cv_AKAZE_DescriptorType,
        descriptor_size: ::std::os::raw::c_int,
        descriptor_channels: ::std::os::raw::c_int,
        threshold: f32,
        nOctaves: ::std::os::raw::c_int,
        nOctaveLayers: ::std::os::raw::c_int,
        diffusivity: cv_KAZE_DiffusivityType,
    ) -> cv_Ptr;
}
impl cv_AKAZE {
    #[inline]
    pub unsafe fn create(
        descriptor_type: cv_AKAZE_DescriptorType,
        descriptor_size: ::std::os::raw::c_int,
        descriptor_channels: ::std::os::raw::c_int,
        threshold: f32,
        nOctaves: ::std::os::raw::c_int,
        nOctaveLayers: ::std::os::raw::c_int,
        diffusivity: cv_KAZE_DiffusivityType,
    ) -> cv_Ptr {
        cv_AKAZE_create(
            descriptor_type,
            descriptor_size,
            descriptor_channels,
            threshold,
            nOctaves,
            nOctaveLayers,
            diffusivity,
        )
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZTv0_n72_NK2cv5AKAZE14getDefaultNameB5cxx11Ev"]
    pub fn cv_AKAZE_getDefaultName(this: *mut ::std::os::raw::c_void) -> cv_String;
}
#[doc = "\\\n                                      Distance                                          *\n\\"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_Accumulator {
    pub _address: u8,
}
pub type cv_Accumulator_Type<T> = T;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Accumulator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<cv_Accumulator>() - 1usize];
    ["Align of template specialization: cv_Accumulator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<cv_Accumulator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Accumulator_open0_unsigned_short_close0"]
        [::std::mem::size_of::<cv_Accumulator>() - 1usize];
    ["Align of template specialization: cv_Accumulator_open0_unsigned_short_close0"]
        [::std::mem::align_of::<cv_Accumulator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Accumulator_open0_char_close0"]
        [::std::mem::size_of::<cv_Accumulator>() - 1usize];
    ["Align of template specialization: cv_Accumulator_open0_char_close0"]
        [::std::mem::align_of::<cv_Accumulator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Accumulator_open0_short_close0"]
        [::std::mem::size_of::<cv_Accumulator>() - 1usize];
    ["Align of template specialization: cv_Accumulator_open0_short_close0"]
        [::std::mem::align_of::<cv_Accumulator>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_SL2 {
    pub _address: u8,
}
pub type cv_SL2_ValueType<T> = T;
pub type cv_SL2_ResultType = cv_Accumulator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_L2 {
    pub _address: u8,
}
pub type cv_L2_ValueType<T> = T;
pub type cv_L2_ResultType = cv_Accumulator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_L1 {
    pub _address: u8,
}
pub type cv_L1_ValueType<T> = T;
pub type cv_L1_ResultType = cv_Accumulator;
#[doc = " @brief Abstract base class for matching keypoint descriptors.\n\nIt has two groups of match methods: for matching descriptors of an image with another image or with\nan image set."]
#[repr(C)]
pub struct cv_DescriptorMatcher {
    pub _base: cv_Algorithm,
    #[doc = "! Collection of descriptors from train images."]
    pub trainDescCollection: std_vector,
    pub utrainDescCollection: std_vector,
}
pub const cv_DescriptorMatcher_MatcherType_FLANNBASED: cv_DescriptorMatcher_MatcherType = 1;
pub const cv_DescriptorMatcher_MatcherType_BRUTEFORCE: cv_DescriptorMatcher_MatcherType = 2;
pub const cv_DescriptorMatcher_MatcherType_BRUTEFORCE_L1: cv_DescriptorMatcher_MatcherType = 3;
pub const cv_DescriptorMatcher_MatcherType_BRUTEFORCE_HAMMING: cv_DescriptorMatcher_MatcherType = 4;
pub const cv_DescriptorMatcher_MatcherType_BRUTEFORCE_HAMMINGLUT: cv_DescriptorMatcher_MatcherType =
    5;
pub const cv_DescriptorMatcher_MatcherType_BRUTEFORCE_SL2: cv_DescriptorMatcher_MatcherType = 6;
pub type cv_DescriptorMatcher_MatcherType = ::std::os::raw::c_uint;
#[repr(C)]
pub struct cv_DescriptorMatcher_DescriptorCollection__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Class to work with descriptors from several images as with one merged matrix.\n It is used e.g. in FlannBasedMatcher."]
#[repr(C)]
pub struct cv_DescriptorMatcher_DescriptorCollection {
    pub vtable_: *const cv_DescriptorMatcher_DescriptorCollection__bindgen_vtable,
    pub mergedDescriptors: cv_Mat,
    pub startIdxs: std_vector,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_DescriptorMatcher_DescriptorCollection"]
        [::std::mem::size_of::<cv_DescriptorMatcher_DescriptorCollection>() - 128usize];
    ["Alignment of cv_DescriptorMatcher_DescriptorCollection"]
        [::std::mem::align_of::<cv_DescriptorMatcher_DescriptorCollection>() - 8usize];
    ["Offset of field: cv_DescriptorMatcher_DescriptorCollection::mergedDescriptors"][::std::mem::offset_of!(
        cv_DescriptorMatcher_DescriptorCollection,
        mergedDescriptors
    ) - 8usize];
    ["Offset of field: cv_DescriptorMatcher_DescriptorCollection::startIdxs"]
        [::std::mem::offset_of!(cv_DescriptorMatcher_DescriptorCollection, startIdxs) - 104usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17DescriptorMatcher20DescriptorCollection3setERKSt6vectorINS_3MatESaIS3_EE"]
    pub fn cv_DescriptorMatcher_DescriptorCollection_set(
        this: *mut cv_DescriptorMatcher_DescriptorCollection,
        descriptors: *const std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv17DescriptorMatcher20DescriptorCollection14getDescriptorsEv"]
    pub fn cv_DescriptorMatcher_DescriptorCollection_getDescriptors(
        this: *const cv_DescriptorMatcher_DescriptorCollection,
    ) -> *const cv_Mat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv17DescriptorMatcher20DescriptorCollection13getDescriptorEii"]
    pub fn cv_DescriptorMatcher_DescriptorCollection_getDescriptor(
        this: *const cv_DescriptorMatcher_DescriptorCollection,
        imgIdx: ::std::os::raw::c_int,
        localDescIdx: ::std::os::raw::c_int,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv17DescriptorMatcher20DescriptorCollection13getDescriptorEi"]
    pub fn cv_DescriptorMatcher_DescriptorCollection_getDescriptor1(
        this: *const cv_DescriptorMatcher_DescriptorCollection,
        globalDescIdx: ::std::os::raw::c_int,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv17DescriptorMatcher20DescriptorCollection11getLocalIdxEiRiS2_"]
    pub fn cv_DescriptorMatcher_DescriptorCollection_getLocalIdx(
        this: *const cv_DescriptorMatcher_DescriptorCollection,
        globalDescIdx: ::std::os::raw::c_int,
        imgIdx: *mut ::std::os::raw::c_int,
        localDescIdx: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv17DescriptorMatcher20DescriptorCollection4sizeEv"]
    pub fn cv_DescriptorMatcher_DescriptorCollection_size(
        this: *const cv_DescriptorMatcher_DescriptorCollection,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17DescriptorMatcher20DescriptorCollectionC1Ev"]
    pub fn cv_DescriptorMatcher_DescriptorCollection_DescriptorCollection(
        this: *mut cv_DescriptorMatcher_DescriptorCollection,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17DescriptorMatcher20DescriptorCollectionC1ERKS1_"]
    pub fn cv_DescriptorMatcher_DescriptorCollection_DescriptorCollection1(
        this: *mut cv_DescriptorMatcher_DescriptorCollection,
        collection: *const cv_DescriptorMatcher_DescriptorCollection,
    );
}
impl cv_DescriptorMatcher_DescriptorCollection {
    #[inline]
    pub unsafe fn set(&mut self, descriptors: *const std_vector) {
        cv_DescriptorMatcher_DescriptorCollection_set(self, descriptors)
    }
    #[inline]
    pub unsafe fn getDescriptors(&self) -> *const cv_Mat {
        cv_DescriptorMatcher_DescriptorCollection_getDescriptors(self)
    }
    #[inline]
    pub unsafe fn getDescriptor(
        &self,
        imgIdx: ::std::os::raw::c_int,
        localDescIdx: ::std::os::raw::c_int,
    ) -> cv_Mat {
        cv_DescriptorMatcher_DescriptorCollection_getDescriptor(self, imgIdx, localDescIdx)
    }
    #[inline]
    pub unsafe fn getDescriptor1(&self, globalDescIdx: ::std::os::raw::c_int) -> cv_Mat {
        cv_DescriptorMatcher_DescriptorCollection_getDescriptor1(self, globalDescIdx)
    }
    #[inline]
    pub unsafe fn getLocalIdx(
        &self,
        globalDescIdx: ::std::os::raw::c_int,
        imgIdx: *mut ::std::os::raw::c_int,
        localDescIdx: *mut ::std::os::raw::c_int,
    ) {
        cv_DescriptorMatcher_DescriptorCollection_getLocalIdx(
            self,
            globalDescIdx,
            imgIdx,
            localDescIdx,
        )
    }
    #[inline]
    pub unsafe fn size(&self) -> ::std::os::raw::c_int {
        cv_DescriptorMatcher_DescriptorCollection_size(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_DescriptorMatcher_DescriptorCollection_DescriptorCollection(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(collection: *const cv_DescriptorMatcher_DescriptorCollection) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_DescriptorMatcher_DescriptorCollection_DescriptorCollection1(
            __bindgen_tmp.as_mut_ptr(),
            collection,
        );
        __bindgen_tmp.assume_init()
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_DescriptorMatcher"][::std::mem::size_of::<cv_DescriptorMatcher>() - 56usize];
    ["Alignment of cv_DescriptorMatcher"][::std::mem::align_of::<cv_DescriptorMatcher>() - 8usize];
    ["Offset of field: cv_DescriptorMatcher::trainDescCollection"]
        [::std::mem::offset_of!(cv_DescriptorMatcher, trainDescCollection) - 8usize];
    ["Offset of field: cv_DescriptorMatcher::utrainDescCollection"]
        [::std::mem::offset_of!(cv_DescriptorMatcher, utrainDescCollection) - 32usize];
};
unsafe extern "C" {
    #[doc = " @brief Returns a constant link to the train descriptor collection trainDescCollection ."]
    #[link_name = "\u{1}_ZNK2cv17DescriptorMatcher19getTrainDescriptorsEv"]
    pub fn cv_DescriptorMatcher_getTrainDescriptors(
        this: *const cv_DescriptorMatcher,
    ) -> *const std_vector;
}
unsafe extern "C" {
    #[doc = " @brief Finds the best match for each descriptor from a query set.\n\n@param queryDescriptors Query set of descriptors.\n@param trainDescriptors Train set of descriptors. This set is not added to the train descriptors\ncollection stored in the class object.\n@param matches Matches. If a query descriptor is masked out in mask , no match is added for this\ndescriptor. So, matches size may be smaller than the query descriptors count.\n@param mask Mask specifying permissible matches between an input query and train matrices of\ndescriptors.\n\nIn the first variant of this method, the train descriptors are passed as an input argument. In the\nsecond variant of the method, train descriptors collection that was set by DescriptorMatcher::add is\nused. Optional mask (or masks) can be passed to specify which query and training descriptors can be\nmatched. Namely, queryDescriptors[i] can be matched with trainDescriptors[j] only if\nmask.at\\<uchar\\>(i,j) is non-zero."]
    #[link_name = "\u{1}_ZNK2cv17DescriptorMatcher5matchERKNS_11_InputArrayES3_RSt6vectorINS_6DMatchESaIS5_EES3_"]
    pub fn cv_DescriptorMatcher_match(
        this: *const cv_DescriptorMatcher,
        queryDescriptors: cv_InputArray,
        trainDescriptors: cv_InputArray,
        matches: *mut std_vector,
        mask: cv_InputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Finds the k best matches for each descriptor from a query set.\n\n@param queryDescriptors Query set of descriptors.\n@param trainDescriptors Train set of descriptors. This set is not added to the train descriptors\ncollection stored in the class object.\n@param mask Mask specifying permissible matches between an input query and train matrices of\ndescriptors.\n@param matches Matches. Each matches[i] is k or less matches for the same query descriptor.\n@param k Count of best matches found per each query descriptor or less if a query descriptor has\nless than k possible matches in total.\n@param compactResult Parameter used when the mask (or masks) is not empty. If compactResult is\nfalse, the matches vector has the same size as queryDescriptors rows. If compactResult is true,\nthe matches vector does not contain matches for fully masked-out query descriptors.\n\nThese extended variants of DescriptorMatcher::match methods find several best matches for each query\ndescriptor. The matches are returned in the distance increasing order. See DescriptorMatcher::match\nfor the details about query and train descriptors."]
    #[link_name = "\u{1}_ZNK2cv17DescriptorMatcher8knnMatchERKNS_11_InputArrayES3_RSt6vectorIS4_INS_6DMatchESaIS5_EESaIS7_EEiS3_b"]
    pub fn cv_DescriptorMatcher_knnMatch(
        this: *const cv_DescriptorMatcher,
        queryDescriptors: cv_InputArray,
        trainDescriptors: cv_InputArray,
        matches: *mut std_vector,
        k: ::std::os::raw::c_int,
        mask: cv_InputArray,
        compactResult: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief For each query descriptor, finds the training descriptors not farther than the specified distance.\n\n@param queryDescriptors Query set of descriptors.\n@param trainDescriptors Train set of descriptors. This set is not added to the train descriptors\ncollection stored in the class object.\n@param matches Found matches.\n@param compactResult Parameter used when the mask (or masks) is not empty. If compactResult is\nfalse, the matches vector has the same size as queryDescriptors rows. If compactResult is true,\nthe matches vector does not contain matches for fully masked-out query descriptors.\n@param maxDistance Threshold for the distance between matched descriptors. Distance means here\nmetric distance (e.g. Hamming distance), not the distance between coordinates (which is measured\nin Pixels)!\n@param mask Mask specifying permissible matches between an input query and train matrices of\ndescriptors.\n\nFor each query descriptor, the methods find such training descriptors that the distance between the\nquery descriptor and the training descriptor is equal or smaller than maxDistance. Found matches are\nreturned in the distance increasing order."]
    #[link_name = "\u{1}_ZNK2cv17DescriptorMatcher11radiusMatchERKNS_11_InputArrayES3_RSt6vectorIS4_INS_6DMatchESaIS5_EESaIS7_EEfS3_b"]
    pub fn cv_DescriptorMatcher_radiusMatch(
        this: *const cv_DescriptorMatcher,
        queryDescriptors: cv_InputArray,
        trainDescriptors: cv_InputArray,
        matches: *mut std_vector,
        maxDistance: f32,
        mask: cv_InputArray,
        compactResult: bool,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param queryDescriptors Query set of descriptors.\n@param matches Matches. If a query descriptor is masked out in mask , no match is added for this\ndescriptor. So, matches size may be smaller than the query descriptors count.\n@param masks Set of masks. Each masks[i] specifies permissible matches between the input query\ndescriptors and stored train descriptors from the i-th image trainDescCollection[i]."]
    #[link_name = "\u{1}_ZN2cv17DescriptorMatcher5matchERKNS_11_InputArrayERSt6vectorINS_6DMatchESaIS5_EES3_"]
    pub fn cv_DescriptorMatcher_match1(
        this: *mut cv_DescriptorMatcher,
        queryDescriptors: cv_InputArray,
        matches: *mut std_vector,
        masks: cv_InputArrayOfArrays,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param queryDescriptors Query set of descriptors.\n@param matches Matches. Each matches[i] is k or less matches for the same query descriptor.\n@param k Count of best matches found per each query descriptor or less if a query descriptor has\nless than k possible matches in total.\n@param masks Set of masks. Each masks[i] specifies permissible matches between the input query\ndescriptors and stored train descriptors from the i-th image trainDescCollection[i].\n@param compactResult Parameter used when the mask (or masks) is not empty. If compactResult is\nfalse, the matches vector has the same size as queryDescriptors rows. If compactResult is true,\nthe matches vector does not contain matches for fully masked-out query descriptors."]
    #[link_name = "\u{1}_ZN2cv17DescriptorMatcher8knnMatchERKNS_11_InputArrayERSt6vectorIS4_INS_6DMatchESaIS5_EESaIS7_EEiS3_b"]
    pub fn cv_DescriptorMatcher_knnMatch1(
        this: *mut cv_DescriptorMatcher,
        queryDescriptors: cv_InputArray,
        matches: *mut std_vector,
        k: ::std::os::raw::c_int,
        masks: cv_InputArrayOfArrays,
        compactResult: bool,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param queryDescriptors Query set of descriptors.\n@param matches Found matches.\n@param maxDistance Threshold for the distance between matched descriptors. Distance means here\nmetric distance (e.g. Hamming distance), not the distance between coordinates (which is measured\nin Pixels)!\n@param masks Set of masks. Each masks[i] specifies permissible matches between the input query\ndescriptors and stored train descriptors from the i-th image trainDescCollection[i].\n@param compactResult Parameter used when the mask (or masks) is not empty. If compactResult is\nfalse, the matches vector has the same size as queryDescriptors rows. If compactResult is true,\nthe matches vector does not contain matches for fully masked-out query descriptors."]
    #[link_name = "\u{1}_ZN2cv17DescriptorMatcher11radiusMatchERKNS_11_InputArrayERSt6vectorIS4_INS_6DMatchESaIS5_EESaIS7_EEfS3_b"]
    pub fn cv_DescriptorMatcher_radiusMatch1(
        this: *mut cv_DescriptorMatcher,
        queryDescriptors: cv_InputArray,
        matches: *mut std_vector,
        maxDistance: f32,
        masks: cv_InputArrayOfArrays,
        compactResult: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief Creates a descriptor matcher of a given type with the default parameters (using default\nconstructor).\n\n@param descriptorMatcherType Descriptor matcher type. Now the following matcher types are\nsupported:\n-   `BruteForce` (it uses L2 )\n-   `BruteForce-L1`\n-   `BruteForce-Hamming`\n-   `BruteForce-Hamming(2)`\n-   `FlannBased`"]
    #[link_name = "\u{1}_ZN2cv17DescriptorMatcher6createERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_DescriptorMatcher_create(descriptorMatcherType: *const cv_String) -> cv_Ptr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17DescriptorMatcher6createERKNS0_11MatcherTypeE"]
    pub fn cv_DescriptorMatcher_create1(
        matcherType: *const cv_DescriptorMatcher_MatcherType,
    ) -> cv_Ptr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17DescriptorMatcher15isPossibleMatchERKNS_11_InputArrayEii"]
    pub fn cv_DescriptorMatcher_isPossibleMatch(
        mask: cv_InputArray,
        queryIdx: ::std::os::raw::c_int,
        trainIdx: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17DescriptorMatcher11isMaskedOutERKNS_11_InputArrayEi"]
    pub fn cv_DescriptorMatcher_isMaskedOut(
        masks: cv_InputArrayOfArrays,
        queryIdx: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv17DescriptorMatcher10checkMasksERKNS_11_InputArrayEi"]
    pub fn cv_DescriptorMatcher_checkMasks(
        this: *const cv_DescriptorMatcher,
        masks: cv_InputArrayOfArrays,
        queryDescriptorsCount: ::std::os::raw::c_int,
    );
}
impl cv_DescriptorMatcher {
    #[inline]
    pub unsafe fn getTrainDescriptors(&self) -> *const std_vector {
        cv_DescriptorMatcher_getTrainDescriptors(self)
    }
    #[inline]
    pub unsafe fn match_(
        &self,
        queryDescriptors: cv_InputArray,
        trainDescriptors: cv_InputArray,
        matches: *mut std_vector,
        mask: cv_InputArray,
    ) {
        cv_DescriptorMatcher_match(self, queryDescriptors, trainDescriptors, matches, mask)
    }
    #[inline]
    pub unsafe fn knnMatch(
        &self,
        queryDescriptors: cv_InputArray,
        trainDescriptors: cv_InputArray,
        matches: *mut std_vector,
        k: ::std::os::raw::c_int,
        mask: cv_InputArray,
        compactResult: bool,
    ) {
        cv_DescriptorMatcher_knnMatch(
            self,
            queryDescriptors,
            trainDescriptors,
            matches,
            k,
            mask,
            compactResult,
        )
    }
    #[inline]
    pub unsafe fn radiusMatch(
        &self,
        queryDescriptors: cv_InputArray,
        trainDescriptors: cv_InputArray,
        matches: *mut std_vector,
        maxDistance: f32,
        mask: cv_InputArray,
        compactResult: bool,
    ) {
        cv_DescriptorMatcher_radiusMatch(
            self,
            queryDescriptors,
            trainDescriptors,
            matches,
            maxDistance,
            mask,
            compactResult,
        )
    }
    #[inline]
    pub unsafe fn match1(
        &mut self,
        queryDescriptors: cv_InputArray,
        matches: *mut std_vector,
        masks: cv_InputArrayOfArrays,
    ) {
        cv_DescriptorMatcher_match1(self, queryDescriptors, matches, masks)
    }
    #[inline]
    pub unsafe fn knnMatch1(
        &mut self,
        queryDescriptors: cv_InputArray,
        matches: *mut std_vector,
        k: ::std::os::raw::c_int,
        masks: cv_InputArrayOfArrays,
        compactResult: bool,
    ) {
        cv_DescriptorMatcher_knnMatch1(self, queryDescriptors, matches, k, masks, compactResult)
    }
    #[inline]
    pub unsafe fn radiusMatch1(
        &mut self,
        queryDescriptors: cv_InputArray,
        matches: *mut std_vector,
        maxDistance: f32,
        masks: cv_InputArrayOfArrays,
        compactResult: bool,
    ) {
        cv_DescriptorMatcher_radiusMatch1(
            self,
            queryDescriptors,
            matches,
            maxDistance,
            masks,
            compactResult,
        )
    }
    #[inline]
    pub unsafe fn create(descriptorMatcherType: *const cv_String) -> cv_Ptr {
        cv_DescriptorMatcher_create(descriptorMatcherType)
    }
    #[inline]
    pub unsafe fn create1(matcherType: *const cv_DescriptorMatcher_MatcherType) -> cv_Ptr {
        cv_DescriptorMatcher_create1(matcherType)
    }
    #[inline]
    pub unsafe fn isPossibleMatch(
        mask: cv_InputArray,
        queryIdx: ::std::os::raw::c_int,
        trainIdx: ::std::os::raw::c_int,
    ) -> bool {
        cv_DescriptorMatcher_isPossibleMatch(mask, queryIdx, trainIdx)
    }
    #[inline]
    pub unsafe fn isMaskedOut(
        masks: cv_InputArrayOfArrays,
        queryIdx: ::std::os::raw::c_int,
    ) -> bool {
        cv_DescriptorMatcher_isMaskedOut(masks, queryIdx)
    }
    #[inline]
    pub unsafe fn checkMasks(
        &self,
        masks: cv_InputArrayOfArrays,
        queryDescriptorsCount: ::std::os::raw::c_int,
    ) {
        cv_DescriptorMatcher_checkMasks(self, masks, queryDescriptorsCount)
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17DescriptorMatcherD1Ev"]
    pub fn cv_DescriptorMatcher_DescriptorMatcher_destructor(this: *mut cv_DescriptorMatcher);
}
unsafe extern "C" {
    #[doc = " @brief Adds descriptors to train a CPU(trainDescCollectionis) or GPU(utrainDescCollectionis) descriptor\ncollection.\n\nIf the collection is not empty, the new descriptors are added to existing train descriptors.\n\n@param descriptors Descriptors to add. Each descriptors[i] is a set of descriptors from the same\ntrain image."]
    #[link_name = "\u{1}_ZN2cv17DescriptorMatcher3addERKNS_11_InputArrayE"]
    pub fn cv_DescriptorMatcher_add(
        this: *mut ::std::os::raw::c_void,
        descriptors: cv_InputArrayOfArrays,
    );
}
unsafe extern "C" {
    #[doc = " @brief Clears the train descriptor collections."]
    #[link_name = "\u{1}_ZN2cv17DescriptorMatcher5clearEv"]
    pub fn cv_DescriptorMatcher_clear(this: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " @brief Returns true if there are no train descriptors in the both collections."]
    #[link_name = "\u{1}_ZNK2cv17DescriptorMatcher5emptyEv"]
    pub fn cv_DescriptorMatcher_empty(this: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Trains a descriptor matcher\n\nTrains a descriptor matcher (for example, the flann index). In all methods to match, the method\ntrain() is run every time before matching. Some descriptor matchers (for example, BruteForceMatcher)\nhave an empty implementation of this method. Other matchers really train their inner structures (for\nexample, FlannBasedMatcher trains flann::Index )."]
    #[link_name = "\u{1}_ZN2cv17DescriptorMatcher5trainEv"]
    pub fn cv_DescriptorMatcher_train(this: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17DescriptorMatcher4readERKNS_8FileNodeE"]
    pub fn cv_DescriptorMatcher_read(this: *mut ::std::os::raw::c_void, arg1: *const cv_FileNode);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv17DescriptorMatcher5writeERNS_11FileStorageE"]
    pub fn cv_DescriptorMatcher_write(this: *mut ::std::os::raw::c_void, arg1: *mut cv_FileStorage);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17DescriptorMatcher20DescriptorCollectionD1Ev"]
    pub fn cv_DescriptorMatcher_DescriptorCollection_DescriptorCollection_destructor(
        this: *mut cv_DescriptorMatcher_DescriptorCollection,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17DescriptorMatcher20DescriptorCollection5clearEv"]
    pub fn cv_DescriptorMatcher_DescriptorCollection_clear(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief Brute-force descriptor matcher.\n\nFor each descriptor in the first set, this matcher finds the closest descriptor in the second set\nby trying each one. This descriptor matcher supports masking permissible matches of descriptor\nsets."]
#[repr(C)]
pub struct cv_BFMatcher {
    pub _base: cv_DescriptorMatcher,
    pub normType: ::std::os::raw::c_int,
    pub crossCheck: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_BFMatcher"][::std::mem::size_of::<cv_BFMatcher>() - 64usize];
    ["Alignment of cv_BFMatcher"][::std::mem::align_of::<cv_BFMatcher>() - 8usize];
    ["Offset of field: cv_BFMatcher::normType"]
        [::std::mem::offset_of!(cv_BFMatcher, normType) - 56usize];
    ["Offset of field: cv_BFMatcher::crossCheck"]
        [::std::mem::offset_of!(cv_BFMatcher, crossCheck) - 60usize];
};
unsafe extern "C" {
    #[doc = " @brief Brute-force matcher create method.\n@param normType One of NORM_L1, NORM_L2, NORM_HAMMING, NORM_HAMMING2. L1 and L2 norms are\npreferable choices for SIFT and SURF descriptors, NORM_HAMMING should be used with ORB, BRISK and\nBRIEF, NORM_HAMMING2 should be used with ORB when WTA_K==3 or 4 (see ORB::ORB constructor\ndescription).\n@param crossCheck If it is false, this is will be default BFMatcher behaviour when it finds the k\nnearest neighbors for each query descriptor. If crossCheck==true, then the knnMatch() method with\nk=1 will only return pairs (i,j) such that for i-th query descriptor the j-th descriptor in the\nmatcher's collection is the nearest and vice versa, i.e. the BFMatcher will only return consistent\npairs. Such technique usually produces best results with minimal number of outliers when there are\nenough matches. This is alternative to the ratio test, used by D. Lowe in SIFT paper."]
    #[link_name = "\u{1}_ZN2cv9BFMatcher6createEib"]
    pub fn cv_BFMatcher_create(normType: ::std::os::raw::c_int, crossCheck: bool) -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Brute-force matcher constructor (obsolete). Please use BFMatcher.create()\n\n"]
    #[link_name = "\u{1}_ZN2cv9BFMatcherC1Eib"]
    pub fn cv_BFMatcher_BFMatcher(
        this: *mut cv_BFMatcher,
        normType: ::std::os::raw::c_int,
        crossCheck: bool,
    );
}
impl cv_BFMatcher {
    #[inline]
    pub unsafe fn create(normType: ::std::os::raw::c_int, crossCheck: bool) -> cv_Ptr {
        cv_BFMatcher_create(normType, crossCheck)
    }
    #[inline]
    pub unsafe fn new(normType: ::std::os::raw::c_int, crossCheck: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_BFMatcher_BFMatcher(__bindgen_tmp.as_mut_ptr(), normType, crossCheck);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv9BFMatcher5cloneEb"]
    pub fn cv_BFMatcher_clone(this: *mut ::std::os::raw::c_void, emptyTrainData: bool) -> cv_Ptr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9BFMatcher12knnMatchImplERKNS_11_InputArrayERSt6vectorIS4_INS_6DMatchESaIS5_EESaIS7_EEiS3_b"]
    pub fn cv_BFMatcher_knnMatchImpl(
        this: *mut ::std::os::raw::c_void,
        queryDescriptors: cv_InputArray,
        matches: *mut std_vector,
        k: ::std::os::raw::c_int,
        masks: cv_InputArrayOfArrays,
        compactResult: bool,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9BFMatcher15radiusMatchImplERKNS_11_InputArrayERSt6vectorIS4_INS_6DMatchESaIS5_EESaIS7_EEfS3_b"]
    pub fn cv_BFMatcher_radiusMatchImpl(
        this: *mut ::std::os::raw::c_void,
        queryDescriptors: cv_InputArray,
        matches: *mut std_vector,
        maxDistance: f32,
        masks: cv_InputArrayOfArrays,
        compactResult: bool,
    );
}
#[doc = " @brief Flann-based descriptor matcher.\n\nThis matcher trains cv::flann::Index on a train descriptor collection and calls its nearest search\nmethods to find the best matches. So, this matcher may be faster when matching a large train\ncollection than the brute force matcher. FlannBasedMatcher does not support masking permissible\nmatches of descriptor sets because flann::Index does not support this. :"]
#[repr(C)]
pub struct cv_FlannBasedMatcher {
    pub _base: cv_DescriptorMatcher,
    pub indexParams: cv_Ptr,
    pub searchParams: cv_Ptr,
    pub flannIndex: cv_Ptr,
    pub mergedDescriptors: cv_DescriptorMatcher_DescriptorCollection,
    pub addedDescCount: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_FlannBasedMatcher"][::std::mem::size_of::<cv_FlannBasedMatcher>() - 240usize];
    ["Alignment of cv_FlannBasedMatcher"][::std::mem::align_of::<cv_FlannBasedMatcher>() - 8usize];
    ["Offset of field: cv_FlannBasedMatcher::indexParams"]
        [::std::mem::offset_of!(cv_FlannBasedMatcher, indexParams) - 56usize];
    ["Offset of field: cv_FlannBasedMatcher::searchParams"]
        [::std::mem::offset_of!(cv_FlannBasedMatcher, searchParams) - 72usize];
    ["Offset of field: cv_FlannBasedMatcher::flannIndex"]
        [::std::mem::offset_of!(cv_FlannBasedMatcher, flannIndex) - 88usize];
    ["Offset of field: cv_FlannBasedMatcher::mergedDescriptors"]
        [::std::mem::offset_of!(cv_FlannBasedMatcher, mergedDescriptors) - 104usize];
    ["Offset of field: cv_FlannBasedMatcher::addedDescCount"]
        [::std::mem::offset_of!(cv_FlannBasedMatcher, addedDescCount) - 232usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17FlannBasedMatcher6createEv"]
    pub fn cv_FlannBasedMatcher_create() -> cv_Ptr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17FlannBasedMatcher17convertToDMatchesERKNS_17DescriptorMatcher20DescriptorCollectionERKNS_3MatES7_RSt6vectorIS8_INS_6DMatchESaIS9_EESaISB_EE"]
    pub fn cv_FlannBasedMatcher_convertToDMatches(
        descriptors: *const cv_DescriptorMatcher_DescriptorCollection,
        indices: *const cv_Mat,
        distances: *const cv_Mat,
        matches: *mut std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17FlannBasedMatcherC1ERKNS_3PtrINS_5flann11IndexParamsEEERKNS1_INS2_12SearchParamsEEE"]
    pub fn cv_FlannBasedMatcher_FlannBasedMatcher(
        this: *mut cv_FlannBasedMatcher,
        indexParams: *const cv_Ptr,
        searchParams: *const cv_Ptr,
    );
}
impl cv_FlannBasedMatcher {
    #[inline]
    pub unsafe fn create() -> cv_Ptr {
        cv_FlannBasedMatcher_create()
    }
    #[inline]
    pub unsafe fn convertToDMatches(
        descriptors: *const cv_DescriptorMatcher_DescriptorCollection,
        indices: *const cv_Mat,
        distances: *const cv_Mat,
        matches: *mut std_vector,
    ) {
        cv_FlannBasedMatcher_convertToDMatches(descriptors, indices, distances, matches)
    }
    #[inline]
    pub unsafe fn new(indexParams: *const cv_Ptr, searchParams: *const cv_Ptr) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_FlannBasedMatcher_FlannBasedMatcher(
            __bindgen_tmp.as_mut_ptr(),
            indexParams,
            searchParams,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17FlannBasedMatcher3addERKNS_11_InputArrayE"]
    pub fn cv_FlannBasedMatcher_add(
        this: *mut ::std::os::raw::c_void,
        descriptors: cv_InputArrayOfArrays,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17FlannBasedMatcher5clearEv"]
    pub fn cv_FlannBasedMatcher_clear(this: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17FlannBasedMatcher4readERKNS_8FileNodeE"]
    pub fn cv_FlannBasedMatcher_read(this: *mut ::std::os::raw::c_void, arg1: *const cv_FileNode);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv17FlannBasedMatcher5writeERNS_11FileStorageE"]
    pub fn cv_FlannBasedMatcher_write(this: *mut ::std::os::raw::c_void, arg1: *mut cv_FileStorage);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17FlannBasedMatcher5trainEv"]
    pub fn cv_FlannBasedMatcher_train(this: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv17FlannBasedMatcher15isMaskSupportedEv"]
    pub fn cv_FlannBasedMatcher_isMaskSupported(this: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv17FlannBasedMatcher5cloneEb"]
    pub fn cv_FlannBasedMatcher_clone(
        this: *mut ::std::os::raw::c_void,
        emptyTrainData: bool,
    ) -> cv_Ptr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17FlannBasedMatcher12knnMatchImplERKNS_11_InputArrayERSt6vectorIS4_INS_6DMatchESaIS5_EESaIS7_EEiS3_b"]
    pub fn cv_FlannBasedMatcher_knnMatchImpl(
        this: *mut ::std::os::raw::c_void,
        queryDescriptors: cv_InputArray,
        matches: *mut std_vector,
        k: ::std::os::raw::c_int,
        masks: cv_InputArrayOfArrays,
        compactResult: bool,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17FlannBasedMatcher15radiusMatchImplERKNS_11_InputArrayERSt6vectorIS4_INS_6DMatchESaIS5_EESaIS7_EEfS3_b"]
    pub fn cv_FlannBasedMatcher_radiusMatchImpl(
        this: *mut ::std::os::raw::c_void,
        queryDescriptors: cv_InputArray,
        matches: *mut std_vector,
        maxDistance: f32,
        masks: cv_InputArrayOfArrays,
        compactResult: bool,
    );
}
#[doc = "!< Output image matrix will be created (Mat::create),\n!< i.e. existing memory of output image may be reused.\n!< Two source image, matches and single keypoints will be drawn.\n!< For each keypoint only the center point will be drawn (without\n!< the circle around keypoint with keypoint size and orientation)."]
pub const cv_DrawMatchesFlags_DEFAULT: cv_DrawMatchesFlags = 0;
#[doc = "!< Output image matrix will not be created (Mat::create).\n!< Matches will be drawn on existing content of output image."]
pub const cv_DrawMatchesFlags_DRAW_OVER_OUTIMG: cv_DrawMatchesFlags = 1;
#[doc = "!< Single keypoints will not be drawn."]
pub const cv_DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS: cv_DrawMatchesFlags = 2;
#[doc = "!< For each keypoint the circle around keypoint with keypoint size and\n!< orientation will be drawn."]
pub const cv_DrawMatchesFlags_DRAW_RICH_KEYPOINTS: cv_DrawMatchesFlags = 4;
#[doc = "! @addtogroup features2d_draw\n! @{"]
pub type cv_DrawMatchesFlags = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = " @brief Draws keypoints.\n\n@param image Source image.\n@param keypoints Keypoints from the source image.\n@param outImage Output image. Its content depends on the flags value defining what is drawn in the\noutput image. See possible flags bit values below.\n@param color Color of keypoints.\n@param flags Flags setting drawing features. Possible flags bit values are defined by\nDrawMatchesFlags. See details above in drawMatches .\n\n@note\nFor Python API, flags are modified as cv.DRAW_MATCHES_FLAGS_DEFAULT,\ncv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS, cv.DRAW_MATCHES_FLAGS_DRAW_OVER_OUTIMG,\ncv.DRAW_MATCHES_FLAGS_NOT_DRAW_SINGLE_POINTS"]
    #[link_name = "\u{1}_ZN2cv13drawKeypointsERKNS_11_InputArrayERKSt6vectorINS_8KeyPointESaIS4_EERKNS_17_InputOutputArrayERKNS_7Scalar_IdEENS_16DrawMatchesFlagsE"]
    pub fn cv_drawKeypoints(
        image: cv_InputArray,
        keypoints: *const std_vector,
        outImage: cv_InputOutputArray,
        color: *const cv_Scalar,
        flags: cv_DrawMatchesFlags,
    );
}
unsafe extern "C" {
    #[doc = " @brief Draws the found matches of keypoints from two images.\n\n@param img1 First source image.\n@param keypoints1 Keypoints from the first source image.\n@param img2 Second source image.\n@param keypoints2 Keypoints from the second source image.\n@param matches1to2 Matches from the first image to the second one, which means that keypoints1[i]\nhas a corresponding point in keypoints2[matches[i]] .\n@param outImg Output image. Its content depends on the flags value defining what is drawn in the\noutput image. See possible flags bit values below.\n@param matchColor Color of matches (lines and connected keypoints). If matchColor==Scalar::all(-1)\n, the color is generated randomly.\n@param singlePointColor Color of single keypoints (circles), which means that keypoints do not\nhave the matches. If singlePointColor==Scalar::all(-1) , the color is generated randomly.\n@param matchesMask Mask determining which matches are drawn. If the mask is empty, all matches are\ndrawn.\n@param flags Flags setting drawing features. Possible flags bit values are defined by\nDrawMatchesFlags.\n\nThis function draws matches of keypoints from two images in the output image. Match is a line\nconnecting two keypoints (circles). See cv::DrawMatchesFlags."]
    #[link_name = "\u{1}_ZN2cv11drawMatchesERKNS_11_InputArrayERKSt6vectorINS_8KeyPointESaIS4_EES2_S8_RKS3_INS_6DMatchESaIS9_EERKNS_17_InputOutputArrayERKNS_7Scalar_IdEESK_RKS3_IcSaIcEENS_16DrawMatchesFlagsE"]
    pub fn cv_drawMatches(
        img1: cv_InputArray,
        keypoints1: *const std_vector,
        img2: cv_InputArray,
        keypoints2: *const std_vector,
        matches1to2: *const std_vector,
        outImg: cv_InputOutputArray,
        matchColor: *const cv_Scalar,
        singlePointColor: *const cv_Scalar,
        matchesMask: *const std_vector,
        flags: cv_DrawMatchesFlags,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv11drawMatchesERKNS_11_InputArrayERKSt6vectorINS_8KeyPointESaIS4_EES2_S8_RKS3_IS3_INS_6DMatchESaIS9_EESaISB_EERKNS_17_InputOutputArrayERKNS_7Scalar_IdEESM_RKS3_IS3_IcSaIcEESaISO_EENS_16DrawMatchesFlagsE"]
    pub fn cv_drawMatches1(
        img1: cv_InputArray,
        keypoints1: *const std_vector,
        img2: cv_InputArray,
        keypoints2: *const std_vector,
        matches1to2: *const std_vector,
        outImg: cv_InputOutputArray,
        matchColor: *const cv_Scalar,
        singlePointColor: *const cv_Scalar,
        matchesMask: *const std_vector,
        flags: cv_DrawMatchesFlags,
    );
}
unsafe extern "C" {
    #[doc = "\\\n   Functions to evaluate the feature detectors and [generic] descriptor extractors      *\n\\"]
    #[link_name = "\u{1}_ZN2cv23evaluateFeatureDetectorERKNS_3MatES2_S2_PSt6vectorINS_8KeyPointESaIS4_EES7_RfRiRKNS_3PtrINS_9Feature2DEEE"]
    pub fn cv_evaluateFeatureDetector(
        img1: *const cv_Mat,
        img2: *const cv_Mat,
        H1to2: *const cv_Mat,
        keypoints1: *mut std_vector,
        keypoints2: *mut std_vector,
        repeatability: *mut f32,
        correspCount: *mut ::std::os::raw::c_int,
        fdetector: *const cv_Ptr,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv27computeRecallPrecisionCurveERKSt6vectorIS0_INS_6DMatchESaIS1_EESaIS3_EERKS0_IS0_IhSaIhEESaIS9_EERS0_INS_6Point_IfEESaISF_EE"]
    pub fn cv_computeRecallPrecisionCurve(
        matches1to2: *const std_vector,
        correctMatches1to2Mask: *const std_vector,
        recallPrecisionCurve: *mut std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9getRecallERKSt6vectorINS_6Point_IfEESaIS2_EEf"]
    pub fn cv_getRecall(recallPrecisionCurve: *const std_vector, l_precision: f32) -> f32;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv15getNearestPointERKSt6vectorINS_6Point_IfEESaIS2_EEf"]
    pub fn cv_getNearestPoint(
        recallPrecisionCurve: *const std_vector,
        l_precision: f32,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
pub struct cv_BOWTrainer__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief Abstract base class for training the *bag of visual words* vocabulary from a set of descriptors.\n\nFor details, see, for example, *Visual Categorization with Bags of Keypoints* by Gabriella Csurka,\nChristopher R. Dance, Lixin Fan, Jutta Willamowski, Cedric Bray, 2004. :"]
#[repr(C)]
pub struct cv_BOWTrainer {
    pub vtable_: *const cv_BOWTrainer__bindgen_vtable,
    pub descriptors: std_vector,
    pub size: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_BOWTrainer"][::std::mem::size_of::<cv_BOWTrainer>() - 40usize];
    ["Alignment of cv_BOWTrainer"][::std::mem::align_of::<cv_BOWTrainer>() - 8usize];
    ["Offset of field: cv_BOWTrainer::descriptors"]
        [::std::mem::offset_of!(cv_BOWTrainer, descriptors) - 8usize];
    ["Offset of field: cv_BOWTrainer::size"][::std::mem::offset_of!(cv_BOWTrainer, size) - 32usize];
};
unsafe extern "C" {
    #[doc = " @brief Adds descriptors to a training set.\n\n@param descriptors Descriptors to add to a training set. Each row of the descriptors matrix is a\ndescriptor.\n\nThe training set is clustered using clustermethod to construct the vocabulary."]
    #[link_name = "\u{1}_ZN2cv10BOWTrainer3addERKNS_3MatE"]
    pub fn cv_BOWTrainer_add(this: *mut cv_BOWTrainer, descriptors: *const cv_Mat);
}
unsafe extern "C" {
    #[doc = " @brief Returns a training set of descriptors."]
    #[link_name = "\u{1}_ZNK2cv10BOWTrainer14getDescriptorsEv"]
    pub fn cv_BOWTrainer_getDescriptors(this: *const cv_BOWTrainer) -> *const std_vector;
}
unsafe extern "C" {
    #[doc = " @brief Returns the count of all descriptors stored in the training set."]
    #[link_name = "\u{1}_ZNK2cv10BOWTrainer16descriptorsCountEv"]
    pub fn cv_BOWTrainer_descriptorsCount(this: *const cv_BOWTrainer) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv10BOWTrainerC2Ev"]
    pub fn cv_BOWTrainer_BOWTrainer(this: *mut cv_BOWTrainer);
}
impl cv_BOWTrainer {
    #[inline]
    pub unsafe fn add(&mut self, descriptors: *const cv_Mat) {
        cv_BOWTrainer_add(self, descriptors)
    }
    #[inline]
    pub unsafe fn getDescriptors(&self) -> *const std_vector {
        cv_BOWTrainer_getDescriptors(self)
    }
    #[inline]
    pub unsafe fn descriptorsCount(&self) -> ::std::os::raw::c_int {
        cv_BOWTrainer_descriptorsCount(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_BOWTrainer_BOWTrainer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv10BOWTrainerD1Ev"]
    pub fn cv_BOWTrainer_BOWTrainer_destructor(this: *mut cv_BOWTrainer);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv10BOWTrainer5clearEv"]
    pub fn cv_BOWTrainer_clear(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief kmeans -based class to train visual vocabulary using the *bag of visual words* approach. :"]
#[repr(C)]
pub struct cv_BOWKMeansTrainer {
    pub _base: cv_BOWTrainer,
    pub clusterCount: ::std::os::raw::c_int,
    pub termcrit: cv_TermCriteria,
    pub attempts: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_BOWKMeansTrainer"][::std::mem::size_of::<cv_BOWKMeansTrainer>() - 64usize];
    ["Alignment of cv_BOWKMeansTrainer"][::std::mem::align_of::<cv_BOWKMeansTrainer>() - 8usize];
    ["Offset of field: cv_BOWKMeansTrainer::clusterCount"]
        [::std::mem::offset_of!(cv_BOWKMeansTrainer, clusterCount) - 36usize];
    ["Offset of field: cv_BOWKMeansTrainer::termcrit"]
        [::std::mem::offset_of!(cv_BOWKMeansTrainer, termcrit) - 40usize];
    ["Offset of field: cv_BOWKMeansTrainer::attempts"]
        [::std::mem::offset_of!(cv_BOWKMeansTrainer, attempts) - 56usize];
    ["Offset of field: cv_BOWKMeansTrainer::flags"]
        [::std::mem::offset_of!(cv_BOWKMeansTrainer, flags) - 60usize];
};
unsafe extern "C" {
    #[doc = " @brief The constructor.\n\n@see cv::kmeans"]
    #[link_name = "\u{1}_ZN2cv16BOWKMeansTrainerC1EiRKNS_12TermCriteriaEii"]
    pub fn cv_BOWKMeansTrainer_BOWKMeansTrainer(
        this: *mut cv_BOWKMeansTrainer,
        clusterCount: ::std::os::raw::c_int,
        termcrit: *const cv_TermCriteria,
        attempts: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    );
}
impl cv_BOWKMeansTrainer {
    #[inline]
    pub unsafe fn new(
        clusterCount: ::std::os::raw::c_int,
        termcrit: *const cv_TermCriteria,
        attempts: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_BOWKMeansTrainer_BOWKMeansTrainer(
            __bindgen_tmp.as_mut_ptr(),
            clusterCount,
            termcrit,
            attempts,
            flags,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv16BOWKMeansTrainerD1Ev"]
    pub fn cv_BOWKMeansTrainer_BOWKMeansTrainer_destructor(this: *mut cv_BOWKMeansTrainer);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv16BOWKMeansTrainer7clusterEv"]
    pub fn cv_BOWKMeansTrainer_cluster(this: *mut ::std::os::raw::c_void) -> cv_Mat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv16BOWKMeansTrainer7clusterERKNS_3MatE"]
    pub fn cv_BOWKMeansTrainer_cluster1(
        this: *mut ::std::os::raw::c_void,
        descriptors: *const cv_Mat,
    ) -> cv_Mat;
}
#[repr(C)]
pub struct cv_BOWImgDescriptorExtractor__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief Class to compute an image descriptor using the *bag of visual words*.\n\nSuch a computation consists of the following steps:\n\n1.  Compute descriptors for a given image and its keypoints set.\n2.  Find the nearest visual words from the vocabulary for each keypoint descriptor.\n3.  Compute the bag-of-words image descriptor as is a normalized histogram of vocabulary words\nencountered in the image. The i-th bin of the histogram is a frequency of i-th word of the\nvocabulary in the given image."]
#[repr(C)]
pub struct cv_BOWImgDescriptorExtractor {
    pub vtable_: *const cv_BOWImgDescriptorExtractor__bindgen_vtable,
    pub vocabulary: cv_Mat,
    pub dextractor: cv_Ptr,
    pub dmatcher: cv_Ptr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_BOWImgDescriptorExtractor"]
        [::std::mem::size_of::<cv_BOWImgDescriptorExtractor>() - 136usize];
    ["Alignment of cv_BOWImgDescriptorExtractor"]
        [::std::mem::align_of::<cv_BOWImgDescriptorExtractor>() - 8usize];
    ["Offset of field: cv_BOWImgDescriptorExtractor::vocabulary"]
        [::std::mem::offset_of!(cv_BOWImgDescriptorExtractor, vocabulary) - 8usize];
    ["Offset of field: cv_BOWImgDescriptorExtractor::dextractor"]
        [::std::mem::offset_of!(cv_BOWImgDescriptorExtractor, dextractor) - 104usize];
    ["Offset of field: cv_BOWImgDescriptorExtractor::dmatcher"]
        [::std::mem::offset_of!(cv_BOWImgDescriptorExtractor, dmatcher) - 120usize];
};
unsafe extern "C" {
    #[doc = " @brief Sets a visual vocabulary.\n\n@param vocabulary Vocabulary (can be trained using the inheritor of BOWTrainer ). Each row of the\nvocabulary is a visual word (cluster center)."]
    #[link_name = "\u{1}_ZN2cv25BOWImgDescriptorExtractor13setVocabularyERKNS_3MatE"]
    pub fn cv_BOWImgDescriptorExtractor_setVocabulary(
        this: *mut cv_BOWImgDescriptorExtractor,
        vocabulary: *const cv_Mat,
    );
}
unsafe extern "C" {
    #[doc = " @brief Returns the set vocabulary."]
    #[link_name = "\u{1}_ZNK2cv25BOWImgDescriptorExtractor13getVocabularyEv"]
    pub fn cv_BOWImgDescriptorExtractor_getVocabulary(
        this: *const cv_BOWImgDescriptorExtractor,
    ) -> *const cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Computes an image descriptor using the set visual vocabulary.\n\n@param image Image, for which the descriptor is computed.\n@param keypoints Keypoints detected in the input image.\n@param imgDescriptor Computed output image descriptor.\n@param pointIdxsOfClusters Indices of keypoints that belong to the cluster. This means that\npointIdxsOfClusters[i] are keypoint indices that belong to the i -th cluster (word of vocabulary)\nreturned if it is non-zero.\n@param descriptors Descriptors of the image keypoints that are returned if they are non-zero."]
    #[link_name = "\u{1}_ZN2cv25BOWImgDescriptorExtractor7computeERKNS_11_InputArrayERSt6vectorINS_8KeyPointESaIS5_EERKNS_12_OutputArrayEPS4_IS4_IiSaIiEESaISD_EEPNS_3MatE"]
    pub fn cv_BOWImgDescriptorExtractor_compute(
        this: *mut cv_BOWImgDescriptorExtractor,
        image: cv_InputArray,
        keypoints: *mut std_vector,
        imgDescriptor: cv_OutputArray,
        pointIdxsOfClusters: *mut std_vector,
        descriptors: *mut cv_Mat,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param keypointDescriptors Computed descriptors to match with vocabulary.\n@param imgDescriptor Computed output image descriptor.\n@param pointIdxsOfClusters Indices of keypoints that belong to the cluster. This means that\npointIdxsOfClusters[i] are keypoint indices that belong to the i -th cluster (word of vocabulary)\nreturned if it is non-zero."]
    #[link_name = "\u{1}_ZN2cv25BOWImgDescriptorExtractor7computeERKNS_11_InputArrayERKNS_12_OutputArrayEPSt6vectorIS7_IiSaIiEESaIS9_EE"]
    pub fn cv_BOWImgDescriptorExtractor_compute1(
        this: *mut cv_BOWImgDescriptorExtractor,
        keypointDescriptors: cv_InputArray,
        imgDescriptor: cv_OutputArray,
        pointIdxsOfClusters: *mut std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @brief Returns an image descriptor size if the vocabulary is set. Otherwise, it returns 0."]
    #[link_name = "\u{1}_ZNK2cv25BOWImgDescriptorExtractor14descriptorSizeEv"]
    pub fn cv_BOWImgDescriptorExtractor_descriptorSize(
        this: *const cv_BOWImgDescriptorExtractor,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Returns an image descriptor type."]
    #[link_name = "\u{1}_ZNK2cv25BOWImgDescriptorExtractor14descriptorTypeEv"]
    pub fn cv_BOWImgDescriptorExtractor_descriptorType(
        this: *const cv_BOWImgDescriptorExtractor,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief The constructor.\n\n@param dextractor Descriptor extractor that is used to compute descriptors for an input image and\nits keypoints.\n@param dmatcher Descriptor matcher that is used to find the nearest word of the trained vocabulary\nfor each keypoint descriptor of the image."]
    #[link_name = "\u{1}_ZN2cv25BOWImgDescriptorExtractorC1ERKNS_3PtrINS_9Feature2DEEERKNS1_INS_17DescriptorMatcherEEE"]
    pub fn cv_BOWImgDescriptorExtractor_BOWImgDescriptorExtractor(
        this: *mut cv_BOWImgDescriptorExtractor,
        dextractor: *const cv_Ptr,
        dmatcher: *const cv_Ptr,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv25BOWImgDescriptorExtractorC1ERKNS_3PtrINS_17DescriptorMatcherEEE"]
    pub fn cv_BOWImgDescriptorExtractor_BOWImgDescriptorExtractor1(
        this: *mut cv_BOWImgDescriptorExtractor,
        dmatcher: *const cv_Ptr,
    );
}
impl cv_BOWImgDescriptorExtractor {
    #[inline]
    pub unsafe fn setVocabulary(&mut self, vocabulary: *const cv_Mat) {
        cv_BOWImgDescriptorExtractor_setVocabulary(self, vocabulary)
    }
    #[inline]
    pub unsafe fn getVocabulary(&self) -> *const cv_Mat {
        cv_BOWImgDescriptorExtractor_getVocabulary(self)
    }
    #[inline]
    pub unsafe fn compute(
        &mut self,
        image: cv_InputArray,
        keypoints: *mut std_vector,
        imgDescriptor: cv_OutputArray,
        pointIdxsOfClusters: *mut std_vector,
        descriptors: *mut cv_Mat,
    ) {
        cv_BOWImgDescriptorExtractor_compute(
            self,
            image,
            keypoints,
            imgDescriptor,
            pointIdxsOfClusters,
            descriptors,
        )
    }
    #[inline]
    pub unsafe fn compute1(
        &mut self,
        keypointDescriptors: cv_InputArray,
        imgDescriptor: cv_OutputArray,
        pointIdxsOfClusters: *mut std_vector,
    ) {
        cv_BOWImgDescriptorExtractor_compute1(
            self,
            keypointDescriptors,
            imgDescriptor,
            pointIdxsOfClusters,
        )
    }
    #[inline]
    pub unsafe fn descriptorSize(&self) -> ::std::os::raw::c_int {
        cv_BOWImgDescriptorExtractor_descriptorSize(self)
    }
    #[inline]
    pub unsafe fn descriptorType(&self) -> ::std::os::raw::c_int {
        cv_BOWImgDescriptorExtractor_descriptorType(self)
    }
    #[inline]
    pub unsafe fn new(dextractor: *const cv_Ptr, dmatcher: *const cv_Ptr) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_BOWImgDescriptorExtractor_BOWImgDescriptorExtractor(
            __bindgen_tmp.as_mut_ptr(),
            dextractor,
            dmatcher,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(dmatcher: *const cv_Ptr) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_BOWImgDescriptorExtractor_BOWImgDescriptorExtractor1(
            __bindgen_tmp.as_mut_ptr(),
            dmatcher,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv25BOWImgDescriptorExtractorD1Ev"]
    pub fn cv_BOWImgDescriptorExtractor_BOWImgDescriptorExtractor_destructor(
        this: *mut cv_BOWImgDescriptorExtractor,
    );
}
#[doc = " @brief Affine transform\n\n It represents a 4x4 homogeneous transformation matrix \\f$T\\f$\n\n  \\f[T =\n  \\begin{bmatrix}\n  R & t\\\\\n  0 & 1\\\\\n  \\end{bmatrix}\n  \\f]\n\n  where \\f$R\\f$ is a 3x3 rotation matrix and \\f$t\\f$ is a 3x1 translation vector.\n\n  You can specify \\f$R\\f$ either by a 3x3 rotation matrix or by a 3x1 rotation vector,\n  which is converted to a 3x3 rotation matrix by the Rodrigues formula.\n\n  To construct a matrix \\f$T\\f$ representing first rotation around the axis \\f$r\\f$ with rotation\n  angle \\f$|r|\\f$ in radian (right hand rule) and then translation by the vector \\f$t\\f$, you can use\n\n  @code\n  cv::Vec3f r, t;\n  cv::Affine3f T(r, t);\n  @endcode\n\n  If you already have the rotation matrix \\f$R\\f$, then you can use\n\n  @code\n  cv::Matx33f R;\n  cv::Affine3f T(R, t);\n  @endcode\n\n  To extract the rotation matrix \\f$R\\f$ from \\f$T\\f$, use\n\n  @code\n  cv::Matx33f R = T.rotation();\n  @endcode\n\n  To extract the translation vector \\f$t\\f$ from \\f$T\\f$, use\n\n  @code\n  cv::Vec3f t = T.translation();\n  @endcode\n\n  To extract the rotation vector \\f$r\\f$ from \\f$T\\f$, use\n\n  @code\n  cv::Vec3f r = T.rvec();\n  @endcode\n\n  Note that since the mapping from rotation vectors to rotation matrices\n  is many to one. The returned rotation vector is not necessarily the one\n  you used before to set the matrix.\n\n  If you have two transformations \\f$T = T_1 * T_2\\f$, use\n\n  @code\n  cv::Affine3f T, T1, T2;\n  T = T2.concatenate(T1);\n  @endcode\n\n  To get the inverse transform of \\f$T\\f$, use\n\n  @code\n  cv::Affine3f T, T_inv;\n  T_inv = T.inv();\n  @endcode\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_Affine3 {
    pub matrix: cv_Affine3_Mat4,
}
pub type cv_Affine3_float_type<T> = T;
#[doc = " @brief Template class for small matrices whose type and size are known at compilation time\n\nIf you need a more flexible type, use Mat . The elements of the matrix M are accessible using the\nM(i,j) notation. Most of the common matrix operations (see also @ref MatrixExpressions ) are\navailable. To do an operation on Matx that is not implemented, you can easily convert the matrix to\nMat and backwards:\n@code{.cpp}\nMatx33f m(1, 2, 3,\n4, 5, 6,\n7, 8, 9);\ncout << sum(Mat(m*m.t())) << endl;\n@endcode\nExcept of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:\n@code{.cpp}\nfloat values[] = { 1, 2, 3};\nMatx31f m(values);\n@endcode\nIn case if C++11 features are available, std::initializer_list can be also used to initialize Matx:\n@code{.cpp}\nMatx31f m = { 1, 2, 3};\n@endcode"]
pub type cv_Affine3_Mat3 = u8;
#[doc = " @brief Template class for small matrices whose type and size are known at compilation time\n\nIf you need a more flexible type, use Mat . The elements of the matrix M are accessible using the\nM(i,j) notation. Most of the common matrix operations (see also @ref MatrixExpressions ) are\navailable. To do an operation on Matx that is not implemented, you can easily convert the matrix to\nMat and backwards:\n@code{.cpp}\nMatx33f m(1, 2, 3,\n4, 5, 6,\n7, 8, 9);\ncout << sum(Mat(m*m.t())) << endl;\n@endcode\nExcept of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:\n@code{.cpp}\nfloat values[] = { 1, 2, 3};\nMatx31f m(values);\n@endcode\nIn case if C++11 features are available, std::initializer_list can be also used to initialize Matx:\n@code{.cpp}\nMatx31f m = { 1, 2, 3};\n@endcode"]
pub type cv_Affine3_Mat4 = u8;
#[doc = "! @cond IGNORED"]
pub type cv_Affine3_Vec3 = u8;
#[doc = " @brief Affine transform\n\n It represents a 4x4 homogeneous transformation matrix \\f$T\\f$\n\n  \\f[T =\n  \\begin{bmatrix}\n  R & t\\\\\n  0 & 1\\\\\n  \\end{bmatrix}\n  \\f]\n\n  where \\f$R\\f$ is a 3x3 rotation matrix and \\f$t\\f$ is a 3x1 translation vector.\n\n  You can specify \\f$R\\f$ either by a 3x3 rotation matrix or by a 3x1 rotation vector,\n  which is converted to a 3x3 rotation matrix by the Rodrigues formula.\n\n  To construct a matrix \\f$T\\f$ representing first rotation around the axis \\f$r\\f$ with rotation\n  angle \\f$|r|\\f$ in radian (right hand rule) and then translation by the vector \\f$t\\f$, you can use\n\n  @code\n  cv::Vec3f r, t;\n  cv::Affine3f T(r, t);\n  @endcode\n\n  If you already have the rotation matrix \\f$R\\f$, then you can use\n\n  @code\n  cv::Matx33f R;\n  cv::Affine3f T(R, t);\n  @endcode\n\n  To extract the rotation matrix \\f$R\\f$ from \\f$T\\f$, use\n\n  @code\n  cv::Matx33f R = T.rotation();\n  @endcode\n\n  To extract the translation vector \\f$t\\f$ from \\f$T\\f$, use\n\n  @code\n  cv::Vec3f t = T.translation();\n  @endcode\n\n  To extract the rotation vector \\f$r\\f$ from \\f$T\\f$, use\n\n  @code\n  cv::Vec3f r = T.rvec();\n  @endcode\n\n  Note that since the mapping from rotation vectors to rotation matrices\n  is many to one. The returned rotation vector is not necessarily the one\n  you used before to set the matrix.\n\n  If you have two transformations \\f$T = T_1 * T_2\\f$, use\n\n  @code\n  cv::Affine3f T, T1, T2;\n  T = T2.concatenate(T1);\n  @endcode\n\n  To get the inverse transform of \\f$T\\f$, use\n\n  @code\n  cv::Affine3f T, T_inv;\n  T_inv = T.inv();\n  @endcode\n"]
pub type cv_Affine3f = cv_Affine3;
#[doc = " @brief Affine transform\n\n It represents a 4x4 homogeneous transformation matrix \\f$T\\f$\n\n  \\f[T =\n  \\begin{bmatrix}\n  R & t\\\\\n  0 & 1\\\\\n  \\end{bmatrix}\n  \\f]\n\n  where \\f$R\\f$ is a 3x3 rotation matrix and \\f$t\\f$ is a 3x1 translation vector.\n\n  You can specify \\f$R\\f$ either by a 3x3 rotation matrix or by a 3x1 rotation vector,\n  which is converted to a 3x3 rotation matrix by the Rodrigues formula.\n\n  To construct a matrix \\f$T\\f$ representing first rotation around the axis \\f$r\\f$ with rotation\n  angle \\f$|r|\\f$ in radian (right hand rule) and then translation by the vector \\f$t\\f$, you can use\n\n  @code\n  cv::Vec3f r, t;\n  cv::Affine3f T(r, t);\n  @endcode\n\n  If you already have the rotation matrix \\f$R\\f$, then you can use\n\n  @code\n  cv::Matx33f R;\n  cv::Affine3f T(R, t);\n  @endcode\n\n  To extract the rotation matrix \\f$R\\f$ from \\f$T\\f$, use\n\n  @code\n  cv::Matx33f R = T.rotation();\n  @endcode\n\n  To extract the translation vector \\f$t\\f$ from \\f$T\\f$, use\n\n  @code\n  cv::Vec3f t = T.translation();\n  @endcode\n\n  To extract the rotation vector \\f$r\\f$ from \\f$T\\f$, use\n\n  @code\n  cv::Vec3f r = T.rvec();\n  @endcode\n\n  Note that since the mapping from rotation vectors to rotation matrices\n  is many to one. The returned rotation vector is not necessarily the one\n  you used before to set the matrix.\n\n  If you have two transformations \\f$T = T_1 * T_2\\f$, use\n\n  @code\n  cv::Affine3f T, T1, T2;\n  T = T2.concatenate(T1);\n  @endcode\n\n  To get the inverse transform of \\f$T\\f$, use\n\n  @code\n  cv::Affine3f T, T_inv;\n  T_inv = T.inv();\n  @endcode\n"]
pub type cv_Affine3d = cv_Affine3;
#[doc = "!< least-median of squares algorithm"]
pub const LMEDS: cv__bindgen_ty_1 = 4;
#[doc = "!< RANSAC algorithm"]
pub const RANSAC: cv__bindgen_ty_1 = 8;
#[doc = "!< RHO algorithm"]
pub const RHO: cv__bindgen_ty_1 = 16;
#[doc = "! type of the robust estimation algorithm"]
pub type cv__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const cv_SolvePnPMethod_SOLVEPNP_ITERATIVE: cv_SolvePnPMethod = 0;
#[doc = "!< EPnP: Efficient Perspective-n-Point Camera Pose Estimation @cite lepetit2009epnp"]
pub const cv_SolvePnPMethod_SOLVEPNP_EPNP: cv_SolvePnPMethod = 1;
#[doc = "!< Complete Solution Classification for the Perspective-Three-Point Problem @cite gao2003complete"]
pub const cv_SolvePnPMethod_SOLVEPNP_P3P: cv_SolvePnPMethod = 2;
#[doc = "!< A Direct Least-Squares (DLS) Method for PnP  @cite hesch2011direct"]
pub const cv_SolvePnPMethod_SOLVEPNP_DLS: cv_SolvePnPMethod = 3;
#[doc = "!< Exhaustive Linearization for Robust Camera Pose and Focal Length Estimation @cite penate2013exhaustive"]
pub const cv_SolvePnPMethod_SOLVEPNP_UPNP: cv_SolvePnPMethod = 4;
#[doc = "!< An Efficient Algebraic Solution to the Perspective-Three-Point Problem @cite Ke17"]
pub const cv_SolvePnPMethod_SOLVEPNP_AP3P: cv_SolvePnPMethod = 5;
#[doc = "!< Infinitesimal Plane-Based Pose Estimation @cite Collins14 \\n\n!< Object points must be coplanar."]
pub const cv_SolvePnPMethod_SOLVEPNP_IPPE: cv_SolvePnPMethod = 6;
#[doc = "!< Infinitesimal Plane-Based Pose Estimation @cite Collins14 \\n\n!< This is a special case suitable for marker pose estimation.\\n\n!< 4 coplanar object points must be defined in the following order:\n!<   - point 0: [-squareLength / 2,  squareLength / 2, 0]\n!<   - point 1: [ squareLength / 2,  squareLength / 2, 0]\n!<   - point 2: [ squareLength / 2, -squareLength / 2, 0]\n!<   - point 3: [-squareLength / 2, -squareLength / 2, 0]"]
pub const cv_SolvePnPMethod_SOLVEPNP_IPPE_SQUARE: cv_SolvePnPMethod = 7;
#[doc = "!< Used for count"]
pub const cv_SolvePnPMethod_SOLVEPNP_MAX_COUNT: cv_SolvePnPMethod = 8;
pub type cv_SolvePnPMethod = ::std::os::raw::c_uint;
pub const CALIB_CB_ADAPTIVE_THRESH: cv__bindgen_ty_2 = 1;
pub const CALIB_CB_NORMALIZE_IMAGE: cv__bindgen_ty_2 = 2;
pub const CALIB_CB_FILTER_QUADS: cv__bindgen_ty_2 = 4;
pub const CALIB_CB_FAST_CHECK: cv__bindgen_ty_2 = 8;
pub const CALIB_CB_EXHAUSTIVE: cv__bindgen_ty_2 = 16;
pub const CALIB_CB_ACCURACY: cv__bindgen_ty_2 = 32;
pub type cv__bindgen_ty_2 = ::std::os::raw::c_uint;
pub const CALIB_CB_SYMMETRIC_GRID: cv__bindgen_ty_3 = 1;
pub const CALIB_CB_ASYMMETRIC_GRID: cv__bindgen_ty_3 = 2;
pub const CALIB_CB_CLUSTERING: cv__bindgen_ty_3 = 4;
pub type cv__bindgen_ty_3 = ::std::os::raw::c_uint;
pub const CALIB_NINTRINSIC: cv__bindgen_ty_4 = 18;
pub const CALIB_USE_INTRINSIC_GUESS: cv__bindgen_ty_4 = 1;
pub const CALIB_FIX_ASPECT_RATIO: cv__bindgen_ty_4 = 2;
pub const CALIB_FIX_PRINCIPAL_POINT: cv__bindgen_ty_4 = 4;
pub const CALIB_ZERO_TANGENT_DIST: cv__bindgen_ty_4 = 8;
pub const CALIB_FIX_FOCAL_LENGTH: cv__bindgen_ty_4 = 16;
pub const CALIB_FIX_K1: cv__bindgen_ty_4 = 32;
pub const CALIB_FIX_K2: cv__bindgen_ty_4 = 64;
pub const CALIB_FIX_K3: cv__bindgen_ty_4 = 128;
pub const CALIB_FIX_K4: cv__bindgen_ty_4 = 2048;
pub const CALIB_FIX_K5: cv__bindgen_ty_4 = 4096;
pub const CALIB_FIX_K6: cv__bindgen_ty_4 = 8192;
pub const CALIB_RATIONAL_MODEL: cv__bindgen_ty_4 = 16384;
pub const CALIB_THIN_PRISM_MODEL: cv__bindgen_ty_4 = 32768;
pub const CALIB_FIX_S1_S2_S3_S4: cv__bindgen_ty_4 = 65536;
pub const CALIB_TILTED_MODEL: cv__bindgen_ty_4 = 262144;
pub const CALIB_FIX_TAUX_TAUY: cv__bindgen_ty_4 = 524288;
#[doc = "!< use QR instead of SVD decomposition for solving. Faster but potentially less precise"]
pub const CALIB_USE_QR: cv__bindgen_ty_4 = 1048576;
pub const CALIB_FIX_TANGENT_DIST: cv__bindgen_ty_4 = 2097152;
pub const CALIB_FIX_INTRINSIC: cv__bindgen_ty_4 = 256;
pub const CALIB_SAME_FOCAL_LENGTH: cv__bindgen_ty_4 = 512;
pub const CALIB_ZERO_DISPARITY: cv__bindgen_ty_4 = 1024;
#[doc = "!< use LU instead of SVD decomposition for solving. much faster but potentially less precise"]
pub const CALIB_USE_LU: cv__bindgen_ty_4 = 131072;
#[doc = "!< for stereoCalibrate"]
pub const CALIB_USE_EXTRINSIC_GUESS: cv__bindgen_ty_4 = 4194304;
pub type cv__bindgen_ty_4 = ::std::os::raw::c_uint;
#[doc = "!< 7-point algorithm"]
pub const FM_7POINT: cv__bindgen_ty_5 = 1;
#[doc = "!< 8-point algorithm"]
pub const FM_8POINT: cv__bindgen_ty_5 = 2;
#[doc = "!< least-median algorithm. 7-point algorithm is used."]
pub const FM_LMEDS: cv__bindgen_ty_5 = 4;
#[doc = "!< RANSAC algorithm. It needs at least 15 points. 7-point algorithm is used."]
pub const FM_RANSAC: cv__bindgen_ty_5 = 8;
#[doc = "! the algorithm for finding fundamental matrix"]
pub type cv__bindgen_ty_5 = ::std::os::raw::c_uint;
#[doc = "!< A New Technique for Fully Autonomous and Efficient 3D Robotics Hand/Eye Calibration @cite Tsai89"]
pub const cv_HandEyeCalibrationMethod_CALIB_HAND_EYE_TSAI: cv_HandEyeCalibrationMethod = 0;
#[doc = "!< Robot Sensor Calibration: Solving AX = XB on the Euclidean Group @cite Park94"]
pub const cv_HandEyeCalibrationMethod_CALIB_HAND_EYE_PARK: cv_HandEyeCalibrationMethod = 1;
#[doc = "!< Hand-eye Calibration @cite Horaud95"]
pub const cv_HandEyeCalibrationMethod_CALIB_HAND_EYE_HORAUD: cv_HandEyeCalibrationMethod = 2;
#[doc = "!< On-line Hand-Eye Calibration @cite Andreff99"]
pub const cv_HandEyeCalibrationMethod_CALIB_HAND_EYE_ANDREFF: cv_HandEyeCalibrationMethod = 3;
#[doc = "!< Hand-Eye Calibration Using Dual Quaternions @cite Daniilidis98"]
pub const cv_HandEyeCalibrationMethod_CALIB_HAND_EYE_DANIILIDIS: cv_HandEyeCalibrationMethod = 4;
pub type cv_HandEyeCalibrationMethod = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Converts a rotation matrix to a rotation vector or vice versa.\n\n@param src Input rotation vector (3x1 or 1x3) or rotation matrix (3x3).\n@param dst Output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively.\n@param jacobian Optional output Jacobian matrix, 3x9 or 9x3, which is a matrix of partial\nderivatives of the output array components with respect to the input array components.\n\n\\f[\\begin{array}{l} \\theta \\leftarrow norm(r) \\\\ r  \\leftarrow r/ \\theta \\\\ R =  \\cos(\\theta) I + (1- \\cos{\\theta} ) r r^T +  \\sin(\\theta) \\vecthreethree{0}{-r_z}{r_y}{r_z}{0}{-r_x}{-r_y}{r_x}{0} \\end{array}\\f]\n\nInverse transformation can be also done easily, since\n\n\\f[\\sin ( \\theta ) \\vecthreethree{0}{-r_z}{r_y}{r_z}{0}{-r_x}{-r_y}{r_x}{0} = \\frac{R - R^T}{2}\\f]\n\nA rotation vector is a convenient and most compact representation of a rotation matrix (since any\nrotation matrix has just 3 degrees of freedom). The representation is used in the global 3D geometry\noptimization procedures like @ref calibrateCamera, @ref stereoCalibrate, or @ref solvePnP .\n\n@note More information about the computation of the derivative of a 3D rotation matrix with respect to its exponential coordinate\ncan be found in:\n- A Compact Formula for the Derivative of a 3-D Rotation in Exponential Coordinates, Guillermo Gallego, Anthony J. Yezzi @cite Gallego2014ACF\n\n@note Useful information on SE(3) and Lie Groups can be found in:\n- A tutorial on SE(3) transformation parameterizations and on-manifold optimization, Jose-Luis Blanco @cite blanco2010tutorial\n- Lie Groups for 2D and 3D Transformation, Ethan Eade @cite Eade17\n- A micro Lie theory for state estimation in robotics, Joan Sol, Jrmie Deray, Dinesh Atchuthan @cite Sol2018AML"]
    #[link_name = "\u{1}_ZN2cv9RodriguesERKNS_11_InputArrayERKNS_12_OutputArrayES5_"]
    pub fn cv_Rodrigues(src: cv_InputArray, dst: cv_OutputArray, jacobian: cv_OutputArray);
}
#[doc = " Levenberg-Marquardt solver. Starting with the specified vector of parameters it\noptimizes the target vector criteria \"err\"\n(finds local minima of each target vector component absolute value).\n\nWhen needed, it calls user-provided callback."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_LMSolver {
    pub _base: cv_Algorithm,
}
#[repr(C)]
pub struct cv_LMSolver_Callback__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct cv_LMSolver_Callback {
    pub vtable_: *const cv_LMSolver_Callback__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_LMSolver_Callback"][::std::mem::size_of::<cv_LMSolver_Callback>() - 8usize];
    ["Alignment of cv_LMSolver_Callback"][::std::mem::align_of::<cv_LMSolver_Callback>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_LMSolver"][::std::mem::size_of::<cv_LMSolver>() - 8usize];
    ["Alignment of cv_LMSolver"][::std::mem::align_of::<cv_LMSolver>() - 8usize];
};
unsafe extern "C" {
    #[doc = "Creates Levenberg-Marquard solver\n\n@param cb callback\n@param maxIters maximum number of iterations that can be further\nmodified using setMaxIters() method."]
    #[link_name = "\u{1}_ZN2cv8LMSolver6createERKNS_3PtrINS0_8CallbackEEEi"]
    pub fn cv_LMSolver_create(cb: *const cv_Ptr, maxIters: ::std::os::raw::c_int) -> cv_Ptr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8LMSolver6createERKNS_3PtrINS0_8CallbackEEEid"]
    pub fn cv_LMSolver_create1(
        cb: *const cv_Ptr,
        maxIters: ::std::os::raw::c_int,
        eps: f64,
    ) -> cv_Ptr;
}
impl cv_LMSolver {
    #[inline]
    pub unsafe fn create(cb: *const cv_Ptr, maxIters: ::std::os::raw::c_int) -> cv_Ptr {
        cv_LMSolver_create(cb, maxIters)
    }
    #[inline]
    pub unsafe fn create1(cb: *const cv_Ptr, maxIters: ::std::os::raw::c_int, eps: f64) -> cv_Ptr {
        cv_LMSolver_create1(cb, maxIters, eps)
    }
}
unsafe extern "C" {
    #[doc = " @brief Finds a perspective transformation between two planes.\n\n@param srcPoints Coordinates of the points in the original plane, a matrix of the type CV_32FC2\nor vector\\<Point2f\\> .\n@param dstPoints Coordinates of the points in the target plane, a matrix of the type CV_32FC2 or\na vector\\<Point2f\\> .\n@param method Method used to compute a homography matrix. The following methods are possible:\n-   **0** - a regular method using all the points, i.e., the least squares method\n-   **RANSAC** - RANSAC-based robust method\n-   **LMEDS** - Least-Median robust method\n-   **RHO** - PROSAC-based robust method\n@param ransacReprojThreshold Maximum allowed reprojection error to treat a point pair as an inlier\n(used in the RANSAC and RHO methods only). That is, if\n\\f[\\| \\texttt{dstPoints} _i -  \\texttt{convertPointsHomogeneous} ( \\texttt{H} * \\texttt{srcPoints} _i) \\|_2  >  \\texttt{ransacReprojThreshold}\\f]\nthen the point \\f$i\\f$ is considered as an outlier. If srcPoints and dstPoints are measured in pixels,\nit usually makes sense to set this parameter somewhere in the range of 1 to 10.\n@param mask Optional output mask set by a robust method ( RANSAC or LMEDS ). Note that the input\nmask values are ignored.\n@param maxIters The maximum number of RANSAC iterations.\n@param confidence Confidence level, between 0 and 1.\n\nThe function finds and returns the perspective transformation \\f$H\\f$ between the source and the\ndestination planes:\n\n\\f[s_i  \\vecthree{x'_i}{y'_i}{1} \\sim H  \\vecthree{x_i}{y_i}{1}\\f]\n\nso that the back-projection error\n\n\\f[\\sum _i \\left ( x'_i- \\frac{h_{11} x_i + h_{12} y_i + h_{13}}{h_{31} x_i + h_{32} y_i + h_{33}} \\right )^2+ \\left ( y'_i- \\frac{h_{21} x_i + h_{22} y_i + h_{23}}{h_{31} x_i + h_{32} y_i + h_{33}} \\right )^2\\f]\n\nis minimized. If the parameter method is set to the default value 0, the function uses all the point\npairs to compute an initial homography estimate with a simple least-squares scheme.\n\nHowever, if not all of the point pairs ( \\f$srcPoints_i\\f$, \\f$dstPoints_i\\f$ ) fit the rigid perspective\ntransformation (that is, there are some outliers), this initial estimate will be poor. In this case,\nyou can use one of the three robust methods. The methods RANSAC, LMeDS and RHO try many different\nrandom subsets of the corresponding point pairs (of four pairs each, collinear pairs are discarded), estimate the homography matrix\nusing this subset and a simple least-squares algorithm, and then compute the quality/goodness of the\ncomputed homography (which is the number of inliers for RANSAC or the least median re-projection error for\nLMeDS). The best subset is then used to produce the initial estimate of the homography matrix and\nthe mask of inliers/outliers.\n\nRegardless of the method, robust or not, the computed homography matrix is refined further (using\ninliers only in case of a robust method) with the Levenberg-Marquardt method to reduce the\nre-projection error even more.\n\nThe methods RANSAC and RHO can handle practically any ratio of outliers but need a threshold to\ndistinguish inliers from outliers. The method LMeDS does not need any threshold but it works\ncorrectly only when there are more than 50% of inliers. Finally, if there are no outliers and the\nnoise is rather small, use the default method (method=0).\n\nThe function is used to find initial intrinsic and extrinsic matrices. Homography matrix is\ndetermined up to a scale. Thus, it is normalized so that \\f$h_{33}=1\\f$. Note that whenever an \\f$H\\f$ matrix\ncannot be estimated, an empty one will be returned.\n\n@sa\ngetAffineTransform, estimateAffine2D, estimateAffinePartial2D, getPerspectiveTransform, warpPerspective,\nperspectiveTransform"]
    #[link_name = "\u{1}_ZN2cv14findHomographyERKNS_11_InputArrayES2_idRKNS_12_OutputArrayEid"]
    pub fn cv_findHomography(
        srcPoints: cv_InputArray,
        dstPoints: cv_InputArray,
        method: ::std::os::raw::c_int,
        ransacReprojThreshold: f64,
        mask: cv_OutputArray,
        maxIters: ::std::os::raw::c_int,
        confidence: f64,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv14findHomographyERKNS_11_InputArrayES2_RKNS_12_OutputArrayEid"]
    pub fn cv_findHomography1(
        srcPoints: cv_InputArray,
        dstPoints: cv_InputArray,
        mask: cv_OutputArray,
        method: ::std::os::raw::c_int,
        ransacReprojThreshold: f64,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Computes an RQ decomposition of 3x3 matrices.\n\n@param src 3x3 input matrix.\n@param mtxR Output 3x3 upper-triangular matrix.\n@param mtxQ Output 3x3 orthogonal matrix.\n@param Qx Optional output 3x3 rotation matrix around x-axis.\n@param Qy Optional output 3x3 rotation matrix around y-axis.\n@param Qz Optional output 3x3 rotation matrix around z-axis.\n\nThe function computes a RQ decomposition using the given rotations. This function is used in\ndecomposeProjectionMatrix to decompose the left 3x3 submatrix of a projection matrix into a camera\nand a rotation matrix.\n\nIt optionally returns three rotation matrices, one for each axis, and the three Euler angles in\ndegrees (as the return value) that could be used in OpenGL. Note, there is always more than one\nsequence of rotations about the three principal axes that results in the same orientation of an\nobject, e.g. see @cite Slabaugh . Returned tree rotation matrices and corresponding three Euler angles\nare only one of the possible solutions."]
    #[link_name = "\u{1}_ZN2cv11RQDecomp3x3ERKNS_11_InputArrayERKNS_12_OutputArrayES5_S5_S5_S5_"]
    pub fn cv_RQDecomp3x3(
        src: cv_InputArray,
        mtxR: cv_OutputArray,
        mtxQ: cv_OutputArray,
        Qx: cv_OutputArray,
        Qy: cv_OutputArray,
        Qz: cv_OutputArray,
    ) -> cv_Vec3d;
}
unsafe extern "C" {
    #[doc = " @brief Decomposes a projection matrix into a rotation matrix and a camera matrix.\n\n@param projMatrix 3x4 input projection matrix P.\n@param cameraMatrix Output 3x3 camera matrix K.\n@param rotMatrix Output 3x3 external rotation matrix R.\n@param transVect Output 4x1 translation vector T.\n@param rotMatrixX Optional 3x3 rotation matrix around x-axis.\n@param rotMatrixY Optional 3x3 rotation matrix around y-axis.\n@param rotMatrixZ Optional 3x3 rotation matrix around z-axis.\n@param eulerAngles Optional three-element vector containing three Euler angles of rotation in\ndegrees.\n\nThe function computes a decomposition of a projection matrix into a calibration and a rotation\nmatrix and the position of a camera.\n\nIt optionally returns three rotation matrices, one for each axis, and three Euler angles that could\nbe used in OpenGL. Note, there is always more than one sequence of rotations about the three\nprincipal axes that results in the same orientation of an object, e.g. see @cite Slabaugh . Returned\ntree rotation matrices and corresponding three Euler angles are only one of the possible solutions.\n\nThe function is based on RQDecomp3x3 ."]
    #[link_name = "\u{1}_ZN2cv25decomposeProjectionMatrixERKNS_11_InputArrayERKNS_12_OutputArrayES5_S5_S5_S5_S5_S5_"]
    pub fn cv_decomposeProjectionMatrix(
        projMatrix: cv_InputArray,
        cameraMatrix: cv_OutputArray,
        rotMatrix: cv_OutputArray,
        transVect: cv_OutputArray,
        rotMatrixX: cv_OutputArray,
        rotMatrixY: cv_OutputArray,
        rotMatrixZ: cv_OutputArray,
        eulerAngles: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Computes partial derivatives of the matrix product for each multiplied matrix.\n\n@param A First multiplied matrix.\n@param B Second multiplied matrix.\n@param dABdA First output derivative matrix d(A\\*B)/dA of size\n\\f$\\texttt{A.rows*B.cols} \\times {A.rows*A.cols}\\f$ .\n@param dABdB Second output derivative matrix d(A\\*B)/dB of size\n\\f$\\texttt{A.rows*B.cols} \\times {B.rows*B.cols}\\f$ .\n\nThe function computes partial derivatives of the elements of the matrix product \\f$A*B\\f$ with regard to\nthe elements of each of the two input matrices. The function is used to compute the Jacobian\nmatrices in stereoCalibrate but can also be used in any other similar optimization function."]
    #[link_name = "\u{1}_ZN2cv11matMulDerivERKNS_11_InputArrayES2_RKNS_12_OutputArrayES5_"]
    pub fn cv_matMulDeriv(
        A: cv_InputArray,
        B: cv_InputArray,
        dABdA: cv_OutputArray,
        dABdB: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Combines two rotation-and-shift transformations.\n\n@param rvec1 First rotation vector.\n@param tvec1 First translation vector.\n@param rvec2 Second rotation vector.\n@param tvec2 Second translation vector.\n@param rvec3 Output rotation vector of the superposition.\n@param tvec3 Output translation vector of the superposition.\n@param dr3dr1 Optional output derivative of rvec3 with regard to rvec1\n@param dr3dt1 Optional output derivative of rvec3 with regard to tvec1\n@param dr3dr2 Optional output derivative of rvec3 with regard to rvec2\n@param dr3dt2 Optional output derivative of rvec3 with regard to tvec2\n@param dt3dr1 Optional output derivative of tvec3 with regard to rvec1\n@param dt3dt1 Optional output derivative of tvec3 with regard to tvec1\n@param dt3dr2 Optional output derivative of tvec3 with regard to rvec2\n@param dt3dt2 Optional output derivative of tvec3 with regard to tvec2\n\nThe functions compute:\n\n\\f[\\begin{array}{l} \\texttt{rvec3} =  \\mathrm{rodrigues} ^{-1} \\left ( \\mathrm{rodrigues} ( \\texttt{rvec2} )  \\cdot \\mathrm{rodrigues} ( \\texttt{rvec1} ) \\right )  \\\\ \\texttt{tvec3} =  \\mathrm{rodrigues} ( \\texttt{rvec2} )  \\cdot \\texttt{tvec1} +  \\texttt{tvec2} \\end{array} ,\\f]\n\nwhere \\f$\\mathrm{rodrigues}\\f$ denotes a rotation vector to a rotation matrix transformation, and\n\\f$\\mathrm{rodrigues}^{-1}\\f$ denotes the inverse transformation. See Rodrigues for details.\n\nAlso, the functions can compute the derivatives of the output vectors with regards to the input\nvectors (see matMulDeriv ). The functions are used inside stereoCalibrate but can also be used in\nyour own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a\nfunction that contains a matrix multiplication."]
    #[link_name = "\u{1}_ZN2cv9composeRTERKNS_11_InputArrayES2_S2_S2_RKNS_12_OutputArrayES5_S5_S5_S5_S5_S5_S5_S5_S5_"]
    pub fn cv_composeRT(
        rvec1: cv_InputArray,
        tvec1: cv_InputArray,
        rvec2: cv_InputArray,
        tvec2: cv_InputArray,
        rvec3: cv_OutputArray,
        tvec3: cv_OutputArray,
        dr3dr1: cv_OutputArray,
        dr3dt1: cv_OutputArray,
        dr3dr2: cv_OutputArray,
        dr3dt2: cv_OutputArray,
        dt3dr1: cv_OutputArray,
        dt3dt1: cv_OutputArray,
        dt3dr2: cv_OutputArray,
        dt3dt2: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Projects 3D points to an image plane.\n\n@param objectPoints Array of object points, 3xN/Nx3 1-channel or 1xN/Nx1 3-channel (or\nvector\\<Point3f\\> ), where N is the number of points in the view.\n@param rvec Rotation vector. See Rodrigues for details.\n@param tvec Translation vector.\n@param cameraMatrix Camera matrix \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}\\f$ .\n@param distCoeffs Input vector of distortion coefficients\n\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of\n4, 5, 8, 12 or 14 elements. If the vector is empty, the zero distortion coefficients are assumed.\n@param imagePoints Output array of image points, 1xN/Nx1 2-channel, or\nvector\\<Point2f\\> .\n@param jacobian Optional output 2Nx(10+\\<numDistCoeffs\\>) jacobian matrix of derivatives of image\npoints with respect to components of the rotation vector, translation vector, focal lengths,\ncoordinates of the principal point and the distortion coefficients. In the old interface different\ncomponents of the jacobian are returned via different output parameters.\n@param aspectRatio Optional \"fixed aspect ratio\" parameter. If the parameter is not 0, the\nfunction assumes that the aspect ratio (*fx/fy*) is fixed and correspondingly adjusts the jacobian\nmatrix.\n\nThe function computes projections of 3D points to the image plane given intrinsic and extrinsic\ncamera parameters. Optionally, the function computes Jacobians - matrices of partial derivatives of\nimage points coordinates (as functions of all the input parameters) with respect to the particular\nparameters, intrinsic and/or extrinsic. The Jacobians are used during the global optimization in\ncalibrateCamera, solvePnP, and stereoCalibrate . The function itself can also be used to compute a\nre-projection error given the current intrinsic and extrinsic parameters.\n\n@note By setting rvec=tvec=(0,0,0) or by setting cameraMatrix to a 3x3 identity matrix, or by\npassing zero distortion coefficients, you can get various useful partial cases of the function. This\nmeans that you can compute the distorted coordinates for a sparse set of points or apply a\nperspective transformation (and also compute the derivatives) in the ideal zero-distortion setup."]
    #[link_name = "\u{1}_ZN2cv13projectPointsERKNS_11_InputArrayES2_S2_S2_S2_RKNS_12_OutputArrayES5_d"]
    pub fn cv_projectPoints(
        objectPoints: cv_InputArray,
        rvec: cv_InputArray,
        tvec: cv_InputArray,
        cameraMatrix: cv_InputArray,
        distCoeffs: cv_InputArray,
        imagePoints: cv_OutputArray,
        jacobian: cv_OutputArray,
        aspectRatio: f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Finds an object pose from 3D-2D point correspondences.\nThis function returns the rotation and the translation vectors that transform a 3D point expressed in the object\ncoordinate frame to the camera coordinate frame, using different methods:\n- P3P methods (@ref SOLVEPNP_P3P, @ref SOLVEPNP_AP3P): need 4 input points to return a unique solution.\n- @ref SOLVEPNP_IPPE Input points must be >= 4 and object points must be coplanar.\n- @ref SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.\nNumber of input points must be 4. Object points must be defined in the following order:\n- point 0: [-squareLength / 2,  squareLength / 2, 0]\n- point 1: [ squareLength / 2,  squareLength / 2, 0]\n- point 2: [ squareLength / 2, -squareLength / 2, 0]\n- point 3: [-squareLength / 2, -squareLength / 2, 0]\n- for all the other flags, number of input points must be >= 4 and object points can be in any configuration.\n\n@param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or\n1xN/Nx1 3-channel, where N is the number of points. vector\\<Point3d\\> can be also passed here.\n@param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,\nwhere N is the number of points. vector\\<Point2d\\> can be also passed here.\n@param cameraMatrix Input camera matrix \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .\n@param distCoeffs Input vector of distortion coefficients\n\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of\n4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are\nassumed.\n@param rvec Output rotation vector (see @ref Rodrigues ) that, together with tvec, brings points from\nthe model coordinate system to the camera coordinate system.\n@param tvec Output translation vector.\n@param useExtrinsicGuess Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses\nthe provided rvec and tvec values as initial approximations of the rotation and translation\nvectors, respectively, and further optimizes them.\n@param flags Method for solving a PnP problem:\n-   **SOLVEPNP_ITERATIVE** Iterative method is based on a Levenberg-Marquardt optimization. In\nthis case the function finds such a pose that minimizes reprojection error, that is the sum\nof squared distances between the observed projections imagePoints and the projected (using\nprojectPoints ) objectPoints .\n-   **SOLVEPNP_P3P** Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang\n\"Complete Solution Classification for the Perspective-Three-Point Problem\" (@cite gao2003complete).\nIn this case the function requires exactly four object and image points.\n-   **SOLVEPNP_AP3P** Method is based on the paper of T. Ke, S. Roumeliotis\n\"An Efficient Algebraic Solution to the Perspective-Three-Point Problem\" (@cite Ke17).\nIn this case the function requires exactly four object and image points.\n-   **SOLVEPNP_EPNP** Method has been introduced by F. Moreno-Noguer, V. Lepetit and P. Fua in the\npaper \"EPnP: Efficient Perspective-n-Point Camera Pose Estimation\" (@cite lepetit2009epnp).\n-   **SOLVEPNP_DLS** Method is based on the paper of J. Hesch and S. Roumeliotis.\n\"A Direct Least-Squares (DLS) Method for PnP\" (@cite hesch2011direct).\n-   **SOLVEPNP_UPNP** Method is based on the paper of A. Penate-Sanchez, J. Andrade-Cetto,\nF. Moreno-Noguer. \"Exhaustive Linearization for Robust Camera Pose and Focal Length\nEstimation\" (@cite penate2013exhaustive). In this case the function also estimates the parameters \\f$f_x\\f$ and \\f$f_y\\f$\nassuming that both have the same value. Then the cameraMatrix is updated with the estimated\nfocal length.\n-   **SOLVEPNP_IPPE** Method is based on the paper of T. Collins and A. Bartoli.\n\"Infinitesimal Plane-Based Pose Estimation\" (@cite Collins14). This method requires coplanar object points.\n-   **SOLVEPNP_IPPE_SQUARE** Method is based on the paper of Toby Collins and Adrien Bartoli.\n\"Infinitesimal Plane-Based Pose Estimation\" (@cite Collins14). This method is suitable for marker pose estimation.\nIt requires 4 coplanar object points defined in the following order:\n- point 0: [-squareLength / 2,  squareLength / 2, 0]\n- point 1: [ squareLength / 2,  squareLength / 2, 0]\n- point 2: [ squareLength / 2, -squareLength / 2, 0]\n- point 3: [-squareLength / 2, -squareLength / 2, 0]\n\nThe function estimates the object pose given a set of object points, their corresponding image\nprojections, as well as the camera matrix and the distortion coefficients, see the figure below\n(more precisely, the X-axis of the camera frame is pointing to the right, the Y-axis downward\nand the Z-axis forward).\n\n[](pnp.jpg)\n\nPoints expressed in the world frame \\f$ \\bf{X}_w \\f$ are projected into the image plane \\f$ \\left[ u, v \\right] \\f$\nusing the perspective projection model \\f$ \\Pi \\f$ and the camera intrinsic parameters matrix \\f$ \\bf{A} \\f$:\n\n\\f[\n\\begin{align*}\n\\begin{bmatrix}\nu \\\\\nv \\\\\n1\n\\end{bmatrix} &=\n\\bf{A} \\hspace{0.1em} \\Pi \\hspace{0.2em} ^{c}\\bf{T}_w\n\\begin{bmatrix}\nX_{w} \\\\\nY_{w} \\\\\nZ_{w} \\\\\n1\n\\end{bmatrix} \\\\\n\\begin{bmatrix}\nu \\\\\nv \\\\\n1\n\\end{bmatrix} &=\n\\begin{bmatrix}\nf_x & 0 & c_x \\\\\n0 & f_y & c_y \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & 0\n\\end{bmatrix}\n\\begin{bmatrix}\nr_{11} & r_{12} & r_{13} & t_x \\\\\nr_{21} & r_{22} & r_{23} & t_y \\\\\nr_{31} & r_{32} & r_{33} & t_z \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nX_{w} \\\\\nY_{w} \\\\\nZ_{w} \\\\\n1\n\\end{bmatrix}\n\\end{align*}\n\\f]\n\nThe estimated pose is thus the rotation (`rvec`) and the translation (`tvec`) vectors that allow transforming\na 3D point expressed in the world frame into the camera frame:\n\n\\f[\n\\begin{align*}\n\\begin{bmatrix}\nX_c \\\\\nY_c \\\\\nZ_c \\\\\n1\n\\end{bmatrix} &=\n\\hspace{0.2em} ^{c}\\bf{T}_w\n\\begin{bmatrix}\nX_{w} \\\\\nY_{w} \\\\\nZ_{w} \\\\\n1\n\\end{bmatrix} \\\\\n\\begin{bmatrix}\nX_c \\\\\nY_c \\\\\nZ_c \\\\\n1\n\\end{bmatrix} &=\n\\begin{bmatrix}\nr_{11} & r_{12} & r_{13} & t_x \\\\\nr_{21} & r_{22} & r_{23} & t_y \\\\\nr_{31} & r_{32} & r_{33} & t_z \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nX_{w} \\\\\nY_{w} \\\\\nZ_{w} \\\\\n1\n\\end{bmatrix}\n\\end{align*}\n\\f]\n\n@note\n-   An example of how to use solvePnP for planar augmented reality can be found at\nopencv_source_code/samples/python/plane_ar.py\n-   If you are using Python:\n- Numpy array slices won't work as input because solvePnP requires contiguous\narrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of\nmodules/calib3d/src/solvepnp.cpp version 2.4.9)\n- The P3P algorithm requires image points to be in an array of shape (N,1,2) due\nto its calling of cv::undistortPoints (around line 75 of modules/calib3d/src/solvepnp.cpp version 2.4.9)\nwhich requires 2-channel information.\n- Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of\nit as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =\nnp.ascontiguousarray(D[:,:2]).reshape((N,1,2))\n-   The methods **SOLVEPNP_DLS** and **SOLVEPNP_UPNP** cannot be used as the current implementations are\nunstable and sometimes give completely wrong results. If you pass one of these two\nflags, **SOLVEPNP_EPNP** method will be used instead.\n-   The minimum number of points is 4 in the general case. In the case of **SOLVEPNP_P3P** and **SOLVEPNP_AP3P**\nmethods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions\nof the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).\n-   With **SOLVEPNP_ITERATIVE** method and `useExtrinsicGuess=true`, the minimum number of points is 3 (3 points\nare sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the\nglobal solution to converge.\n-   With **SOLVEPNP_IPPE** input points must be >= 4 and object points must be coplanar.\n-   With **SOLVEPNP_IPPE_SQUARE** this is a special case suitable for marker pose estimation.\nNumber of input points must be 4. Object points must be defined in the following order:\n- point 0: [-squareLength / 2,  squareLength / 2, 0]\n- point 1: [ squareLength / 2,  squareLength / 2, 0]\n- point 2: [ squareLength / 2, -squareLength / 2, 0]\n- point 3: [-squareLength / 2, -squareLength / 2, 0]"]
    #[link_name = "\u{1}_ZN2cv8solvePnPERKNS_11_InputArrayES2_S2_S2_RKNS_12_OutputArrayES5_bi"]
    pub fn cv_solvePnP(
        objectPoints: cv_InputArray,
        imagePoints: cv_InputArray,
        cameraMatrix: cv_InputArray,
        distCoeffs: cv_InputArray,
        rvec: cv_OutputArray,
        tvec: cv_OutputArray,
        useExtrinsicGuess: bool,
        flags: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.\n\n@param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or\n1xN/Nx1 3-channel, where N is the number of points. vector\\<Point3d\\> can be also passed here.\n@param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,\nwhere N is the number of points. vector\\<Point2d\\> can be also passed here.\n@param cameraMatrix Input camera matrix \\f$A = \\vecthreethree{fx}{0}{cx}{0}{fy}{cy}{0}{0}{1}\\f$ .\n@param distCoeffs Input vector of distortion coefficients\n\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of\n4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are\nassumed.\n@param rvec Output rotation vector (see @ref Rodrigues ) that, together with tvec, brings points from\nthe model coordinate system to the camera coordinate system.\n@param tvec Output translation vector.\n@param useExtrinsicGuess Parameter used for @ref SOLVEPNP_ITERATIVE. If true (1), the function uses\nthe provided rvec and tvec values as initial approximations of the rotation and translation\nvectors, respectively, and further optimizes them.\n@param iterationsCount Number of iterations.\n@param reprojectionError Inlier threshold value used by the RANSAC procedure. The parameter value\nis the maximum allowed distance between the observed and computed point projections to consider it\nan inlier.\n@param confidence The probability that the algorithm produces a useful result.\n@param inliers Output vector that contains indices of inliers in objectPoints and imagePoints .\n@param flags Method for solving a PnP problem (see @ref solvePnP ).\n\nThe function estimates an object pose given a set of object points, their corresponding image\nprojections, as well as the camera matrix and the distortion coefficients. This function finds such\na pose that minimizes reprojection error, that is, the sum of squared distances between the observed\nprojections imagePoints and the projected (using @ref projectPoints ) objectPoints. The use of RANSAC\nmakes the function resistant to outliers.\n\n@note\n-   An example of how to use solvePNPRansac for object detection can be found at\nopencv_source_code/samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/\n-   The default method used to estimate the camera pose for the Minimal Sample Sets step\nis #SOLVEPNP_EPNP. Exceptions are:\n- if you choose #SOLVEPNP_P3P or #SOLVEPNP_AP3P, these methods will be used.\n- if the number of input points is equal to 4, #SOLVEPNP_P3P is used.\n-   The method used to estimate the camera pose using all the inliers is defined by the\nflags parameters unless it is equal to #SOLVEPNP_P3P or #SOLVEPNP_AP3P. In this case,\nthe method #SOLVEPNP_EPNP will be used instead."]
    #[link_name = "\u{1}_ZN2cv14solvePnPRansacERKNS_11_InputArrayES2_S2_S2_RKNS_12_OutputArrayES5_bifdS5_i"]
    pub fn cv_solvePnPRansac(
        objectPoints: cv_InputArray,
        imagePoints: cv_InputArray,
        cameraMatrix: cv_InputArray,
        distCoeffs: cv_InputArray,
        rvec: cv_OutputArray,
        tvec: cv_OutputArray,
        useExtrinsicGuess: bool,
        iterationsCount: ::std::os::raw::c_int,
        reprojectionError: f32,
        confidence: f64,
        inliers: cv_OutputArray,
        flags: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Finds an object pose from 3 3D-2D point correspondences.\n\n@param objectPoints Array of object points in the object coordinate space, 3x3 1-channel or\n1x3/3x1 3-channel. vector\\<Point3f\\> can be also passed here.\n@param imagePoints Array of corresponding image points, 3x2 1-channel or 1x3/3x1 2-channel.\nvector\\<Point2f\\> can be also passed here.\n@param cameraMatrix Input camera matrix \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .\n@param distCoeffs Input vector of distortion coefficients\n\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of\n4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are\nassumed.\n@param rvecs Output rotation vectors (see @ref Rodrigues ) that, together with tvecs, brings points from\nthe model coordinate system to the camera coordinate system. A P3P problem has up to 4 solutions.\n@param tvecs Output translation vectors.\n@param flags Method for solving a P3P problem:\n-   **SOLVEPNP_P3P** Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang\n\"Complete Solution Classification for the Perspective-Three-Point Problem\" (@cite gao2003complete).\n-   **SOLVEPNP_AP3P** Method is based on the paper of T. Ke and S. Roumeliotis.\n\"An Efficient Algebraic Solution to the Perspective-Three-Point Problem\" (@cite Ke17).\n\nThe function estimates the object pose given 3 object points, their corresponding image\nprojections, as well as the camera matrix and the distortion coefficients.\n\n@note\nThe solutions are sorted by reprojection errors (lowest to highest)."]
    #[link_name = "\u{1}_ZN2cv8solveP3PERKNS_11_InputArrayES2_S2_S2_RKNS_12_OutputArrayES5_i"]
    pub fn cv_solveP3P(
        objectPoints: cv_InputArray,
        imagePoints: cv_InputArray,
        cameraMatrix: cv_InputArray,
        distCoeffs: cv_InputArray,
        rvecs: cv_OutputArrayOfArrays,
        tvecs: cv_OutputArrayOfArrays,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame\nto the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.\n\n@param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel,\nwhere N is the number of points. vector\\<Point3d\\> can also be passed here.\n@param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,\nwhere N is the number of points. vector\\<Point2d\\> can also be passed here.\n@param cameraMatrix Input camera matrix \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .\n@param distCoeffs Input vector of distortion coefficients\n\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of\n4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are\nassumed.\n@param rvec Input/Output rotation vector (see @ref Rodrigues ) that, together with tvec, brings points from\nthe model coordinate system to the camera coordinate system. Input values are used as an initial solution.\n@param tvec Input/Output translation vector. Input values are used as an initial solution.\n@param criteria Criteria when to stop the Levenberg-Marquard iterative algorithm.\n\nThe function refines the object pose given at least 3 object points, their corresponding image\nprojections, an initial solution for the rotation and translation vector,\nas well as the camera matrix and the distortion coefficients.\nThe function minimizes the projection error with respect to the rotation and the translation vectors, according\nto a Levenberg-Marquardt iterative minimization @cite Madsen04 @cite Eade13 process."]
    #[link_name = "\u{1}_ZN2cv16solvePnPRefineLMERKNS_11_InputArrayES2_S2_S2_RKNS_17_InputOutputArrayES5_NS_12TermCriteriaE"]
    pub fn cv_solvePnPRefineLM(
        objectPoints: cv_InputArray,
        imagePoints: cv_InputArray,
        cameraMatrix: cv_InputArray,
        distCoeffs: cv_InputArray,
        rvec: cv_InputOutputArray,
        tvec: cv_InputOutputArray,
        criteria: cv_TermCriteria,
    );
}
unsafe extern "C" {
    #[doc = " @brief Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame\nto the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.\n\n@param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel,\nwhere N is the number of points. vector\\<Point3d\\> can also be passed here.\n@param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,\nwhere N is the number of points. vector\\<Point2d\\> can also be passed here.\n@param cameraMatrix Input camera matrix \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .\n@param distCoeffs Input vector of distortion coefficients\n\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of\n4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are\nassumed.\n@param rvec Input/Output rotation vector (see @ref Rodrigues ) that, together with tvec, brings points from\nthe model coordinate system to the camera coordinate system. Input values are used as an initial solution.\n@param tvec Input/Output translation vector. Input values are used as an initial solution.\n@param criteria Criteria when to stop the Levenberg-Marquard iterative algorithm.\n@param VVSlambda Gain for the virtual visual servoing control law, equivalent to the \\f$\\alpha\\f$\ngain in the Damped Gauss-Newton formulation.\n\nThe function refines the object pose given at least 3 object points, their corresponding image\nprojections, an initial solution for the rotation and translation vector,\nas well as the camera matrix and the distortion coefficients.\nThe function minimizes the projection error with respect to the rotation and the translation vectors, using a\nvirtual visual servoing (VVS) @cite Chaumette06 @cite Marchand16 scheme."]
    #[link_name = "\u{1}_ZN2cv17solvePnPRefineVVSERKNS_11_InputArrayES2_S2_S2_RKNS_17_InputOutputArrayES5_NS_12TermCriteriaEd"]
    pub fn cv_solvePnPRefineVVS(
        objectPoints: cv_InputArray,
        imagePoints: cv_InputArray,
        cameraMatrix: cv_InputArray,
        distCoeffs: cv_InputArray,
        rvec: cv_InputOutputArray,
        tvec: cv_InputOutputArray,
        criteria: cv_TermCriteria,
        VVSlambda: f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Finds an object pose from 3D-2D point correspondences.\nThis function returns a list of all the possible solutions (a solution is a <rotation vector, translation vector>\ncouple), depending on the number of input points and the chosen method:\n- P3P methods (@ref SOLVEPNP_P3P, @ref SOLVEPNP_AP3P): 3 or 4 input points. Number of returned solutions can be between 0 and 4 with 3 input points.\n- @ref SOLVEPNP_IPPE Input points must be >= 4 and object points must be coplanar. Returns 2 solutions.\n- @ref SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.\nNumber of input points must be 4 and 2 solutions are returned. Object points must be defined in the following order:\n- point 0: [-squareLength / 2,  squareLength / 2, 0]\n- point 1: [ squareLength / 2,  squareLength / 2, 0]\n- point 2: [ squareLength / 2, -squareLength / 2, 0]\n- point 3: [-squareLength / 2, -squareLength / 2, 0]\n- for all the other flags, number of input points must be >= 4 and object points can be in any configuration.\nOnly 1 solution is returned.\n\n@param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or\n1xN/Nx1 3-channel, where N is the number of points. vector\\<Point3d\\> can be also passed here.\n@param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,\nwhere N is the number of points. vector\\<Point2d\\> can be also passed here.\n@param cameraMatrix Input camera matrix \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .\n@param distCoeffs Input vector of distortion coefficients\n\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of\n4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are\nassumed.\n@param rvecs Vector of output rotation vectors (see @ref Rodrigues ) that, together with tvecs, brings points from\nthe model coordinate system to the camera coordinate system.\n@param tvecs Vector of output translation vectors.\n@param useExtrinsicGuess Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses\nthe provided rvec and tvec values as initial approximations of the rotation and translation\nvectors, respectively, and further optimizes them.\n@param flags Method for solving a PnP problem:\n-   **SOLVEPNP_ITERATIVE** Iterative method is based on a Levenberg-Marquardt optimization. In\nthis case the function finds such a pose that minimizes reprojection error, that is the sum\nof squared distances between the observed projections imagePoints and the projected (using\nprojectPoints ) objectPoints .\n-   **SOLVEPNP_P3P** Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang\n\"Complete Solution Classification for the Perspective-Three-Point Problem\" (@cite gao2003complete).\nIn this case the function requires exactly four object and image points.\n-   **SOLVEPNP_AP3P** Method is based on the paper of T. Ke, S. Roumeliotis\n\"An Efficient Algebraic Solution to the Perspective-Three-Point Problem\" (@cite Ke17).\nIn this case the function requires exactly four object and image points.\n-   **SOLVEPNP_EPNP** Method has been introduced by F.Moreno-Noguer, V.Lepetit and P.Fua in the\npaper \"EPnP: Efficient Perspective-n-Point Camera Pose Estimation\" (@cite lepetit2009epnp).\n-   **SOLVEPNP_DLS** Method is based on the paper of Joel A. Hesch and Stergios I. Roumeliotis.\n\"A Direct Least-Squares (DLS) Method for PnP\" (@cite hesch2011direct).\n-   **SOLVEPNP_UPNP** Method is based on the paper of A.Penate-Sanchez, J.Andrade-Cetto,\nF.Moreno-Noguer. \"Exhaustive Linearization for Robust Camera Pose and Focal Length\nEstimation\" (@cite penate2013exhaustive). In this case the function also estimates the parameters \\f$f_x\\f$ and \\f$f_y\\f$\nassuming that both have the same value. Then the cameraMatrix is updated with the estimated\nfocal length.\n-   **SOLVEPNP_IPPE** Method is based on the paper of T. Collins and A. Bartoli.\n\"Infinitesimal Plane-Based Pose Estimation\" (@cite Collins14). This method requires coplanar object points.\n-   **SOLVEPNP_IPPE_SQUARE** Method is based on the paper of Toby Collins and Adrien Bartoli.\n\"Infinitesimal Plane-Based Pose Estimation\" (@cite Collins14). This method is suitable for marker pose estimation.\nIt requires 4 coplanar object points defined in the following order:\n- point 0: [-squareLength / 2,  squareLength / 2, 0]\n- point 1: [ squareLength / 2,  squareLength / 2, 0]\n- point 2: [ squareLength / 2, -squareLength / 2, 0]\n- point 3: [-squareLength / 2, -squareLength / 2, 0]\n@param rvec Rotation vector used to initialize an iterative PnP refinement algorithm, when flag is SOLVEPNP_ITERATIVE\nand useExtrinsicGuess is set to true.\n@param tvec Translation vector used to initialize an iterative PnP refinement algorithm, when flag is SOLVEPNP_ITERATIVE\nand useExtrinsicGuess is set to true.\n@param reprojectionError Optional vector of reprojection error, that is the RMS error\n(\\f$ \\text{RMSE} = \\sqrt{\\frac{\\sum_{i}^{N} \\left ( \\hat{y_i} - y_i \\right )^2}{N}} \\f$) between the input image points\nand the 3D object points projected with the estimated pose.\n\nThe function estimates the object pose given a set of object points, their corresponding image\nprojections, as well as the camera matrix and the distortion coefficients, see the figure below\n(more precisely, the X-axis of the camera frame is pointing to the right, the Y-axis downward\nand the Z-axis forward).\n\n[](pnp.jpg)\n\nPoints expressed in the world frame \\f$ \\bf{X}_w \\f$ are projected into the image plane \\f$ \\left[ u, v \\right] \\f$\nusing the perspective projection model \\f$ \\Pi \\f$ and the camera intrinsic parameters matrix \\f$ \\bf{A} \\f$:\n\n\\f[\n\\begin{align*}\n\\begin{bmatrix}\nu \\\\\nv \\\\\n1\n\\end{bmatrix} &=\n\\bf{A} \\hspace{0.1em} \\Pi \\hspace{0.2em} ^{c}\\bf{T}_w\n\\begin{bmatrix}\nX_{w} \\\\\nY_{w} \\\\\nZ_{w} \\\\\n1\n\\end{bmatrix} \\\\\n\\begin{bmatrix}\nu \\\\\nv \\\\\n1\n\\end{bmatrix} &=\n\\begin{bmatrix}\nf_x & 0 & c_x \\\\\n0 & f_y & c_y \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & 0\n\\end{bmatrix}\n\\begin{bmatrix}\nr_{11} & r_{12} & r_{13} & t_x \\\\\nr_{21} & r_{22} & r_{23} & t_y \\\\\nr_{31} & r_{32} & r_{33} & t_z \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nX_{w} \\\\\nY_{w} \\\\\nZ_{w} \\\\\n1\n\\end{bmatrix}\n\\end{align*}\n\\f]\n\nThe estimated pose is thus the rotation (`rvec`) and the translation (`tvec`) vectors that allow transforming\na 3D point expressed in the world frame into the camera frame:\n\n\\f[\n\\begin{align*}\n\\begin{bmatrix}\nX_c \\\\\nY_c \\\\\nZ_c \\\\\n1\n\\end{bmatrix} &=\n\\hspace{0.2em} ^{c}\\bf{T}_w\n\\begin{bmatrix}\nX_{w} \\\\\nY_{w} \\\\\nZ_{w} \\\\\n1\n\\end{bmatrix} \\\\\n\\begin{bmatrix}\nX_c \\\\\nY_c \\\\\nZ_c \\\\\n1\n\\end{bmatrix} &=\n\\begin{bmatrix}\nr_{11} & r_{12} & r_{13} & t_x \\\\\nr_{21} & r_{22} & r_{23} & t_y \\\\\nr_{31} & r_{32} & r_{33} & t_z \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nX_{w} \\\\\nY_{w} \\\\\nZ_{w} \\\\\n1\n\\end{bmatrix}\n\\end{align*}\n\\f]\n\n@note\n-   An example of how to use solvePnP for planar augmented reality can be found at\nopencv_source_code/samples/python/plane_ar.py\n-   If you are using Python:\n- Numpy array slices won't work as input because solvePnP requires contiguous\narrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of\nmodules/calib3d/src/solvepnp.cpp version 2.4.9)\n- The P3P algorithm requires image points to be in an array of shape (N,1,2) due\nto its calling of cv::undistortPoints (around line 75 of modules/calib3d/src/solvepnp.cpp version 2.4.9)\nwhich requires 2-channel information.\n- Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of\nit as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =\nnp.ascontiguousarray(D[:,:2]).reshape((N,1,2))\n-   The methods **SOLVEPNP_DLS** and **SOLVEPNP_UPNP** cannot be used as the current implementations are\nunstable and sometimes give completely wrong results. If you pass one of these two\nflags, **SOLVEPNP_EPNP** method will be used instead.\n-   The minimum number of points is 4 in the general case. In the case of **SOLVEPNP_P3P** and **SOLVEPNP_AP3P**\nmethods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions\nof the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).\n-   With **SOLVEPNP_ITERATIVE** method and `useExtrinsicGuess=true`, the minimum number of points is 3 (3 points\nare sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the\nglobal solution to converge.\n-   With **SOLVEPNP_IPPE** input points must be >= 4 and object points must be coplanar.\n-   With **SOLVEPNP_IPPE_SQUARE** this is a special case suitable for marker pose estimation.\nNumber of input points must be 4. Object points must be defined in the following order:\n- point 0: [-squareLength / 2,  squareLength / 2, 0]\n- point 1: [ squareLength / 2,  squareLength / 2, 0]\n- point 2: [ squareLength / 2, -squareLength / 2, 0]\n- point 3: [-squareLength / 2, -squareLength / 2, 0]"]
    #[link_name = "\u{1}_ZN2cv15solvePnPGenericERKNS_11_InputArrayES2_S2_S2_RKNS_12_OutputArrayES5_bNS_14SolvePnPMethodES2_S2_S5_"]
    pub fn cv_solvePnPGeneric(
        objectPoints: cv_InputArray,
        imagePoints: cv_InputArray,
        cameraMatrix: cv_InputArray,
        distCoeffs: cv_InputArray,
        rvecs: cv_OutputArrayOfArrays,
        tvecs: cv_OutputArrayOfArrays,
        useExtrinsicGuess: bool,
        flags: cv_SolvePnPMethod,
        rvec: cv_InputArray,
        tvec: cv_InputArray,
        reprojectionError: cv_OutputArray,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Finds an initial camera matrix from 3D-2D point correspondences.\n\n@param objectPoints Vector of vectors of the calibration pattern points in the calibration pattern\ncoordinate space. In the old interface all the per-view vectors are concatenated. See\ncalibrateCamera for details.\n@param imagePoints Vector of vectors of the projections of the calibration pattern points. In the\nold interface all the per-view vectors are concatenated.\n@param imageSize Image size in pixels used to initialize the principal point.\n@param aspectRatio If it is zero or negative, both \\f$f_x\\f$ and \\f$f_y\\f$ are estimated independently.\nOtherwise, \\f$f_x = f_y * \\texttt{aspectRatio}\\f$ .\n\nThe function estimates and returns an initial camera matrix for the camera calibration process.\nCurrently, the function only supports planar calibration patterns, which are patterns where each\nobject point has z-coordinate =0."]
    #[link_name = "\u{1}_ZN2cv18initCameraMatrix2DERKNS_11_InputArrayES2_NS_5Size_IiEEd"]
    pub fn cv_initCameraMatrix2D(
        objectPoints: cv_InputArrayOfArrays,
        imagePoints: cv_InputArrayOfArrays,
        imageSize: cv_Size,
        aspectRatio: f64,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Finds the positions of internal corners of the chessboard.\n\n@param image Source chessboard view. It must be an 8-bit grayscale or color image.\n@param patternSize Number of inner corners per a chessboard row and column\n( patternSize = cv::Size(points_per_row,points_per_colum) = cv::Size(columns,rows) ).\n@param corners Output array of detected corners.\n@param flags Various operation flags that can be zero or a combination of the following values:\n-   **CALIB_CB_ADAPTIVE_THRESH** Use adaptive thresholding to convert the image to black\nand white, rather than a fixed threshold level (computed from the average image brightness).\n-   **CALIB_CB_NORMALIZE_IMAGE** Normalize the image gamma with equalizeHist before\napplying fixed or adaptive thresholding.\n-   **CALIB_CB_FILTER_QUADS** Use additional criteria (like contour area, perimeter,\nsquare-like shape) to filter out false quads extracted at the contour retrieval stage.\n-   **CALIB_CB_FAST_CHECK** Run a fast check on the image that looks for chessboard corners,\nand shortcut the call if none is found. This can drastically speed up the call in the\ndegenerate condition when no chessboard is observed.\n\nThe function attempts to determine whether the input image is a view of the chessboard pattern and\nlocate the internal chessboard corners. The function returns a non-zero value if all of the corners\nare found and they are placed in a certain order (row by row, left to right in every row).\nOtherwise, if the function fails to find all the corners or reorder them, it returns 0. For example,\na regular chessboard has 8 x 8 squares and 7 x 7 internal corners, that is, points where the black\nsquares touch each other. The detected coordinates are approximate, and to determine their positions\nmore accurately, the function calls cornerSubPix. You also may use the function cornerSubPix with\ndifferent parameters if returned coordinates are not accurate enough.\n\nSample usage of detecting and drawing chessboard corners: :\n@code\nSize patternsize(8,6); //interior number of corners\nMat gray = ....; //source image\nvector<Point2f> corners; //this will be filled by the detected corners\n\n//CALIB_CB_FAST_CHECK saves a lot of time on images\n//that do not contain any chessboard corners\nbool patternfound = findChessboardCorners(gray, patternsize, corners,\nCALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE\n+ CALIB_CB_FAST_CHECK);\n\nif(patternfound)\ncornerSubPix(gray, corners, Size(11, 11), Size(-1, -1),\nTermCriteria(CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, 30, 0.1));\n\ndrawChessboardCorners(img, patternsize, Mat(corners), patternfound);\n@endcode\n@note The function requires white space (like a square-thick border, the wider the better) around\nthe board to make the detection more robust in various environments. Otherwise, if there is no\nborder and the background is dark, the outer black squares cannot be segmented properly and so the\nsquare grouping and ordering algorithm fails."]
    #[link_name = "\u{1}_ZN2cv21findChessboardCornersERKNS_11_InputArrayENS_5Size_IiEERKNS_12_OutputArrayEi"]
    pub fn cv_findChessboardCorners(
        image: cv_InputArray,
        patternSize: cv_Size,
        corners: cv_OutputArray,
        flags: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv15checkChessboardERKNS_11_InputArrayENS_5Size_IiEE"]
    pub fn cv_checkChessboard(img: cv_InputArray, size: cv_Size) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Finds the positions of internal corners of the chessboard using a sector based approach.\n\n@param image Source chessboard view. It must be an 8-bit grayscale or color image.\n@param patternSize Number of inner corners per a chessboard row and column\n( patternSize = cv::Size(points_per_row,points_per_colum) = cv::Size(columns,rows) ).\n@param corners Output array of detected corners.\n@param flags Various operation flags that can be zero or a combination of the following values:\n-   **CALIB_CB_NORMALIZE_IMAGE** Normalize the image gamma with equalizeHist before detection.\n-   **CALIB_CB_EXHAUSTIVE** Run an exhaustive search to improve detection rate.\n-   **CALIB_CB_ACCURACY** Up sample input image to improve sub-pixel accuracy due to aliasing effects.\nThis should be used if an accurate camera calibration is required.\n\nThe function is analog to findchessboardCorners but uses a localized radon\ntransformation approximated by box filters being more robust to all sort of\nnoise, faster on larger images and is able to directly return the sub-pixel\nposition of the internal chessboard corners. The Method is based on the paper\n@cite duda2018 \"Accurate Detection and Localization of Checkerboard Corners for\nCalibration\" demonstrating that the returned sub-pixel positions are more\naccurate than the one returned by cornerSubPix allowing a precise camera\ncalibration for demanding applications.\n\n@note The function requires a white boarder with roughly the same width as one\nof the checkerboard fields around the whole board to improve the detection in\nvarious environments. In addition, because of the localized radon\ntransformation it is beneficial to use round corners for the field corners\nwhich are located on the outside of the board. The following figure illustrates\na sample checkerboard optimized for the detection. However, any other checkerboard\ncan be used as well.\n[Checkerboard](pics/checkerboard_radon.png)"]
    #[link_name = "\u{1}_ZN2cv23findChessboardCornersSBERKNS_11_InputArrayENS_5Size_IiEERKNS_12_OutputArrayEi"]
    pub fn cv_findChessboardCornersSB(
        image: cv_InputArray,
        patternSize: cv_Size,
        corners: cv_OutputArray,
        flags: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! finds subpixel-accurate positions of the chessboard corners"]
    #[link_name = "\u{1}_ZN2cv21find4QuadCornerSubpixERKNS_11_InputArrayERKNS_17_InputOutputArrayENS_5Size_IiEE"]
    pub fn cv_find4QuadCornerSubpix(
        img: cv_InputArray,
        corners: cv_InputOutputArray,
        region_size: cv_Size,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Renders the detected chessboard corners.\n\n@param image Destination image. It must be an 8-bit color image.\n@param patternSize Number of inner corners per a chessboard row and column\n(patternSize = cv::Size(points_per_row,points_per_column)).\n@param corners Array of detected corners, the output of findChessboardCorners.\n@param patternWasFound Parameter indicating whether the complete board was found or not. The\nreturn value of findChessboardCorners should be passed here.\n\nThe function draws individual chessboard corners detected either as red circles if the board was not\nfound, or as colored corners connected with lines if the board was found."]
    #[link_name = "\u{1}_ZN2cv21drawChessboardCornersERKNS_17_InputOutputArrayENS_5Size_IiEERKNS_11_InputArrayEb"]
    pub fn cv_drawChessboardCorners(
        image: cv_InputOutputArray,
        patternSize: cv_Size,
        corners: cv_InputArray,
        patternWasFound: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief Draw axes of the world/object coordinate system from pose estimation. @sa solvePnP\n\n@param image Input/output image. It must have 1 or 3 channels. The number of channels is not altered.\n@param cameraMatrix Input 3x3 floating-point matrix of camera intrinsic parameters.\n\\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$\n@param distCoeffs Input vector of distortion coefficients\n\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of\n4, 5, 8, 12 or 14 elements. If the vector is empty, the zero distortion coefficients are assumed.\n@param rvec Rotation vector (see @ref Rodrigues ) that, together with tvec, brings points from\nthe model coordinate system to the camera coordinate system.\n@param tvec Translation vector.\n@param length Length of the painted axes in the same unit than tvec (usually in meters).\n@param thickness Line thickness of the painted axes.\n\nThis function draws the axes of the world/object coordinate system w.r.t. to the camera frame.\nOX is drawn in red, OY in green and OZ in blue."]
    #[link_name = "\u{1}_ZN2cv13drawFrameAxesERKNS_17_InputOutputArrayERKNS_11_InputArrayES5_S5_S5_fi"]
    pub fn cv_drawFrameAxes(
        image: cv_InputOutputArray,
        cameraMatrix: cv_InputArray,
        distCoeffs: cv_InputArray,
        rvec: cv_InputArray,
        tvec: cv_InputArray,
        length: f32,
        thickness: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_CirclesGridFinderParameters {
    pub densityNeighborhoodSize: cv_Size2f,
    pub minDensity: f32,
    pub kmeansAttempts: ::std::os::raw::c_int,
    pub minDistanceToAddKeypoint: ::std::os::raw::c_int,
    pub keypointScale: ::std::os::raw::c_int,
    pub minGraphConfidence: f32,
    pub vertexGain: f32,
    pub vertexPenalty: f32,
    pub existingVertexGain: f32,
    pub edgeGain: f32,
    pub edgePenalty: f32,
    pub convexHullFactor: f32,
    pub minRNGEdgeSwitchDist: f32,
    pub gridType: cv_CirclesGridFinderParameters_GridType,
    #[doc = "!< Distance between two adjacent points. Used by CALIB_CB_CLUSTERING."]
    pub squareSize: f32,
    #[doc = "!< Max deviation from predicion. Used by CALIB_CB_CLUSTERING."]
    pub maxRectifiedDistance: f32,
}
pub const cv_CirclesGridFinderParameters_GridType_SYMMETRIC_GRID:
    cv_CirclesGridFinderParameters_GridType = 0;
pub const cv_CirclesGridFinderParameters_GridType_ASYMMETRIC_GRID:
    cv_CirclesGridFinderParameters_GridType = 1;
pub type cv_CirclesGridFinderParameters_GridType = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_CirclesGridFinderParameters"]
        [::std::mem::size_of::<cv_CirclesGridFinderParameters>() - 68usize];
    ["Alignment of cv_CirclesGridFinderParameters"]
        [::std::mem::align_of::<cv_CirclesGridFinderParameters>() - 4usize];
    ["Offset of field: cv_CirclesGridFinderParameters::densityNeighborhoodSize"]
        [::std::mem::offset_of!(cv_CirclesGridFinderParameters, densityNeighborhoodSize) - 0usize];
    ["Offset of field: cv_CirclesGridFinderParameters::minDensity"]
        [::std::mem::offset_of!(cv_CirclesGridFinderParameters, minDensity) - 8usize];
    ["Offset of field: cv_CirclesGridFinderParameters::kmeansAttempts"]
        [::std::mem::offset_of!(cv_CirclesGridFinderParameters, kmeansAttempts) - 12usize];
    ["Offset of field: cv_CirclesGridFinderParameters::minDistanceToAddKeypoint"][::std::mem::offset_of!(
        cv_CirclesGridFinderParameters,
        minDistanceToAddKeypoint
    ) - 16usize];
    ["Offset of field: cv_CirclesGridFinderParameters::keypointScale"]
        [::std::mem::offset_of!(cv_CirclesGridFinderParameters, keypointScale) - 20usize];
    ["Offset of field: cv_CirclesGridFinderParameters::minGraphConfidence"]
        [::std::mem::offset_of!(cv_CirclesGridFinderParameters, minGraphConfidence) - 24usize];
    ["Offset of field: cv_CirclesGridFinderParameters::vertexGain"]
        [::std::mem::offset_of!(cv_CirclesGridFinderParameters, vertexGain) - 28usize];
    ["Offset of field: cv_CirclesGridFinderParameters::vertexPenalty"]
        [::std::mem::offset_of!(cv_CirclesGridFinderParameters, vertexPenalty) - 32usize];
    ["Offset of field: cv_CirclesGridFinderParameters::existingVertexGain"]
        [::std::mem::offset_of!(cv_CirclesGridFinderParameters, existingVertexGain) - 36usize];
    ["Offset of field: cv_CirclesGridFinderParameters::edgeGain"]
        [::std::mem::offset_of!(cv_CirclesGridFinderParameters, edgeGain) - 40usize];
    ["Offset of field: cv_CirclesGridFinderParameters::edgePenalty"]
        [::std::mem::offset_of!(cv_CirclesGridFinderParameters, edgePenalty) - 44usize];
    ["Offset of field: cv_CirclesGridFinderParameters::convexHullFactor"]
        [::std::mem::offset_of!(cv_CirclesGridFinderParameters, convexHullFactor) - 48usize];
    ["Offset of field: cv_CirclesGridFinderParameters::minRNGEdgeSwitchDist"]
        [::std::mem::offset_of!(cv_CirclesGridFinderParameters, minRNGEdgeSwitchDist) - 52usize];
    ["Offset of field: cv_CirclesGridFinderParameters::gridType"]
        [::std::mem::offset_of!(cv_CirclesGridFinderParameters, gridType) - 56usize];
    ["Offset of field: cv_CirclesGridFinderParameters::squareSize"]
        [::std::mem::offset_of!(cv_CirclesGridFinderParameters, squareSize) - 60usize];
    ["Offset of field: cv_CirclesGridFinderParameters::maxRectifiedDistance"]
        [::std::mem::offset_of!(cv_CirclesGridFinderParameters, maxRectifiedDistance) - 64usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv27CirclesGridFinderParametersC1Ev"]
    pub fn cv_CirclesGridFinderParameters_CirclesGridFinderParameters(
        this: *mut cv_CirclesGridFinderParameters,
    );
}
impl cv_CirclesGridFinderParameters {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_CirclesGridFinderParameters_CirclesGridFinderParameters(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
pub type cv_CirclesGridFinderParameters2 = cv_CirclesGridFinderParameters;
unsafe extern "C" {
    #[doc = " @brief Finds centers in the grid of circles.\n\n@param image grid view of input circles; it must be an 8-bit grayscale or color image.\n@param patternSize number of circles per row and column\n( patternSize = Size(points_per_row, points_per_colum) ).\n@param centers output array of detected centers.\n@param flags various operation flags that can be one of the following values:\n-   **CALIB_CB_SYMMETRIC_GRID** uses symmetric pattern of circles.\n-   **CALIB_CB_ASYMMETRIC_GRID** uses asymmetric pattern of circles.\n-   **CALIB_CB_CLUSTERING** uses a special algorithm for grid detection. It is more robust to\nperspective distortions but much more sensitive to background clutter.\n@param blobDetector feature detector that finds blobs like dark circles on light background.\n@param parameters struct for finding circles in a grid pattern.\n\nThe function attempts to determine whether the input image contains a grid of circles. If it is, the\nfunction locates centers of the circles. The function returns a non-zero value if all of the centers\nhave been found and they have been placed in a certain order (row by row, left to right in every\nrow). Otherwise, if the function fails to find all the corners or reorder them, it returns 0.\n\nSample usage of detecting and drawing the centers of circles: :\n@code\nSize patternsize(7,7); //number of centers\nMat gray = ....; //source image\nvector<Point2f> centers; //this will be filled by the detected centers\n\nbool patternfound = findCirclesGrid(gray, patternsize, centers);\n\ndrawChessboardCorners(img, patternsize, Mat(centers), patternfound);\n@endcode\n@note The function requires white space (like a square-thick border, the wider the better) around\nthe board to make the detection more robust in various environments."]
    #[link_name = "\u{1}_ZN2cv15findCirclesGridERKNS_11_InputArrayENS_5Size_IiEERKNS_12_OutputArrayEiRKNS_3PtrINS_9Feature2DEEERKNS_27CirclesGridFinderParametersE"]
    pub fn cv_findCirclesGrid(
        image: cv_InputArray,
        patternSize: cv_Size,
        centers: cv_OutputArray,
        flags: ::std::os::raw::c_int,
        blobDetector: *const cv_Ptr,
        parameters: *const cv_CirclesGridFinderParameters,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv15findCirclesGridERKNS_11_InputArrayENS_5Size_IiEERKNS_12_OutputArrayEiRKNS_3PtrINS_9Feature2DEEE"]
    pub fn cv_findCirclesGrid1(
        image: cv_InputArray,
        patternSize: cv_Size,
        centers: cv_OutputArray,
        flags: ::std::os::raw::c_int,
        blobDetector: *const cv_Ptr,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Finds the camera intrinsic and extrinsic parameters from several views of a calibration pattern.\n\n@param objectPoints In the new interface it is a vector of vectors of calibration pattern points in\nthe calibration pattern coordinate space (e.g. std::vector<std::vector<cv::Vec3f>>). The outer\nvector contains as many elements as the number of the pattern views. If the same calibration pattern\nis shown in each view and it is fully visible, all the vectors will be the same. Although, it is\npossible to use partially occluded patterns, or even different patterns in different views. Then,\nthe vectors will be different. The points are 3D, but since they are in a pattern coordinate system,\nthen, if the rig is planar, it may make sense to put the model to a XY coordinate plane so that\nZ-coordinate of each input object point is 0.\nIn the old interface all the vectors of object points from different views are concatenated\ntogether.\n@param imagePoints In the new interface it is a vector of vectors of the projections of calibration\npattern points (e.g. std::vector<std::vector<cv::Vec2f>>). imagePoints.size() and\nobjectPoints.size() and imagePoints[i].size() must be equal to objectPoints[i].size() for each i.\nIn the old interface all the vectors of object points from different views are concatenated\ntogether.\n@param imageSize Size of the image used only to initialize the intrinsic camera matrix.\n@param cameraMatrix Output 3x3 floating-point camera matrix\n\\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ . If CV\\_CALIB\\_USE\\_INTRINSIC\\_GUESS\nand/or CALIB_FIX_ASPECT_RATIO are specified, some or all of fx, fy, cx, cy must be\ninitialized before calling the function.\n@param distCoeffs Output vector of distortion coefficients\n\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of\n4, 5, 8, 12 or 14 elements.\n@param rvecs Output vector of rotation vectors (see Rodrigues ) estimated for each pattern view\n(e.g. std::vector<cv::Mat>>). That is, each k-th rotation vector together with the corresponding\nk-th translation vector (see the next output parameter description) brings the calibration pattern\nfrom the model coordinate space (in which object points are specified) to the world coordinate\nspace, that is, a real position of the calibration pattern in the k-th pattern view (k=0.. *M* -1).\n@param tvecs Output vector of translation vectors estimated for each pattern view.\n@param stdDeviationsIntrinsics Output vector of standard deviations estimated for intrinsic parameters.\nOrder of deviations values:\n\\f$(f_x, f_y, c_x, c_y, k_1, k_2, p_1, p_2, k_3, k_4, k_5, k_6 , s_1, s_2, s_3,\ns_4, \\tau_x, \\tau_y)\\f$ If one of parameters is not estimated, it's deviation is equals to zero.\n@param stdDeviationsExtrinsics Output vector of standard deviations estimated for extrinsic parameters.\nOrder of deviations values: \\f$(R_1, T_1, \\dotsc , R_M, T_M)\\f$ where M is number of pattern views,\n\\f$R_i, T_i\\f$ are concatenated 1x3 vectors.\n@param perViewErrors Output vector of the RMS re-projection error estimated for each pattern view.\n@param flags Different flags that may be zero or a combination of the following values:\n-   **CALIB_USE_INTRINSIC_GUESS** cameraMatrix contains valid initial values of\nfx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image\ncenter ( imageSize is used), and focal distances are computed in a least-squares fashion.\nNote, that if intrinsic parameters are known, there is no need to use this function just to\nestimate extrinsic parameters. Use solvePnP instead.\n-   **CALIB_FIX_PRINCIPAL_POINT** The principal point is not changed during the global\noptimization. It stays at the center or at a different location specified when\nCALIB_USE_INTRINSIC_GUESS is set too.\n-   **CALIB_FIX_ASPECT_RATIO** The functions considers only fy as a free parameter. The\nratio fx/fy stays the same as in the input cameraMatrix . When\nCALIB_USE_INTRINSIC_GUESS is not set, the actual input values of fx and fy are\nignored, only their ratio is computed and used further.\n-   **CALIB_ZERO_TANGENT_DIST** Tangential distortion coefficients \\f$(p_1, p_2)\\f$ are set\nto zeros and stay zero.\n-   **CALIB_FIX_K1,...,CALIB_FIX_K6** The corresponding radial distortion\ncoefficient is not changed during the optimization. If CALIB_USE_INTRINSIC_GUESS is\nset, the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0.\n-   **CALIB_RATIONAL_MODEL** Coefficients k4, k5, and k6 are enabled. To provide the\nbackward compatibility, this extra flag should be explicitly specified to make the\ncalibration function use the rational model and return 8 coefficients. If the flag is not\nset, the function computes and returns only 5 distortion coefficients.\n-   **CALIB_THIN_PRISM_MODEL** Coefficients s1, s2, s3 and s4 are enabled. To provide the\nbackward compatibility, this extra flag should be explicitly specified to make the\ncalibration function use the thin prism model and return 12 coefficients. If the flag is not\nset, the function computes and returns only 5 distortion coefficients.\n-   **CALIB_FIX_S1_S2_S3_S4** The thin prism distortion coefficients are not changed during\nthe optimization. If CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the\nsupplied distCoeffs matrix is used. Otherwise, it is set to 0.\n-   **CALIB_TILTED_MODEL** Coefficients tauX and tauY are enabled. To provide the\nbackward compatibility, this extra flag should be explicitly specified to make the\ncalibration function use the tilted sensor model and return 14 coefficients. If the flag is not\nset, the function computes and returns only 5 distortion coefficients.\n-   **CALIB_FIX_TAUX_TAUY** The coefficients of the tilted sensor model are not changed during\nthe optimization. If CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the\nsupplied distCoeffs matrix is used. Otherwise, it is set to 0.\n@param criteria Termination criteria for the iterative optimization algorithm.\n\n@return the overall RMS re-projection error.\n\nThe function estimates the intrinsic camera parameters and extrinsic parameters for each of the\nviews. The algorithm is based on @cite Zhang2000 and @cite BouguetMCT . The coordinates of 3D object\npoints and their corresponding 2D projections in each view must be specified. That may be achieved\nby using an object with a known geometry and easily detectable feature points. Such an object is\ncalled a calibration rig or calibration pattern, and OpenCV has built-in support for a chessboard as\na calibration rig (see findChessboardCorners ). Currently, initialization of intrinsic parameters\n(when CALIB_USE_INTRINSIC_GUESS is not set) is only implemented for planar calibration\npatterns (where Z-coordinates of the object points must be all zeros). 3D calibration rigs can also\nbe used as long as initial cameraMatrix is provided.\n\nThe algorithm performs the following steps:\n\n-   Compute the initial intrinsic parameters (the option only available for planar calibration\npatterns) or read them from the input parameters. The distortion coefficients are all set to\nzeros initially unless some of CALIB_FIX_K? are specified.\n\n-   Estimate the initial camera pose as if the intrinsic parameters have been already known. This is\ndone using solvePnP .\n\n-   Run the global Levenberg-Marquardt optimization algorithm to minimize the reprojection error,\nthat is, the total sum of squared distances between the observed feature points imagePoints and\nthe projected (using the current estimates for camera parameters and the poses) object points\nobjectPoints. See projectPoints for details.\n\n@note\nIf you use a non-square (=non-NxN) grid and findChessboardCorners for calibration, and\ncalibrateCamera returns bad values (zero distortion coefficients, an image center very far from\n(w/2-0.5,h/2-0.5), and/or large differences between \\f$f_x\\f$ and \\f$f_y\\f$ (ratios of 10:1 or more)),\nthen you have probably used patternSize=cvSize(rows,cols) instead of using\npatternSize=cvSize(cols,rows) in findChessboardCorners .\n\n@sa\ncalibrateCameraRO, findChessboardCorners, solvePnP, initCameraMatrix2D, stereoCalibrate, undistort"]
    #[link_name = "\u{1}_ZN2cv15calibrateCameraERKNS_11_InputArrayES2_NS_5Size_IiEERKNS_17_InputOutputArrayES7_RKNS_12_OutputArrayESA_SA_SA_SA_iNS_12TermCriteriaE"]
    pub fn cv_calibrateCamera(
        objectPoints: cv_InputArrayOfArrays,
        imagePoints: cv_InputArrayOfArrays,
        imageSize: cv_Size,
        cameraMatrix: cv_InputOutputArray,
        distCoeffs: cv_InputOutputArray,
        rvecs: cv_OutputArrayOfArrays,
        tvecs: cv_OutputArrayOfArrays,
        stdDeviationsIntrinsics: cv_OutputArray,
        stdDeviationsExtrinsics: cv_OutputArray,
        perViewErrors: cv_OutputArray,
        flags: ::std::os::raw::c_int,
        criteria: cv_TermCriteria,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv15calibrateCameraERKNS_11_InputArrayES2_NS_5Size_IiEERKNS_17_InputOutputArrayES7_RKNS_12_OutputArrayESA_iNS_12TermCriteriaE"]
    pub fn cv_calibrateCamera1(
        objectPoints: cv_InputArrayOfArrays,
        imagePoints: cv_InputArrayOfArrays,
        imageSize: cv_Size,
        cameraMatrix: cv_InputOutputArray,
        distCoeffs: cv_InputOutputArray,
        rvecs: cv_OutputArrayOfArrays,
        tvecs: cv_OutputArrayOfArrays,
        flags: ::std::os::raw::c_int,
        criteria: cv_TermCriteria,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Finds the camera intrinsic and extrinsic parameters from several views of a calibration pattern.\n\nThis function is an extension of calibrateCamera() with the method of releasing object which was\nproposed in @cite strobl2011iccv. In many common cases with inaccurate, unmeasured, roughly planar\ntargets (calibration plates), this method can dramatically improve the precision of the estimated\ncamera parameters. Both the object-releasing method and standard method are supported by this\nfunction. Use the parameter **iFixedPoint** for method selection. In the internal implementation,\ncalibrateCamera() is a wrapper for this function.\n\n@param objectPoints Vector of vectors of calibration pattern points in the calibration pattern\ncoordinate space. See calibrateCamera() for details. If the method of releasing object to be used,\nthe identical calibration board must be used in each view and it must be fully visible, and all\nobjectPoints[i] must be the same and all points should be roughly close to a plane. **The calibration\ntarget has to be rigid, or at least static if the camera (rather than the calibration target) is\nshifted for grabbing images.**\n@param imagePoints Vector of vectors of the projections of calibration pattern points. See\ncalibrateCamera() for details.\n@param imageSize Size of the image used only to initialize the intrinsic camera matrix.\n@param iFixedPoint The index of the 3D object point in objectPoints[0] to be fixed. It also acts as\na switch for calibration method selection. If object-releasing method to be used, pass in the\nparameter in the range of [1, objectPoints[0].size()-2], otherwise a value out of this range will\nmake standard calibration method selected. Usually the top-right corner point of the calibration\nboard grid is recommended to be fixed when object-releasing method being utilized. According to\n\\cite strobl2011iccv, two other points are also fixed. In this implementation, objectPoints[0].front\nand objectPoints[0].back.z are used. With object-releasing method, accurate rvecs, tvecs and\nnewObjPoints are only possible if coordinates of these three fixed points are accurate enough.\n@param cameraMatrix Output 3x3 floating-point camera matrix. See calibrateCamera() for details.\n@param distCoeffs Output vector of distortion coefficients. See calibrateCamera() for details.\n@param rvecs Output vector of rotation vectors estimated for each pattern view. See calibrateCamera()\nfor details.\n@param tvecs Output vector of translation vectors estimated for each pattern view.\n@param newObjPoints The updated output vector of calibration pattern points. The coordinates might\nbe scaled based on three fixed points. The returned coordinates are accurate only if the above\nmentioned three fixed points are accurate. If not needed, noArray() can be passed in. This parameter\nis ignored with standard calibration method.\n@param stdDeviationsIntrinsics Output vector of standard deviations estimated for intrinsic parameters.\nSee calibrateCamera() for details.\n@param stdDeviationsExtrinsics Output vector of standard deviations estimated for extrinsic parameters.\nSee calibrateCamera() for details.\n@param stdDeviationsObjPoints Output vector of standard deviations estimated for refined coordinates\nof calibration pattern points. It has the same size and order as objectPoints[0] vector. This\nparameter is ignored with standard calibration method.\n@param perViewErrors Output vector of the RMS re-projection error estimated for each pattern view.\n@param flags Different flags that may be zero or a combination of some predefined values. See\ncalibrateCamera() for details. If the method of releasing object is used, the calibration time may\nbe much longer. CALIB_USE_QR or CALIB_USE_LU could be used for faster calibration with potentially\nless precise and less stable in some rare cases.\n@param criteria Termination criteria for the iterative optimization algorithm.\n\n@return the overall RMS re-projection error.\n\nThe function estimates the intrinsic camera parameters and extrinsic parameters for each of the\nviews. The algorithm is based on @cite Zhang2000, @cite BouguetMCT and @cite strobl2011iccv. See\ncalibrateCamera() for other detailed explanations.\n@sa\ncalibrateCamera, findChessboardCorners, solvePnP, initCameraMatrix2D, stereoCalibrate, undistort"]
    #[link_name = "\u{1}_ZN2cv17calibrateCameraROERKNS_11_InputArrayES2_NS_5Size_IiEEiRKNS_17_InputOutputArrayES7_RKNS_12_OutputArrayESA_SA_SA_SA_SA_SA_iNS_12TermCriteriaE"]
    pub fn cv_calibrateCameraRO(
        objectPoints: cv_InputArrayOfArrays,
        imagePoints: cv_InputArrayOfArrays,
        imageSize: cv_Size,
        iFixedPoint: ::std::os::raw::c_int,
        cameraMatrix: cv_InputOutputArray,
        distCoeffs: cv_InputOutputArray,
        rvecs: cv_OutputArrayOfArrays,
        tvecs: cv_OutputArrayOfArrays,
        newObjPoints: cv_OutputArray,
        stdDeviationsIntrinsics: cv_OutputArray,
        stdDeviationsExtrinsics: cv_OutputArray,
        stdDeviationsObjPoints: cv_OutputArray,
        perViewErrors: cv_OutputArray,
        flags: ::std::os::raw::c_int,
        criteria: cv_TermCriteria,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv17calibrateCameraROERKNS_11_InputArrayES2_NS_5Size_IiEEiRKNS_17_InputOutputArrayES7_RKNS_12_OutputArrayESA_SA_iNS_12TermCriteriaE"]
    pub fn cv_calibrateCameraRO1(
        objectPoints: cv_InputArrayOfArrays,
        imagePoints: cv_InputArrayOfArrays,
        imageSize: cv_Size,
        iFixedPoint: ::std::os::raw::c_int,
        cameraMatrix: cv_InputOutputArray,
        distCoeffs: cv_InputOutputArray,
        rvecs: cv_OutputArrayOfArrays,
        tvecs: cv_OutputArrayOfArrays,
        newObjPoints: cv_OutputArray,
        flags: ::std::os::raw::c_int,
        criteria: cv_TermCriteria,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Computes useful camera characteristics from the camera matrix.\n\n@param cameraMatrix Input camera matrix that can be estimated by calibrateCamera or\nstereoCalibrate .\n@param imageSize Input image size in pixels.\n@param apertureWidth Physical width in mm of the sensor.\n@param apertureHeight Physical height in mm of the sensor.\n@param fovx Output field of view in degrees along the horizontal sensor axis.\n@param fovy Output field of view in degrees along the vertical sensor axis.\n@param focalLength Focal length of the lens in mm.\n@param principalPoint Principal point in mm.\n@param aspectRatio \\f$f_y/f_x\\f$\n\nThe function computes various useful camera characteristics from the previously estimated camera\nmatrix.\n\n@note\nDo keep in mind that the unity measure 'mm' stands for whatever unit of measure one chooses for\nthe chessboard pitch (it can thus be any value)."]
    #[link_name = "\u{1}_ZN2cv23calibrationMatrixValuesERKNS_11_InputArrayENS_5Size_IiEEddRdS5_S5_RNS_6Point_IdEES5_"]
    pub fn cv_calibrationMatrixValues(
        cameraMatrix: cv_InputArray,
        imageSize: cv_Size,
        apertureWidth: f64,
        apertureHeight: f64,
        fovx: *mut f64,
        fovy: *mut f64,
        focalLength: *mut f64,
        principalPoint: *mut cv_Point2d,
        aspectRatio: *mut f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calibrates the stereo camera.\n\n@param objectPoints Vector of vectors of the calibration pattern points.\n@param imagePoints1 Vector of vectors of the projections of the calibration pattern points,\nobserved by the first camera.\n@param imagePoints2 Vector of vectors of the projections of the calibration pattern points,\nobserved by the second camera.\n@param cameraMatrix1 Input/output first camera matrix:\n\\f$\\vecthreethree{f_x^{(j)}}{0}{c_x^{(j)}}{0}{f_y^{(j)}}{c_y^{(j)}}{0}{0}{1}\\f$ , \\f$j = 0,\\, 1\\f$ . If\nany of CALIB_USE_INTRINSIC_GUESS , CALIB_FIX_ASPECT_RATIO ,\nCALIB_FIX_INTRINSIC , or CALIB_FIX_FOCAL_LENGTH are specified, some or all of the\nmatrix components must be initialized. See the flags description for details.\n@param distCoeffs1 Input/output vector of distortion coefficients\n\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of\n4, 5, 8, 12 or 14 elements. The output vector length depends on the flags.\n@param cameraMatrix2 Input/output second camera matrix. The parameter is similar to cameraMatrix1\n@param distCoeffs2 Input/output lens distortion coefficients for the second camera. The parameter\nis similar to distCoeffs1 .\n@param imageSize Size of the image used only to initialize intrinsic camera matrix.\n@param R Output rotation matrix between the 1st and the 2nd camera coordinate systems.\n@param T Output translation vector between the coordinate systems of the cameras.\n@param E Output essential matrix.\n@param F Output fundamental matrix.\n@param perViewErrors Output vector of the RMS re-projection error estimated for each pattern view.\n@param flags Different flags that may be zero or a combination of the following values:\n-   **CALIB_FIX_INTRINSIC** Fix cameraMatrix? and distCoeffs? so that only R, T, E , and F\nmatrices are estimated.\n-   **CALIB_USE_INTRINSIC_GUESS** Optimize some or all of the intrinsic parameters\naccording to the specified flags. Initial values are provided by the user.\n-   **CALIB_USE_EXTRINSIC_GUESS** R, T contain valid initial values that are optimized further.\nOtherwise R, T are initialized to the median value of the pattern views (each dimension separately).\n-   **CALIB_FIX_PRINCIPAL_POINT** Fix the principal points during the optimization.\n-   **CALIB_FIX_FOCAL_LENGTH** Fix \\f$f^{(j)}_x\\f$ and \\f$f^{(j)}_y\\f$ .\n-   **CALIB_FIX_ASPECT_RATIO** Optimize \\f$f^{(j)}_y\\f$ . Fix the ratio \\f$f^{(j)}_x/f^{(j)}_y\\f$\n.\n-   **CALIB_SAME_FOCAL_LENGTH** Enforce \\f$f^{(0)}_x=f^{(1)}_x\\f$ and \\f$f^{(0)}_y=f^{(1)}_y\\f$ .\n-   **CALIB_ZERO_TANGENT_DIST** Set tangential distortion coefficients for each camera to\nzeros and fix there.\n-   **CALIB_FIX_K1,...,CALIB_FIX_K6** Do not change the corresponding radial\ndistortion coefficient during the optimization. If CALIB_USE_INTRINSIC_GUESS is set,\nthe coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0.\n-   **CALIB_RATIONAL_MODEL** Enable coefficients k4, k5, and k6. To provide the backward\ncompatibility, this extra flag should be explicitly specified to make the calibration\nfunction use the rational model and return 8 coefficients. If the flag is not set, the\nfunction computes and returns only 5 distortion coefficients.\n-   **CALIB_THIN_PRISM_MODEL** Coefficients s1, s2, s3 and s4 are enabled. To provide the\nbackward compatibility, this extra flag should be explicitly specified to make the\ncalibration function use the thin prism model and return 12 coefficients. If the flag is not\nset, the function computes and returns only 5 distortion coefficients.\n-   **CALIB_FIX_S1_S2_S3_S4** The thin prism distortion coefficients are not changed during\nthe optimization. If CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the\nsupplied distCoeffs matrix is used. Otherwise, it is set to 0.\n-   **CALIB_TILTED_MODEL** Coefficients tauX and tauY are enabled. To provide the\nbackward compatibility, this extra flag should be explicitly specified to make the\ncalibration function use the tilted sensor model and return 14 coefficients. If the flag is not\nset, the function computes and returns only 5 distortion coefficients.\n-   **CALIB_FIX_TAUX_TAUY** The coefficients of the tilted sensor model are not changed during\nthe optimization. If CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the\nsupplied distCoeffs matrix is used. Otherwise, it is set to 0.\n@param criteria Termination criteria for the iterative optimization algorithm.\n\nThe function estimates transformation between two cameras making a stereo pair. If you have a stereo\ncamera where the relative position and orientation of two cameras is fixed, and if you computed\nposes of an object relative to the first camera and to the second camera, (R1, T1) and (R2, T2),\nrespectively (this can be done with solvePnP ), then those poses definitely relate to each other.\nThis means that, given ( \\f$R_1\\f$,\\f$T_1\\f$ ), it should be possible to compute ( \\f$R_2\\f$,\\f$T_2\\f$ ). You only\nneed to know the position and orientation of the second camera relative to the first camera. This is\nwhat the described function does. It computes ( \\f$R\\f$,\\f$T\\f$ ) so that:\n\n\\f[R_2=R*R_1\\f]\n\\f[T_2=R*T_1 + T,\\f]\n\nOptionally, it computes the essential matrix E:\n\n\\f[E= \\vecthreethree{0}{-T_2}{T_1}{T_2}{0}{-T_0}{-T_1}{T_0}{0} *R\\f]\n\nwhere \\f$T_i\\f$ are components of the translation vector \\f$T\\f$ : \\f$T=[T_0, T_1, T_2]^T\\f$ . And the function\ncan also compute the fundamental matrix F:\n\n\\f[F = cameraMatrix2^{-T} E cameraMatrix1^{-1}\\f]\n\nBesides the stereo-related information, the function can also perform a full calibration of each of\ntwo cameras. However, due to the high dimensionality of the parameter space and noise in the input\ndata, the function can diverge from the correct solution. If the intrinsic parameters can be\nestimated with high accuracy for each of the cameras individually (for example, using\ncalibrateCamera ), you are recommended to do so and then pass CALIB_FIX_INTRINSIC flag to the\nfunction along with the computed intrinsic parameters. Otherwise, if all the parameters are\nestimated at once, it makes sense to restrict some parameters, for example, pass\nCALIB_SAME_FOCAL_LENGTH and CALIB_ZERO_TANGENT_DIST flags, which is usually a\nreasonable assumption.\n\nSimilarly to calibrateCamera , the function minimizes the total re-projection error for all the\npoints in all the available views from both cameras. The function returns the final value of the\nre-projection error."]
    #[link_name = "\u{1}_ZN2cv15stereoCalibrateERKNS_11_InputArrayES2_S2_RKNS_17_InputOutputArrayES5_S5_S5_NS_5Size_IiEES5_S5_RKNS_12_OutputArrayESA_SA_iNS_12TermCriteriaE"]
    pub fn cv_stereoCalibrate(
        objectPoints: cv_InputArrayOfArrays,
        imagePoints1: cv_InputArrayOfArrays,
        imagePoints2: cv_InputArrayOfArrays,
        cameraMatrix1: cv_InputOutputArray,
        distCoeffs1: cv_InputOutputArray,
        cameraMatrix2: cv_InputOutputArray,
        distCoeffs2: cv_InputOutputArray,
        imageSize: cv_Size,
        R: cv_InputOutputArray,
        T: cv_InputOutputArray,
        E: cv_OutputArray,
        F: cv_OutputArray,
        perViewErrors: cv_OutputArray,
        flags: ::std::os::raw::c_int,
        criteria: cv_TermCriteria,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv15stereoCalibrateERKNS_11_InputArrayES2_S2_RKNS_17_InputOutputArrayES5_S5_S5_NS_5Size_IiEERKNS_12_OutputArrayESA_SA_SA_iNS_12TermCriteriaE"]
    pub fn cv_stereoCalibrate1(
        objectPoints: cv_InputArrayOfArrays,
        imagePoints1: cv_InputArrayOfArrays,
        imagePoints2: cv_InputArrayOfArrays,
        cameraMatrix1: cv_InputOutputArray,
        distCoeffs1: cv_InputOutputArray,
        cameraMatrix2: cv_InputOutputArray,
        distCoeffs2: cv_InputOutputArray,
        imageSize: cv_Size,
        R: cv_OutputArray,
        T: cv_OutputArray,
        E: cv_OutputArray,
        F: cv_OutputArray,
        flags: ::std::os::raw::c_int,
        criteria: cv_TermCriteria,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Computes rectification transforms for each head of a calibrated stereo camera.\n\n@param cameraMatrix1 First camera matrix.\n@param distCoeffs1 First camera distortion parameters.\n@param cameraMatrix2 Second camera matrix.\n@param distCoeffs2 Second camera distortion parameters.\n@param imageSize Size of the image used for stereo calibration.\n@param R Rotation matrix from the coordinate system of the first camera to the second.\n@param T Translation vector from the coordinate system of the first camera to the second.\n@param R1 Output 3x3 rectification transform (rotation matrix) for the first camera.\n@param R2 Output 3x3 rectification transform (rotation matrix) for the second camera.\n@param P1 Output 3x4 projection matrix in the new (rectified) coordinate systems for the first\ncamera.\n@param P2 Output 3x4 projection matrix in the new (rectified) coordinate systems for the second\ncamera.\n@param Q Output \\f$4 \\times 4\\f$ disparity-to-depth mapping matrix (see reprojectImageTo3D ).\n@param flags Operation flags that may be zero or CALIB_ZERO_DISPARITY . If the flag is set,\nthe function makes the principal points of each camera have the same pixel coordinates in the\nrectified views. And if the flag is not set, the function may still shift the images in the\nhorizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the\nuseful image area.\n@param alpha Free scaling parameter. If it is -1 or absent, the function performs the default\nscaling. Otherwise, the parameter should be between 0 and 1. alpha=0 means that the rectified\nimages are zoomed and shifted so that only valid pixels are visible (no black areas after\nrectification). alpha=1 means that the rectified image is decimated and shifted so that all the\npixels from the original images from the cameras are retained in the rectified images (no source\nimage pixels are lost). Obviously, any intermediate value yields an intermediate result between\nthose two extreme cases.\n@param newImageSize New image resolution after rectification. The same size should be passed to\ninitUndistortRectifyMap (see the stereo_calib.cpp sample in OpenCV samples directory). When (0,0)\nis passed (default), it is set to the original imageSize . Setting it to larger value can help you\npreserve details in the original image, especially when there is a big radial distortion.\n@param validPixROI1 Optional output rectangles inside the rectified images where all the pixels\nare valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller\n(see the picture below).\n@param validPixROI2 Optional output rectangles inside the rectified images where all the pixels\nare valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller\n(see the picture below).\n\nThe function computes the rotation matrices for each camera that (virtually) make both camera image\nplanes the same plane. Consequently, this makes all the epipolar lines parallel and thus simplifies\nthe dense stereo correspondence problem. The function takes the matrices computed by stereoCalibrate\nas input. As output, it provides two rotation matrices and also two projection matrices in the new\ncoordinates. The function distinguishes the following two cases:\n\n-   **Horizontal stereo**: the first and the second camera views are shifted relative to each other\nmainly along the x axis (with possible small vertical shift). In the rectified images, the\ncorresponding epipolar lines in the left and right cameras are horizontal and have the same\ny-coordinate. P1 and P2 look like:\n\n\\f[\\texttt{P1} = \\begin{bmatrix} f & 0 & cx_1 & 0 \\\\ 0 & f & cy & 0 \\\\ 0 & 0 & 1 & 0 \\end{bmatrix}\\f]\n\n\\f[\\texttt{P2} = \\begin{bmatrix} f & 0 & cx_2 & T_x*f \\\\ 0 & f & cy & 0 \\\\ 0 & 0 & 1 & 0 \\end{bmatrix} ,\\f]\n\nwhere \\f$T_x\\f$ is a horizontal shift between the cameras and \\f$cx_1=cx_2\\f$ if\nCALIB_ZERO_DISPARITY is set.\n\n-   **Vertical stereo**: the first and the second camera views are shifted relative to each other\nmainly in vertical direction (and probably a bit in the horizontal direction too). The epipolar\nlines in the rectified images are vertical and have the same x-coordinate. P1 and P2 look like:\n\n\\f[\\texttt{P1} = \\begin{bmatrix} f & 0 & cx & 0 \\\\ 0 & f & cy_1 & 0 \\\\ 0 & 0 & 1 & 0 \\end{bmatrix}\\f]\n\n\\f[\\texttt{P2} = \\begin{bmatrix} f & 0 & cx & 0 \\\\ 0 & f & cy_2 & T_y*f \\\\ 0 & 0 & 1 & 0 \\end{bmatrix} ,\\f]\n\nwhere \\f$T_y\\f$ is a vertical shift between the cameras and \\f$cy_1=cy_2\\f$ if CALIB_ZERO_DISPARITY is\nset.\n\nAs you can see, the first three columns of P1 and P2 will effectively be the new \"rectified\" camera\nmatrices. The matrices, together with R1 and R2 , can then be passed to initUndistortRectifyMap to\ninitialize the rectification map for each camera.\n\nSee below the screenshot from the stereo_calib.cpp sample. Some red horizontal lines pass through\nthe corresponding image regions. This means that the images are well rectified, which is what most\nstereo correspondence algorithms rely on. The green rectangles are roi1 and roi2 . You see that\ntheir interiors are all valid pixels.\n\n[image](pics/stereo_undistort.jpg)"]
    #[link_name = "\u{1}_ZN2cv13stereoRectifyERKNS_11_InputArrayES2_S2_S2_NS_5Size_IiEES2_S2_RKNS_12_OutputArrayES7_S7_S7_S7_idS4_PNS_5Rect_IiEESA_"]
    pub fn cv_stereoRectify(
        cameraMatrix1: cv_InputArray,
        distCoeffs1: cv_InputArray,
        cameraMatrix2: cv_InputArray,
        distCoeffs2: cv_InputArray,
        imageSize: cv_Size,
        R: cv_InputArray,
        T: cv_InputArray,
        R1: cv_OutputArray,
        R2: cv_OutputArray,
        P1: cv_OutputArray,
        P2: cv_OutputArray,
        Q: cv_OutputArray,
        flags: ::std::os::raw::c_int,
        alpha: f64,
        newImageSize: cv_Size,
        validPixROI1: *mut cv_Rect,
        validPixROI2: *mut cv_Rect,
    );
}
unsafe extern "C" {
    #[doc = " @brief Computes a rectification transform for an uncalibrated stereo camera.\n\n@param points1 Array of feature points in the first image.\n@param points2 The corresponding points in the second image. The same formats as in\nfindFundamentalMat are supported.\n@param F Input fundamental matrix. It can be computed from the same set of point pairs using\nfindFundamentalMat .\n@param imgSize Size of the image.\n@param H1 Output rectification homography matrix for the first image.\n@param H2 Output rectification homography matrix for the second image.\n@param threshold Optional threshold used to filter out the outliers. If the parameter is greater\nthan zero, all the point pairs that do not comply with the epipolar geometry (that is, the points\nfor which \\f$|\\texttt{points2[i]}^T*\\texttt{F}*\\texttt{points1[i]}|>\\texttt{threshold}\\f$ ) are\nrejected prior to computing the homographies. Otherwise, all the points are considered inliers.\n\nThe function computes the rectification transformations without knowing intrinsic parameters of the\ncameras and their relative position in the space, which explains the suffix \"uncalibrated\". Another\nrelated difference from stereoRectify is that the function outputs not the rectification\ntransformations in the object (3D) space, but the planar perspective transformations encoded by the\nhomography matrices H1 and H2 . The function implements the algorithm @cite Hartley99 .\n\n@note\nWhile the algorithm does not need to know the intrinsic parameters of the cameras, it heavily\ndepends on the epipolar geometry. Therefore, if the camera lenses have a significant distortion,\nit would be better to correct it before computing the fundamental matrix and calling this\nfunction. For example, distortion coefficients can be estimated for each head of stereo camera\nseparately by using calibrateCamera . Then, the images can be corrected using undistort , or\njust the point coordinates can be corrected with undistortPoints ."]
    #[link_name = "\u{1}_ZN2cv25stereoRectifyUncalibratedERKNS_11_InputArrayES2_S2_NS_5Size_IiEERKNS_12_OutputArrayES7_d"]
    pub fn cv_stereoRectifyUncalibrated(
        points1: cv_InputArray,
        points2: cv_InputArray,
        F: cv_InputArray,
        imgSize: cv_Size,
        H1: cv_OutputArray,
        H2: cv_OutputArray,
        threshold: f64,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! computes the rectification transformations for 3-head camera, where all the heads are on the same line."]
    #[link_name = "\u{1}_ZN2cv17rectify3CollinearERKNS_11_InputArrayES2_S2_S2_S2_S2_S2_S2_NS_5Size_IiEES2_S2_S2_S2_RKNS_12_OutputArrayES7_S7_S7_S7_S7_S7_dS4_PNS_5Rect_IiEESA_i"]
    pub fn cv_rectify3Collinear(
        cameraMatrix1: cv_InputArray,
        distCoeffs1: cv_InputArray,
        cameraMatrix2: cv_InputArray,
        distCoeffs2: cv_InputArray,
        cameraMatrix3: cv_InputArray,
        distCoeffs3: cv_InputArray,
        imgpt1: cv_InputArrayOfArrays,
        imgpt3: cv_InputArrayOfArrays,
        imageSize: cv_Size,
        R12: cv_InputArray,
        T12: cv_InputArray,
        R13: cv_InputArray,
        T13: cv_InputArray,
        R1: cv_OutputArray,
        R2: cv_OutputArray,
        R3: cv_OutputArray,
        P1: cv_OutputArray,
        P2: cv_OutputArray,
        P3: cv_OutputArray,
        Q: cv_OutputArray,
        alpha: f64,
        newImgSize: cv_Size,
        roi1: *mut cv_Rect,
        roi2: *mut cv_Rect,
        flags: ::std::os::raw::c_int,
    ) -> f32;
}
unsafe extern "C" {
    #[doc = " @brief Returns the new camera matrix based on the free scaling parameter.\n\n@param cameraMatrix Input camera matrix.\n@param distCoeffs Input vector of distortion coefficients\n\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$ of\n4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are\nassumed.\n@param imageSize Original image size.\n@param alpha Free scaling parameter between 0 (when all the pixels in the undistorted image are\nvalid) and 1 (when all the source image pixels are retained in the undistorted image). See\nstereoRectify for details.\n@param newImgSize Image size after rectification. By default, it is set to imageSize .\n@param validPixROI Optional output rectangle that outlines all-good-pixels region in the\nundistorted image. See roi1, roi2 description in stereoRectify .\n@param centerPrincipalPoint Optional flag that indicates whether in the new camera matrix the\nprincipal point should be at the image center or not. By default, the principal point is chosen to\nbest fit a subset of the source image (determined by alpha) to the corrected image.\n@return new_camera_matrix Output new camera matrix.\n\nThe function computes and returns the optimal new camera matrix based on the free scaling parameter.\nBy varying this parameter, you may retrieve only sensible pixels alpha=0 , keep all the original\nimage pixels if there is valuable information in the corners alpha=1 , or get something in between.\nWhen alpha\\>0 , the undistorted result is likely to have some black pixels corresponding to\n\"virtual\" pixels outside of the captured distorted image. The original camera matrix, distortion\ncoefficients, the computed new camera matrix, and newImageSize should be passed to\ninitUndistortRectifyMap to produce the maps for remap ."]
    #[link_name = "\u{1}_ZN2cv25getOptimalNewCameraMatrixERKNS_11_InputArrayES2_NS_5Size_IiEEdS4_PNS_5Rect_IiEEb"]
    pub fn cv_getOptimalNewCameraMatrix(
        cameraMatrix: cv_InputArray,
        distCoeffs: cv_InputArray,
        imageSize: cv_Size,
        alpha: f64,
        newImgSize: cv_Size,
        validPixROI: *mut cv_Rect,
        centerPrincipalPoint: bool,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Computes Hand-Eye calibration: \\f$_{}^{g}\\textrm{T}_c\\f$\n\n@param[in] R_gripper2base Rotation part extracted from the homogeneous matrix that transforms a point\nexpressed in the gripper frame to the robot base frame (\\f$_{}^{b}\\textrm{T}_g\\f$).\nThis is a vector (`vector<Mat>`) that contains the rotation matrices for all the transformations\nfrom gripper frame to robot base frame.\n@param[in] t_gripper2base Translation part extracted from the homogeneous matrix that transforms a point\nexpressed in the gripper frame to the robot base frame (\\f$_{}^{b}\\textrm{T}_g\\f$).\nThis is a vector (`vector<Mat>`) that contains the translation vectors for all the transformations\nfrom gripper frame to robot base frame.\n@param[in] R_target2cam Rotation part extracted from the homogeneous matrix that transforms a point\nexpressed in the target frame to the camera frame (\\f$_{}^{c}\\textrm{T}_t\\f$).\nThis is a vector (`vector<Mat>`) that contains the rotation matrices for all the transformations\nfrom calibration target frame to camera frame.\n@param[in] t_target2cam Rotation part extracted from the homogeneous matrix that transforms a point\nexpressed in the target frame to the camera frame (\\f$_{}^{c}\\textrm{T}_t\\f$).\nThis is a vector (`vector<Mat>`) that contains the translation vectors for all the transformations\nfrom calibration target frame to camera frame.\n@param[out] R_cam2gripper Estimated rotation part extracted from the homogeneous matrix that transforms a point\nexpressed in the camera frame to the gripper frame (\\f$_{}^{g}\\textrm{T}_c\\f$).\n@param[out] t_cam2gripper Estimated translation part extracted from the homogeneous matrix that transforms a point\nexpressed in the camera frame to the gripper frame (\\f$_{}^{g}\\textrm{T}_c\\f$).\n@param[in] method One of the implemented Hand-Eye calibration method, see cv::HandEyeCalibrationMethod\n\nThe function performs the Hand-Eye calibration using various methods. One approach consists in estimating the\nrotation then the translation (separable solutions) and the following methods are implemented:\n- R. Tsai, R. Lenz A New Technique for Fully Autonomous and Efficient 3D Robotics Hand/EyeCalibration \\cite Tsai89\n- F. Park, B. Martin Robot Sensor Calibration: Solving AX = XB on the Euclidean Group \\cite Park94\n- R. Horaud, F. Dornaika Hand-Eye Calibration \\cite Horaud95\n\nAnother approach consists in estimating simultaneously the rotation and the translation (simultaneous solutions),\nwith the following implemented method:\n- N. Andreff, R. Horaud, B. Espiau On-line Hand-Eye Calibration \\cite Andreff99\n- K. Daniilidis Hand-Eye Calibration Using Dual Quaternions \\cite Daniilidis98\n\nThe following picture describes the Hand-Eye calibration problem where the transformation between a camera (\"eye\")\nmounted on a robot gripper (\"hand\") has to be estimated.\n\n[](pics/hand-eye_figure.png)\n\nThe calibration procedure is the following:\n- a static calibration pattern is used to estimate the transformation between the target frame\nand the camera frame\n- the robot gripper is moved in order to acquire several poses\n- for each pose, the homogeneous transformation between the gripper frame and the robot base frame is recorded using for\ninstance the robot kinematics\n\\f[\n\\begin{bmatrix}\nX_b\\\\\nY_b\\\\\nZ_b\\\\\n1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n_{}^{b}\\textrm{R}_g & _{}^{b}\\textrm{t}_g \\\\\n0_{1 \\times 3} & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nX_g\\\\\nY_g\\\\\nZ_g\\\\\n1\n\\end{bmatrix}\n\\f]\n- for each pose, the homogeneous transformation between the calibration target frame and the camera frame is recorded using\nfor instance a pose estimation method (PnP) from 2D-3D point correspondences\n\\f[\n\\begin{bmatrix}\nX_c\\\\\nY_c\\\\\nZ_c\\\\\n1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n_{}^{c}\\textrm{R}_t & _{}^{c}\\textrm{t}_t \\\\\n0_{1 \\times 3} & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nX_t\\\\\nY_t\\\\\nZ_t\\\\\n1\n\\end{bmatrix}\n\\f]\n\nThe Hand-Eye calibration procedure returns the following homogeneous transformation\n\\f[\n\\begin{bmatrix}\nX_g\\\\\nY_g\\\\\nZ_g\\\\\n1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n_{}^{g}\\textrm{R}_c & _{}^{g}\\textrm{t}_c \\\\\n0_{1 \\times 3} & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nX_c\\\\\nY_c\\\\\nZ_c\\\\\n1\n\\end{bmatrix}\n\\f]\n\nThis problem is also known as solving the \\f$\\mathbf{A}\\mathbf{X}=\\mathbf{X}\\mathbf{B}\\f$ equation:\n\\f[\n\\begin{align*}\n^{b}{\\textrm{T}_g}^{(1)} \\hspace{0.2em} ^{g}\\textrm{T}_c \\hspace{0.2em} ^{c}{\\textrm{T}_t}^{(1)} &=\n\\hspace{0.1em} ^{b}{\\textrm{T}_g}^{(2)} \\hspace{0.2em} ^{g}\\textrm{T}_c \\hspace{0.2em} ^{c}{\\textrm{T}_t}^{(2)} \\\\\n\n(^{b}{\\textrm{T}_g}^{(2)})^{-1} \\hspace{0.2em} ^{b}{\\textrm{T}_g}^{(1)} \\hspace{0.2em} ^{g}\\textrm{T}_c &=\n\\hspace{0.1em} ^{g}\\textrm{T}_c \\hspace{0.2em} ^{c}{\\textrm{T}_t}^{(2)} (^{c}{\\textrm{T}_t}^{(1)})^{-1} \\\\\n\n\\textrm{A}_i \\textrm{X} &= \\textrm{X} \\textrm{B}_i \\\\\n\\end{align*}\n\\f]\n\n\\note\nAdditional information can be found on this [website](http://campar.in.tum.de/Chair/HandEyeCalibration).\n\\note\nA minimum of 2 motions with non parallel rotation axes are necessary to determine the hand-eye transformation.\nSo at least 3 different poses are required, but it is strongly recommended to use many more poses.\n"]
    #[link_name = "\u{1}_ZN2cv16calibrateHandEyeERKNS_11_InputArrayES2_S2_S2_RKNS_12_OutputArrayES5_NS_24HandEyeCalibrationMethodE"]
    pub fn cv_calibrateHandEye(
        R_gripper2base: cv_InputArrayOfArrays,
        t_gripper2base: cv_InputArrayOfArrays,
        R_target2cam: cv_InputArrayOfArrays,
        t_target2cam: cv_InputArrayOfArrays,
        R_cam2gripper: cv_OutputArray,
        t_cam2gripper: cv_OutputArray,
        method: cv_HandEyeCalibrationMethod,
    );
}
unsafe extern "C" {
    #[doc = " @brief Converts points from Euclidean to homogeneous space.\n\n@param src Input vector of N-dimensional points.\n@param dst Output vector of N+1-dimensional points.\n\nThe function converts points from Euclidean to homogeneous space by appending 1's to the tuple of\npoint coordinates. That is, each point (x1, x2, ..., xn) is converted to (x1, x2, ..., xn, 1)."]
    #[link_name = "\u{1}_ZN2cv26convertPointsToHomogeneousERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_convertPointsToHomogeneous(src: cv_InputArray, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief Converts points from homogeneous to Euclidean space.\n\n@param src Input vector of N-dimensional points.\n@param dst Output vector of N-1-dimensional points.\n\nThe function converts points homogeneous to Euclidean space using perspective projection. That is,\neach point (x1, x2, ... x(n-1), xn) is converted to (x1/xn, x2/xn, ..., x(n-1)/xn). When xn=0, the\noutput point coordinates will be (0,0,0,...)."]
    #[link_name = "\u{1}_ZN2cv28convertPointsFromHomogeneousERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_convertPointsFromHomogeneous(src: cv_InputArray, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief Converts points to/from homogeneous coordinates.\n\n@param src Input array or vector of 2D, 3D, or 4D points.\n@param dst Output vector of 2D, 3D, or 4D points.\n\nThe function converts 2D or 3D points from/to homogeneous coordinates by calling either\nconvertPointsToHomogeneous or convertPointsFromHomogeneous.\n\n@note The function is obsolete. Use one of the previous two functions instead."]
    #[link_name = "\u{1}_ZN2cv24convertPointsHomogeneousERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_convertPointsHomogeneous(src: cv_InputArray, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief Calculates a fundamental matrix from the corresponding points in two images.\n\n@param points1 Array of N points from the first image. The point coordinates should be\nfloating-point (single or double precision).\n@param points2 Array of the second image points of the same size and format as points1 .\n@param method Method for computing a fundamental matrix.\n-   **CV_FM_7POINT** for a 7-point algorithm. \\f$N = 7\\f$\n-   **CV_FM_8POINT** for an 8-point algorithm. \\f$N \\ge 8\\f$\n-   **CV_FM_RANSAC** for the RANSAC algorithm. \\f$N \\ge 8\\f$\n-   **CV_FM_LMEDS** for the LMedS algorithm. \\f$N \\ge 8\\f$\n@param ransacReprojThreshold Parameter used only for RANSAC. It is the maximum distance from a point to an epipolar\nline in pixels, beyond which the point is considered an outlier and is not used for computing the\nfinal fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the\npoint localization, image resolution, and the image noise.\n@param confidence Parameter used for the RANSAC and LMedS methods only. It specifies a desirable level\nof confidence (probability) that the estimated matrix is correct.\n@param mask\n\nThe epipolar geometry is described by the following equation:\n\n\\f[[p_2; 1]^T F [p_1; 1] = 0\\f]\n\nwhere \\f$F\\f$ is a fundamental matrix, \\f$p_1\\f$ and \\f$p_2\\f$ are corresponding points in the first and the\nsecond images, respectively.\n\nThe function calculates the fundamental matrix using one of four methods listed above and returns\nthe found fundamental matrix. Normally just one matrix is found. But in case of the 7-point\nalgorithm, the function may return up to 3 solutions ( \\f$9 \\times 3\\f$ matrix that stores all 3\nmatrices sequentially).\n\nThe calculated fundamental matrix may be passed further to computeCorrespondEpilines that finds the\nepipolar lines corresponding to the specified points. It can also be passed to\nstereoRectifyUncalibrated to compute the rectification transformation. :\n@code\n// Example. Estimation of fundamental matrix using the RANSAC algorithm\nint point_count = 100;\nvector<Point2f> points1(point_count);\nvector<Point2f> points2(point_count);\n\n// initialize the points here ...\nfor( int i = 0; i < point_count; i++ )\n{\npoints1[i] = ...;\npoints2[i] = ...;\n}\n\nMat fundamental_matrix =\nfindFundamentalMat(points1, points2, FM_RANSAC, 3, 0.99);\n@endcode"]
    #[link_name = "\u{1}_ZN2cv18findFundamentalMatERKNS_11_InputArrayES2_iddRKNS_12_OutputArrayE"]
    pub fn cv_findFundamentalMat(
        points1: cv_InputArray,
        points2: cv_InputArray,
        method: ::std::os::raw::c_int,
        ransacReprojThreshold: f64,
        confidence: f64,
        mask: cv_OutputArray,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv18findFundamentalMatERKNS_11_InputArrayES2_RKNS_12_OutputArrayEidd"]
    pub fn cv_findFundamentalMat1(
        points1: cv_InputArray,
        points2: cv_InputArray,
        mask: cv_OutputArray,
        method: ::std::os::raw::c_int,
        ransacReprojThreshold: f64,
        confidence: f64,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Calculates an essential matrix from the corresponding points in two images.\n\n@param points1 Array of N (N \\>= 5) 2D points from the first image. The point coordinates should\nbe floating-point (single or double precision).\n@param points2 Array of the second image points of the same size and format as points1 .\n@param cameraMatrix Camera matrix \\f$K = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .\nNote that this function assumes that points1 and points2 are feature points from cameras with the\nsame camera matrix.\n@param method Method for computing an essential matrix.\n-   **RANSAC** for the RANSAC algorithm.\n-   **LMEDS** for the LMedS algorithm.\n@param prob Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of\nconfidence (probability) that the estimated matrix is correct.\n@param threshold Parameter used for RANSAC. It is the maximum distance from a point to an epipolar\nline in pixels, beyond which the point is considered an outlier and is not used for computing the\nfinal fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the\npoint localization, image resolution, and the image noise.\n@param mask Output array of N elements, every element of which is set to 0 for outliers and to 1\nfor the other points. The array is computed only in the RANSAC and LMedS methods.\n\nThis function estimates essential matrix based on the five-point algorithm solver in @cite Nister03 .\n@cite SteweniusCFS is also a related. The epipolar geometry is described by the following equation:\n\n\\f[[p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\\f]\n\nwhere \\f$E\\f$ is an essential matrix, \\f$p_1\\f$ and \\f$p_2\\f$ are corresponding points in the first and the\nsecond images, respectively. The result of this function may be passed further to\ndecomposeEssentialMat or recoverPose to recover the relative pose between cameras."]
    #[link_name = "\u{1}_ZN2cv16findEssentialMatERKNS_11_InputArrayES2_S2_iddRKNS_12_OutputArrayE"]
    pub fn cv_findEssentialMat(
        points1: cv_InputArray,
        points2: cv_InputArray,
        cameraMatrix: cv_InputArray,
        method: ::std::os::raw::c_int,
        prob: f64,
        threshold: f64,
        mask: cv_OutputArray,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @overload\n@param points1 Array of N (N \\>= 5) 2D points from the first image. The point coordinates should\nbe floating-point (single or double precision).\n@param points2 Array of the second image points of the same size and format as points1 .\n@param focal focal length of the camera. Note that this function assumes that points1 and points2\nare feature points from cameras with same focal length and principal point.\n@param pp principal point of the camera.\n@param method Method for computing a fundamental matrix.\n-   **RANSAC** for the RANSAC algorithm.\n-   **LMEDS** for the LMedS algorithm.\n@param threshold Parameter used for RANSAC. It is the maximum distance from a point to an epipolar\nline in pixels, beyond which the point is considered an outlier and is not used for computing the\nfinal fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the\npoint localization, image resolution, and the image noise.\n@param prob Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of\nconfidence (probability) that the estimated matrix is correct.\n@param mask Output array of N elements, every element of which is set to 0 for outliers and to 1\nfor the other points. The array is computed only in the RANSAC and LMedS methods.\n\nThis function differs from the one above that it computes camera matrix from focal length and\nprincipal point:\n\n\\f[K =\n\\begin{bmatrix}\nf & 0 & x_{pp}  \\\\\n0 & f & y_{pp}  \\\\\n0 & 0 & 1\n\\end{bmatrix}\\f]"]
    #[link_name = "\u{1}_ZN2cv16findEssentialMatERKNS_11_InputArrayES2_dNS_6Point_IdEEiddRKNS_12_OutputArrayE"]
    pub fn cv_findEssentialMat1(
        points1: cv_InputArray,
        points2: cv_InputArray,
        focal: f64,
        pp: cv_Point2d,
        method: ::std::os::raw::c_int,
        prob: f64,
        threshold: f64,
        mask: cv_OutputArray,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Decompose an essential matrix to possible rotations and translation.\n\n@param E The input essential matrix.\n@param R1 One possible rotation matrix.\n@param R2 Another possible rotation matrix.\n@param t One possible translation.\n\nThis function decompose an essential matrix E using svd decomposition @cite HartleyZ00 . Generally 4\npossible poses exists for a given E. They are \\f$[R_1, t]\\f$, \\f$[R_1, -t]\\f$, \\f$[R_2, t]\\f$, \\f$[R_2, -t]\\f$. By\ndecomposing E, you can only get the direction of the translation, so the function returns unit t."]
    #[link_name = "\u{1}_ZN2cv21decomposeEssentialMatERKNS_11_InputArrayERKNS_12_OutputArrayES5_S5_"]
    pub fn cv_decomposeEssentialMat(
        E: cv_InputArray,
        R1: cv_OutputArray,
        R2: cv_OutputArray,
        t: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Recover relative camera rotation and translation from an estimated essential matrix and the\ncorresponding points in two images, using cheirality check. Returns the number of inliers which pass\nthe check.\n\n@param E The input essential matrix.\n@param points1 Array of N 2D points from the first image. The point coordinates should be\nfloating-point (single or double precision).\n@param points2 Array of the second image points of the same size and format as points1 .\n@param cameraMatrix Camera matrix \\f$K = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .\nNote that this function assumes that points1 and points2 are feature points from cameras with the\nsame camera matrix.\n@param R Recovered relative rotation.\n@param t Recovered relative translation.\n@param mask Input/output mask for inliers in points1 and points2.\n:   If it is not empty, then it marks inliers in points1 and points2 for then given essential\nmatrix E. Only these inliers will be used to recover pose. In the output mask only inliers\nwhich pass the cheirality check.\nThis function decomposes an essential matrix using decomposeEssentialMat and then verifies possible\npose hypotheses by doing cheirality check. The cheirality check basically means that the\ntriangulated 3D points should have positive depth. Some details can be found in @cite Nister03 .\n\nThis function can be used to process output E and mask from findEssentialMat. In this scenario,\npoints1 and points2 are the same input for findEssentialMat. :\n@code\n// Example. Estimation of fundamental matrix using the RANSAC algorithm\nint point_count = 100;\nvector<Point2f> points1(point_count);\nvector<Point2f> points2(point_count);\n\n// initialize the points here ...\nfor( int i = 0; i < point_count; i++ )\n{\npoints1[i] = ...;\npoints2[i] = ...;\n}\n\n// cametra matrix with both focal lengths = 1, and principal point = (0, 0)\nMat cameraMatrix = Mat::eye(3, 3, CV_64F);\n\nMat E, R, t, mask;\n\nE = findEssentialMat(points1, points2, cameraMatrix, RANSAC, 0.999, 1.0, mask);\nrecoverPose(E, points1, points2, cameraMatrix, R, t, mask);\n@endcode"]
    #[link_name = "\u{1}_ZN2cv11recoverPoseERKNS_11_InputArrayES2_S2_S2_RKNS_12_OutputArrayES5_RKNS_17_InputOutputArrayE"]
    pub fn cv_recoverPose(
        E: cv_InputArray,
        points1: cv_InputArray,
        points2: cv_InputArray,
        cameraMatrix: cv_InputArray,
        R: cv_OutputArray,
        t: cv_OutputArray,
        mask: cv_InputOutputArray,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @overload\n@param E The input essential matrix.\n@param points1 Array of N 2D points from the first image. The point coordinates should be\nfloating-point (single or double precision).\n@param points2 Array of the second image points of the same size and format as points1 .\n@param R Recovered relative rotation.\n@param t Recovered relative translation.\n@param focal Focal length of the camera. Note that this function assumes that points1 and points2\nare feature points from cameras with same focal length and principal point.\n@param pp principal point of the camera.\n@param mask Input/output mask for inliers in points1 and points2.\n:   If it is not empty, then it marks inliers in points1 and points2 for then given essential\nmatrix E. Only these inliers will be used to recover pose. In the output mask only inliers\nwhich pass the cheirality check.\n\nThis function differs from the one above that it computes camera matrix from focal length and\nprincipal point:\n\n\\f[K =\n\\begin{bmatrix}\nf & 0 & x_{pp}  \\\\\n0 & f & y_{pp}  \\\\\n0 & 0 & 1\n\\end{bmatrix}\\f]"]
    #[link_name = "\u{1}_ZN2cv11recoverPoseERKNS_11_InputArrayES2_S2_RKNS_12_OutputArrayES5_dNS_6Point_IdEERKNS_17_InputOutputArrayE"]
    pub fn cv_recoverPose1(
        E: cv_InputArray,
        points1: cv_InputArray,
        points2: cv_InputArray,
        R: cv_OutputArray,
        t: cv_OutputArray,
        focal: f64,
        pp: cv_Point2d,
        mask: cv_InputOutputArray,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @overload\n@param E The input essential matrix.\n@param points1 Array of N 2D points from the first image. The point coordinates should be\nfloating-point (single or double precision).\n@param points2 Array of the second image points of the same size and format as points1.\n@param cameraMatrix Camera matrix \\f$K = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .\nNote that this function assumes that points1 and points2 are feature points from cameras with the\nsame camera matrix.\n@param R Recovered relative rotation.\n@param t Recovered relative translation.\n@param distanceThresh threshold distance which is used to filter out far away points (i.e. infinite points).\n@param mask Input/output mask for inliers in points1 and points2.\n:   If it is not empty, then it marks inliers in points1 and points2 for then given essential\nmatrix E. Only these inliers will be used to recover pose. In the output mask only inliers\nwhich pass the cheirality check.\n@param triangulatedPoints 3d points which were reconstructed by triangulation."]
    #[link_name = "\u{1}_ZN2cv11recoverPoseERKNS_11_InputArrayES2_S2_S2_RKNS_12_OutputArrayES5_dRKNS_17_InputOutputArrayES5_"]
    pub fn cv_recoverPose2(
        E: cv_InputArray,
        points1: cv_InputArray,
        points2: cv_InputArray,
        cameraMatrix: cv_InputArray,
        R: cv_OutputArray,
        t: cv_OutputArray,
        distanceThresh: f64,
        mask: cv_InputOutputArray,
        triangulatedPoints: cv_OutputArray,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief For points in an image of a stereo pair, computes the corresponding epilines in the other image.\n\n@param points Input points. \\f$N \\times 1\\f$ or \\f$1 \\times N\\f$ matrix of type CV_32FC2 or\nvector\\<Point2f\\> .\n@param whichImage Index of the image (1 or 2) that contains the points .\n@param F Fundamental matrix that can be estimated using findFundamentalMat or stereoRectify .\n@param lines Output vector of the epipolar lines corresponding to the points in the other image.\nEach line \\f$ax + by + c=0\\f$ is encoded by 3 numbers \\f$(a, b, c)\\f$ .\n\nFor every point in one of the two images of a stereo pair, the function finds the equation of the\ncorresponding epipolar line in the other image.\n\nFrom the fundamental matrix definition (see findFundamentalMat ), line \\f$l^{(2)}_i\\f$ in the second\nimage for the point \\f$p^{(1)}_i\\f$ in the first image (when whichImage=1 ) is computed as:\n\n\\f[l^{(2)}_i = F p^{(1)}_i\\f]\n\nAnd vice versa, when whichImage=2, \\f$l^{(1)}_i\\f$ is computed from \\f$p^{(2)}_i\\f$ as:\n\n\\f[l^{(1)}_i = F^T p^{(2)}_i\\f]\n\nLine coefficients are defined up to a scale. They are normalized so that \\f$a_i^2+b_i^2=1\\f$ ."]
    #[link_name = "\u{1}_ZN2cv25computeCorrespondEpilinesERKNS_11_InputArrayEiS2_RKNS_12_OutputArrayE"]
    pub fn cv_computeCorrespondEpilines(
        points: cv_InputArray,
        whichImage: ::std::os::raw::c_int,
        F: cv_InputArray,
        lines: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Reconstructs points by triangulation.\n\n@param projMatr1 3x4 projection matrix of the first camera.\n@param projMatr2 3x4 projection matrix of the second camera.\n@param projPoints1 2xN array of feature points in the first image. In case of c++ version it can\nbe also a vector of feature points or two-channel matrix of size 1xN or Nx1.\n@param projPoints2 2xN array of corresponding points in the second image. In case of c++ version\nit can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.\n@param points4D 4xN array of reconstructed points in homogeneous coordinates.\n\nThe function reconstructs 3-dimensional points (in homogeneous coordinates) by using their\nobservations with a stereo camera. Projections matrices can be obtained from stereoRectify.\n\n@note\nKeep in mind that all input data should be of float type in order for this function to work.\n\n@sa\nreprojectImageTo3D"]
    #[link_name = "\u{1}_ZN2cv17triangulatePointsERKNS_11_InputArrayES2_S2_S2_RKNS_12_OutputArrayE"]
    pub fn cv_triangulatePoints(
        projMatr1: cv_InputArray,
        projMatr2: cv_InputArray,
        projPoints1: cv_InputArray,
        projPoints2: cv_InputArray,
        points4D: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Refines coordinates of corresponding points.\n\n@param F 3x3 fundamental matrix.\n@param points1 1xN array containing the first set of points.\n@param points2 1xN array containing the second set of points.\n@param newPoints1 The optimized points1.\n@param newPoints2 The optimized points2.\n\nThe function implements the Optimal Triangulation Method (see Multiple View Geometry for details).\nFor each given point correspondence points1[i] \\<-\\> points2[i], and a fundamental matrix F, it\ncomputes the corrected correspondences newPoints1[i] \\<-\\> newPoints2[i] that minimize the geometric\nerror \\f$d(points1[i], newPoints1[i])^2 + d(points2[i],newPoints2[i])^2\\f$ (where \\f$d(a,b)\\f$ is the\ngeometric distance between points \\f$a\\f$ and \\f$b\\f$ ) subject to the epipolar constraint\n\\f$newPoints2^T * F * newPoints1 = 0\\f$ ."]
    #[link_name = "\u{1}_ZN2cv14correctMatchesERKNS_11_InputArrayES2_S2_RKNS_12_OutputArrayES5_"]
    pub fn cv_correctMatches(
        F: cv_InputArray,
        points1: cv_InputArray,
        points2: cv_InputArray,
        newPoints1: cv_OutputArray,
        newPoints2: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Filters off small noise blobs (speckles) in the disparity map\n\n@param img The input 16-bit signed disparity image\n@param newVal The disparity value used to paint-off the speckles\n@param maxSpeckleSize The maximum speckle size to consider it a speckle. Larger blobs are not\naffected by the algorithm\n@param maxDiff Maximum difference between neighbor disparity pixels to put them into the same\nblob. Note that since StereoBM, StereoSGBM and may be other algorithms return a fixed-point\ndisparity map, where disparity values are multiplied by 16, this scale factor should be taken into\naccount when specifying this parameter value.\n@param buf The optional temporary buffer to avoid memory allocation within the function."]
    #[link_name = "\u{1}_ZN2cv14filterSpecklesERKNS_17_InputOutputArrayEdidS2_"]
    pub fn cv_filterSpeckles(
        img: cv_InputOutputArray,
        newVal: f64,
        maxSpeckleSize: ::std::os::raw::c_int,
        maxDiff: f64,
        buf: cv_InputOutputArray,
    );
}
unsafe extern "C" {
    #[doc = "! computes valid disparity ROI from the valid ROIs of the rectified images (that are returned by cv::stereoRectify())"]
    #[link_name = "\u{1}_ZN2cv20getValidDisparityROIENS_5Rect_IiEES1_iii"]
    pub fn cv_getValidDisparityROI(
        roi1: cv_Rect,
        roi2: cv_Rect,
        minDisparity: ::std::os::raw::c_int,
        numberOfDisparities: ::std::os::raw::c_int,
        SADWindowSize: ::std::os::raw::c_int,
    ) -> cv_Rect;
}
unsafe extern "C" {
    #[doc = "! validates disparity using the left-right check. The matrix \"cost\" should be computed by the stereo correspondence algorithm"]
    #[link_name = "\u{1}_ZN2cv17validateDisparityERKNS_17_InputOutputArrayERKNS_11_InputArrayEiii"]
    pub fn cv_validateDisparity(
        disparity: cv_InputOutputArray,
        cost: cv_InputArray,
        minDisparity: ::std::os::raw::c_int,
        numberOfDisparities: ::std::os::raw::c_int,
        disp12MaxDisp: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Reprojects a disparity image to 3D space.\n\n@param disparity Input single-channel 8-bit unsigned, 16-bit signed, 32-bit signed or 32-bit\nfloating-point disparity image.\nThe values of 8-bit / 16-bit signed formats are assumed to have no fractional bits.\nIf the disparity is 16-bit signed format as computed by\nStereoBM/StereoSGBM/StereoBinaryBM/StereoBinarySGBM and may be other algorithms,\nit should be divided by 16 (and scaled to float) before being used here.\n@param _3dImage Output 3-channel floating-point image of the same size as disparity . Each\nelement of _3dImage(x,y) contains 3D coordinates of the point (x,y) computed from the disparity\nmap.\n@param Q \\f$4 \\times 4\\f$ perspective transformation matrix that can be obtained with stereoRectify.\n@param handleMissingValues Indicates, whether the function should handle missing values (i.e.\npoints where the disparity was not computed). If handleMissingValues=true, then pixels with the\nminimal disparity that corresponds to the outliers (see StereoMatcher::compute ) are transformed\nto 3D points with a very large Z value (currently set to 10000).\n@param ddepth The optional output array depth. If it is -1, the output image will have CV_32F\ndepth. ddepth can also be set to CV_16S, CV_32S or CV_32F.\n\nThe function transforms a single-channel disparity map to a 3-channel image representing a 3D\nsurface. That is, for each pixel (x,y) and the corresponding disparity d=disparity(x,y) , it\ncomputes:\n\n\\f[\\begin{array}{l} [X \\; Y \\; Z \\; W]^T =  \\texttt{Q} *[x \\; y \\; \\texttt{disparity} (x,y) \\; 1]^T  \\\\ \\texttt{\\_3dImage} (x,y) = (X/W, \\; Y/W, \\; Z/W) \\end{array}\\f]\n\nThe matrix Q can be an arbitrary \\f$4 \\times 4\\f$ matrix (for example, the one computed by\nstereoRectify). To reproject a sparse set of points {(x,y,d),...} to 3D space, use\nperspectiveTransform ."]
    #[link_name = "\u{1}_ZN2cv18reprojectImageTo3DERKNS_11_InputArrayERKNS_12_OutputArrayES2_bi"]
    pub fn cv_reprojectImageTo3D(
        disparity: cv_InputArray,
        _3dImage: cv_OutputArray,
        Q: cv_InputArray,
        handleMissingValues: bool,
        ddepth: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the Sampson Distance between two points.\n\nThe function cv::sampsonDistance calculates and returns the first order approximation of the geometric error as:\n\\f[\nsd( \\texttt{pt1} , \\texttt{pt2} )=\n\\frac{(\\texttt{pt2}^t \\cdot \\texttt{F} \\cdot \\texttt{pt1})^2}\n{((\\texttt{F} \\cdot \\texttt{pt1})(0))^2 +\n((\\texttt{F} \\cdot \\texttt{pt1})(1))^2 +\n((\\texttt{F}^t \\cdot \\texttt{pt2})(0))^2 +\n((\\texttt{F}^t \\cdot \\texttt{pt2})(1))^2}\n\\f]\nThe fundamental matrix may be calculated using the cv::findFundamentalMat function. See @cite HartleyZ00 11.4.3 for details.\n@param pt1 first homogeneous 2d point\n@param pt2 second homogeneous 2d point\n@param F fundamental matrix\n@return The computed Sampson distance."]
    #[link_name = "\u{1}_ZN2cv15sampsonDistanceERKNS_11_InputArrayES2_S2_"]
    pub fn cv_sampsonDistance(pt1: cv_InputArray, pt2: cv_InputArray, F: cv_InputArray) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Computes an optimal affine transformation between two 3D point sets.\n\nIt computes\n\\f[\n\\begin{bmatrix}\nx\\\\\ny\\\\\nz\\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na_{11} & a_{12} & a_{13}\\\\\na_{21} & a_{22} & a_{23}\\\\\na_{31} & a_{32} & a_{33}\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nX\\\\\nY\\\\\nZ\\\\\n\\end{bmatrix}\n+\n\\begin{bmatrix}\nb_1\\\\\nb_2\\\\\nb_3\\\\\n\\end{bmatrix}\n\\f]\n\n@param src First input 3D point set containing \\f$(X,Y,Z)\\f$.\n@param dst Second input 3D point set containing \\f$(x,y,z)\\f$.\n@param out Output 3D affine transformation matrix \\f$3 \\times 4\\f$ of the form\n\\f[\n\\begin{bmatrix}\na_{11} & a_{12} & a_{13} & b_1\\\\\na_{21} & a_{22} & a_{23} & b_2\\\\\na_{31} & a_{32} & a_{33} & b_3\\\\\n\\end{bmatrix}\n\\f]\n@param inliers Output vector indicating which points are inliers (1-inlier, 0-outlier).\n@param ransacThreshold Maximum reprojection error in the RANSAC algorithm to consider a point as\nan inlier.\n@param confidence Confidence level, between 0 and 1, for the estimated transformation. Anything\nbetween 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation\nsignificantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.\n\nThe function estimates an optimal 3D affine transformation between two 3D point sets using the\nRANSAC algorithm."]
    #[link_name = "\u{1}_ZN2cv16estimateAffine3DERKNS_11_InputArrayES2_RKNS_12_OutputArrayES5_dd"]
    pub fn cv_estimateAffine3D(
        src: cv_InputArray,
        dst: cv_InputArray,
        out: cv_OutputArray,
        inliers: cv_OutputArray,
        ransacThreshold: f64,
        confidence: f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Computes an optimal affine transformation between two 2D point sets.\n\nIt computes\n\\f[\n\\begin{bmatrix}\nx\\\\\ny\\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na_{11} & a_{12}\\\\\na_{21} & a_{22}\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nX\\\\\nY\\\\\n\\end{bmatrix}\n+\n\\begin{bmatrix}\nb_1\\\\\nb_2\\\\\n\\end{bmatrix}\n\\f]\n\n@param from First input 2D point set containing \\f$(X,Y)\\f$.\n@param to Second input 2D point set containing \\f$(x,y)\\f$.\n@param inliers Output vector indicating which points are inliers (1-inlier, 0-outlier).\n@param method Robust method used to compute transformation. The following methods are possible:\n-   cv::RANSAC - RANSAC-based robust method\n-   cv::LMEDS - Least-Median robust method\nRANSAC is the default method.\n@param ransacReprojThreshold Maximum reprojection error in the RANSAC algorithm to consider\na point as an inlier. Applies only to RANSAC.\n@param maxIters The maximum number of robust method iterations.\n@param confidence Confidence level, between 0 and 1, for the estimated transformation. Anything\nbetween 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation\nsignificantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.\n@param refineIters Maximum number of iterations of refining algorithm (Levenberg-Marquardt).\nPassing 0 will disable refining, so the output matrix will be output of robust method.\n\n@return Output 2D affine transformation matrix \\f$2 \\times 3\\f$ or empty matrix if transformation\ncould not be estimated. The returned matrix has the following form:\n\\f[\n\\begin{bmatrix}\na_{11} & a_{12} & b_1\\\\\na_{21} & a_{22} & b_2\\\\\n\\end{bmatrix}\n\\f]\n\nThe function estimates an optimal 2D affine transformation between two 2D point sets using the\nselected robust algorithm.\n\nThe computed transformation is then refined further (using only inliers) with the\nLevenberg-Marquardt method to reduce the re-projection error even more.\n\n@note\nThe RANSAC method can handle practically any ratio of outliers but needs a threshold to\ndistinguish inliers from outliers. The method LMeDS does not need any threshold but it works\ncorrectly only when there are more than 50% of inliers.\n\n@sa estimateAffinePartial2D, getAffineTransform"]
    #[link_name = "\u{1}_ZN2cv16estimateAffine2DERKNS_11_InputArrayES2_RKNS_12_OutputArrayEidmdm"]
    pub fn cv_estimateAffine2D(
        from: cv_InputArray,
        to: cv_InputArray,
        inliers: cv_OutputArray,
        method: ::std::os::raw::c_int,
        ransacReprojThreshold: f64,
        maxIters: usize,
        confidence: f64,
        refineIters: usize,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Computes an optimal limited affine transformation with 4 degrees of freedom between\ntwo 2D point sets.\n\n@param from First input 2D point set.\n@param to Second input 2D point set.\n@param inliers Output vector indicating which points are inliers.\n@param method Robust method used to compute transformation. The following methods are possible:\n-   cv::RANSAC - RANSAC-based robust method\n-   cv::LMEDS - Least-Median robust method\nRANSAC is the default method.\n@param ransacReprojThreshold Maximum reprojection error in the RANSAC algorithm to consider\na point as an inlier. Applies only to RANSAC.\n@param maxIters The maximum number of robust method iterations.\n@param confidence Confidence level, between 0 and 1, for the estimated transformation. Anything\nbetween 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation\nsignificantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.\n@param refineIters Maximum number of iterations of refining algorithm (Levenberg-Marquardt).\nPassing 0 will disable refining, so the output matrix will be output of robust method.\n\n@return Output 2D affine transformation (4 degrees of freedom) matrix \\f$2 \\times 3\\f$ or\nempty matrix if transformation could not be estimated.\n\nThe function estimates an optimal 2D affine transformation with 4 degrees of freedom limited to\ncombinations of translation, rotation, and uniform scaling. Uses the selected algorithm for robust\nestimation.\n\nThe computed transformation is then refined further (using only inliers) with the\nLevenberg-Marquardt method to reduce the re-projection error even more.\n\nEstimated transformation matrix is:\n\\f[ \\begin{bmatrix} \\cos(\\theta) \\cdot s & -\\sin(\\theta) \\cdot s & t_x \\\\\n\\sin(\\theta) \\cdot s & \\cos(\\theta) \\cdot s & t_y\n\\end{bmatrix} \\f]\nWhere \\f$ \\theta \\f$ is the rotation angle, \\f$ s \\f$ the scaling factor and \\f$ t_x, t_y \\f$ are\ntranslations in \\f$ x, y \\f$ axes respectively.\n\n@note\nThe RANSAC method can handle practically any ratio of outliers but need a threshold to\ndistinguish inliers from outliers. The method LMeDS does not need any threshold but it works\ncorrectly only when there are more than 50% of inliers.\n\n@sa estimateAffine2D, getAffineTransform"]
    #[link_name = "\u{1}_ZN2cv23estimateAffinePartial2DERKNS_11_InputArrayES2_RKNS_12_OutputArrayEidmdm"]
    pub fn cv_estimateAffinePartial2D(
        from: cv_InputArray,
        to: cv_InputArray,
        inliers: cv_OutputArray,
        method: ::std::os::raw::c_int,
        ransacReprojThreshold: f64,
        maxIters: usize,
        confidence: f64,
        refineIters: usize,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Decompose a homography matrix to rotation(s), translation(s) and plane normal(s).\n\n@param H The input homography matrix between two images.\n@param K The input intrinsic camera calibration matrix.\n@param rotations Array of rotation matrices.\n@param translations Array of translation matrices.\n@param normals Array of plane normal matrices.\n\nThis function extracts relative camera motion between two views observing a planar object from the\nhomography H induced by the plane. The intrinsic camera matrix K must also be provided. The function\nmay return up to four mathematical solution sets. At least two of the solutions may further be\ninvalidated if point correspondences are available by applying positive depth constraint (all points\nmust be in front of the camera). The decomposition method is described in detail in @cite Malis ."]
    #[link_name = "\u{1}_ZN2cv22decomposeHomographyMatERKNS_11_InputArrayES2_RKNS_12_OutputArrayES5_S5_"]
    pub fn cv_decomposeHomographyMat(
        H: cv_InputArray,
        K: cv_InputArray,
        rotations: cv_OutputArrayOfArrays,
        translations: cv_OutputArrayOfArrays,
        normals: cv_OutputArrayOfArrays,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Filters homography decompositions based on additional information.\n\n@param rotations Vector of rotation matrices.\n@param normals Vector of plane normal matrices.\n@param beforePoints Vector of (rectified) visible reference points before the homography is applied\n@param afterPoints Vector of (rectified) visible reference points after the homography is applied\n@param possibleSolutions Vector of int indices representing the viable solution set after filtering\n@param pointsMask optional Mat/Vector of 8u type representing the mask for the inliers as given by the findHomography function\n\nThis function is intended to filter the output of the decomposeHomographyMat based on additional\ninformation as described in @cite Malis . The summary of the method: the decomposeHomographyMat function\nreturns 2 unique solutions and their \"opposites\" for a total of 4 solutions. If we have access to the\nsets of points visible in the camera frame before and after the homography transformation is applied,\nwe can determine which are the true potential solutions and which are the opposites by verifying which\nhomographies are consistent with all visible reference points being in front of the camera. The inputs\nare left unchanged; the filtered solution set is returned as indices into the existing one."]
    #[link_name = "\u{1}_ZN2cv40filterHomographyDecompByVisibleRefpointsERKNS_11_InputArrayES2_S2_S2_RKNS_12_OutputArrayES2_"]
    pub fn cv_filterHomographyDecompByVisibleRefpoints(
        rotations: cv_InputArrayOfArrays,
        normals: cv_InputArrayOfArrays,
        beforePoints: cv_InputArray,
        afterPoints: cv_InputArray,
        possibleSolutions: cv_OutputArray,
        pointsMask: cv_InputArray,
    );
}
#[doc = " @brief The base class for stereo correspondence algorithms."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_StereoMatcher {
    pub _base: cv_Algorithm,
}
pub const cv_StereoMatcher_DISP_SHIFT: cv_StereoMatcher__bindgen_ty_1 = 4;
pub const cv_StereoMatcher_DISP_SCALE: cv_StereoMatcher__bindgen_ty_1 = 16;
pub type cv_StereoMatcher__bindgen_ty_1 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_StereoMatcher"][::std::mem::size_of::<cv_StereoMatcher>() - 8usize];
    ["Alignment of cv_StereoMatcher"][::std::mem::align_of::<cv_StereoMatcher>() - 8usize];
};
#[doc = " @brief Class for computing stereo correspondence using the block matching algorithm, introduced and\ncontributed to OpenCV by K. Konolige."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_StereoBM {
    pub _base: cv_StereoMatcher,
}
pub const cv_StereoBM_PREFILTER_NORMALIZED_RESPONSE: cv_StereoBM__bindgen_ty_1 = 0;
pub const cv_StereoBM_PREFILTER_XSOBEL: cv_StereoBM__bindgen_ty_1 = 1;
pub type cv_StereoBM__bindgen_ty_1 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_StereoBM"][::std::mem::size_of::<cv_StereoBM>() - 8usize];
    ["Alignment of cv_StereoBM"][::std::mem::align_of::<cv_StereoBM>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates StereoBM object\n\n@param numDisparities the disparity search range. For each pixel algorithm will find the best\ndisparity from 0 (default minimum disparity) to numDisparities. The search range can then be\nshifted by changing the minimum disparity.\n@param blockSize the linear size of the blocks compared by the algorithm. The size should be odd\n(as the block is centered at the current pixel). Larger block size implies smoother, though less\naccurate disparity map. Smaller block size gives more detailed disparity map, but there is higher\nchance for algorithm to find a wrong correspondence.\n\nThe function create StereoBM object. You can then call StereoBM::compute() to compute disparity for\na specific stereo pair."]
    #[link_name = "\u{1}_ZN2cv8StereoBM6createEii"]
    pub fn cv_StereoBM_create(
        numDisparities: ::std::os::raw::c_int,
        blockSize: ::std::os::raw::c_int,
    ) -> cv_Ptr;
}
impl cv_StereoBM {
    #[inline]
    pub unsafe fn create(
        numDisparities: ::std::os::raw::c_int,
        blockSize: ::std::os::raw::c_int,
    ) -> cv_Ptr {
        cv_StereoBM_create(numDisparities, blockSize)
    }
}
#[doc = " @brief The class implements the modified H. Hirschmuller algorithm @cite HH08 that differs from the original\none as follows:\n\n-   By default, the algorithm is single-pass, which means that you consider only 5 directions\ninstead of 8. Set mode=StereoSGBM::MODE_HH in createStereoSGBM to run the full variant of the\nalgorithm but beware that it may consume a lot of memory.\n-   The algorithm matches blocks, not individual pixels. Though, setting blockSize=1 reduces the\nblocks to single pixels.\n-   Mutual information cost function is not implemented. Instead, a simpler Birchfield-Tomasi\nsub-pixel metric from @cite BT98 is used. Though, the color images are supported as well.\n-   Some pre- and post- processing steps from K. Konolige algorithm StereoBM are included, for\nexample: pre-filtering (StereoBM::PREFILTER_XSOBEL type) and post-filtering (uniqueness\ncheck, quadratic interpolation and speckle filtering).\n\n@note\n-   (Python) An example illustrating the use of the StereoSGBM matching algorithm can be found\nat opencv_source_code/samples/python/stereo_match.py"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_StereoSGBM {
    pub _base: cv_StereoMatcher,
}
pub const cv_StereoSGBM_MODE_SGBM: cv_StereoSGBM__bindgen_ty_1 = 0;
pub const cv_StereoSGBM_MODE_HH: cv_StereoSGBM__bindgen_ty_1 = 1;
pub const cv_StereoSGBM_MODE_SGBM_3WAY: cv_StereoSGBM__bindgen_ty_1 = 2;
pub const cv_StereoSGBM_MODE_HH4: cv_StereoSGBM__bindgen_ty_1 = 3;
pub type cv_StereoSGBM__bindgen_ty_1 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_StereoSGBM"][::std::mem::size_of::<cv_StereoSGBM>() - 8usize];
    ["Alignment of cv_StereoSGBM"][::std::mem::align_of::<cv_StereoSGBM>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates StereoSGBM object\n\n@param minDisparity Minimum possible disparity value. Normally, it is zero but sometimes\nrectification algorithms can shift images, so this parameter needs to be adjusted accordingly.\n@param numDisparities Maximum disparity minus minimum disparity. The value is always greater than\nzero. In the current implementation, this parameter must be divisible by 16.\n@param blockSize Matched block size. It must be an odd number \\>=1 . Normally, it should be\nsomewhere in the 3..11 range.\n@param P1 The first parameter controlling the disparity smoothness. See below.\n@param P2 The second parameter controlling the disparity smoothness. The larger the values are,\nthe smoother the disparity is. P1 is the penalty on the disparity change by plus or minus 1\nbetween neighbor pixels. P2 is the penalty on the disparity change by more than 1 between neighbor\npixels. The algorithm requires P2 \\> P1 . See stereo_match.cpp sample where some reasonably good\nP1 and P2 values are shown (like 8\\*number_of_image_channels\\*SADWindowSize\\*SADWindowSize and\n32\\*number_of_image_channels\\*SADWindowSize\\*SADWindowSize , respectively).\n@param disp12MaxDiff Maximum allowed difference (in integer pixel units) in the left-right\ndisparity check. Set it to a non-positive value to disable the check.\n@param preFilterCap Truncation value for the prefiltered image pixels. The algorithm first\ncomputes x-derivative at each pixel and clips its value by [-preFilterCap, preFilterCap] interval.\nThe result values are passed to the Birchfield-Tomasi pixel cost function.\n@param uniquenessRatio Margin in percentage by which the best (minimum) computed cost function\nvalue should \"win\" the second best value to consider the found match correct. Normally, a value\nwithin the 5-15 range is good enough.\n@param speckleWindowSize Maximum size of smooth disparity regions to consider their noise speckles\nand invalidate. Set it to 0 to disable speckle filtering. Otherwise, set it somewhere in the\n50-200 range.\n@param speckleRange Maximum disparity variation within each connected component. If you do speckle\nfiltering, set the parameter to a positive value, it will be implicitly multiplied by 16.\nNormally, 1 or 2 is good enough.\n@param mode Set it to StereoSGBM::MODE_HH to run the full-scale two-pass dynamic programming\nalgorithm. It will consume O(W\\*H\\*numDisparities) bytes, which is large for 640x480 stereo and\nhuge for HD-size pictures. By default, it is set to false .\n\nThe first constructor initializes StereoSGBM with all the default parameters. So, you only have to\nset StereoSGBM::numDisparities at minimum. The second constructor enables you to set each parameter\nto a custom value."]
    #[link_name = "\u{1}_ZN2cv10StereoSGBM6createEiiiiiiiiiii"]
    pub fn cv_StereoSGBM_create(
        minDisparity: ::std::os::raw::c_int,
        numDisparities: ::std::os::raw::c_int,
        blockSize: ::std::os::raw::c_int,
        P1: ::std::os::raw::c_int,
        P2: ::std::os::raw::c_int,
        disp12MaxDiff: ::std::os::raw::c_int,
        preFilterCap: ::std::os::raw::c_int,
        uniquenessRatio: ::std::os::raw::c_int,
        speckleWindowSize: ::std::os::raw::c_int,
        speckleRange: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) -> cv_Ptr;
}
impl cv_StereoSGBM {
    #[inline]
    pub unsafe fn create(
        minDisparity: ::std::os::raw::c_int,
        numDisparities: ::std::os::raw::c_int,
        blockSize: ::std::os::raw::c_int,
        P1: ::std::os::raw::c_int,
        P2: ::std::os::raw::c_int,
        disp12MaxDiff: ::std::os::raw::c_int,
        preFilterCap: ::std::os::raw::c_int,
        uniquenessRatio: ::std::os::raw::c_int,
        speckleWindowSize: ::std::os::raw::c_int,
        speckleRange: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) -> cv_Ptr {
        cv_StereoSGBM_create(
            minDisparity,
            numDisparities,
            blockSize,
            P1,
            P2,
            disp12MaxDiff,
            preFilterCap,
            uniquenessRatio,
            speckleWindowSize,
            speckleRange,
            mode,
        )
    }
}
pub const cv_UndistortTypes_PROJ_SPHERICAL_ORTHO: cv_UndistortTypes = 0;
pub const cv_UndistortTypes_PROJ_SPHERICAL_EQRECT: cv_UndistortTypes = 1;
#[doc = "! cv::undistort mode"]
pub type cv_UndistortTypes = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Transforms an image to compensate for lens distortion.\n\nThe function transforms an image to compensate radial and tangential lens distortion.\n\nThe function is simply a combination of #initUndistortRectifyMap (with unity R ) and #remap\n(with bilinear interpolation). See the former function for details of the transformation being\nperformed.\n\nThose pixels in the destination image, for which there is no correspondent pixels in the source\nimage, are filled with zeros (black color).\n\nA particular subset of the source image that will be visible in the corrected image can be regulated\nby newCameraMatrix. You can use #getOptimalNewCameraMatrix to compute the appropriate\nnewCameraMatrix depending on your requirements.\n\nThe camera matrix and the distortion parameters can be determined using #calibrateCamera. If\nthe resolution of images is different from the resolution used at the calibration stage, \\f$f_x,\nf_y, c_x\\f$ and \\f$c_y\\f$ need to be scaled accordingly, while the distortion coefficients remain\nthe same.\n\n@param src Input (distorted) image.\n@param dst Output (corrected) image that has the same size and type as src .\n@param cameraMatrix Input camera matrix \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .\n@param distCoeffs Input vector of distortion coefficients\n\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$\nof 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.\n@param newCameraMatrix Camera matrix of the distorted image. By default, it is the same as\ncameraMatrix but you may additionally scale and shift the result by using a different matrix."]
    #[link_name = "\u{1}_ZN2cv9undistortERKNS_11_InputArrayERKNS_12_OutputArrayES2_S2_S2_"]
    pub fn cv_undistort(
        src: cv_InputArray,
        dst: cv_OutputArray,
        cameraMatrix: cv_InputArray,
        distCoeffs: cv_InputArray,
        newCameraMatrix: cv_InputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Computes the undistortion and rectification transformation map.\n\nThe function computes the joint undistortion and rectification transformation and represents the\nresult in the form of maps for remap. The undistorted image looks like original, as if it is\ncaptured with a camera using the camera matrix =newCameraMatrix and zero distortion. In case of a\nmonocular camera, newCameraMatrix is usually equal to cameraMatrix, or it can be computed by\n#getOptimalNewCameraMatrix for a better control over scaling. In case of a stereo camera,\nnewCameraMatrix is normally set to P1 or P2 computed by #stereoRectify .\n\nAlso, this new camera is oriented differently in the coordinate space, according to R. That, for\nexample, helps to align two heads of a stereo camera so that the epipolar lines on both images\nbecome horizontal and have the same y- coordinate (in case of a horizontally aligned stereo camera).\n\nThe function actually builds the maps for the inverse mapping algorithm that is used by remap. That\nis, for each pixel \\f$(u, v)\\f$ in the destination (corrected and rectified) image, the function\ncomputes the corresponding coordinates in the source image (that is, in the original image from\ncamera). The following process is applied:\n\\f[\n\\begin{array}{l}\nx  \\leftarrow (u - {c'}_x)/{f'}_x  \\\\\ny  \\leftarrow (v - {c'}_y)/{f'}_y  \\\\\n{[X\\,Y\\,W]} ^T  \\leftarrow R^{-1}*[x \\, y \\, 1]^T  \\\\\nx'  \\leftarrow X/W  \\\\\ny'  \\leftarrow Y/W  \\\\\nr^2  \\leftarrow x'^2 + y'^2 \\\\\nx''  \\leftarrow x' \\frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6}\n+ 2p_1 x' y' + p_2(r^2 + 2 x'^2)  + s_1 r^2 + s_2 r^4\\\\\ny''  \\leftarrow y' \\frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6}\n+ p_1 (r^2 + 2 y'^2) + 2 p_2 x' y' + s_3 r^2 + s_4 r^4 \\\\\ns\\vecthree{x'''}{y'''}{1} =\n\\vecthreethree{R_{33}(\\tau_x, \\tau_y)}{0}{-R_{13}((\\tau_x, \\tau_y)}\n{0}{R_{33}(\\tau_x, \\tau_y)}{-R_{23}(\\tau_x, \\tau_y)}\n{0}{0}{1} R(\\tau_x, \\tau_y) \\vecthree{x''}{y''}{1}\\\\\nmap_x(u,v)  \\leftarrow x''' f_x + c_x  \\\\\nmap_y(u,v)  \\leftarrow y''' f_y + c_y\n\\end{array}\n\\f]\nwhere \\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$\nare the distortion coefficients.\n\nIn case of a stereo camera, this function is called twice: once for each camera head, after\nstereoRectify, which in its turn is called after #stereoCalibrate. But if the stereo camera\nwas not calibrated, it is still possible to compute the rectification transformations directly from\nthe fundamental matrix using #stereoRectifyUncalibrated. For each camera, the function computes\nhomography H as the rectification transformation in a pixel domain, not a rotation matrix R in 3D\nspace. R can be computed from H as\n\\f[\\texttt{R} = \\texttt{cameraMatrix} ^{-1} \\cdot \\texttt{H} \\cdot \\texttt{cameraMatrix}\\f]\nwhere cameraMatrix can be chosen arbitrarily.\n\n@param cameraMatrix Input camera matrix \\f$A=\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .\n@param distCoeffs Input vector of distortion coefficients\n\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$\nof 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.\n@param R Optional rectification transformation in the object space (3x3 matrix). R1 or R2 ,\ncomputed by #stereoRectify can be passed here. If the matrix is empty, the identity transformation\nis assumed. In cvInitUndistortMap R assumed to be an identity matrix.\n@param newCameraMatrix New camera matrix \\f$A'=\\vecthreethree{f_x'}{0}{c_x'}{0}{f_y'}{c_y'}{0}{0}{1}\\f$.\n@param size Undistorted image size.\n@param m1type Type of the first output map that can be CV_32FC1, CV_32FC2 or CV_16SC2, see #convertMaps\n@param map1 The first output map.\n@param map2 The second output map."]
    #[link_name = "\u{1}_ZN2cv23initUndistortRectifyMapERKNS_11_InputArrayES2_S2_S2_NS_5Size_IiEEiRKNS_12_OutputArrayES7_"]
    pub fn cv_initUndistortRectifyMap(
        cameraMatrix: cv_InputArray,
        distCoeffs: cv_InputArray,
        R: cv_InputArray,
        newCameraMatrix: cv_InputArray,
        size: cv_Size,
        m1type: ::std::os::raw::c_int,
        map1: cv_OutputArray,
        map2: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = "! initializes maps for #remap for wide-angle"]
    #[link_name = "\u{1}_ZN2cv20initWideAngleProjMapERKNS_11_InputArrayES2_NS_5Size_IiEEiiRKNS_12_OutputArrayES7_NS_14UndistortTypesEd"]
    pub fn cv_initWideAngleProjMap(
        cameraMatrix: cv_InputArray,
        distCoeffs: cv_InputArray,
        imageSize: cv_Size,
        destImageWidth: ::std::os::raw::c_int,
        m1type: ::std::os::raw::c_int,
        map1: cv_OutputArray,
        map2: cv_OutputArray,
        projType: cv_UndistortTypes,
        alpha: f64,
    ) -> f32;
}
unsafe extern "C" {
    #[doc = " @brief Returns the default new camera matrix.\n\nThe function returns the camera matrix that is either an exact copy of the input cameraMatrix (when\ncenterPrinicipalPoint=false ), or the modified one (when centerPrincipalPoint=true).\n\nIn the latter case, the new camera matrix will be:\n\n\\f[\\begin{bmatrix} f_x && 0 && ( \\texttt{imgSize.width} -1)*0.5  \\\\ 0 && f_y && ( \\texttt{imgSize.height} -1)*0.5  \\\\ 0 && 0 && 1 \\end{bmatrix} ,\\f]\n\nwhere \\f$f_x\\f$ and \\f$f_y\\f$ are \\f$(0,0)\\f$ and \\f$(1,1)\\f$ elements of cameraMatrix, respectively.\n\nBy default, the undistortion functions in OpenCV (see #initUndistortRectifyMap, #undistort) do not\nmove the principal point. However, when you work with stereo, it is important to move the principal\npoints in both views to the same y-coordinate (which is required by most of stereo correspondence\nalgorithms), and may be to the same x-coordinate too. So, you can form the new camera matrix for\neach view where the principal points are located at the center.\n\n@param cameraMatrix Input camera matrix.\n@param imgsize Camera view image size in pixels.\n@param centerPrincipalPoint Location of the principal point in the new camera matrix. The\nparameter indicates whether this location should be at the image center or not."]
    #[link_name = "\u{1}_ZN2cv25getDefaultNewCameraMatrixERKNS_11_InputArrayENS_5Size_IiEEb"]
    pub fn cv_getDefaultNewCameraMatrix(
        cameraMatrix: cv_InputArray,
        imgsize: cv_Size,
        centerPrincipalPoint: bool,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Computes the ideal point coordinates from the observed point coordinates.\n\nThe function is similar to #undistort and #initUndistortRectifyMap but it operates on a\nsparse set of points instead of a raster image. Also the function performs a reverse transformation\nto projectPoints. In case of a 3D object, it does not reconstruct its 3D coordinates, but for a\nplanar object, it does, up to a translation vector, if the proper R is specified.\n\nFor each observed point coordinate \\f$(u, v)\\f$ the function computes:\n\\f[\n\\begin{array}{l}\nx^{\"}  \\leftarrow (u - c_x)/f_x  \\\\\ny^{\"}  \\leftarrow (v - c_y)/f_y  \\\\\n(x',y') = undistort(x^{\"},y^{\"}, \\texttt{distCoeffs}) \\\\\n{[X\\,Y\\,W]} ^T  \\leftarrow R*[x' \\, y' \\, 1]^T  \\\\\nx  \\leftarrow X/W  \\\\\ny  \\leftarrow Y/W  \\\\\n\\text{only performed if P is specified:} \\\\\nu'  \\leftarrow x {f'}_x + {c'}_x  \\\\\nv'  \\leftarrow y {f'}_y + {c'}_y\n\\end{array}\n\\f]\n\nwhere *undistort* is an approximate iterative algorithm that estimates the normalized original\npoint coordinates out of the normalized distorted point coordinates (\"normalized\" means that the\ncoordinates do not depend on the camera matrix).\n\nThe function can be used for both a stereo camera head or a monocular camera (when R is empty).\n@param src Observed point coordinates, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel (CV_32FC2 or CV_64FC2) (or\nvector\\<Point2f\\> ).\n@param dst Output ideal point coordinates (1xN/Nx1 2-channel or vector\\<Point2f\\> ) after undistortion and reverse perspective\ntransformation. If matrix P is identity or omitted, dst will contain normalized point coordinates.\n@param cameraMatrix Camera matrix \\f$\\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ .\n@param distCoeffs Input vector of distortion coefficients\n\\f$(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]])\\f$\nof 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.\n@param R Rectification transformation in the object space (3x3 matrix). R1 or R2 computed by\n#stereoRectify can be passed here. If the matrix is empty, the identity transformation is used.\n@param P New camera matrix (3x3) or new projection matrix (3x4) \\f$\\begin{bmatrix} {f'}_x & 0 & {c'}_x & t_x \\\\ 0 & {f'}_y & {c'}_y & t_y \\\\ 0 & 0 & 1 & t_z \\end{bmatrix}\\f$. P1 or P2 computed by\n#stereoRectify can be passed here. If the matrix is empty, the identity new camera matrix is used."]
    #[link_name = "\u{1}_ZN2cv15undistortPointsERKNS_11_InputArrayERKNS_12_OutputArrayES2_S2_S2_S2_"]
    pub fn cv_undistortPoints(
        src: cv_InputArray,
        dst: cv_OutputArray,
        cameraMatrix: cv_InputArray,
        distCoeffs: cv_InputArray,
        R: cv_InputArray,
        P: cv_InputArray,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@note Default version of #undistortPoints does 5 iterations to compute undistorted points."]
    #[link_name = "\u{1}_ZN2cv15undistortPointsERKNS_11_InputArrayERKNS_12_OutputArrayES2_S2_S2_S2_NS_12TermCriteriaE"]
    pub fn cv_undistortPoints1(
        src: cv_InputArray,
        dst: cv_OutputArray,
        cameraMatrix: cv_InputArray,
        distCoeffs: cv_InputArray,
        R: cv_InputArray,
        P: cv_InputArray,
        criteria: cv_TermCriteria,
    );
}
pub const CALIB_USE_INTRINSIC_GUESS: cv_fisheye__bindgen_ty_1 = 1;
pub const CALIB_RECOMPUTE_EXTRINSIC: cv_fisheye__bindgen_ty_1 = 2;
pub const CALIB_CHECK_COND: cv_fisheye__bindgen_ty_1 = 4;
pub const CALIB_FIX_SKEW: cv_fisheye__bindgen_ty_1 = 8;
pub const CALIB_FIX_K1: cv_fisheye__bindgen_ty_1 = 16;
pub const CALIB_FIX_K2: cv_fisheye__bindgen_ty_1 = 32;
pub const CALIB_FIX_K3: cv_fisheye__bindgen_ty_1 = 64;
pub const CALIB_FIX_K4: cv_fisheye__bindgen_ty_1 = 128;
pub const CALIB_FIX_INTRINSIC: cv_fisheye__bindgen_ty_1 = 256;
pub const CALIB_FIX_PRINCIPAL_POINT: cv_fisheye__bindgen_ty_1 = 512;
#[doc = "! @addtogroup calib3d_fisheye\n! @{"]
pub type cv_fisheye__bindgen_ty_1 = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Projects points using fisheye model\n\n@param objectPoints Array of object points, 1xN/Nx1 3-channel (or vector\\<Point3f\\> ), where N is\nthe number of points in the view.\n@param imagePoints Output array of image points, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel, or\nvector\\<Point2f\\>.\n@param affine\n@param K Camera matrix \\f$K = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}\\f$.\n@param D Input vector of distortion coefficients \\f$(k_1, k_2, k_3, k_4)\\f$.\n@param alpha The skew coefficient.\n@param jacobian Optional output 2Nx15 jacobian matrix of derivatives of image points with respect\nto components of the focal lengths, coordinates of the principal point, distortion coefficients,\nrotation vector, translation vector, and the skew. In the old interface different components of\nthe jacobian are returned via different output parameters.\n\nThe function computes projections of 3D points to the image plane given intrinsic and extrinsic\ncamera parameters. Optionally, the function computes Jacobians - matrices of partial derivatives of\nimage points coordinates (as functions of all the input parameters) with respect to the particular\nparameters, intrinsic and/or extrinsic."]
    #[link_name = "\u{1}_ZN2cv7fisheye13projectPointsERKNS_11_InputArrayERKNS_12_OutputArrayERKNS_7Affine3IdEES3_S3_dS6_"]
    pub fn cv_fisheye_projectPoints(
        objectPoints: cv_InputArray,
        imagePoints: cv_OutputArray,
        affine: *const cv_Affine3d,
        K: cv_InputArray,
        D: cv_InputArray,
        alpha: f64,
        jacobian: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv7fisheye13projectPointsERKNS_11_InputArrayERKNS_12_OutputArrayES3_S3_S3_S3_dS6_"]
    pub fn cv_fisheye_projectPoints1(
        objectPoints: cv_InputArray,
        imagePoints: cv_OutputArray,
        rvec: cv_InputArray,
        tvec: cv_InputArray,
        K: cv_InputArray,
        D: cv_InputArray,
        alpha: f64,
        jacobian: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Distorts 2D points using fisheye model.\n\n@param undistorted Array of object points, 1xN/Nx1 2-channel (or vector\\<Point2f\\> ), where N is\nthe number of points in the view.\n@param K Camera matrix \\f$K = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}\\f$.\n@param D Input vector of distortion coefficients \\f$(k_1, k_2, k_3, k_4)\\f$.\n@param alpha The skew coefficient.\n@param distorted Output array of image points, 1xN/Nx1 2-channel, or vector\\<Point2f\\> .\n\nNote that the function assumes the camera matrix of the undistorted points to be identity.\nThis means if you want to transform back points undistorted with undistortPoints() you have to\nmultiply them with \\f$P^{-1}\\f$."]
    #[link_name = "\u{1}_ZN2cv7fisheye13distortPointsERKNS_11_InputArrayERKNS_12_OutputArrayES3_S3_d"]
    pub fn cv_fisheye_distortPoints(
        undistorted: cv_InputArray,
        distorted: cv_OutputArray,
        K: cv_InputArray,
        D: cv_InputArray,
        alpha: f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Undistorts 2D points using fisheye model\n\n@param distorted Array of object points, 1xN/Nx1 2-channel (or vector\\<Point2f\\> ), where N is the\nnumber of points in the view.\n@param K Camera matrix \\f$K = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}\\f$.\n@param D Input vector of distortion coefficients \\f$(k_1, k_2, k_3, k_4)\\f$.\n@param R Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3\n1-channel or 1x1 3-channel\n@param P New camera matrix (3x3) or new projection matrix (3x4)\n@param undistorted Output array of image points, 1xN/Nx1 2-channel, or vector\\<Point2f\\> ."]
    #[link_name = "\u{1}_ZN2cv7fisheye15undistortPointsERKNS_11_InputArrayERKNS_12_OutputArrayES3_S3_S3_S3_"]
    pub fn cv_fisheye_undistortPoints(
        distorted: cv_InputArray,
        undistorted: cv_OutputArray,
        K: cv_InputArray,
        D: cv_InputArray,
        R: cv_InputArray,
        P: cv_InputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Computes undistortion and rectification maps for image transform by cv::remap(). If D is empty zero\ndistortion is used, if R or P is empty identity matrixes are used.\n\n@param K Camera matrix \\f$K = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}\\f$.\n@param D Input vector of distortion coefficients \\f$(k_1, k_2, k_3, k_4)\\f$.\n@param R Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3\n1-channel or 1x1 3-channel\n@param P New camera matrix (3x3) or new projection matrix (3x4)\n@param size Undistorted image size.\n@param m1type Type of the first output map that can be CV_32FC1 or CV_16SC2 . See convertMaps()\nfor details.\n@param map1 The first output map.\n@param map2 The second output map."]
    #[link_name = "\u{1}_ZN2cv7fisheye23initUndistortRectifyMapERKNS_11_InputArrayES3_S3_S3_RKNS_5Size_IiEEiRKNS_12_OutputArrayESA_"]
    pub fn cv_fisheye_initUndistortRectifyMap(
        K: cv_InputArray,
        D: cv_InputArray,
        R: cv_InputArray,
        P: cv_InputArray,
        size: *const cv_Size,
        m1type: ::std::os::raw::c_int,
        map1: cv_OutputArray,
        map2: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Transforms an image to compensate for fisheye lens distortion.\n\n@param distorted image with fisheye lens distortion.\n@param undistorted Output image with compensated fisheye lens distortion.\n@param K Camera matrix \\f$K = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}\\f$.\n@param D Input vector of distortion coefficients \\f$(k_1, k_2, k_3, k_4)\\f$.\n@param Knew Camera matrix of the distorted image. By default, it is the identity matrix but you\nmay additionally scale and shift the result by using a different matrix.\n@param new_size the new size\n\nThe function transforms an image to compensate radial and tangential lens distortion.\n\nThe function is simply a combination of fisheye::initUndistortRectifyMap (with unity R ) and remap\n(with bilinear interpolation). See the former function for details of the transformation being\nperformed.\n\nSee below the results of undistortImage.\n-   a\\) result of undistort of perspective camera model (all possible coefficients (k_1, k_2, k_3,\nk_4, k_5, k_6) of distortion were optimized under calibration)\n-   b\\) result of fisheye::undistortImage of fisheye camera model (all possible coefficients (k_1, k_2,\nk_3, k_4) of fisheye distortion were optimized under calibration)\n-   c\\) original image was captured with fisheye lens\n\nPictures a) and b) almost the same. But if we consider points of image located far from the center\nof image, we can notice that on image a) these points are distorted.\n\n[image](pics/fisheye_undistorted.jpg)"]
    #[link_name = "\u{1}_ZN2cv7fisheye14undistortImageERKNS_11_InputArrayERKNS_12_OutputArrayES3_S3_S3_RKNS_5Size_IiEE"]
    pub fn cv_fisheye_undistortImage(
        distorted: cv_InputArray,
        undistorted: cv_OutputArray,
        K: cv_InputArray,
        D: cv_InputArray,
        Knew: cv_InputArray,
        new_size: *const cv_Size,
    );
}
unsafe extern "C" {
    #[doc = " @brief Estimates new camera matrix for undistortion or rectification.\n\n@param K Camera matrix \\f$K = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{_1}\\f$.\n@param image_size Size of the image\n@param D Input vector of distortion coefficients \\f$(k_1, k_2, k_3, k_4)\\f$.\n@param R Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3\n1-channel or 1x1 3-channel\n@param P New camera matrix (3x3) or new projection matrix (3x4)\n@param balance Sets the new focal length in range between the min focal length and the max focal\nlength. Balance is in range of [0, 1].\n@param new_size the new size\n@param fov_scale Divisor for new focal length."]
    #[link_name = "\u{1}_ZN2cv7fisheye42estimateNewCameraMatrixForUndistortRectifyERKNS_11_InputArrayES3_RKNS_5Size_IiEES3_RKNS_12_OutputArrayEdS7_d"]
    pub fn cv_fisheye_estimateNewCameraMatrixForUndistortRectify(
        K: cv_InputArray,
        D: cv_InputArray,
        image_size: *const cv_Size,
        R: cv_InputArray,
        P: cv_OutputArray,
        balance: f64,
        new_size: *const cv_Size,
        fov_scale: f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Performs camera calibaration\n\n@param objectPoints vector of vectors of calibration pattern points in the calibration pattern\ncoordinate space.\n@param imagePoints vector of vectors of the projections of calibration pattern points.\nimagePoints.size() and objectPoints.size() and imagePoints[i].size() must be equal to\nobjectPoints[i].size() for each i.\n@param image_size Size of the image used only to initialize the intrinsic camera matrix.\n@param K Output 3x3 floating-point camera matrix\n\\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$ . If\nfisheye::CALIB_USE_INTRINSIC_GUESS/ is specified, some or all of fx, fy, cx, cy must be\ninitialized before calling the function.\n@param D Output vector of distortion coefficients \\f$(k_1, k_2, k_3, k_4)\\f$.\n@param rvecs Output vector of rotation vectors (see Rodrigues ) estimated for each pattern view.\nThat is, each k-th rotation vector together with the corresponding k-th translation vector (see\nthe next output parameter description) brings the calibration pattern from the model coordinate\nspace (in which object points are specified) to the world coordinate space, that is, a real\nposition of the calibration pattern in the k-th pattern view (k=0.. *M* -1).\n@param tvecs Output vector of translation vectors estimated for each pattern view.\n@param flags Different flags that may be zero or a combination of the following values:\n-   **fisheye::CALIB_USE_INTRINSIC_GUESS** cameraMatrix contains valid initial values of\nfx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image\ncenter ( imageSize is used), and focal distances are computed in a least-squares fashion.\n-   **fisheye::CALIB_RECOMPUTE_EXTRINSIC** Extrinsic will be recomputed after each iteration\nof intrinsic optimization.\n-   **fisheye::CALIB_CHECK_COND** The functions will check validity of condition number.\n-   **fisheye::CALIB_FIX_SKEW** Skew coefficient (alpha) is set to zero and stay zero.\n-   **fisheye::CALIB_FIX_K1..fisheye::CALIB_FIX_K4** Selected distortion coefficients\nare set to zeros and stay zero.\n-   **fisheye::CALIB_FIX_PRINCIPAL_POINT** The principal point is not changed during the global\noptimization. It stays at the center or at a different location specified when CALIB_USE_INTRINSIC_GUESS is set too.\n@param criteria Termination criteria for the iterative optimization algorithm."]
    #[link_name = "\u{1}_ZN2cv7fisheye9calibrateERKNS_11_InputArrayES3_RKNS_5Size_IiEERKNS_17_InputOutputArrayESA_RKNS_12_OutputArrayESD_iNS_12TermCriteriaE"]
    pub fn cv_fisheye_calibrate(
        objectPoints: cv_InputArrayOfArrays,
        imagePoints: cv_InputArrayOfArrays,
        image_size: *const cv_Size,
        K: cv_InputOutputArray,
        D: cv_InputOutputArray,
        rvecs: cv_OutputArrayOfArrays,
        tvecs: cv_OutputArrayOfArrays,
        flags: ::std::os::raw::c_int,
        criteria: cv_TermCriteria,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Stereo rectification for fisheye camera model\n\n@param K1 First camera matrix.\n@param D1 First camera distortion parameters.\n@param K2 Second camera matrix.\n@param D2 Second camera distortion parameters.\n@param imageSize Size of the image used for stereo calibration.\n@param R Rotation matrix between the coordinate systems of the first and the second\ncameras.\n@param tvec Translation vector between coordinate systems of the cameras.\n@param R1 Output 3x3 rectification transform (rotation matrix) for the first camera.\n@param R2 Output 3x3 rectification transform (rotation matrix) for the second camera.\n@param P1 Output 3x4 projection matrix in the new (rectified) coordinate systems for the first\ncamera.\n@param P2 Output 3x4 projection matrix in the new (rectified) coordinate systems for the second\ncamera.\n@param Q Output \\f$4 \\times 4\\f$ disparity-to-depth mapping matrix (see reprojectImageTo3D ).\n@param flags Operation flags that may be zero or CALIB_ZERO_DISPARITY . If the flag is set,\nthe function makes the principal points of each camera have the same pixel coordinates in the\nrectified views. And if the flag is not set, the function may still shift the images in the\nhorizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the\nuseful image area.\n@param newImageSize New image resolution after rectification. The same size should be passed to\ninitUndistortRectifyMap (see the stereo_calib.cpp sample in OpenCV samples directory). When (0,0)\nis passed (default), it is set to the original imageSize . Setting it to larger value can help you\npreserve details in the original image, especially when there is a big radial distortion.\n@param balance Sets the new focal length in range between the min focal length and the max focal\nlength. Balance is in range of [0, 1].\n@param fov_scale Divisor for new focal length."]
    #[link_name = "\u{1}_ZN2cv7fisheye13stereoRectifyERKNS_11_InputArrayES3_S3_S3_RKNS_5Size_IiEES3_S3_RKNS_12_OutputArrayESA_SA_SA_SA_iS7_dd"]
    pub fn cv_fisheye_stereoRectify(
        K1: cv_InputArray,
        D1: cv_InputArray,
        K2: cv_InputArray,
        D2: cv_InputArray,
        imageSize: *const cv_Size,
        R: cv_InputArray,
        tvec: cv_InputArray,
        R1: cv_OutputArray,
        R2: cv_OutputArray,
        P1: cv_OutputArray,
        P2: cv_OutputArray,
        Q: cv_OutputArray,
        flags: ::std::os::raw::c_int,
        newImageSize: *const cv_Size,
        balance: f64,
        fov_scale: f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Performs stereo calibration\n\n@param objectPoints Vector of vectors of the calibration pattern points.\n@param imagePoints1 Vector of vectors of the projections of the calibration pattern points,\nobserved by the first camera.\n@param imagePoints2 Vector of vectors of the projections of the calibration pattern points,\nobserved by the second camera.\n@param K1 Input/output first camera matrix:\n\\f$\\vecthreethree{f_x^{(j)}}{0}{c_x^{(j)}}{0}{f_y^{(j)}}{c_y^{(j)}}{0}{0}{1}\\f$ , \\f$j = 0,\\, 1\\f$ . If\nany of fisheye::CALIB_USE_INTRINSIC_GUESS , fisheye::CALIB_FIX_INTRINSIC are specified,\nsome or all of the matrix components must be initialized.\n@param D1 Input/output vector of distortion coefficients \\f$(k_1, k_2, k_3, k_4)\\f$ of 4 elements.\n@param K2 Input/output second camera matrix. The parameter is similar to K1 .\n@param D2 Input/output lens distortion coefficients for the second camera. The parameter is\nsimilar to D1 .\n@param imageSize Size of the image used only to initialize intrinsic camera matrix.\n@param R Output rotation matrix between the 1st and the 2nd camera coordinate systems.\n@param T Output translation vector between the coordinate systems of the cameras.\n@param flags Different flags that may be zero or a combination of the following values:\n-   **fisheye::CALIB_FIX_INTRINSIC** Fix K1, K2? and D1, D2? so that only R, T matrices\nare estimated.\n-   **fisheye::CALIB_USE_INTRINSIC_GUESS** K1, K2 contains valid initial values of\nfx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image\ncenter (imageSize is used), and focal distances are computed in a least-squares fashion.\n-   **fisheye::CALIB_RECOMPUTE_EXTRINSIC** Extrinsic will be recomputed after each iteration\nof intrinsic optimization.\n-   **fisheye::CALIB_CHECK_COND** The functions will check validity of condition number.\n-   **fisheye::CALIB_FIX_SKEW** Skew coefficient (alpha) is set to zero and stay zero.\n-   **fisheye::CALIB_FIX_K1..4** Selected distortion coefficients are set to zeros and stay\nzero.\n@param criteria Termination criteria for the iterative optimization algorithm."]
    #[link_name = "\u{1}_ZN2cv7fisheye15stereoCalibrateERKNS_11_InputArrayES3_S3_RKNS_17_InputOutputArrayES6_S6_S6_NS_5Size_IiEERKNS_12_OutputArrayESB_iNS_12TermCriteriaE"]
    pub fn cv_fisheye_stereoCalibrate(
        objectPoints: cv_InputArrayOfArrays,
        imagePoints1: cv_InputArrayOfArrays,
        imagePoints2: cv_InputArrayOfArrays,
        K1: cv_InputOutputArray,
        D1: cv_InputOutputArray,
        K2: cv_InputOutputArray,
        D2: cv_InputOutputArray,
        imageSize: cv_Size,
        R: cv_OutputArray,
        T: cv_OutputArray,
        flags: ::std::os::raw::c_int,
        criteria: cv_TermCriteria,
    ) -> f64;
}
#[doc = " @brief Returns result of asynchronous operations\n\nObject has attached asynchronous state.\nAssignment operator doesn't clone asynchronous state (it is shared between all instances).\n\nResult can be fetched via get() method only once."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_AsyncArray {
    pub p: *mut cv_AsyncArray_Impl,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_AsyncArray_Impl {
    _unused: [u8; 0],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_AsyncArray"][::std::mem::size_of::<cv_AsyncArray>() - 8usize];
    ["Alignment of cv_AsyncArray"][::std::mem::align_of::<cv_AsyncArray>() - 8usize];
    ["Offset of field: cv_AsyncArray::p"][::std::mem::offset_of!(cv_AsyncArray, p) - 0usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv10AsyncArray7releaseEv"]
    pub fn cv_AsyncArray_release(this: *mut cv_AsyncArray);
}
unsafe extern "C" {
    #[doc = " Fetch the result.\n@param[out] dst destination array\n\nWaits for result until container has valid result.\nThrows exception if exception was stored as a result.\n\nThrows exception on invalid container state.\n\n@note Result or stored exception can be fetched only once."]
    #[link_name = "\u{1}_ZNK2cv10AsyncArray3getERKNS_12_OutputArrayE"]
    pub fn cv_AsyncArray_get(this: *const cv_AsyncArray, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " Retrieving the result with timeout\n@param[out] dst destination array\n@param[in] timeoutNs timeout in nanoseconds, -1 for infinite wait\n\n@returns true if result is ready, false if the timeout has expired\n\n@note Result or stored exception can be fetched only once."]
    #[link_name = "\u{1}_ZNK2cv10AsyncArray3getERKNS_12_OutputArrayEl"]
    pub fn cv_AsyncArray_get1(
        this: *const cv_AsyncArray,
        dst: cv_OutputArray,
        timeoutNs: int64,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv10AsyncArray8wait_forEl"]
    pub fn cv_AsyncArray_wait_for(this: *const cv_AsyncArray, timeoutNs: int64) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv10AsyncArray5validEv"]
    pub fn cv_AsyncArray_valid(this: *const cv_AsyncArray) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv10AsyncArrayC1Ev"]
    pub fn cv_AsyncArray_AsyncArray(this: *mut cv_AsyncArray);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv10AsyncArrayC1ERKS0_"]
    pub fn cv_AsyncArray_AsyncArray1(this: *mut cv_AsyncArray, o: *const cv_AsyncArray);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv10AsyncArrayD1Ev"]
    pub fn cv_AsyncArray_AsyncArray_destructor(this: *mut cv_AsyncArray);
}
impl cv_AsyncArray {
    #[inline]
    pub unsafe fn release(&mut self) {
        cv_AsyncArray_release(self)
    }
    #[inline]
    pub unsafe fn get(&self, dst: cv_OutputArray) {
        cv_AsyncArray_get(self, dst)
    }
    #[inline]
    pub unsafe fn get1(&self, dst: cv_OutputArray, timeoutNs: int64) -> bool {
        cv_AsyncArray_get1(self, dst, timeoutNs)
    }
    #[inline]
    pub unsafe fn wait_for(&self, timeoutNs: int64) -> bool {
        cv_AsyncArray_wait_for(self, timeoutNs)
    }
    #[inline]
    pub unsafe fn valid(&self) -> bool {
        cv_AsyncArray_valid(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_AsyncArray_AsyncArray(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(o: *const cv_AsyncArray) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_AsyncArray_AsyncArray1(__bindgen_tmp.as_mut_ptr(), o);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cv_AsyncArray_AsyncArray_destructor(self)
    }
}
#[doc = " @brief This struct stores the scalar value (or array) of one of the following type: double, cv::String or int64.\n  @todo Maybe int64 is useless because double type exactly stores at least 2^52 integers."]
#[repr(C)]
pub struct cv_dnn_dnn4_v20191202_DictValue {
    pub type_: cv_Param,
    pub __bindgen_anon_1: cv_dnn_dnn4_v20191202_DictValue__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cv_dnn_dnn4_v20191202_DictValue__bindgen_ty_1 {
    pub pi: *mut __BindgenOpaqueArray<u64, 3usize>,
    pub pd: *mut __BindgenOpaqueArray<u64, 3usize>,
    pub ps: *mut __BindgenOpaqueArray<u64, 6usize>,
    pub pv: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_dnn_dnn4_v20191202_DictValue__bindgen_ty_1"]
        [::std::mem::size_of::<cv_dnn_dnn4_v20191202_DictValue__bindgen_ty_1>() - 8usize];
    ["Alignment of cv_dnn_dnn4_v20191202_DictValue__bindgen_ty_1"]
        [::std::mem::align_of::<cv_dnn_dnn4_v20191202_DictValue__bindgen_ty_1>() - 8usize];
    ["Offset of field: cv_dnn_dnn4_v20191202_DictValue__bindgen_ty_1::pi"]
        [::std::mem::offset_of!(cv_dnn_dnn4_v20191202_DictValue__bindgen_ty_1, pi) - 0usize];
    ["Offset of field: cv_dnn_dnn4_v20191202_DictValue__bindgen_ty_1::pd"]
        [::std::mem::offset_of!(cv_dnn_dnn4_v20191202_DictValue__bindgen_ty_1, pd) - 0usize];
    ["Offset of field: cv_dnn_dnn4_v20191202_DictValue__bindgen_ty_1::ps"]
        [::std::mem::offset_of!(cv_dnn_dnn4_v20191202_DictValue__bindgen_ty_1, ps) - 0usize];
    ["Offset of field: cv_dnn_dnn4_v20191202_DictValue__bindgen_ty_1::pv"]
        [::std::mem::offset_of!(cv_dnn_dnn4_v20191202_DictValue__bindgen_ty_1, pv) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_dnn_dnn4_v20191202_DictValue"]
        [::std::mem::size_of::<cv_dnn_dnn4_v20191202_DictValue>() - 16usize];
    ["Alignment of cv_dnn_dnn4_v20191202_DictValue"]
        [::std::mem::align_of::<cv_dnn_dnn4_v20191202_DictValue>() - 8usize];
    ["Offset of field: cv_dnn_dnn4_v20191202_DictValue::type_"]
        [::std::mem::offset_of!(cv_dnn_dnn4_v20191202_DictValue, type_) - 0usize];
};
#[doc = " @brief This class implements name-value dictionary, values are instances of DictValue."]
#[repr(C)]
pub struct cv_dnn_dnn4_v20191202_Dict {
    pub dict: cv_dnn_dnn4_v20191202_Dict__Dict,
}
pub type cv_dnn_dnn4_v20191202_Dict__Dict = std_map;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_dnn_dnn4_v20191202_Dict"]
        [::std::mem::size_of::<cv_dnn_dnn4_v20191202_Dict>() - 48usize];
    ["Alignment of cv_dnn_dnn4_v20191202_Dict"]
        [::std::mem::align_of::<cv_dnn_dnn4_v20191202_Dict>() - 8usize];
    ["Offset of field: cv_dnn_dnn4_v20191202_Dict::dict"]
        [::std::mem::offset_of!(cv_dnn_dnn4_v20191202_Dict, dict) - 0usize];
};
#[doc = "! @addtogroup dnn\n! @{"]
pub type cv_dnn_dnn4_v20191202_MatShape = std_vector;
#[doc = "! DNN_BACKEND_DEFAULT equals to DNN_BACKEND_INFERENCE_ENGINE if\n! OpenCV is built with Intel's Inference Engine library or\n! DNN_BACKEND_OPENCV otherwise."]
pub const cv_dnn_dnn4_v20191202_Backend_DNN_BACKEND_DEFAULT: cv_dnn_dnn4_v20191202_Backend = 0;
#[doc = "! DNN_BACKEND_DEFAULT equals to DNN_BACKEND_INFERENCE_ENGINE if\n! OpenCV is built with Intel's Inference Engine library or\n! DNN_BACKEND_OPENCV otherwise."]
pub const cv_dnn_dnn4_v20191202_Backend_DNN_BACKEND_HALIDE: cv_dnn_dnn4_v20191202_Backend = 1;
#[doc = "!< Intel's Inference Engine computational backend\n!< @sa setInferenceEngineBackendType"]
pub const cv_dnn_dnn4_v20191202_Backend_DNN_BACKEND_INFERENCE_ENGINE:
    cv_dnn_dnn4_v20191202_Backend = 2;
pub const cv_dnn_dnn4_v20191202_Backend_DNN_BACKEND_OPENCV: cv_dnn_dnn4_v20191202_Backend = 3;
pub const cv_dnn_dnn4_v20191202_Backend_DNN_BACKEND_VKCOM: cv_dnn_dnn4_v20191202_Backend = 4;
pub const cv_dnn_dnn4_v20191202_Backend_DNN_BACKEND_CUDA: cv_dnn_dnn4_v20191202_Backend = 5;
#[doc = " @brief Enum of computation backends supported by layers.\n @see Net::setPreferableBackend"]
pub type cv_dnn_dnn4_v20191202_Backend = ::std::os::raw::c_uint;
pub const cv_dnn_dnn4_v20191202_Target_DNN_TARGET_CPU: cv_dnn_dnn4_v20191202_Target = 0;
pub const cv_dnn_dnn4_v20191202_Target_DNN_TARGET_OPENCL: cv_dnn_dnn4_v20191202_Target = 1;
pub const cv_dnn_dnn4_v20191202_Target_DNN_TARGET_OPENCL_FP16: cv_dnn_dnn4_v20191202_Target = 2;
pub const cv_dnn_dnn4_v20191202_Target_DNN_TARGET_MYRIAD: cv_dnn_dnn4_v20191202_Target = 3;
pub const cv_dnn_dnn4_v20191202_Target_DNN_TARGET_VULKAN: cv_dnn_dnn4_v20191202_Target = 4;
#[doc = "!< FPGA device with CPU fallbacks using Inference Engine's Heterogeneous plugin."]
pub const cv_dnn_dnn4_v20191202_Target_DNN_TARGET_FPGA: cv_dnn_dnn4_v20191202_Target = 5;
pub const cv_dnn_dnn4_v20191202_Target_DNN_TARGET_CUDA: cv_dnn_dnn4_v20191202_Target = 6;
pub const cv_dnn_dnn4_v20191202_Target_DNN_TARGET_CUDA_FP16: cv_dnn_dnn4_v20191202_Target = 7;
#[doc = " @brief Enum of target devices for computations.\n @see Net::setPreferableTarget"]
pub type cv_dnn_dnn4_v20191202_Target = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120220getAvailableBackendsEv"]
    pub fn cv_dnn_dnn4_v20191202_getAvailableBackends() -> std_vector;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120219getAvailableTargetsENS1_7BackendE"]
    pub fn cv_dnn_dnn4_v20191202_getAvailableTargets(
        be: cv_dnn_dnn4_v20191202_Backend,
    ) -> std_vector;
}
#[doc = " @brief This class provides all data needed to initialize layer.\n\n It includes dictionary with scalar params (which can be read by using Dict interface),\n blob params #blobs and optional meta information: #name and #type of layer instance."]
#[repr(C)]
pub struct cv_dnn_dnn4_v20191202_LayerParams {
    pub _base: cv_dnn_dnn4_v20191202_Dict,
    #[doc = "!< List of learned parameters stored as blobs."]
    pub blobs: std_vector,
    #[doc = "!< Name of the layer instance (optional, can be used internal purposes)."]
    pub name: cv_String,
    #[doc = "!< Type name which was used for creating layer by layer factory (optional)."]
    pub type_: cv_String,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_dnn_dnn4_v20191202_LayerParams"]
        [::std::mem::size_of::<cv_dnn_dnn4_v20191202_LayerParams>() - 136usize];
    ["Alignment of cv_dnn_dnn4_v20191202_LayerParams"]
        [::std::mem::align_of::<cv_dnn_dnn4_v20191202_LayerParams>() - 8usize];
    ["Offset of field: cv_dnn_dnn4_v20191202_LayerParams::blobs"]
        [::std::mem::offset_of!(cv_dnn_dnn4_v20191202_LayerParams, blobs) - 48usize];
    ["Offset of field: cv_dnn_dnn4_v20191202_LayerParams::name"]
        [::std::mem::offset_of!(cv_dnn_dnn4_v20191202_LayerParams, name) - 72usize];
    ["Offset of field: cv_dnn_dnn4_v20191202_LayerParams::type_"]
        [::std::mem::offset_of!(cv_dnn_dnn4_v20191202_LayerParams, type_) - 104usize];
};
#[repr(C)]
pub struct cv_dnn_dnn4_v20191202_BackendNode__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief Derivatives of this class encapsulates functions of certain backends."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_dnn_dnn4_v20191202_BackendNode {
    pub vtable_: *const cv_dnn_dnn4_v20191202_BackendNode__bindgen_vtable,
    #[doc = "!< Backend identifier."]
    pub backendId: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_dnn_dnn4_v20191202_BackendNode"]
        [::std::mem::size_of::<cv_dnn_dnn4_v20191202_BackendNode>() - 16usize];
    ["Alignment of cv_dnn_dnn4_v20191202_BackendNode"]
        [::std::mem::align_of::<cv_dnn_dnn4_v20191202_BackendNode>() - 8usize];
    ["Offset of field: cv_dnn_dnn4_v20191202_BackendNode::backendId"]
        [::std::mem::offset_of!(cv_dnn_dnn4_v20191202_BackendNode, backendId) - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120211BackendNodeC1Ei"]
    pub fn cv_dnn_dnn4_v20191202_BackendNode_BackendNode(
        this: *mut cv_dnn_dnn4_v20191202_BackendNode,
        backendId: ::std::os::raw::c_int,
    );
}
impl cv_dnn_dnn4_v20191202_BackendNode {
    #[inline]
    pub unsafe fn new(backendId: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_dnn_dnn4_v20191202_BackendNode_BackendNode(__bindgen_tmp.as_mut_ptr(), backendId);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120211BackendNodeD1Ev"]
    pub fn cv_dnn_dnn4_v20191202_BackendNode_BackendNode_destructor(
        this: *mut cv_dnn_dnn4_v20191202_BackendNode,
    );
}
#[repr(C)]
pub struct cv_dnn_dnn4_v20191202_BackendWrapper__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief Derivatives of this class wraps cv::Mat for different backends and targets."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_dnn_dnn4_v20191202_BackendWrapper {
    pub vtable_: *const cv_dnn_dnn4_v20191202_BackendWrapper__bindgen_vtable,
    #[doc = "!< Backend identifier."]
    pub backendId: ::std::os::raw::c_int,
    #[doc = "!< Target identifier."]
    pub targetId: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_dnn_dnn4_v20191202_BackendWrapper"]
        [::std::mem::size_of::<cv_dnn_dnn4_v20191202_BackendWrapper>() - 16usize];
    ["Alignment of cv_dnn_dnn4_v20191202_BackendWrapper"]
        [::std::mem::align_of::<cv_dnn_dnn4_v20191202_BackendWrapper>() - 8usize];
    ["Offset of field: cv_dnn_dnn4_v20191202_BackendWrapper::backendId"]
        [::std::mem::offset_of!(cv_dnn_dnn4_v20191202_BackendWrapper, backendId) - 8usize];
    ["Offset of field: cv_dnn_dnn4_v20191202_BackendWrapper::targetId"]
        [::std::mem::offset_of!(cv_dnn_dnn4_v20191202_BackendWrapper, targetId) - 12usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120214BackendWrapperC2Eii"]
    pub fn cv_dnn_dnn4_v20191202_BackendWrapper_BackendWrapper(
        this: *mut cv_dnn_dnn4_v20191202_BackendWrapper,
        backendId: ::std::os::raw::c_int,
        targetId: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Wrap cv::Mat for specific backend and target.\n @param[in] targetId Target identifier.\n @param[in] m cv::Mat for wrapping.\n\n Make CPU->GPU data transfer if it's require for the target."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120214BackendWrapperC2EiRKNS_3MatE"]
    pub fn cv_dnn_dnn4_v20191202_BackendWrapper_BackendWrapper1(
        this: *mut cv_dnn_dnn4_v20191202_BackendWrapper,
        targetId: ::std::os::raw::c_int,
        m: *const cv_Mat,
    );
}
unsafe extern "C" {
    #[doc = " @brief Make wrapper for reused cv::Mat.\n @param[in] base Wrapper of cv::Mat that will be reused.\n @param[in] shape Specific shape.\n\n Initialize wrapper from another one. It'll wrap the same host CPU\n memory and mustn't allocate memory on device(i.e. GPU). It might\n has different shape. Use in case of CPU memory reusing for reuse\n associated memory on device too."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120214BackendWrapperC2ERKNS_3PtrIS2_EERKSt6vectorIiSaIiEE"]
    pub fn cv_dnn_dnn4_v20191202_BackendWrapper_BackendWrapper2(
        this: *mut cv_dnn_dnn4_v20191202_BackendWrapper,
        base: *const cv_Ptr,
        shape: *const cv_dnn_dnn4_v20191202_MatShape,
    );
}
impl cv_dnn_dnn4_v20191202_BackendWrapper {
    #[inline]
    pub unsafe fn new(backendId: ::std::os::raw::c_int, targetId: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_dnn_dnn4_v20191202_BackendWrapper_BackendWrapper(
            __bindgen_tmp.as_mut_ptr(),
            backendId,
            targetId,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(targetId: ::std::os::raw::c_int, m: *const cv_Mat) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_dnn_dnn4_v20191202_BackendWrapper_BackendWrapper1(
            __bindgen_tmp.as_mut_ptr(),
            targetId,
            m,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(base: *const cv_Ptr, shape: *const cv_dnn_dnn4_v20191202_MatShape) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_dnn_dnn4_v20191202_BackendWrapper_BackendWrapper2(
            __bindgen_tmp.as_mut_ptr(),
            base,
            shape,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120214BackendWrapperD1Ev"]
    pub fn cv_dnn_dnn4_v20191202_BackendWrapper_BackendWrapper_destructor(
        this: *mut cv_dnn_dnn4_v20191202_BackendWrapper,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_dnn_dnn4_v20191202_ActivationLayer {
    _unused: [u8; 0],
}
#[doc = " @brief This interface class allows to build new Layers - are building blocks of networks.\n\n Each class, derived from Layer, must implement allocate() methods to declare own outputs and forward() to compute outputs.\n Also before using the new layer into networks you must register your layer by using one of @ref dnnLayerFactory \"LayerFactory\" macros."]
#[repr(C)]
pub struct cv_dnn_dnn4_v20191202_Layer {
    pub _base: cv_Algorithm,
    #[doc = "! List of learned parameters must be stored here to allow read them by using Net::getParam()."]
    pub blobs: std_vector,
    #[doc = "!< Name of the layer instance, can be used for logging or other internal purposes."]
    pub name: cv_String,
    #[doc = "!< Type name which was used for creating layer by layer factory."]
    pub type_: cv_String,
    #[doc = "!< prefer target for layer forwarding"]
    pub preferableTarget: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_dnn_dnn4_v20191202_Layer"]
        [::std::mem::size_of::<cv_dnn_dnn4_v20191202_Layer>() - 104usize];
    ["Alignment of cv_dnn_dnn4_v20191202_Layer"]
        [::std::mem::align_of::<cv_dnn_dnn4_v20191202_Layer>() - 8usize];
    ["Offset of field: cv_dnn_dnn4_v20191202_Layer::blobs"]
        [::std::mem::offset_of!(cv_dnn_dnn4_v20191202_Layer, blobs) - 8usize];
    ["Offset of field: cv_dnn_dnn4_v20191202_Layer::name"]
        [::std::mem::offset_of!(cv_dnn_dnn4_v20191202_Layer, name) - 32usize];
    ["Offset of field: cv_dnn_dnn4_v20191202_Layer::type_"]
        [::std::mem::offset_of!(cv_dnn_dnn4_v20191202_Layer, type_) - 64usize];
    ["Offset of field: cv_dnn_dnn4_v20191202_Layer::preferableTarget"]
        [::std::mem::offset_of!(cv_dnn_dnn4_v20191202_Layer, preferableTarget) - 96usize];
};
unsafe extern "C" {
    #[doc = " @brief Given the @p input blobs, computes the output @p blobs.\n  @param[in]  inputs  the input blobs.\n  @param[out] outputs allocated output blobs, which will store results of the computation.\n  @param[out] internals allocated internal blobs"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Layer16forward_fallbackERKNS_11_InputArrayERKNS_12_OutputArrayES8_"]
    pub fn cv_dnn_dnn4_v20191202_Layer_forward_fallback(
        this: *mut cv_dnn_dnn4_v20191202_Layer,
        inputs: cv_InputArrayOfArrays,
        outputs: cv_OutputArrayOfArrays,
        internals: cv_OutputArrayOfArrays,
    );
}
unsafe extern "C" {
    #[doc = " @brief\n @overload\n @deprecated Use Layer::finalize(InputArrayOfArrays, OutputArrayOfArrays) instead"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Layer8finalizeERKSt6vectorINS_3MatESaIS4_EERS6_"]
    pub fn cv_dnn_dnn4_v20191202_Layer_finalize2(
        this: *mut cv_dnn_dnn4_v20191202_Layer,
        inputs: *const std_vector,
        outputs: *mut std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @brief\n @overload\n @deprecated Use Layer::finalize(InputArrayOfArrays, OutputArrayOfArrays) instead"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Layer8finalizeERKSt6vectorINS_3MatESaIS4_EE"]
    pub fn cv_dnn_dnn4_v20191202_Layer_finalize3(
        this: *mut cv_dnn_dnn4_v20191202_Layer,
        inputs: *const std_vector,
    ) -> std_vector;
}
unsafe extern "C" {
    #[doc = " @brief Allocates layer and computes output.\n  @deprecated This method will be removed in the future release."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Layer3runERKSt6vectorINS_3MatESaIS4_EERS6_S9_"]
    pub fn cv_dnn_dnn4_v20191202_Layer_run(
        this: *mut cv_dnn_dnn4_v20191202_Layer,
        inputs: *const std_vector,
        outputs: *mut std_vector,
        internals: *mut std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Layer13setParamsFromERKNS1_11LayerParamsE"]
    pub fn cv_dnn_dnn4_v20191202_Layer_setParamsFrom(
        this: *mut cv_dnn_dnn4_v20191202_Layer,
        params: *const cv_dnn_dnn4_v20191202_LayerParams,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025LayerC1Ev"]
    pub fn cv_dnn_dnn4_v20191202_Layer_Layer(this: *mut cv_dnn_dnn4_v20191202_Layer);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025LayerC1ERKNS1_11LayerParamsE"]
    pub fn cv_dnn_dnn4_v20191202_Layer_Layer1(
        this: *mut cv_dnn_dnn4_v20191202_Layer,
        params: *const cv_dnn_dnn4_v20191202_LayerParams,
    );
}
impl cv_dnn_dnn4_v20191202_Layer {
    #[inline]
    pub unsafe fn forward_fallback(
        &mut self,
        inputs: cv_InputArrayOfArrays,
        outputs: cv_OutputArrayOfArrays,
        internals: cv_OutputArrayOfArrays,
    ) {
        cv_dnn_dnn4_v20191202_Layer_forward_fallback(self, inputs, outputs, internals)
    }
    #[inline]
    pub unsafe fn finalize(&mut self, inputs: *const std_vector, outputs: *mut std_vector) {
        cv_dnn_dnn4_v20191202_Layer_finalize2(self, inputs, outputs)
    }
    #[inline]
    pub unsafe fn finalize1(&mut self, inputs: *const std_vector) -> std_vector {
        cv_dnn_dnn4_v20191202_Layer_finalize3(self, inputs)
    }
    #[inline]
    pub unsafe fn run(
        &mut self,
        inputs: *const std_vector,
        outputs: *mut std_vector,
        internals: *mut std_vector,
    ) {
        cv_dnn_dnn4_v20191202_Layer_run(self, inputs, outputs, internals)
    }
    #[inline]
    pub unsafe fn setParamsFrom(&mut self, params: *const cv_dnn_dnn4_v20191202_LayerParams) {
        cv_dnn_dnn4_v20191202_Layer_setParamsFrom(self, params)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_dnn_dnn4_v20191202_Layer_Layer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(params: *const cv_dnn_dnn4_v20191202_LayerParams) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_dnn_dnn4_v20191202_Layer_Layer1(__bindgen_tmp.as_mut_ptr(), params);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[doc = " @brief Computes and sets internal parameters according to inputs, outputs and blobs.\n  @deprecated Use Layer::finalize(InputArrayOfArrays, OutputArrayOfArrays) instead\n  @param[in]  input  vector of already allocated input blobs\n  @param[out] output vector of already allocated output blobs\n\n If this method is called after network has allocated all memory for input and output blobs\n and before inferencing."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Layer8finalizeERKSt6vectorIPNS_3MatESaIS5_EERS3_IS4_SaIS4_EE"]
    pub fn cv_dnn_dnn4_v20191202_Layer_finalize(
        this: *mut ::std::os::raw::c_void,
        input: *const std_vector,
        output: *mut std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @brief Computes and sets internal parameters according to inputs, outputs and blobs.\n  @param[in]  inputs  vector of already allocated input blobs\n  @param[out] outputs vector of already allocated output blobs\n\n If this method is called after network has allocated all memory for input and output blobs\n and before inferencing."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Layer8finalizeERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_dnn_dnn4_v20191202_Layer_finalize1(
        this: *mut ::std::os::raw::c_void,
        inputs: cv_InputArrayOfArrays,
        outputs: cv_OutputArrayOfArrays,
    );
}
unsafe extern "C" {
    #[doc = " @brief Given the @p input blobs, computes the output @p blobs.\n  @deprecated Use Layer::forward(InputArrayOfArrays, OutputArrayOfArrays, OutputArrayOfArrays) instead\n  @param[in]  input  the input blobs.\n  @param[out] output allocated output blobs, which will store results of the computation.\n  @param[out] internals allocated internal blobs"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Layer7forwardERSt6vectorIPNS_3MatESaIS5_EERS3_IS4_SaIS4_EESB_"]
    pub fn cv_dnn_dnn4_v20191202_Layer_forward(
        this: *mut ::std::os::raw::c_void,
        input: *mut std_vector,
        output: *mut std_vector,
        internals: *mut std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @brief Given the @p input blobs, computes the output @p blobs.\n  @param[in]  inputs  the input blobs.\n  @param[out] outputs allocated output blobs, which will store results of the computation.\n  @param[out] internals allocated internal blobs"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Layer7forwardERKNS_11_InputArrayERKNS_12_OutputArrayES8_"]
    pub fn cv_dnn_dnn4_v20191202_Layer_forward1(
        this: *mut ::std::os::raw::c_void,
        inputs: cv_InputArrayOfArrays,
        outputs: cv_OutputArrayOfArrays,
        internals: cv_OutputArrayOfArrays,
    );
}
unsafe extern "C" {
    #[doc = " @brief Returns index of input blob into the input array.\n  @param inputName label of input blob\n\n Each layer input and output can be labeled to easily identify them using \"%<layer_name%>[.output_name]\" notation.\n This method maps label of input blob to its index into input vector."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Layer16inputNameToIndexENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_dnn_dnn4_v20191202_Layer_inputNameToIndex(
        this: *mut ::std::os::raw::c_void,
        inputName: cv_String,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Returns index of output blob in output array.\n  @see inputNameToIndex()"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Layer17outputNameToIndexERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_dnn_dnn4_v20191202_Layer_outputNameToIndex(
        this: *mut ::std::os::raw::c_void,
        outputName: *const cv_String,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Ask layer if it support specific backend for doing computations.\n @param[in] backendId computation backend identifier.\n @see Backend"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Layer14supportBackendEi"]
    pub fn cv_dnn_dnn4_v20191202_Layer_supportBackend(
        this: *mut ::std::os::raw::c_void,
        backendId: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Returns Halide backend node.\n @param[in] inputs Input Halide buffers.\n @see BackendNode, BackendWrapper\n\n Input buffers should be exactly the same that will be used in forward invocations.\n Despite we can use Halide::ImageParam based on input shape only,\n it helps prevent some memory management issues (if something wrong,\n Halide tests will be failed)."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Layer10initHalideERKSt6vectorINS_3PtrINS1_14BackendWrapperEEESaIS6_EE"]
    pub fn cv_dnn_dnn4_v20191202_Layer_initHalide(
        this: *mut ::std::os::raw::c_void,
        inputs: *const std_vector,
    ) -> cv_Ptr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Layer13initInfEngineERKSt6vectorINS_3PtrINS1_14BackendWrapperEEESaIS6_EE"]
    pub fn cv_dnn_dnn4_v20191202_Layer_initInfEngine(
        this: *mut ::std::os::raw::c_void,
        inputs: *const std_vector,
    ) -> cv_Ptr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Layer10initNgraphERKSt6vectorINS_3PtrINS1_14BackendWrapperEEESaIS6_EERKS3_INS4_INS1_11BackendNodeEEESaISC_EE"]
    pub fn cv_dnn_dnn4_v20191202_Layer_initNgraph(
        this: *mut ::std::os::raw::c_void,
        inputs: *const std_vector,
        nodes: *const std_vector,
    ) -> cv_Ptr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Layer9initVkComERKSt6vectorINS_3PtrINS1_14BackendWrapperEEESaIS6_EE"]
    pub fn cv_dnn_dnn4_v20191202_Layer_initVkCom(
        this: *mut ::std::os::raw::c_void,
        inputs: *const std_vector,
    ) -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Returns a CUDA backend node\n\n @param   context  void pointer to CSLContext object\n @param   inputs   layer inputs\n @param   outputs  layer outputs"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Layer8initCUDAEPvRKSt6vectorINS_3PtrINS1_14BackendWrapperEEESaIS7_EESB_"]
    pub fn cv_dnn_dnn4_v20191202_Layer_initCUDA(
        this: *mut ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
        inputs: *const std_vector,
        outputs: *const std_vector,
    ) -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Automatic Halide scheduling based on layer hyper-parameters.\n @param[in] node Backend node with Halide functions.\n @param[in] inputs Blobs that will be used in forward invocations.\n @param[in] outputs Blobs that will be used in forward invocations.\n @param[in] targetId Target identifier\n @see BackendNode, Target\n\n Layer don't use own Halide::Func members because we can have applied\n layers fusing. In this way the fused function should be scheduled."]
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912025Layer20applyHalideSchedulerERNS_3PtrINS1_11BackendNodeEEERKSt6vectorIPNS_3MatESaIS9_EERKS7_IS8_SaIS8_EEi"]
    pub fn cv_dnn_dnn4_v20191202_Layer_applyHalideScheduler(
        this: *mut ::std::os::raw::c_void,
        node: *mut cv_Ptr,
        inputs: *const std_vector,
        outputs: *const std_vector,
        targetId: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Implement layers fusing.\n @param[in] node Backend node of bottom layer.\n @see BackendNode\n\n Actual for graph-based backends. If layer attached successfully,\n returns non-empty cv::Ptr to node of the same backend.\n Fuse only over the last function."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Layer9tryAttachERKNS_3PtrINS1_11BackendNodeEEE"]
    pub fn cv_dnn_dnn4_v20191202_Layer_tryAttach(
        this: *mut ::std::os::raw::c_void,
        node: *const cv_Ptr,
    ) -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Tries to attach to the layer the subsequent activation layer, i.e. do the layer fusion in a partial case.\n @param[in] layer The subsequent activation layer.\n\n Returns true if the activation layer has been attached successfully."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Layer13setActivationERKNS_3PtrINS1_15ActivationLayerEEE"]
    pub fn cv_dnn_dnn4_v20191202_Layer_setActivation(
        this: *mut ::std::os::raw::c_void,
        layer: *const cv_Ptr,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Try to fuse current layer with a next one\n @param[in] top Next layer to be fused.\n @returns True if fusion was performed."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Layer7tryFuseERNS_3PtrIS2_EE"]
    pub fn cv_dnn_dnn4_v20191202_Layer_tryFuse(
        this: *mut ::std::os::raw::c_void,
        top: *mut cv_Ptr,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Returns parameters of layers with channel-wise multiplication and addition.\n @param[out] scale Channel-wise multipliers. Total number of values should\n                   be equal to number of channels.\n @param[out] shift Channel-wise offsets. Total number of values should\n                   be equal to number of channels.\n\n Some layers can fuse their transformations with further layers.\n In example, convolution + batch normalization. This way base layer\n use weights from layer after it. Fused layer is skipped.\n By default, @p scale and @p shift are empty that means layer has no\n element-wise multiplications or additions."]
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912025Layer13getScaleShiftERNS_3MatES4_"]
    pub fn cv_dnn_dnn4_v20191202_Layer_getScaleShift(
        this: *mut ::std::os::raw::c_void,
        scale: *mut cv_Mat,
        shift: *mut cv_Mat,
    );
}
unsafe extern "C" {
    #[doc = " @brief \"Deattaches\" all the layers, attached to particular layer."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Layer13unsetAttachedEv"]
    pub fn cv_dnn_dnn4_v20191202_Layer_unsetAttached(this: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912025Layer15getMemoryShapesERKSt6vectorIS3_IiSaIiEESaIS5_EEiRS7_SA_"]
    pub fn cv_dnn_dnn4_v20191202_Layer_getMemoryShapes(
        this: *mut ::std::os::raw::c_void,
        inputs: *const std_vector,
        requiredOutputs: ::std::os::raw::c_int,
        outputs: *mut std_vector,
        internals: *mut std_vector,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025LayerD1Ev"]
    pub fn cv_dnn_dnn4_v20191202_Layer_Layer_destructor(this: *mut cv_dnn_dnn4_v20191202_Layer);
}
#[doc = " @brief This class allows to create and manipulate comprehensive artificial neural networks.\n\n Neural network is presented as directed acyclic graph (DAG), where vertices are Layer instances,\n and edges specify relationships between layers inputs and outputs.\n\n Each network layer has unique integer id and unique string name inside its network.\n LayerId can store either layer name or layer id.\n\n This class supports reference counting of its instances, i. e. copies point to the same instance."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_dnn_dnn4_v20191202_Net {
    pub impl_: cv_Ptr,
}
#[doc = " @brief Container for strings and integers."]
pub type cv_dnn_dnn4_v20191202_Net_LayerId = cv_dnn_dnn4_v20191202_DictValue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_dnn_dnn4_v20191202_Net_Impl {
    _unused: [u8; 0],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_dnn_dnn4_v20191202_Net"]
        [::std::mem::size_of::<cv_dnn_dnn4_v20191202_Net>() - 16usize];
    ["Alignment of cv_dnn_dnn4_v20191202_Net"]
        [::std::mem::align_of::<cv_dnn_dnn4_v20191202_Net>() - 8usize];
    ["Offset of field: cv_dnn_dnn4_v20191202_Net::impl_"]
        [::std::mem::offset_of!(cv_dnn_dnn4_v20191202_Net, impl_) - 0usize];
};
unsafe extern "C" {
    #[doc = " @brief Create a network from Intel's Model Optimizer intermediate representation (IR).\n  @param[in] xml XML configuration file with network's topology.\n  @param[in] bin Binary file with trained weights.\n  Networks imported from Intel's Model Optimizer are launched in Intel's Inference Engine\n  backend."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net22readFromModelOptimizerERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESA_"]
    pub fn cv_dnn_dnn4_v20191202_Net_readFromModelOptimizer(
        xml: *const cv_String,
        bin: *const cv_String,
    ) -> cv_dnn_dnn4_v20191202_Net;
}
unsafe extern "C" {
    #[doc = " @brief Create a network from Intel's Model Optimizer in-memory buffers with intermediate representation (IR).\n  @param[in] bufferModelConfig buffer with model's configuration.\n  @param[in] bufferWeights buffer with model's trained weights.\n  @returns Net object."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net22readFromModelOptimizerERKSt6vectorIhSaIhEES7_"]
    pub fn cv_dnn_dnn4_v20191202_Net_readFromModelOptimizer1(
        bufferModelConfig: *const std_vector,
        bufferWeights: *const std_vector,
    ) -> cv_dnn_dnn4_v20191202_Net;
}
unsafe extern "C" {
    #[doc = " @brief Create a network from Intel's Model Optimizer in-memory buffers with intermediate representation (IR).\n  @param[in] bufferModelConfigPtr buffer pointer of model's configuration.\n  @param[in] bufferModelConfigSize buffer size of model's configuration.\n  @param[in] bufferWeightsPtr buffer pointer of model's trained weights.\n  @param[in] bufferWeightsSize buffer size of model's trained weights.\n  @returns Net object."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net22readFromModelOptimizerEPKhmS4_m"]
    pub fn cv_dnn_dnn4_v20191202_Net_readFromModelOptimizer2(
        bufferModelConfigPtr: *const uchar,
        bufferModelConfigSize: usize,
        bufferWeightsPtr: *const uchar,
        bufferWeightsSize: usize,
    ) -> cv_dnn_dnn4_v20191202_Net;
}
unsafe extern "C" {
    #[doc = " Returns true if there are no layers in the network."]
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912023Net5emptyEv"]
    pub fn cv_dnn_dnn4_v20191202_Net_empty(this: *const cv_dnn_dnn4_v20191202_Net) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Dump net to String\n  @returns String with structure, hyperparameters, backend, target and fusion\n  Call method after setInput(). To see correct backend, target and fusion run after forward()."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net4dumpB5cxx11Ev"]
    pub fn cv_dnn_dnn4_v20191202_Net_dump(this: *mut cv_dnn_dnn4_v20191202_Net) -> cv_String;
}
unsafe extern "C" {
    #[doc = " @brief Dump net structure, hyperparameters, backend, target and fusion to dot file\n  @param path   path to output file with .dot extension\n  @see dump()"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net10dumpToFileERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_dnn_dnn4_v20191202_Net_dumpToFile(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        path: *const cv_String,
    );
}
unsafe extern "C" {
    #[doc = " @brief Adds new layer to the net.\n  @param name   unique name of the adding layer.\n  @param type   typename of the adding layer (type must be registered in LayerRegister).\n  @param params parameters which will be used to initialize the creating layer.\n  @returns unique identifier of created layer, or -1 if a failure will happen."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net8addLayerERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESA_RNS1_11LayerParamsE"]
    pub fn cv_dnn_dnn4_v20191202_Net_addLayer(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        name: *const cv_String,
        type_: *const cv_String,
        params: *mut cv_dnn_dnn4_v20191202_LayerParams,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Adds new layer and connects its first input to the first output of previously added layer.\n  @see addLayer()"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net14addLayerToPrevERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESA_RNS1_11LayerParamsE"]
    pub fn cv_dnn_dnn4_v20191202_Net_addLayerToPrev(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        name: *const cv_String,
        type_: *const cv_String,
        params: *mut cv_dnn_dnn4_v20191202_LayerParams,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Converts string name of the layer to the integer identifier.\n  @returns id of the layer, or -1 if the layer wasn't found."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net10getLayerIdERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_dnn_dnn4_v20191202_Net_getLayerId(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        layer: *const cv_String,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912023Net13getLayerNamesB5cxx11Ev"]
    pub fn cv_dnn_dnn4_v20191202_Net_getLayerNames(
        this: *const cv_dnn_dnn4_v20191202_Net,
    ) -> std_vector;
}
unsafe extern "C" {
    #[doc = " @brief Returns pointer to layer with specified id or name which the network use."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net8getLayerENS1_9DictValueE"]
    pub fn cv_dnn_dnn4_v20191202_Net_getLayer(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        layerId: cv_dnn_dnn4_v20191202_Net_LayerId,
    ) -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Returns pointers to input layers of specific layer."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net14getLayerInputsENS1_9DictValueE"]
    pub fn cv_dnn_dnn4_v20191202_Net_getLayerInputs(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        layerId: cv_dnn_dnn4_v20191202_Net_LayerId,
    ) -> std_vector;
}
unsafe extern "C" {
    #[doc = " @brief Connects output of the first layer to input of the second layer.\n  @param outPin descriptor of the first layer output.\n  @param inpPin descriptor of the second layer input.\n\n Descriptors have the following template <DFN>&lt;layer_name&gt;[.input_number]</DFN>:\n - the first part of the template <DFN>layer_name</DFN> is string name of the added layer.\n   If this part is empty then the network input pseudo layer will be used;\n - the second optional part of the template <DFN>input_number</DFN>\n   is either number of the layer input, either label one.\n   If this part is omitted then the first layer input will be used.\n\n  @see setNetInputs(), Layer::inputNameToIndex(), Layer::outputNameToIndex()"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net7connectENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
    pub fn cv_dnn_dnn4_v20191202_Net_connect(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        outPin: cv_String,
        inpPin: cv_String,
    );
}
unsafe extern "C" {
    #[doc = " @brief Connects #@p outNum output of the first layer to #@p inNum input of the second layer.\n  @param outLayerId identifier of the first layer\n  @param outNum number of the first layer output\n  @param inpLayerId identifier of the second layer\n  @param inpNum number of the second layer input"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net7connectEiiii"]
    pub fn cv_dnn_dnn4_v20191202_Net_connect1(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        outLayerId: ::std::os::raw::c_int,
        outNum: ::std::os::raw::c_int,
        inpLayerId: ::std::os::raw::c_int,
        inpNum: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Sets outputs names of the network input pseudo layer.\n\n Each net always has special own the network input pseudo layer with id=0.\n This layer stores the user blobs only and don't make any computations.\n In fact, this layer provides the only way to pass user data into the network.\n As any other layer, this layer can label its outputs and this function provides an easy way to do this."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net14setInputsNamesERKSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS9_EE"]
    pub fn cv_dnn_dnn4_v20191202_Net_setInputsNames(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        inputBlobNames: *const std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @brief Runs forward pass to compute output of layer with name @p outputName.\n  @param outputName name for layer which output is needed to get\n  @return blob for first output of specified layer.\n  @details By default runs forward pass for the whole network."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net7forwardERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_dnn_dnn4_v20191202_Net_forward(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        outputName: *const cv_String,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Runs forward pass to compute output of layer with name @p outputName.\n  @param outputName name for layer which output is needed to get\n  @details By default runs forward pass for the whole network.\n\n  This is an asynchronous version of forward(const String&).\n  dnn::DNN_BACKEND_INFERENCE_ENGINE backend is required."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net12forwardAsyncERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_dnn_dnn4_v20191202_Net_forwardAsync(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        outputName: *const cv_String,
    ) -> cv_AsyncArray;
}
unsafe extern "C" {
    #[doc = " @brief Runs forward pass to compute output of layer with name @p outputName.\n  @param outputBlobs contains all output blobs for specified layer.\n  @param outputName name for layer which output is needed to get\n  @details If @p outputName is empty, runs forward pass for the whole network."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net7forwardERKNS_12_OutputArrayERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_dnn_dnn4_v20191202_Net_forward1(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        outputBlobs: cv_OutputArrayOfArrays,
        outputName: *const cv_String,
    );
}
unsafe extern "C" {
    #[doc = " @brief Runs forward pass to compute outputs of layers listed in @p outBlobNames.\n  @param outputBlobs contains blobs for first outputs of specified layers.\n  @param outBlobNames names for layers which outputs are needed to get"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net7forwardERKNS_12_OutputArrayERKSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISC_EE"]
    pub fn cv_dnn_dnn4_v20191202_Net_forward2(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        outputBlobs: cv_OutputArrayOfArrays,
        outBlobNames: *const std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @brief Runs forward pass to compute outputs of layers listed in @p outBlobNames.\n  @param outputBlobs contains all output blobs for each layer specified in @p outBlobNames.\n  @param outBlobNames names for layers which outputs are needed to get"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net7forwardERSt6vectorIS3_INS_3MatESaIS4_EESaIS6_EERKS3_INSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISF_EE"]
    pub fn cv_dnn_dnn4_v20191202_Net_forward3(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        outputBlobs: *mut std_vector,
        outBlobNames: *const std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @brief Compile Halide layers.\n @param[in] scheduler Path to YAML file with scheduling directives.\n @see setPreferableBackend\n\n Schedule layers that support Halide backend. Then compile them for\n specific target. For layers that not represented in scheduling file\n or if no manual scheduling used at all, automatic scheduling will be applied."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net18setHalideSchedulerERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_dnn_dnn4_v20191202_Net_setHalideScheduler(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        scheduler: *const cv_String,
    );
}
unsafe extern "C" {
    #[doc = " @brief Ask network to use specific computation backend where it supported.\n @param[in] backendId backend identifier.\n @see Backend\n\n If OpenCV is compiled with Intel's Inference Engine library, DNN_BACKEND_DEFAULT\n means DNN_BACKEND_INFERENCE_ENGINE. Otherwise it equals to DNN_BACKEND_OPENCV."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net20setPreferableBackendEi"]
    pub fn cv_dnn_dnn4_v20191202_Net_setPreferableBackend(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        backendId: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Ask network to make computations on specific target device.\n @param[in] targetId target identifier.\n @see Target\n\n List of supported combinations backend / target:\n |                        | DNN_BACKEND_OPENCV | DNN_BACKEND_INFERENCE_ENGINE | DNN_BACKEND_HALIDE |  DNN_BACKEND_CUDA |\n |------------------------|--------------------|------------------------------|--------------------|-------------------|\n | DNN_TARGET_CPU         |                  + |                            + |                  + |                   |\n | DNN_TARGET_OPENCL      |                  + |                            + |                  + |                   |\n | DNN_TARGET_OPENCL_FP16 |                  + |                            + |                    |                   |\n | DNN_TARGET_MYRIAD      |                    |                            + |                    |                   |\n | DNN_TARGET_FPGA        |                    |                            + |                    |                   |\n | DNN_TARGET_CUDA        |                    |                              |                    |                 + |\n | DNN_TARGET_CUDA_FP16   |                    |                              |                    |                 + |"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net19setPreferableTargetEi"]
    pub fn cv_dnn_dnn4_v20191202_Net_setPreferableTarget(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        targetId: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Sets the new input value for the network\n  @param blob        A new blob. Should have CV_32F or CV_8U depth.\n  @param name        A name of input layer.\n  @param scalefactor An optional normalization scale.\n  @param mean        An optional mean subtraction values.\n  @see connect(String, String) to know format of the descriptor.\n\n  If scale or mean values are specified, a final input blob is computed\n  as:\n \\f[input(n,c,h,w) = scalefactor \\times (blob(n,c,h,w) - mean_c)\\f]"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net8setInputERKNS_11_InputArrayERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdRKNS_7Scalar_IdEE"]
    pub fn cv_dnn_dnn4_v20191202_Net_setInput(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        blob: cv_InputArray,
        name: *const cv_String,
        scalefactor: f64,
        mean: *const cv_Scalar,
    );
}
unsafe extern "C" {
    #[doc = " @brief Sets the new value for the learned param of the layer.\n  @param layer name or id of the layer.\n  @param numParam index of the layer parameter in the Layer::blobs array.\n  @param blob the new value.\n  @see Layer::blobs\n  @note If shape of the new blob differs from the previous shape,\n  then the following forward pass may fail."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net8setParamENS1_9DictValueEiRKNS_3MatE"]
    pub fn cv_dnn_dnn4_v20191202_Net_setParam(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        layer: cv_dnn_dnn4_v20191202_Net_LayerId,
        numParam: ::std::os::raw::c_int,
        blob: *const cv_Mat,
    );
}
unsafe extern "C" {
    #[doc = " @brief Returns parameter blob of the layer.\n  @param layer name or id of the layer.\n  @param numParam index of the layer parameter in the Layer::blobs array.\n  @see Layer::blobs"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net8getParamENS1_9DictValueEi"]
    pub fn cv_dnn_dnn4_v20191202_Net_getParam(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        layer: cv_dnn_dnn4_v20191202_Net_LayerId,
        numParam: ::std::os::raw::c_int,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Returns indexes of layers with unconnected outputs."]
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912023Net23getUnconnectedOutLayersEv"]
    pub fn cv_dnn_dnn4_v20191202_Net_getUnconnectedOutLayers(
        this: *const cv_dnn_dnn4_v20191202_Net,
    ) -> std_vector;
}
unsafe extern "C" {
    #[doc = " @brief Returns names of layers with unconnected outputs."]
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912023Net28getUnconnectedOutLayersNamesB5cxx11Ev"]
    pub fn cv_dnn_dnn4_v20191202_Net_getUnconnectedOutLayersNames(
        this: *const cv_dnn_dnn4_v20191202_Net,
    ) -> std_vector;
}
unsafe extern "C" {
    #[doc = " @brief Returns input and output shapes for all layers in loaded model;\n  preliminary inferencing isn't necessary.\n  @param netInputShapes shapes for all input blobs in net input layer.\n  @param layersIds output parameter for layer IDs.\n  @param inLayersShapes output parameter for input layers shapes;\n order is the same as in layersIds\n  @param outLayersShapes output parameter for output layers shapes;\n order is the same as in layersIds"]
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912023Net15getLayersShapesERKSt6vectorIS3_IiSaIiEESaIS5_EERS5_RS3_IS7_SaIS7_EESD_"]
    pub fn cv_dnn_dnn4_v20191202_Net_getLayersShapes(
        this: *const cv_dnn_dnn4_v20191202_Net,
        netInputShapes: *const std_vector,
        layersIds: *mut std_vector,
        inLayersShapes: *mut std_vector,
        outLayersShapes: *mut std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912023Net15getLayersShapesERKSt6vectorIiSaIiEERS5_RS3_IS3_IS5_SaIS5_EESaISA_EESD_"]
    pub fn cv_dnn_dnn4_v20191202_Net_getLayersShapes1(
        this: *const cv_dnn_dnn4_v20191202_Net,
        netInputShape: *const cv_dnn_dnn4_v20191202_MatShape,
        layersIds: *mut std_vector,
        inLayersShapes: *mut std_vector,
        outLayersShapes: *mut std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @brief Returns input and output shapes for layer with specified\n id in loaded model; preliminary inferencing isn't necessary.\n  @param netInputShape shape input blob in net input layer.\n  @param layerId id for layer.\n  @param inLayerShapes output parameter for input layers shapes;\n order is the same as in layersIds\n  @param outLayerShapes output parameter for output layers shapes;\n order is the same as in layersIds"]
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912023Net14getLayerShapesERKSt6vectorIiSaIiEEiRS3_IS5_SaIS5_EESA_"]
    pub fn cv_dnn_dnn4_v20191202_Net_getLayerShapes(
        this: *const cv_dnn_dnn4_v20191202_Net,
        netInputShape: *const cv_dnn_dnn4_v20191202_MatShape,
        layerId: ::std::os::raw::c_int,
        inLayerShapes: *mut std_vector,
        outLayerShapes: *mut std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912023Net14getLayerShapesERKSt6vectorIS3_IiSaIiEESaIS5_EEiRS7_SA_"]
    pub fn cv_dnn_dnn4_v20191202_Net_getLayerShapes1(
        this: *const cv_dnn_dnn4_v20191202_Net,
        netInputShapes: *const std_vector,
        layerId: ::std::os::raw::c_int,
        inLayerShapes: *mut std_vector,
        outLayerShapes: *mut std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @brief Computes FLOP for whole loaded model with specified input shapes.\n @param netInputShapes vector of shapes for all net inputs.\n @returns computed FLOP."]
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912023Net8getFLOPSERKSt6vectorIS3_IiSaIiEESaIS5_EE"]
    pub fn cv_dnn_dnn4_v20191202_Net_getFLOPS(
        this: *const cv_dnn_dnn4_v20191202_Net,
        netInputShapes: *const std_vector,
    ) -> int64;
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912023Net8getFLOPSERKSt6vectorIiSaIiEE"]
    pub fn cv_dnn_dnn4_v20191202_Net_getFLOPS1(
        this: *const cv_dnn_dnn4_v20191202_Net,
        netInputShape: *const cv_dnn_dnn4_v20191202_MatShape,
    ) -> int64;
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912023Net8getFLOPSEiRKSt6vectorIS3_IiSaIiEESaIS5_EE"]
    pub fn cv_dnn_dnn4_v20191202_Net_getFLOPS2(
        this: *const cv_dnn_dnn4_v20191202_Net,
        layerId: ::std::os::raw::c_int,
        netInputShapes: *const std_vector,
    ) -> int64;
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912023Net8getFLOPSEiRKSt6vectorIiSaIiEE"]
    pub fn cv_dnn_dnn4_v20191202_Net_getFLOPS3(
        this: *const cv_dnn_dnn4_v20191202_Net,
        layerId: ::std::os::raw::c_int,
        netInputShape: *const cv_dnn_dnn4_v20191202_MatShape,
    ) -> int64;
}
unsafe extern "C" {
    #[doc = " @brief Returns list of types for layer used in model.\n @param layersTypes output parameter for returning types."]
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912023Net13getLayerTypesERSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS9_EE"]
    pub fn cv_dnn_dnn4_v20191202_Net_getLayerTypes(
        this: *const cv_dnn_dnn4_v20191202_Net,
        layersTypes: *mut std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @brief Returns count of layers of specified type.\n @param layerType type.\n @returns count of layers"]
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912023Net14getLayersCountERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_dnn_dnn4_v20191202_Net_getLayersCount(
        this: *const cv_dnn_dnn4_v20191202_Net,
        layerType: *const cv_String,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Computes bytes number which are required to store\n all weights and intermediate blobs for model.\n @param netInputShapes vector of shapes for all net inputs.\n @param weights output parameter to store resulting bytes for weights.\n @param blobs output parameter to store resulting bytes for intermediate blobs."]
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912023Net20getMemoryConsumptionERKSt6vectorIS3_IiSaIiEESaIS5_EERmSA_"]
    pub fn cv_dnn_dnn4_v20191202_Net_getMemoryConsumption(
        this: *const cv_dnn_dnn4_v20191202_Net,
        netInputShapes: *const std_vector,
        weights: *mut usize,
        blobs: *mut usize,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912023Net20getMemoryConsumptionERKSt6vectorIiSaIiEERmS8_"]
    pub fn cv_dnn_dnn4_v20191202_Net_getMemoryConsumption1(
        this: *const cv_dnn_dnn4_v20191202_Net,
        netInputShape: *const cv_dnn_dnn4_v20191202_MatShape,
        weights: *mut usize,
        blobs: *mut usize,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912023Net20getMemoryConsumptionEiRKSt6vectorIS3_IiSaIiEESaIS5_EERmSA_"]
    pub fn cv_dnn_dnn4_v20191202_Net_getMemoryConsumption2(
        this: *const cv_dnn_dnn4_v20191202_Net,
        layerId: ::std::os::raw::c_int,
        netInputShapes: *const std_vector,
        weights: *mut usize,
        blobs: *mut usize,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912023Net20getMemoryConsumptionEiRKSt6vectorIiSaIiEERmS8_"]
    pub fn cv_dnn_dnn4_v20191202_Net_getMemoryConsumption3(
        this: *const cv_dnn_dnn4_v20191202_Net,
        layerId: ::std::os::raw::c_int,
        netInputShape: *const cv_dnn_dnn4_v20191202_MatShape,
        weights: *mut usize,
        blobs: *mut usize,
    );
}
unsafe extern "C" {
    #[doc = " @brief Computes bytes number which are required to store\n all weights and intermediate blobs for each layer.\n @param netInputShapes vector of shapes for all net inputs.\n @param layerIds output vector to save layer IDs.\n @param weights output parameter to store resulting bytes for weights.\n @param blobs output parameter to store resulting bytes for intermediate blobs."]
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912023Net20getMemoryConsumptionERKSt6vectorIS3_IiSaIiEESaIS5_EERS5_RS3_ImSaImEESD_"]
    pub fn cv_dnn_dnn4_v20191202_Net_getMemoryConsumption4(
        this: *const cv_dnn_dnn4_v20191202_Net,
        netInputShapes: *const std_vector,
        layerIds: *mut std_vector,
        weights: *mut std_vector,
        blobs: *mut std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZNK2cv3dnn14dnn4_v201912023Net20getMemoryConsumptionERKSt6vectorIiSaIiEERS5_RS3_ImSaImEESB_"]
    pub fn cv_dnn_dnn4_v20191202_Net_getMemoryConsumption5(
        this: *const cv_dnn_dnn4_v20191202_Net,
        netInputShape: *const cv_dnn_dnn4_v20191202_MatShape,
        layerIds: *mut std_vector,
        weights: *mut std_vector,
        blobs: *mut std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @brief Enables or disables layer fusion in the network.\n @param fusion true to enable the fusion, false to disable. The fusion is enabled by default."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net12enableFusionEb"]
    pub fn cv_dnn_dnn4_v20191202_Net_enableFusion(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        fusion: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief Returns overall time for inference and timings (in ticks) for layers.\n Indexes in returned vector correspond to layers ids. Some layers can be fused with others,\n in this case zero ticks count will be return for that skipped layers.\n @param timings vector for tick timings for all layers.\n @return overall ticks for model inference."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023Net14getPerfProfileERSt6vectorIdSaIdEE"]
    pub fn cv_dnn_dnn4_v20191202_Net_getPerfProfile(
        this: *mut cv_dnn_dnn4_v20191202_Net,
        timings: *mut std_vector,
    ) -> int64;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023NetC1Ev"]
    pub fn cv_dnn_dnn4_v20191202_Net_Net(this: *mut cv_dnn_dnn4_v20191202_Net);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912023NetD1Ev"]
    pub fn cv_dnn_dnn4_v20191202_Net_Net_destructor(this: *mut cv_dnn_dnn4_v20191202_Net);
}
impl cv_dnn_dnn4_v20191202_Net {
    #[inline]
    pub unsafe fn readFromModelOptimizer(
        xml: *const cv_String,
        bin: *const cv_String,
    ) -> cv_dnn_dnn4_v20191202_Net {
        cv_dnn_dnn4_v20191202_Net_readFromModelOptimizer(xml, bin)
    }
    #[inline]
    pub unsafe fn readFromModelOptimizer1(
        bufferModelConfig: *const std_vector,
        bufferWeights: *const std_vector,
    ) -> cv_dnn_dnn4_v20191202_Net {
        cv_dnn_dnn4_v20191202_Net_readFromModelOptimizer1(bufferModelConfig, bufferWeights)
    }
    #[inline]
    pub unsafe fn readFromModelOptimizer2(
        bufferModelConfigPtr: *const uchar,
        bufferModelConfigSize: usize,
        bufferWeightsPtr: *const uchar,
        bufferWeightsSize: usize,
    ) -> cv_dnn_dnn4_v20191202_Net {
        cv_dnn_dnn4_v20191202_Net_readFromModelOptimizer2(
            bufferModelConfigPtr,
            bufferModelConfigSize,
            bufferWeightsPtr,
            bufferWeightsSize,
        )
    }
    #[inline]
    pub unsafe fn empty(&self) -> bool {
        cv_dnn_dnn4_v20191202_Net_empty(self)
    }
    #[inline]
    pub unsafe fn dump(&mut self) -> cv_String {
        cv_dnn_dnn4_v20191202_Net_dump(self)
    }
    #[inline]
    pub unsafe fn dumpToFile(&mut self, path: *const cv_String) {
        cv_dnn_dnn4_v20191202_Net_dumpToFile(self, path)
    }
    #[inline]
    pub unsafe fn addLayer(
        &mut self,
        name: *const cv_String,
        type_: *const cv_String,
        params: *mut cv_dnn_dnn4_v20191202_LayerParams,
    ) -> ::std::os::raw::c_int {
        cv_dnn_dnn4_v20191202_Net_addLayer(self, name, type_, params)
    }
    #[inline]
    pub unsafe fn addLayerToPrev(
        &mut self,
        name: *const cv_String,
        type_: *const cv_String,
        params: *mut cv_dnn_dnn4_v20191202_LayerParams,
    ) -> ::std::os::raw::c_int {
        cv_dnn_dnn4_v20191202_Net_addLayerToPrev(self, name, type_, params)
    }
    #[inline]
    pub unsafe fn getLayerId(&mut self, layer: *const cv_String) -> ::std::os::raw::c_int {
        cv_dnn_dnn4_v20191202_Net_getLayerId(self, layer)
    }
    #[inline]
    pub unsafe fn getLayerNames(&self) -> std_vector {
        cv_dnn_dnn4_v20191202_Net_getLayerNames(self)
    }
    #[inline]
    pub unsafe fn getLayer(&mut self, layerId: cv_dnn_dnn4_v20191202_Net_LayerId) -> cv_Ptr {
        cv_dnn_dnn4_v20191202_Net_getLayer(self, layerId)
    }
    #[inline]
    pub unsafe fn getLayerInputs(
        &mut self,
        layerId: cv_dnn_dnn4_v20191202_Net_LayerId,
    ) -> std_vector {
        cv_dnn_dnn4_v20191202_Net_getLayerInputs(self, layerId)
    }
    #[inline]
    pub unsafe fn connect(&mut self, outPin: cv_String, inpPin: cv_String) {
        cv_dnn_dnn4_v20191202_Net_connect(self, outPin, inpPin)
    }
    #[inline]
    pub unsafe fn connect1(
        &mut self,
        outLayerId: ::std::os::raw::c_int,
        outNum: ::std::os::raw::c_int,
        inpLayerId: ::std::os::raw::c_int,
        inpNum: ::std::os::raw::c_int,
    ) {
        cv_dnn_dnn4_v20191202_Net_connect1(self, outLayerId, outNum, inpLayerId, inpNum)
    }
    #[inline]
    pub unsafe fn setInputsNames(&mut self, inputBlobNames: *const std_vector) {
        cv_dnn_dnn4_v20191202_Net_setInputsNames(self, inputBlobNames)
    }
    #[inline]
    pub unsafe fn forward(&mut self, outputName: *const cv_String) -> cv_Mat {
        cv_dnn_dnn4_v20191202_Net_forward(self, outputName)
    }
    #[inline]
    pub unsafe fn forwardAsync(&mut self, outputName: *const cv_String) -> cv_AsyncArray {
        cv_dnn_dnn4_v20191202_Net_forwardAsync(self, outputName)
    }
    #[inline]
    pub unsafe fn forward1(
        &mut self,
        outputBlobs: cv_OutputArrayOfArrays,
        outputName: *const cv_String,
    ) {
        cv_dnn_dnn4_v20191202_Net_forward1(self, outputBlobs, outputName)
    }
    #[inline]
    pub unsafe fn forward2(
        &mut self,
        outputBlobs: cv_OutputArrayOfArrays,
        outBlobNames: *const std_vector,
    ) {
        cv_dnn_dnn4_v20191202_Net_forward2(self, outputBlobs, outBlobNames)
    }
    #[inline]
    pub unsafe fn forward3(
        &mut self,
        outputBlobs: *mut std_vector,
        outBlobNames: *const std_vector,
    ) {
        cv_dnn_dnn4_v20191202_Net_forward3(self, outputBlobs, outBlobNames)
    }
    #[inline]
    pub unsafe fn setHalideScheduler(&mut self, scheduler: *const cv_String) {
        cv_dnn_dnn4_v20191202_Net_setHalideScheduler(self, scheduler)
    }
    #[inline]
    pub unsafe fn setPreferableBackend(&mut self, backendId: ::std::os::raw::c_int) {
        cv_dnn_dnn4_v20191202_Net_setPreferableBackend(self, backendId)
    }
    #[inline]
    pub unsafe fn setPreferableTarget(&mut self, targetId: ::std::os::raw::c_int) {
        cv_dnn_dnn4_v20191202_Net_setPreferableTarget(self, targetId)
    }
    #[inline]
    pub unsafe fn setInput(
        &mut self,
        blob: cv_InputArray,
        name: *const cv_String,
        scalefactor: f64,
        mean: *const cv_Scalar,
    ) {
        cv_dnn_dnn4_v20191202_Net_setInput(self, blob, name, scalefactor, mean)
    }
    #[inline]
    pub unsafe fn setParam(
        &mut self,
        layer: cv_dnn_dnn4_v20191202_Net_LayerId,
        numParam: ::std::os::raw::c_int,
        blob: *const cv_Mat,
    ) {
        cv_dnn_dnn4_v20191202_Net_setParam(self, layer, numParam, blob)
    }
    #[inline]
    pub unsafe fn getParam(
        &mut self,
        layer: cv_dnn_dnn4_v20191202_Net_LayerId,
        numParam: ::std::os::raw::c_int,
    ) -> cv_Mat {
        cv_dnn_dnn4_v20191202_Net_getParam(self, layer, numParam)
    }
    #[inline]
    pub unsafe fn getUnconnectedOutLayers(&self) -> std_vector {
        cv_dnn_dnn4_v20191202_Net_getUnconnectedOutLayers(self)
    }
    #[inline]
    pub unsafe fn getUnconnectedOutLayersNames(&self) -> std_vector {
        cv_dnn_dnn4_v20191202_Net_getUnconnectedOutLayersNames(self)
    }
    #[inline]
    pub unsafe fn getLayersShapes(
        &self,
        netInputShapes: *const std_vector,
        layersIds: *mut std_vector,
        inLayersShapes: *mut std_vector,
        outLayersShapes: *mut std_vector,
    ) {
        cv_dnn_dnn4_v20191202_Net_getLayersShapes(
            self,
            netInputShapes,
            layersIds,
            inLayersShapes,
            outLayersShapes,
        )
    }
    #[inline]
    pub unsafe fn getLayersShapes1(
        &self,
        netInputShape: *const cv_dnn_dnn4_v20191202_MatShape,
        layersIds: *mut std_vector,
        inLayersShapes: *mut std_vector,
        outLayersShapes: *mut std_vector,
    ) {
        cv_dnn_dnn4_v20191202_Net_getLayersShapes1(
            self,
            netInputShape,
            layersIds,
            inLayersShapes,
            outLayersShapes,
        )
    }
    #[inline]
    pub unsafe fn getLayerShapes(
        &self,
        netInputShape: *const cv_dnn_dnn4_v20191202_MatShape,
        layerId: ::std::os::raw::c_int,
        inLayerShapes: *mut std_vector,
        outLayerShapes: *mut std_vector,
    ) {
        cv_dnn_dnn4_v20191202_Net_getLayerShapes(
            self,
            netInputShape,
            layerId,
            inLayerShapes,
            outLayerShapes,
        )
    }
    #[inline]
    pub unsafe fn getLayerShapes1(
        &self,
        netInputShapes: *const std_vector,
        layerId: ::std::os::raw::c_int,
        inLayerShapes: *mut std_vector,
        outLayerShapes: *mut std_vector,
    ) {
        cv_dnn_dnn4_v20191202_Net_getLayerShapes1(
            self,
            netInputShapes,
            layerId,
            inLayerShapes,
            outLayerShapes,
        )
    }
    #[inline]
    pub unsafe fn getFLOPS(&self, netInputShapes: *const std_vector) -> int64 {
        cv_dnn_dnn4_v20191202_Net_getFLOPS(self, netInputShapes)
    }
    #[inline]
    pub unsafe fn getFLOPS1(&self, netInputShape: *const cv_dnn_dnn4_v20191202_MatShape) -> int64 {
        cv_dnn_dnn4_v20191202_Net_getFLOPS1(self, netInputShape)
    }
    #[inline]
    pub unsafe fn getFLOPS2(
        &self,
        layerId: ::std::os::raw::c_int,
        netInputShapes: *const std_vector,
    ) -> int64 {
        cv_dnn_dnn4_v20191202_Net_getFLOPS2(self, layerId, netInputShapes)
    }
    #[inline]
    pub unsafe fn getFLOPS3(
        &self,
        layerId: ::std::os::raw::c_int,
        netInputShape: *const cv_dnn_dnn4_v20191202_MatShape,
    ) -> int64 {
        cv_dnn_dnn4_v20191202_Net_getFLOPS3(self, layerId, netInputShape)
    }
    #[inline]
    pub unsafe fn getLayerTypes(&self, layersTypes: *mut std_vector) {
        cv_dnn_dnn4_v20191202_Net_getLayerTypes(self, layersTypes)
    }
    #[inline]
    pub unsafe fn getLayersCount(&self, layerType: *const cv_String) -> ::std::os::raw::c_int {
        cv_dnn_dnn4_v20191202_Net_getLayersCount(self, layerType)
    }
    #[inline]
    pub unsafe fn getMemoryConsumption(
        &self,
        netInputShapes: *const std_vector,
        weights: *mut usize,
        blobs: *mut usize,
    ) {
        cv_dnn_dnn4_v20191202_Net_getMemoryConsumption(self, netInputShapes, weights, blobs)
    }
    #[inline]
    pub unsafe fn getMemoryConsumption1(
        &self,
        netInputShape: *const cv_dnn_dnn4_v20191202_MatShape,
        weights: *mut usize,
        blobs: *mut usize,
    ) {
        cv_dnn_dnn4_v20191202_Net_getMemoryConsumption1(self, netInputShape, weights, blobs)
    }
    #[inline]
    pub unsafe fn getMemoryConsumption2(
        &self,
        layerId: ::std::os::raw::c_int,
        netInputShapes: *const std_vector,
        weights: *mut usize,
        blobs: *mut usize,
    ) {
        cv_dnn_dnn4_v20191202_Net_getMemoryConsumption2(
            self,
            layerId,
            netInputShapes,
            weights,
            blobs,
        )
    }
    #[inline]
    pub unsafe fn getMemoryConsumption3(
        &self,
        layerId: ::std::os::raw::c_int,
        netInputShape: *const cv_dnn_dnn4_v20191202_MatShape,
        weights: *mut usize,
        blobs: *mut usize,
    ) {
        cv_dnn_dnn4_v20191202_Net_getMemoryConsumption3(
            self,
            layerId,
            netInputShape,
            weights,
            blobs,
        )
    }
    #[inline]
    pub unsafe fn getMemoryConsumption4(
        &self,
        netInputShapes: *const std_vector,
        layerIds: *mut std_vector,
        weights: *mut std_vector,
        blobs: *mut std_vector,
    ) {
        cv_dnn_dnn4_v20191202_Net_getMemoryConsumption4(
            self,
            netInputShapes,
            layerIds,
            weights,
            blobs,
        )
    }
    #[inline]
    pub unsafe fn getMemoryConsumption5(
        &self,
        netInputShape: *const cv_dnn_dnn4_v20191202_MatShape,
        layerIds: *mut std_vector,
        weights: *mut std_vector,
        blobs: *mut std_vector,
    ) {
        cv_dnn_dnn4_v20191202_Net_getMemoryConsumption5(
            self,
            netInputShape,
            layerIds,
            weights,
            blobs,
        )
    }
    #[inline]
    pub unsafe fn enableFusion(&mut self, fusion: bool) {
        cv_dnn_dnn4_v20191202_Net_enableFusion(self, fusion)
    }
    #[inline]
    pub unsafe fn getPerfProfile(&mut self, timings: *mut std_vector) -> int64 {
        cv_dnn_dnn4_v20191202_Net_getPerfProfile(self, timings)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_dnn_dnn4_v20191202_Net_Net(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cv_dnn_dnn4_v20191202_Net_Net_destructor(self)
    }
}
unsafe extern "C" {
    #[doc = " @brief Reads a network model stored in <a href=\"https://pjreddie.com/darknet/\">Darknet</a> model files.\n  @param cfgFile      path to the .cfg file with text description of the network architecture.\n  @param darknetModel path to the .weights file with learned network.\n  @returns Network object that ready to do forward, throw an exception in failure cases.\n  @returns Net object."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120218readNetFromDarknetERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_"]
    pub fn cv_dnn_dnn4_v20191202_readNetFromDarknet(
        cfgFile: *const cv_String,
        darknetModel: *const cv_String,
    ) -> cv_dnn_dnn4_v20191202_Net;
}
unsafe extern "C" {
    #[doc = " @brief Reads a network model stored in <a href=\"https://pjreddie.com/darknet/\">Darknet</a> model files.\n  @param bufferCfg   A buffer contains a content of .cfg file with text description of the network architecture.\n  @param bufferModel A buffer contains a content of .weights file with learned network.\n  @returns Net object."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120218readNetFromDarknetERKSt6vectorIhSaIhEES6_"]
    pub fn cv_dnn_dnn4_v20191202_readNetFromDarknet1(
        bufferCfg: *const std_vector,
        bufferModel: *const std_vector,
    ) -> cv_dnn_dnn4_v20191202_Net;
}
unsafe extern "C" {
    #[doc = " @brief Reads a network model stored in <a href=\"https://pjreddie.com/darknet/\">Darknet</a> model files.\n  @param bufferCfg   A buffer contains a content of .cfg file with text description of the network architecture.\n  @param lenCfg      Number of bytes to read from bufferCfg\n  @param bufferModel A buffer contains a content of .weights file with learned network.\n  @param lenModel    Number of bytes to read from bufferModel\n  @returns Net object."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120218readNetFromDarknetEPKcmS3_m"]
    pub fn cv_dnn_dnn4_v20191202_readNetFromDarknet2(
        bufferCfg: *const ::std::os::raw::c_char,
        lenCfg: usize,
        bufferModel: *const ::std::os::raw::c_char,
        lenModel: usize,
    ) -> cv_dnn_dnn4_v20191202_Net;
}
unsafe extern "C" {
    #[doc = " @brief Reads a network model stored in <a href=\"http://caffe.berkeleyvision.org\">Caffe</a> framework's format.\n @param prototxt   path to the .prototxt file with text description of the network architecture.\n @param caffeModel path to the .caffemodel file with learned network.\n @returns Net object."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120216readNetFromCaffeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_"]
    pub fn cv_dnn_dnn4_v20191202_readNetFromCaffe(
        prototxt: *const cv_String,
        caffeModel: *const cv_String,
    ) -> cv_dnn_dnn4_v20191202_Net;
}
unsafe extern "C" {
    #[doc = " @brief Reads a network model stored in Caffe model in memory.\n @param bufferProto buffer containing the content of the .prototxt file\n @param bufferModel buffer containing the content of the .caffemodel file\n @returns Net object."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120216readNetFromCaffeERKSt6vectorIhSaIhEES6_"]
    pub fn cv_dnn_dnn4_v20191202_readNetFromCaffe1(
        bufferProto: *const std_vector,
        bufferModel: *const std_vector,
    ) -> cv_dnn_dnn4_v20191202_Net;
}
unsafe extern "C" {
    #[doc = " @brief Reads a network model stored in Caffe model in memory.\n @details This is an overloaded member function, provided for convenience.\n It differs from the above function only in what argument(s) it accepts.\n @param bufferProto buffer containing the content of the .prototxt file\n @param lenProto length of bufferProto\n @param bufferModel buffer containing the content of the .caffemodel file\n @param lenModel length of bufferModel\n @returns Net object."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120216readNetFromCaffeEPKcmS3_m"]
    pub fn cv_dnn_dnn4_v20191202_readNetFromCaffe2(
        bufferProto: *const ::std::os::raw::c_char,
        lenProto: usize,
        bufferModel: *const ::std::os::raw::c_char,
        lenModel: usize,
    ) -> cv_dnn_dnn4_v20191202_Net;
}
unsafe extern "C" {
    #[doc = " @brief Reads a network model stored in <a href=\"https://www.tensorflow.org/\">TensorFlow</a> framework's format.\n @param model  path to the .pb file with binary protobuf description of the network architecture\n @param config path to the .pbtxt file that contains text graph definition in protobuf format.\n               Resulting Net object is built by text graph using weights from a binary one that\n               let us make it more flexible.\n @returns Net object."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120221readNetFromTensorflowERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_"]
    pub fn cv_dnn_dnn4_v20191202_readNetFromTensorflow(
        model: *const cv_String,
        config: *const cv_String,
    ) -> cv_dnn_dnn4_v20191202_Net;
}
unsafe extern "C" {
    #[doc = " @brief Reads a network model stored in <a href=\"https://www.tensorflow.org/\">TensorFlow</a> framework's format.\n @param bufferModel buffer containing the content of the pb file\n @param bufferConfig buffer containing the content of the pbtxt file\n @returns Net object."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120221readNetFromTensorflowERKSt6vectorIhSaIhEES6_"]
    pub fn cv_dnn_dnn4_v20191202_readNetFromTensorflow1(
        bufferModel: *const std_vector,
        bufferConfig: *const std_vector,
    ) -> cv_dnn_dnn4_v20191202_Net;
}
unsafe extern "C" {
    #[doc = " @brief Reads a network model stored in <a href=\"https://www.tensorflow.org/\">TensorFlow</a> framework's format.\n @details This is an overloaded member function, provided for convenience.\n It differs from the above function only in what argument(s) it accepts.\n @param bufferModel buffer containing the content of the pb file\n @param lenModel length of bufferModel\n @param bufferConfig buffer containing the content of the pbtxt file\n @param lenConfig length of bufferConfig"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120221readNetFromTensorflowEPKcmS3_m"]
    pub fn cv_dnn_dnn4_v20191202_readNetFromTensorflow2(
        bufferModel: *const ::std::os::raw::c_char,
        lenModel: usize,
        bufferConfig: *const ::std::os::raw::c_char,
        lenConfig: usize,
    ) -> cv_dnn_dnn4_v20191202_Net;
}
unsafe extern "C" {
    #[doc = "  @brief Reads a network model stored in <a href=\"http://torch.ch\">Torch7</a> framework's format.\n  @param model    path to the file, dumped from Torch by using torch.save() function.\n  @param isBinary specifies whether the network was serialized in ascii mode or binary.\n  @param evaluate specifies testing phase of network. If true, it's similar to evaluate() method in Torch.\n  @returns Net object.\n\n  @note Ascii mode of Torch serializer is more preferable, because binary mode extensively use `long` type of C language,\n  which has various bit-length on different systems.\n\n The loading file must contain serialized <a href=\"https://github.com/torch/nn/blob/master/doc/module.md\">nn.Module</a> object\n with importing network. Try to eliminate a custom objects from serialazing data to avoid importing errors.\n\n List of supported layers (i.e. object instances derived from Torch nn.Module class):\n - nn.Sequential\n - nn.Parallel\n - nn.Concat\n - nn.Linear\n - nn.SpatialConvolution\n - nn.SpatialMaxPooling, nn.SpatialAveragePooling\n - nn.ReLU, nn.TanH, nn.Sigmoid\n - nn.Reshape\n - nn.SoftMax, nn.LogSoftMax\n\n Also some equivalents of these classes from cunn, cudnn, and fbcunn may be successfully imported."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120216readNetFromTorchERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEbb"]
    pub fn cv_dnn_dnn4_v20191202_readNetFromTorch(
        model: *const cv_String,
        isBinary: bool,
        evaluate: bool,
    ) -> cv_dnn_dnn4_v20191202_Net;
}
unsafe extern "C" {
    #[doc = " @brief Read deep learning network represented in one of the supported formats.\n @param[in] model Binary file contains trained weights. The following file\n                  extensions are expected for models from different frameworks:\n                  * `*.caffemodel` (Caffe, http://caffe.berkeleyvision.org/)\n                  * `*.pb` (TensorFlow, https://www.tensorflow.org/)\n                  * `*.t7` | `*.net` (Torch, http://torch.ch/)\n                  * `*.weights` (Darknet, https://pjreddie.com/darknet/)\n                  * `*.bin` (DLDT, https://software.intel.com/openvino-toolkit)\n                  * `*.onnx` (ONNX, https://onnx.ai/)\n @param[in] config Text file contains network configuration. It could be a\n                   file with the following extensions:\n                  * `*.prototxt` (Caffe, http://caffe.berkeleyvision.org/)\n                  * `*.pbtxt` (TensorFlow, https://www.tensorflow.org/)\n                  * `*.cfg` (Darknet, https://pjreddie.com/darknet/)\n                  * `*.xml` (DLDT, https://software.intel.com/openvino-toolkit)\n @param[in] framework Explicit framework name tag to determine a format.\n @returns Net object.\n\n This function automatically detects an origin framework of trained model\n and calls an appropriate function such @ref readNetFromCaffe, @ref readNetFromTensorflow,\n @ref readNetFromTorch or @ref readNetFromDarknet. An order of @p model and @p config\n arguments does not matter."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912027readNetERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_S9_"]
    pub fn cv_dnn_dnn4_v20191202_readNet(
        model: *const cv_String,
        config: *const cv_String,
        framework: *const cv_String,
    ) -> cv_dnn_dnn4_v20191202_Net;
}
unsafe extern "C" {
    #[doc = " @brief Read deep learning network represented in one of the supported formats.\n @details This is an overloaded member function, provided for convenience.\n          It differs from the above function only in what argument(s) it accepts.\n @param[in] framework    Name of origin framework.\n @param[in] bufferModel  A buffer with a content of binary file with weights\n @param[in] bufferConfig A buffer with a content of text file contains network configuration.\n @returns Net object."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912027readNetERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt6vectorIhSaIhEESE_"]
    pub fn cv_dnn_dnn4_v20191202_readNet1(
        framework: *const cv_String,
        bufferModel: *const std_vector,
        bufferConfig: *const std_vector,
    ) -> cv_dnn_dnn4_v20191202_Net;
}
unsafe extern "C" {
    #[doc = " @brief Loads blob which was serialized as torch.Tensor object of Torch7 framework.\n  @warning This function has the same limitations as readNetFromTorch()."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120213readTorchBlobERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb"]
    pub fn cv_dnn_dnn4_v20191202_readTorchBlob(
        filename: *const cv_String,
        isBinary: bool,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Load a network from Intel's Model Optimizer intermediate representation.\n  @param[in] xml XML configuration file with network's topology.\n  @param[in] bin Binary file with trained weights.\n  @returns Net object.\n  Networks imported from Intel's Model Optimizer are launched in Intel's Inference Engine\n  backend."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120225readNetFromModelOptimizerERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_"]
    pub fn cv_dnn_dnn4_v20191202_readNetFromModelOptimizer(
        xml: *const cv_String,
        bin: *const cv_String,
    ) -> cv_dnn_dnn4_v20191202_Net;
}
unsafe extern "C" {
    #[doc = " @brief Load a network from Intel's Model Optimizer intermediate representation.\n  @param[in] bufferModelConfig Buffer contains XML configuration with network's topology.\n  @param[in] bufferWeights Buffer contains binary data with trained weights.\n  @returns Net object.\n  Networks imported from Intel's Model Optimizer are launched in Intel's Inference Engine\n  backend."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120225readNetFromModelOptimizerERKSt6vectorIhSaIhEES6_"]
    pub fn cv_dnn_dnn4_v20191202_readNetFromModelOptimizer1(
        bufferModelConfig: *const std_vector,
        bufferWeights: *const std_vector,
    ) -> cv_dnn_dnn4_v20191202_Net;
}
unsafe extern "C" {
    #[doc = " @brief Load a network from Intel's Model Optimizer intermediate representation.\n  @param[in] bufferModelConfigPtr Pointer to buffer which contains XML configuration with network's topology.\n  @param[in] bufferModelConfigSize Binary size of XML configuration data.\n  @param[in] bufferWeightsPtr Pointer to buffer which contains binary data with trained weights.\n  @param[in] bufferWeightsSize Binary size of trained weights data.\n  @returns Net object.\n  Networks imported from Intel's Model Optimizer are launched in Intel's Inference Engine\n  backend."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120225readNetFromModelOptimizerEPKhmS3_m"]
    pub fn cv_dnn_dnn4_v20191202_readNetFromModelOptimizer2(
        bufferModelConfigPtr: *const uchar,
        bufferModelConfigSize: usize,
        bufferWeightsPtr: *const uchar,
        bufferWeightsSize: usize,
    ) -> cv_dnn_dnn4_v20191202_Net;
}
unsafe extern "C" {
    #[doc = " @brief Reads a network model <a href=\"https://onnx.ai/\">ONNX</a>.\n  @param onnxFile path to the .onnx file with text description of the network architecture.\n  @returns Network object that ready to do forward, throw an exception in failure cases."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120215readNetFromONNXERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_dnn_dnn4_v20191202_readNetFromONNX(
        onnxFile: *const cv_String,
    ) -> cv_dnn_dnn4_v20191202_Net;
}
unsafe extern "C" {
    #[doc = " @brief Reads a network model from <a href=\"https://onnx.ai/\">ONNX</a>\n         in-memory buffer.\n  @param buffer memory address of the first byte of the buffer.\n  @param sizeBuffer size of the buffer.\n  @returns Network object that ready to do forward, throw an exception\n        in failure cases."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120215readNetFromONNXEPKcm"]
    pub fn cv_dnn_dnn4_v20191202_readNetFromONNX1(
        buffer: *const ::std::os::raw::c_char,
        sizeBuffer: usize,
    ) -> cv_dnn_dnn4_v20191202_Net;
}
unsafe extern "C" {
    #[doc = " @brief Reads a network model from <a href=\"https://onnx.ai/\">ONNX</a>\n         in-memory buffer.\n  @param buffer in-memory buffer that stores the ONNX model bytes.\n  @returns Network object that ready to do forward, throw an exception\n        in failure cases."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120215readNetFromONNXERKSt6vectorIhSaIhEE"]
    pub fn cv_dnn_dnn4_v20191202_readNetFromONNX2(
        buffer: *const std_vector,
    ) -> cv_dnn_dnn4_v20191202_Net;
}
unsafe extern "C" {
    #[doc = " @brief Creates blob from .pb file.\n  @param path to the .pb file with input tensor.\n  @returns Mat."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120218readTensorFromONNXERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_dnn_dnn4_v20191202_readTensorFromONNX(path: *const cv_String) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Creates 4-dimensional blob from image. Optionally resizes and crops @p image from center,\n  subtract @p mean values, scales values by @p scalefactor, swap Blue and Red channels.\n  @param image input image (with 1-, 3- or 4-channels).\n  @param size spatial size for output image\n  @param mean scalar with mean values which are subtracted from channels. Values are intended\n  to be in (mean-R, mean-G, mean-B) order if @p image has BGR ordering and @p swapRB is true.\n  @param scalefactor multiplier for @p image values.\n  @param swapRB flag which indicates that swap first and last channels\n  in 3-channel image is necessary.\n  @param crop flag which indicates whether image will be cropped after resize or not\n  @param ddepth Depth of output blob. Choose CV_32F or CV_8U.\n  @details if @p crop is true, input image is resized so one side after resize is equal to corresponding\n  dimension in @p size and another one is equal or larger. Then, crop from the center is performed.\n  If @p crop is false, direct resize without cropping and preserving aspect ratio is performed.\n  @returns 4-dimensional Mat with NCHW dimensions order."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120213blobFromImageERKNS_11_InputArrayEdRKNS_5Size_IiEERKNS_7Scalar_IdEEbbi"]
    pub fn cv_dnn_dnn4_v20191202_blobFromImage(
        image: cv_InputArray,
        scalefactor: f64,
        size: *const cv_Size,
        mean: *const cv_Scalar,
        swapRB: bool,
        crop: bool,
        ddepth: ::std::os::raw::c_int,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Creates 4-dimensional blob from image.\n  @details This is an overloaded member function, provided for convenience.\n           It differs from the above function only in what argument(s) it accepts."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120213blobFromImageERKNS_11_InputArrayERKNS_12_OutputArrayEdRKNS_5Size_IiEERKNS_7Scalar_IdEEbbi"]
    pub fn cv_dnn_dnn4_v20191202_blobFromImage1(
        image: cv_InputArray,
        blob: cv_OutputArray,
        scalefactor: f64,
        size: *const cv_Size,
        mean: *const cv_Scalar,
        swapRB: bool,
        crop: bool,
        ddepth: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Creates 4-dimensional blob from series of images. Optionally resizes and\n  crops @p images from center, subtract @p mean values, scales values by @p scalefactor,\n  swap Blue and Red channels.\n  @param images input images (all with 1-, 3- or 4-channels).\n  @param size spatial size for output image\n  @param mean scalar with mean values which are subtracted from channels. Values are intended\n  to be in (mean-R, mean-G, mean-B) order if @p image has BGR ordering and @p swapRB is true.\n  @param scalefactor multiplier for @p images values.\n  @param swapRB flag which indicates that swap first and last channels\n  in 3-channel image is necessary.\n  @param crop flag which indicates whether image will be cropped after resize or not\n  @param ddepth Depth of output blob. Choose CV_32F or CV_8U.\n  @details if @p crop is true, input image is resized so one side after resize is equal to corresponding\n  dimension in @p size and another one is equal or larger. Then, crop from the center is performed.\n  If @p crop is false, direct resize without cropping and preserving aspect ratio is performed.\n  @returns 4-dimensional Mat with NCHW dimensions order."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120214blobFromImagesERKNS_11_InputArrayEdNS_5Size_IiEERKNS_7Scalar_IdEEbbi"]
    pub fn cv_dnn_dnn4_v20191202_blobFromImages(
        images: cv_InputArrayOfArrays,
        scalefactor: f64,
        size: cv_Size,
        mean: *const cv_Scalar,
        swapRB: bool,
        crop: bool,
        ddepth: ::std::os::raw::c_int,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Creates 4-dimensional blob from series of images.\n  @details This is an overloaded member function, provided for convenience.\n           It differs from the above function only in what argument(s) it accepts."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120214blobFromImagesERKNS_11_InputArrayERKNS_12_OutputArrayEdNS_5Size_IiEERKNS_7Scalar_IdEEbbi"]
    pub fn cv_dnn_dnn4_v20191202_blobFromImages1(
        images: cv_InputArrayOfArrays,
        blob: cv_OutputArray,
        scalefactor: f64,
        size: cv_Size,
        mean: *const cv_Scalar,
        swapRB: bool,
        crop: bool,
        ddepth: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Parse a 4D blob and output the images it contains as 2D arrays through a simpler data structure\n  (std::vector<cv::Mat>).\n  @param[in] blob_ 4 dimensional array (images, channels, height, width) in floating point precision (CV_32F) from\n  which you would like to extract the images.\n  @param[out] images_ array of 2D Mat containing the images extracted from the blob in floating point precision\n  (CV_32F). They are non normalized neither mean added. The number of returned images equals the first dimension\n  of the blob (batch size). Every image has a number of channels equals to the second dimension of the blob (depth)."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120214imagesFromBlobERKNS_3MatERKNS_12_OutputArrayE"]
    pub fn cv_dnn_dnn4_v20191202_imagesFromBlob(
        blob_: *const cv_Mat,
        images_: cv_OutputArrayOfArrays,
    );
}
unsafe extern "C" {
    #[doc = " @brief Convert all weights of Caffe network to half precision floating point.\n @param src Path to origin model from Caffe framework contains single\n            precision floating point weights (usually has `.caffemodel` extension).\n @param dst Path to destination model with updated weights.\n @param layersTypes Set of layers types which parameters will be converted.\n                    By default, converts only Convolutional and Fully-Connected layers'\n                    weights.\n\n @note Shrinked model has no origin float32 weights so it can't be used\n       in origin Caffe framework anymore. However the structure of data\n       is taken from NVidia's Caffe fork: https://github.com/NVIDIA/caffe.\n       So the resulting model may be used there."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120216shrinkCaffeModelERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_RKSt6vectorIS7_SaIS7_EE"]
    pub fn cv_dnn_dnn4_v20191202_shrinkCaffeModel(
        src: *const cv_String,
        dst: *const cv_String,
        layersTypes: *const std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @brief Create a text representation for a binary network stored in protocol buffer format.\n  @param[in] model  A path to binary network.\n  @param[in] output A path to output text file to be created.\n\n  @note To reduce output file size, trained weights are not included."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120214writeTextGraphERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_"]
    pub fn cv_dnn_dnn4_v20191202_writeTextGraph(model: *const cv_String, output: *const cv_String);
}
unsafe extern "C" {
    #[doc = " @brief Performs non maximum suppression given boxes and corresponding scores.\n\n @param bboxes a set of bounding boxes to apply NMS.\n @param scores a set of corresponding confidences.\n @param score_threshold a threshold used to filter boxes by score.\n @param nms_threshold a threshold used in non maximum suppression.\n @param indices the kept indices of bboxes after NMS.\n @param eta a coefficient in adaptive threshold formula: \\f$nms\\_threshold_{i+1}=eta\\cdot nms\\_threshold_i\\f$.\n @param top_k if `>0`, keep at most @p top_k picked indices."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912028NMSBoxesERKSt6vectorINS_5Rect_IiEESaIS4_EERKS2_IfSaIfEEffRS2_IiSaIiEEfi"]
    pub fn cv_dnn_dnn4_v20191202_NMSBoxes(
        bboxes: *const std_vector,
        scores: *const std_vector,
        score_threshold: f32,
        nms_threshold: f32,
        indices: *mut std_vector,
        eta: f32,
        top_k: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912028NMSBoxesERKSt6vectorINS_5Rect_IdEESaIS4_EERKS2_IfSaIfEEffRS2_IiSaIiEEfi"]
    pub fn cv_dnn_dnn4_v20191202_NMSBoxes1(
        bboxes: *const std_vector,
        scores: *const std_vector,
        score_threshold: f32,
        nms_threshold: f32,
        indices: *mut std_vector,
        eta: f32,
        top_k: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912028NMSBoxesERKSt6vectorINS_11RotatedRectESaIS3_EERKS2_IfSaIfEEffRS2_IiSaIiEEfi"]
    pub fn cv_dnn_dnn4_v20191202_NMSBoxes2(
        bboxes: *const std_vector,
        scores: *const std_vector,
        score_threshold: f32,
        nms_threshold: f32,
        indices: *mut std_vector,
        eta: f32,
        top_k: ::std::os::raw::c_int,
    );
}
#[doc = " @brief This class is presented high-level API for neural networks.\n\n Model allows to set params for preprocessing input image.\n Model creates net from file with trained weights and config,\n sets preprocessing input and runs forward pass."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_dnn_dnn4_v20191202_Model {
    pub _base: cv_dnn_dnn4_v20191202_Net,
    pub impl_: cv_Ptr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_dnn_dnn4_v20191202_Model_Impl {
    _unused: [u8; 0],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_dnn_dnn4_v20191202_Model"]
        [::std::mem::size_of::<cv_dnn_dnn4_v20191202_Model>() - 32usize];
    ["Alignment of cv_dnn_dnn4_v20191202_Model"]
        [::std::mem::align_of::<cv_dnn_dnn4_v20191202_Model>() - 8usize];
    ["Offset of field: cv_dnn_dnn4_v20191202_Model::impl_"]
        [::std::mem::offset_of!(cv_dnn_dnn4_v20191202_Model, impl_) - 16usize];
};
unsafe extern "C" {
    #[doc = " @brief Set input size for frame.\n  @param[in] size New input size.\n  @note If shape of the new blob less than 0, then frame size not change."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Model12setInputSizeERKNS_5Size_IiEE"]
    pub fn cv_dnn_dnn4_v20191202_Model_setInputSize(
        this: *mut cv_dnn_dnn4_v20191202_Model,
        size: *const cv_Size,
    ) -> *mut cv_dnn_dnn4_v20191202_Model;
}
unsafe extern "C" {
    #[doc = " @brief Set input size for frame.\n  @param[in] width New input width.\n  @param[in] height New input height.\n  @note If shape of the new blob less than 0,\n  then frame size not change."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Model12setInputSizeEii"]
    pub fn cv_dnn_dnn4_v20191202_Model_setInputSize1(
        this: *mut cv_dnn_dnn4_v20191202_Model,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> *mut cv_dnn_dnn4_v20191202_Model;
}
unsafe extern "C" {
    #[doc = " @brief Set mean value for frame.\n  @param[in] mean Scalar with mean values which are subtracted from channels."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Model12setInputMeanERKNS_7Scalar_IdEE"]
    pub fn cv_dnn_dnn4_v20191202_Model_setInputMean(
        this: *mut cv_dnn_dnn4_v20191202_Model,
        mean: *const cv_Scalar,
    ) -> *mut cv_dnn_dnn4_v20191202_Model;
}
unsafe extern "C" {
    #[doc = " @brief Set scalefactor value for frame.\n  @param[in] scale Multiplier for frame values."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Model13setInputScaleEd"]
    pub fn cv_dnn_dnn4_v20191202_Model_setInputScale(
        this: *mut cv_dnn_dnn4_v20191202_Model,
        scale: f64,
    ) -> *mut cv_dnn_dnn4_v20191202_Model;
}
unsafe extern "C" {
    #[doc = " @brief Set flag crop for frame.\n  @param[in] crop Flag which indicates whether image will be cropped after resize or not."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Model12setInputCropEb"]
    pub fn cv_dnn_dnn4_v20191202_Model_setInputCrop(
        this: *mut cv_dnn_dnn4_v20191202_Model,
        crop: bool,
    ) -> *mut cv_dnn_dnn4_v20191202_Model;
}
unsafe extern "C" {
    #[doc = " @brief Set flag swapRB for frame.\n  @param[in] swapRB Flag which indicates that swap first and last channels."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Model14setInputSwapRBEb"]
    pub fn cv_dnn_dnn4_v20191202_Model_setInputSwapRB(
        this: *mut cv_dnn_dnn4_v20191202_Model,
        swapRB: bool,
    ) -> *mut cv_dnn_dnn4_v20191202_Model;
}
unsafe extern "C" {
    #[doc = " @brief Set preprocessing parameters for frame.\n  @param[in] size New input size.\n  @param[in] mean Scalar with mean values which are subtracted from channels.\n  @param[in] scale Multiplier for frame values.\n  @param[in] swapRB Flag which indicates that swap first and last channels.\n  @param[in] crop Flag which indicates whether image will be cropped after resize or not.\n  blob(n, c, y, x) = scale * resize( frame(y, x, c) ) - mean(c) )"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Model14setInputParamsEdRKNS_5Size_IiEERKNS_7Scalar_IdEEbb"]
    pub fn cv_dnn_dnn4_v20191202_Model_setInputParams(
        this: *mut cv_dnn_dnn4_v20191202_Model,
        scale: f64,
        size: *const cv_Size,
        mean: *const cv_Scalar,
        swapRB: bool,
        crop: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief Given the @p input frame, create input blob, run net and return the output @p blobs.\n  @param[in]  frame  The input image.\n  @param[out] outs Allocated output blobs, which will store results of the computation."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025Model7predictERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_dnn_dnn4_v20191202_Model_predict(
        this: *mut cv_dnn_dnn4_v20191202_Model,
        frame: cv_InputArray,
        outs: cv_OutputArrayOfArrays,
    );
}
unsafe extern "C" {
    #[doc = " @brief Default constructor."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025ModelC1Ev"]
    pub fn cv_dnn_dnn4_v20191202_Model_Model(this: *mut cv_dnn_dnn4_v20191202_Model);
}
unsafe extern "C" {
    #[doc = " @brief Create model from deep learning network represented in one of the supported formats.\n An order of @p model and @p config arguments does not matter.\n @param[in] model Binary file contains trained weights.\n @param[in] config Text file contains network configuration."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025ModelC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESA_"]
    pub fn cv_dnn_dnn4_v20191202_Model_Model1(
        this: *mut cv_dnn_dnn4_v20191202_Model,
        model: *const cv_String,
        config: *const cv_String,
    );
}
unsafe extern "C" {
    #[doc = " @brief Create model from deep learning network.\n @param[in] network Net object."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v201912025ModelC1ERKNS1_3NetE"]
    pub fn cv_dnn_dnn4_v20191202_Model_Model2(
        this: *mut cv_dnn_dnn4_v20191202_Model,
        network: *const cv_dnn_dnn4_v20191202_Net,
    );
}
impl cv_dnn_dnn4_v20191202_Model {
    #[inline]
    pub unsafe fn setInputSize(
        &mut self,
        size: *const cv_Size,
    ) -> *mut cv_dnn_dnn4_v20191202_Model {
        cv_dnn_dnn4_v20191202_Model_setInputSize(self, size)
    }
    #[inline]
    pub unsafe fn setInputSize1(
        &mut self,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> *mut cv_dnn_dnn4_v20191202_Model {
        cv_dnn_dnn4_v20191202_Model_setInputSize1(self, width, height)
    }
    #[inline]
    pub unsafe fn setInputMean(
        &mut self,
        mean: *const cv_Scalar,
    ) -> *mut cv_dnn_dnn4_v20191202_Model {
        cv_dnn_dnn4_v20191202_Model_setInputMean(self, mean)
    }
    #[inline]
    pub unsafe fn setInputScale(&mut self, scale: f64) -> *mut cv_dnn_dnn4_v20191202_Model {
        cv_dnn_dnn4_v20191202_Model_setInputScale(self, scale)
    }
    #[inline]
    pub unsafe fn setInputCrop(&mut self, crop: bool) -> *mut cv_dnn_dnn4_v20191202_Model {
        cv_dnn_dnn4_v20191202_Model_setInputCrop(self, crop)
    }
    #[inline]
    pub unsafe fn setInputSwapRB(&mut self, swapRB: bool) -> *mut cv_dnn_dnn4_v20191202_Model {
        cv_dnn_dnn4_v20191202_Model_setInputSwapRB(self, swapRB)
    }
    #[inline]
    pub unsafe fn setInputParams(
        &mut self,
        scale: f64,
        size: *const cv_Size,
        mean: *const cv_Scalar,
        swapRB: bool,
        crop: bool,
    ) {
        cv_dnn_dnn4_v20191202_Model_setInputParams(self, scale, size, mean, swapRB, crop)
    }
    #[inline]
    pub unsafe fn predict(&mut self, frame: cv_InputArray, outs: cv_OutputArrayOfArrays) {
        cv_dnn_dnn4_v20191202_Model_predict(self, frame, outs)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_dnn_dnn4_v20191202_Model_Model(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(model: *const cv_String, config: *const cv_String) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_dnn_dnn4_v20191202_Model_Model1(__bindgen_tmp.as_mut_ptr(), model, config);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(network: *const cv_dnn_dnn4_v20191202_Net) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_dnn_dnn4_v20191202_Model_Model2(__bindgen_tmp.as_mut_ptr(), network);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This class represents high-level API for classification models.\n\n ClassificationModel allows to set params for preprocessing input image.\n ClassificationModel creates net from file with trained weights and config,\n sets preprocessing input, runs forward pass and return top-1 prediction."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_dnn_dnn4_v20191202_ClassificationModel {
    pub _base: cv_dnn_dnn4_v20191202_Model,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_dnn_dnn4_v20191202_ClassificationModel"]
        [::std::mem::size_of::<cv_dnn_dnn4_v20191202_ClassificationModel>() - 32usize];
    ["Alignment of cv_dnn_dnn4_v20191202_ClassificationModel"]
        [::std::mem::align_of::<cv_dnn_dnn4_v20191202_ClassificationModel>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Given the @p input frame, create input blob, run net and return top-1 prediction.\n  @param[in]  frame  The input image."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120219ClassificationModel8classifyERKNS_11_InputArrayE"]
    pub fn cv_dnn_dnn4_v20191202_ClassificationModel_classify(
        this: *mut cv_dnn_dnn4_v20191202_ClassificationModel,
        frame: cv_InputArray,
    ) -> std_pair<::std::os::raw::c_int, f32>;
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120219ClassificationModel8classifyERKNS_11_InputArrayERiRf"]
    pub fn cv_dnn_dnn4_v20191202_ClassificationModel_classify1(
        this: *mut cv_dnn_dnn4_v20191202_ClassificationModel,
        frame: cv_InputArray,
        classId: *mut ::std::os::raw::c_int,
        conf: *mut f32,
    );
}
unsafe extern "C" {
    #[doc = " @brief Create classification model from network represented in one of the supported formats.\n An order of @p model and @p config arguments does not matter.\n @param[in] model Binary file contains trained weights.\n @param[in] config Text file contains network configuration."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120219ClassificationModelC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESA_"]
    pub fn cv_dnn_dnn4_v20191202_ClassificationModel_ClassificationModel(
        this: *mut cv_dnn_dnn4_v20191202_ClassificationModel,
        model: *const cv_String,
        config: *const cv_String,
    );
}
unsafe extern "C" {
    #[doc = " @brief Create model from deep learning network.\n @param[in] network Net object."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120219ClassificationModelC1ERKNS1_3NetE"]
    pub fn cv_dnn_dnn4_v20191202_ClassificationModel_ClassificationModel1(
        this: *mut cv_dnn_dnn4_v20191202_ClassificationModel,
        network: *const cv_dnn_dnn4_v20191202_Net,
    );
}
impl cv_dnn_dnn4_v20191202_ClassificationModel {
    #[inline]
    pub unsafe fn classify(
        &mut self,
        frame: cv_InputArray,
    ) -> std_pair<::std::os::raw::c_int, f32> {
        cv_dnn_dnn4_v20191202_ClassificationModel_classify(self, frame)
    }
    #[inline]
    pub unsafe fn classify1(
        &mut self,
        frame: cv_InputArray,
        classId: *mut ::std::os::raw::c_int,
        conf: *mut f32,
    ) {
        cv_dnn_dnn4_v20191202_ClassificationModel_classify1(self, frame, classId, conf)
    }
    #[inline]
    pub unsafe fn new(model: *const cv_String, config: *const cv_String) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_dnn_dnn4_v20191202_ClassificationModel_ClassificationModel(
            __bindgen_tmp.as_mut_ptr(),
            model,
            config,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(network: *const cv_dnn_dnn4_v20191202_Net) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_dnn_dnn4_v20191202_ClassificationModel_ClassificationModel1(
            __bindgen_tmp.as_mut_ptr(),
            network,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This class represents high-level API for keypoints models\n\n KeypointsModel allows to set params for preprocessing input image.\n KeypointsModel creates net from file with trained weights and config,\n sets preprocessing input, runs forward pass and returns the x and y coordinates of each detected keypoint"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_dnn_dnn4_v20191202_KeypointsModel {
    pub _base: cv_dnn_dnn4_v20191202_Model,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_dnn_dnn4_v20191202_KeypointsModel"]
        [::std::mem::size_of::<cv_dnn_dnn4_v20191202_KeypointsModel>() - 32usize];
    ["Alignment of cv_dnn_dnn4_v20191202_KeypointsModel"]
        [::std::mem::align_of::<cv_dnn_dnn4_v20191202_KeypointsModel>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Given the @p input frame, create input blob, run net\n  @param[in]  frame  The input image.\n  @param thresh minimum confidence threshold to select a keypoint\n  @returns a vector holding the x and y coordinates of each detected keypoint\n"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120214KeypointsModel8estimateERKNS_11_InputArrayEf"]
    pub fn cv_dnn_dnn4_v20191202_KeypointsModel_estimate(
        this: *mut cv_dnn_dnn4_v20191202_KeypointsModel,
        frame: cv_InputArray,
        thresh: f32,
    ) -> std_vector;
}
unsafe extern "C" {
    #[doc = " @brief Create keypoints model from network represented in one of the supported formats.\n An order of @p model and @p config arguments does not matter.\n @param[in] model Binary file contains trained weights.\n @param[in] config Text file contains network configuration."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120214KeypointsModelC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESA_"]
    pub fn cv_dnn_dnn4_v20191202_KeypointsModel_KeypointsModel(
        this: *mut cv_dnn_dnn4_v20191202_KeypointsModel,
        model: *const cv_String,
        config: *const cv_String,
    );
}
unsafe extern "C" {
    #[doc = " @brief Create model from deep learning network.\n @param[in] network Net object."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120214KeypointsModelC1ERKNS1_3NetE"]
    pub fn cv_dnn_dnn4_v20191202_KeypointsModel_KeypointsModel1(
        this: *mut cv_dnn_dnn4_v20191202_KeypointsModel,
        network: *const cv_dnn_dnn4_v20191202_Net,
    );
}
impl cv_dnn_dnn4_v20191202_KeypointsModel {
    #[inline]
    pub unsafe fn estimate(&mut self, frame: cv_InputArray, thresh: f32) -> std_vector {
        cv_dnn_dnn4_v20191202_KeypointsModel_estimate(self, frame, thresh)
    }
    #[inline]
    pub unsafe fn new(model: *const cv_String, config: *const cv_String) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_dnn_dnn4_v20191202_KeypointsModel_KeypointsModel(
            __bindgen_tmp.as_mut_ptr(),
            model,
            config,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(network: *const cv_dnn_dnn4_v20191202_Net) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_dnn_dnn4_v20191202_KeypointsModel_KeypointsModel1(__bindgen_tmp.as_mut_ptr(), network);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This class represents high-level API for segmentation  models\n\n SegmentationModel allows to set params for preprocessing input image.\n SegmentationModel creates net from file with trained weights and config,\n sets preprocessing input, runs forward pass and returns the class prediction for each pixel."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_dnn_dnn4_v20191202_SegmentationModel {
    pub _base: cv_dnn_dnn4_v20191202_Model,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_dnn_dnn4_v20191202_SegmentationModel"]
        [::std::mem::size_of::<cv_dnn_dnn4_v20191202_SegmentationModel>() - 32usize];
    ["Alignment of cv_dnn_dnn4_v20191202_SegmentationModel"]
        [::std::mem::align_of::<cv_dnn_dnn4_v20191202_SegmentationModel>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Given the @p input frame, create input blob, run net\n  @param[in]  frame  The input image.\n  @param[out] mask Allocated class prediction for each pixel"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120217SegmentationModel7segmentERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_dnn_dnn4_v20191202_SegmentationModel_segment(
        this: *mut cv_dnn_dnn4_v20191202_SegmentationModel,
        frame: cv_InputArray,
        mask: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Create segmentation model from network represented in one of the supported formats.\n An order of @p model and @p config arguments does not matter.\n @param[in] model Binary file contains trained weights.\n @param[in] config Text file contains network configuration."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120217SegmentationModelC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESA_"]
    pub fn cv_dnn_dnn4_v20191202_SegmentationModel_SegmentationModel(
        this: *mut cv_dnn_dnn4_v20191202_SegmentationModel,
        model: *const cv_String,
        config: *const cv_String,
    );
}
unsafe extern "C" {
    #[doc = " @brief Create model from deep learning network.\n @param[in] network Net object."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120217SegmentationModelC1ERKNS1_3NetE"]
    pub fn cv_dnn_dnn4_v20191202_SegmentationModel_SegmentationModel1(
        this: *mut cv_dnn_dnn4_v20191202_SegmentationModel,
        network: *const cv_dnn_dnn4_v20191202_Net,
    );
}
impl cv_dnn_dnn4_v20191202_SegmentationModel {
    #[inline]
    pub unsafe fn segment(&mut self, frame: cv_InputArray, mask: cv_OutputArray) {
        cv_dnn_dnn4_v20191202_SegmentationModel_segment(self, frame, mask)
    }
    #[inline]
    pub unsafe fn new(model: *const cv_String, config: *const cv_String) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_dnn_dnn4_v20191202_SegmentationModel_SegmentationModel(
            __bindgen_tmp.as_mut_ptr(),
            model,
            config,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(network: *const cv_dnn_dnn4_v20191202_Net) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_dnn_dnn4_v20191202_SegmentationModel_SegmentationModel1(
            __bindgen_tmp.as_mut_ptr(),
            network,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This class represents high-level API for object detection networks.\n\n DetectionModel allows to set params for preprocessing input image.\n DetectionModel creates net from file with trained weights and config,\n sets preprocessing input, runs forward pass and return result detections.\n For DetectionModel SSD, Faster R-CNN, YOLO topologies are supported."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_dnn_dnn4_v20191202_DetectionModel {
    pub _base: cv_dnn_dnn4_v20191202_Model,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_dnn_dnn4_v20191202_DetectionModel"]
        [::std::mem::size_of::<cv_dnn_dnn4_v20191202_DetectionModel>() - 32usize];
    ["Alignment of cv_dnn_dnn4_v20191202_DetectionModel"]
        [::std::mem::align_of::<cv_dnn_dnn4_v20191202_DetectionModel>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Given the @p input frame, create input blob, run net and return result detections.\n  @param[in]  frame  The input image.\n  @param[out] classIds Class indexes in result detection.\n  @param[out] confidences A set of corresponding confidences.\n  @param[out] boxes A set of bounding boxes.\n  @param[in] confThreshold A threshold used to filter boxes by confidences.\n  @param[in] nmsThreshold A threshold used in non maximum suppression."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120214DetectionModel6detectERKNS_11_InputArrayERSt6vectorIiSaIiEERS6_IfSaIfEERS6_INS_5Rect_IiEESaISE_EEff"]
    pub fn cv_dnn_dnn4_v20191202_DetectionModel_detect(
        this: *mut cv_dnn_dnn4_v20191202_DetectionModel,
        frame: cv_InputArray,
        classIds: *mut std_vector,
        confidences: *mut std_vector,
        boxes: *mut std_vector,
        confThreshold: f32,
        nmsThreshold: f32,
    );
}
unsafe extern "C" {
    #[doc = " @brief Create detection model from network represented in one of the supported formats.\n An order of @p model and @p config arguments does not matter.\n @param[in] model Binary file contains trained weights.\n @param[in] config Text file contains network configuration."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120214DetectionModelC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESA_"]
    pub fn cv_dnn_dnn4_v20191202_DetectionModel_DetectionModel(
        this: *mut cv_dnn_dnn4_v20191202_DetectionModel,
        model: *const cv_String,
        config: *const cv_String,
    );
}
unsafe extern "C" {
    #[doc = " @brief Create model from deep learning network.\n @param[in] network Net object."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120214DetectionModelC1ERKNS1_3NetE"]
    pub fn cv_dnn_dnn4_v20191202_DetectionModel_DetectionModel1(
        this: *mut cv_dnn_dnn4_v20191202_DetectionModel,
        network: *const cv_dnn_dnn4_v20191202_Net,
    );
}
impl cv_dnn_dnn4_v20191202_DetectionModel {
    #[inline]
    pub unsafe fn detect(
        &mut self,
        frame: cv_InputArray,
        classIds: *mut std_vector,
        confidences: *mut std_vector,
        boxes: *mut std_vector,
        confThreshold: f32,
        nmsThreshold: f32,
    ) {
        cv_dnn_dnn4_v20191202_DetectionModel_detect(
            self,
            frame,
            classIds,
            confidences,
            boxes,
            confThreshold,
            nmsThreshold,
        )
    }
    #[inline]
    pub unsafe fn new(model: *const cv_String, config: *const cv_String) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_dnn_dnn4_v20191202_DetectionModel_DetectionModel(
            __bindgen_tmp.as_mut_ptr(),
            model,
            config,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(network: *const cv_dnn_dnn4_v20191202_Net) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_dnn_dnn4_v20191202_DetectionModel_DetectionModel1(__bindgen_tmp.as_mut_ptr(), network);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief %Layer factory allows to create instances of registered layers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_dnn_dnn4_v20191202_LayerFactory {
    pub _address: u8,
}
#[doc = "! Each Layer class must provide this function to the factory"]
pub type cv_dnn_dnn4_v20191202_LayerFactory_Constructor = ::std::option::Option<
    unsafe extern "C" fn(params: *mut cv_dnn_dnn4_v20191202_LayerParams) -> cv_Ptr,
>;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_dnn_dnn4_v20191202_LayerFactory"]
        [::std::mem::size_of::<cv_dnn_dnn4_v20191202_LayerFactory>() - 1usize];
    ["Alignment of cv_dnn_dnn4_v20191202_LayerFactory"]
        [::std::mem::align_of::<cv_dnn_dnn4_v20191202_LayerFactory>() - 1usize];
};
unsafe extern "C" {
    #[doc = "! Registers the layer class with typename @p type and specified @p constructor. Thread-safe."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120212LayerFactory13registerLayerERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPFNS_3PtrINS1_5LayerEEERNS1_11LayerParamsEE"]
    pub fn cv_dnn_dnn4_v20191202_LayerFactory_registerLayer(
        type_: *const cv_String,
        constructor: cv_dnn_dnn4_v20191202_LayerFactory_Constructor,
    );
}
unsafe extern "C" {
    #[doc = "! Unregisters registered layer with specified type name. Thread-safe."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120212LayerFactory15unregisterLayerERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_dnn_dnn4_v20191202_LayerFactory_unregisterLayer(type_: *const cv_String);
}
unsafe extern "C" {
    #[doc = " @brief Creates instance of registered layer.\n  @param type type name of creating layer.\n  @param params parameters which will be used for layer initialization.\n  @note Thread-safe."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120212LayerFactory19createLayerInstanceERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERNS1_11LayerParamsE"]
    pub fn cv_dnn_dnn4_v20191202_LayerFactory_createLayerInstance(
        type_: *const cv_String,
        params: *mut cv_dnn_dnn4_v20191202_LayerParams,
    ) -> cv_Ptr;
}
impl cv_dnn_dnn4_v20191202_LayerFactory {
    #[inline]
    pub unsafe fn registerLayer(
        type_: *const cv_String,
        constructor: cv_dnn_dnn4_v20191202_LayerFactory_Constructor,
    ) {
        cv_dnn_dnn4_v20191202_LayerFactory_registerLayer(type_, constructor)
    }
    #[inline]
    pub unsafe fn unregisterLayer(type_: *const cv_String) {
        cv_dnn_dnn4_v20191202_LayerFactory_unregisterLayer(type_)
    }
    #[inline]
    pub unsafe fn createLayerInstance(
        type_: *const cv_String,
        params: *mut cv_dnn_dnn4_v20191202_LayerParams,
    ) -> cv_Ptr {
        cv_dnn_dnn4_v20191202_LayerFactory_createLayerInstance(type_, params)
    }
}
unsafe extern "C" {
    #[doc = " @brief Returns Inference Engine internal backend API.\n\n See values of `CV_DNN_BACKEND_INFERENCE_ENGINE_*` macros.\n\n Default value is controlled through `OPENCV_DNN_BACKEND_INFERENCE_ENGINE_TYPE` runtime parameter (environment variable)."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120229getInferenceEngineBackendTypeB5cxx11Ev"]
    pub fn cv_dnn_dnn4_v20191202_getInferenceEngineBackendType() -> cv_String;
}
unsafe extern "C" {
    #[doc = " @brief Specify Inference Engine internal backend API.\n\n See values of `CV_DNN_BACKEND_INFERENCE_ENGINE_*` macros.\n\n @returns previous value of internal backend API"]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120229setInferenceEngineBackendTypeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_dnn_dnn4_v20191202_setInferenceEngineBackendType(
        newBackendType: *const cv_String,
    ) -> cv_String;
}
unsafe extern "C" {
    #[doc = " @brief Release a Myriad device (binded by OpenCV).\n\n Single Myriad device cannot be shared across multiple processes which uses\n Inference Engine's Myriad plugin."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120217resetMyriadDeviceEv"]
    pub fn cv_dnn_dnn4_v20191202_resetMyriadDevice();
}
unsafe extern "C" {
    #[doc = " @brief Returns Inference Engine VPU type.\n\n See values of `CV_DNN_INFERENCE_ENGINE_VPU_TYPE_*` macros."]
    #[link_name = "\u{1}_ZN2cv3dnn14dnn4_v2019120225getInferenceEngineVPUTypeB5cxx11Ev"]
    pub fn cv_dnn_dnn4_v20191202_getInferenceEngineVPUType() -> cv_String;
}
#[doc = "!< If set, return the loaded image as is (with alpha channel, otherwise it gets cropped)."]
pub const cv_ImreadModes_IMREAD_UNCHANGED: cv_ImreadModes = -1;
#[doc = "!< If set, always convert image to the single channel grayscale image (codec internal conversion)."]
pub const cv_ImreadModes_IMREAD_GRAYSCALE: cv_ImreadModes = 0;
#[doc = "!< If set, always convert image to the 3 channel BGR color image."]
pub const cv_ImreadModes_IMREAD_COLOR: cv_ImreadModes = 1;
#[doc = "!< If set, return 16-bit/32-bit image when the input has the corresponding depth, otherwise convert it to 8-bit."]
pub const cv_ImreadModes_IMREAD_ANYDEPTH: cv_ImreadModes = 2;
#[doc = "!< If set, the image is read in any possible color format."]
pub const cv_ImreadModes_IMREAD_ANYCOLOR: cv_ImreadModes = 4;
#[doc = "!< If set, use the gdal driver for loading the image."]
pub const cv_ImreadModes_IMREAD_LOAD_GDAL: cv_ImreadModes = 8;
#[doc = "!< If set, always convert image to the single channel grayscale image and the image size reduced 1/2."]
pub const cv_ImreadModes_IMREAD_REDUCED_GRAYSCALE_2: cv_ImreadModes = 16;
#[doc = "!< If set, always convert image to the 3 channel BGR color image and the image size reduced 1/2."]
pub const cv_ImreadModes_IMREAD_REDUCED_COLOR_2: cv_ImreadModes = 17;
#[doc = "!< If set, always convert image to the single channel grayscale image and the image size reduced 1/4."]
pub const cv_ImreadModes_IMREAD_REDUCED_GRAYSCALE_4: cv_ImreadModes = 32;
#[doc = "!< If set, always convert image to the 3 channel BGR color image and the image size reduced 1/4."]
pub const cv_ImreadModes_IMREAD_REDUCED_COLOR_4: cv_ImreadModes = 33;
#[doc = "!< If set, always convert image to the single channel grayscale image and the image size reduced 1/8."]
pub const cv_ImreadModes_IMREAD_REDUCED_GRAYSCALE_8: cv_ImreadModes = 64;
#[doc = "!< If set, always convert image to the 3 channel BGR color image and the image size reduced 1/8."]
pub const cv_ImreadModes_IMREAD_REDUCED_COLOR_8: cv_ImreadModes = 65;
#[doc = "!< If set, do not rotate the image according to EXIF's orientation flag."]
pub const cv_ImreadModes_IMREAD_IGNORE_ORIENTATION: cv_ImreadModes = 128;
#[doc = "! Imread flags"]
pub type cv_ImreadModes = ::std::os::raw::c_int;
#[doc = "!< For JPEG, it can be a quality from 0 to 100 (the higher is the better). Default value is 95."]
pub const cv_ImwriteFlags_IMWRITE_JPEG_QUALITY: cv_ImwriteFlags = 1;
#[doc = "!< Enable JPEG features, 0 or 1, default is False."]
pub const cv_ImwriteFlags_IMWRITE_JPEG_PROGRESSIVE: cv_ImwriteFlags = 2;
#[doc = "!< Enable JPEG features, 0 or 1, default is False."]
pub const cv_ImwriteFlags_IMWRITE_JPEG_OPTIMIZE: cv_ImwriteFlags = 3;
#[doc = "!< JPEG restart interval, 0 - 65535, default is 0 - no restart."]
pub const cv_ImwriteFlags_IMWRITE_JPEG_RST_INTERVAL: cv_ImwriteFlags = 4;
#[doc = "!< Separate luma quality level, 0 - 100, default is 0 - don't use."]
pub const cv_ImwriteFlags_IMWRITE_JPEG_LUMA_QUALITY: cv_ImwriteFlags = 5;
#[doc = "!< Separate chroma quality level, 0 - 100, default is 0 - don't use."]
pub const cv_ImwriteFlags_IMWRITE_JPEG_CHROMA_QUALITY: cv_ImwriteFlags = 6;
#[doc = "!< For PNG, it can be the compression level from 0 to 9. A higher value means a smaller size and longer compression time. If specified, strategy is changed to IMWRITE_PNG_STRATEGY_DEFAULT (Z_DEFAULT_STRATEGY). Default value is 1 (best speed setting)."]
pub const cv_ImwriteFlags_IMWRITE_PNG_COMPRESSION: cv_ImwriteFlags = 16;
#[doc = "!< One of cv::ImwritePNGFlags, default is IMWRITE_PNG_STRATEGY_RLE."]
pub const cv_ImwriteFlags_IMWRITE_PNG_STRATEGY: cv_ImwriteFlags = 17;
#[doc = "!< Binary level PNG, 0 or 1, default is 0."]
pub const cv_ImwriteFlags_IMWRITE_PNG_BILEVEL: cv_ImwriteFlags = 18;
#[doc = "!< For PPM, PGM, or PBM, it can be a binary format flag, 0 or 1. Default value is 1."]
pub const cv_ImwriteFlags_IMWRITE_PXM_BINARY: cv_ImwriteFlags = 32;
#[doc = "!< override EXR storage type (FLOAT (FP32) is default)"]
pub const cv_ImwriteFlags_IMWRITE_EXR_TYPE: cv_ImwriteFlags = 48;
#[doc = "!< For WEBP, it can be a quality from 1 to 100 (the higher is the better). By default (without any parameter) and for quality above 100 the lossless compression is used."]
pub const cv_ImwriteFlags_IMWRITE_WEBP_QUALITY: cv_ImwriteFlags = 64;
#[doc = "!< For PAM, sets the TUPLETYPE field to the corresponding string value that is defined for the format"]
pub const cv_ImwriteFlags_IMWRITE_PAM_TUPLETYPE: cv_ImwriteFlags = 128;
#[doc = "!< For TIFF, use to specify which DPI resolution unit to set; see libtiff documentation for valid values"]
pub const cv_ImwriteFlags_IMWRITE_TIFF_RESUNIT: cv_ImwriteFlags = 256;
#[doc = "!< For TIFF, use to specify the X direction DPI"]
pub const cv_ImwriteFlags_IMWRITE_TIFF_XDPI: cv_ImwriteFlags = 257;
#[doc = "!< For TIFF, use to specify the Y direction DPI"]
pub const cv_ImwriteFlags_IMWRITE_TIFF_YDPI: cv_ImwriteFlags = 258;
#[doc = "!< For TIFF, use to specify the image compression scheme. See libtiff for integer constants corresponding to compression formats. Note, for images whose depth is CV_32F, only libtiff's SGILOG compression scheme is used. For other supported depths, the compression scheme can be specified by this flag; LZW compression is the default."]
pub const cv_ImwriteFlags_IMWRITE_TIFF_COMPRESSION: cv_ImwriteFlags = 259;
#[doc = "!< For JPEG2000, use to specify the target compression rate (multiplied by 1000). The value can be from 0 to 1000. Default is 1000."]
pub const cv_ImwriteFlags_IMWRITE_JPEG2000_COMPRESSION_X1000: cv_ImwriteFlags = 272;
#[doc = "! Imwrite flags"]
pub type cv_ImwriteFlags = ::std::os::raw::c_uint;
#[doc = "!< store as HALF (FP16)"]
pub const cv_ImwriteEXRTypeFlags_IMWRITE_EXR_TYPE_HALF: cv_ImwriteEXRTypeFlags = 1;
#[doc = "!< store as FP32 (default)"]
pub const cv_ImwriteEXRTypeFlags_IMWRITE_EXR_TYPE_FLOAT: cv_ImwriteEXRTypeFlags = 2;
pub type cv_ImwriteEXRTypeFlags = ::std::os::raw::c_uint;
#[doc = "!< Use this value for normal data."]
pub const cv_ImwritePNGFlags_IMWRITE_PNG_STRATEGY_DEFAULT: cv_ImwritePNGFlags = 0;
#[doc = "!< Use this value for data produced by a filter (or predictor).Filtered data consists mostly of small values with a somewhat random distribution. In this case, the compression algorithm is tuned to compress them better."]
pub const cv_ImwritePNGFlags_IMWRITE_PNG_STRATEGY_FILTERED: cv_ImwritePNGFlags = 1;
#[doc = "!< Use this value to force Huffman encoding only (no string match)."]
pub const cv_ImwritePNGFlags_IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY: cv_ImwritePNGFlags = 2;
#[doc = "!< Use this value to limit match distances to one (run-length encoding)."]
pub const cv_ImwritePNGFlags_IMWRITE_PNG_STRATEGY_RLE: cv_ImwritePNGFlags = 3;
#[doc = "!< Using this value prevents the use of dynamic Huffman codes, allowing for a simpler decoder for special applications."]
pub const cv_ImwritePNGFlags_IMWRITE_PNG_STRATEGY_FIXED: cv_ImwritePNGFlags = 4;
#[doc = "! Imwrite PNG specific flags used to tune the compression algorithm.\n** These flags will be modify the way of PNG image compression and will be passed to the underlying zlib processing stage.\n\n-   The effect of IMWRITE_PNG_STRATEGY_FILTERED is to force more Huffman coding and less string matching; it is somewhat intermediate between IMWRITE_PNG_STRATEGY_DEFAULT and IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY.\n-   IMWRITE_PNG_STRATEGY_RLE is designed to be almost as fast as IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY, but give better compression for PNG image data.\n-   The strategy parameter only affects the compression ratio but not the correctness of the compressed output even if it is not set appropriately.\n-   IMWRITE_PNG_STRATEGY_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler decoder for special applications.\n*/"]
pub type cv_ImwritePNGFlags = ::std::os::raw::c_uint;
pub const cv_ImwritePAMFlags_IMWRITE_PAM_FORMAT_NULL: cv_ImwritePAMFlags = 0;
pub const cv_ImwritePAMFlags_IMWRITE_PAM_FORMAT_BLACKANDWHITE: cv_ImwritePAMFlags = 1;
pub const cv_ImwritePAMFlags_IMWRITE_PAM_FORMAT_GRAYSCALE: cv_ImwritePAMFlags = 2;
pub const cv_ImwritePAMFlags_IMWRITE_PAM_FORMAT_GRAYSCALE_ALPHA: cv_ImwritePAMFlags = 3;
pub const cv_ImwritePAMFlags_IMWRITE_PAM_FORMAT_RGB: cv_ImwritePAMFlags = 4;
pub const cv_ImwritePAMFlags_IMWRITE_PAM_FORMAT_RGB_ALPHA: cv_ImwritePAMFlags = 5;
#[doc = "! Imwrite PAM specific tupletype flags used to define the 'TUPETYPE' field of a PAM file."]
pub type cv_ImwritePAMFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Loads an image from a file.\n\n@anchor imread\n\nThe function imread loads an image from the specified file and returns it. If the image cannot be\nread (because of missing file, improper permissions, unsupported or invalid format), the function\nreturns an empty matrix ( Mat::data==NULL ).\n\nCurrently, the following file formats are supported:\n\n-   Windows bitmaps - \\*.bmp, \\*.dib (always supported)\n-   JPEG files - \\*.jpeg, \\*.jpg, \\*.jpe (see the *Note* section)\n-   JPEG 2000 files - \\*.jp2 (see the *Note* section)\n-   Portable Network Graphics - \\*.png (see the *Note* section)\n-   WebP - \\*.webp (see the *Note* section)\n-   Portable image format - \\*.pbm, \\*.pgm, \\*.ppm \\*.pxm, \\*.pnm (always supported)\n-   PFM files - \\*.pfm (see the *Note* section)\n-   Sun rasters - \\*.sr, \\*.ras (always supported)\n-   TIFF files - \\*.tiff, \\*.tif (see the *Note* section)\n-   OpenEXR Image files - \\*.exr (see the *Note* section)\n-   Radiance HDR - \\*.hdr, \\*.pic (always supported)\n-   Raster and Vector geospatial data supported by GDAL (see the *Note* section)\n\n@note\n-   The function determines the type of an image by the content, not by the file extension.\n-   In the case of color images, the decoded images will have the channels stored in **B G R** order.\n-   When using IMREAD_GRAYSCALE, the codec's internal grayscale conversion will be used, if available.\nResults may differ to the output of cvtColor()\n-   On Microsoft Windows\\* OS and MacOSX\\*, the codecs shipped with an OpenCV image (libjpeg,\nlibpng, libtiff, and libjasper) are used by default. So, OpenCV can always read JPEGs, PNGs,\nand TIFFs. On MacOSX, there is also an option to use native MacOSX image readers. But beware\nthat currently these native image loaders give images with different pixel values because of\nthe color management embedded into MacOSX.\n-   On Linux\\*, BSD flavors and other Unix-like open-source operating systems, OpenCV looks for\ncodecs supplied with an OS image. Install the relevant packages (do not forget the development\nfiles, for example, \"libjpeg-dev\", in Debian\\* and Ubuntu\\*) to get the codec support or turn\non the OPENCV_BUILD_3RDPARTY_LIBS flag in CMake.\n-   In the case you set *WITH_GDAL* flag to true in CMake and @ref IMREAD_LOAD_GDAL to load the image,\nthen the [GDAL](http://www.gdal.org) driver will be used in order to decode the image, supporting\nthe following formats: [Raster](http://www.gdal.org/formats_list.html),\n[Vector](http://www.gdal.org/ogr_formats.html).\n-   If EXIF information are embedded in the image file, the EXIF orientation will be taken into account\nand thus the image will be rotated accordingly except if the flag @ref IMREAD_IGNORE_ORIENTATION is passed.\n-   Use the IMREAD_UNCHANGED flag to keep the floating point values from PFM image.\n-   By default number of pixels must be less than 2^30. Limit can be set using system\nvariable OPENCV_IO_MAX_IMAGE_PIXELS\n\n@param filename Name of file to be loaded.\n@param flags Flag that can take values of cv::ImreadModes"]
    #[link_name = "\u{1}_ZN2cv6imreadERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
    pub fn cv_imread(filename: *const cv_String, flags: ::std::os::raw::c_int) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Loads a multi-page image from a file.\n\nThe function imreadmulti loads a multi-page image from the specified file into a vector of Mat objects.\n@param filename Name of file to be loaded.\n@param flags Flag that can take values of cv::ImreadModes, default with cv::IMREAD_ANYCOLOR.\n@param mats A vector of Mat objects holding each page, if more than one.\n@sa cv::imread"]
    #[link_name = "\u{1}_ZN2cv11imreadmultiERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERSt6vectorINS_3MatESaIS9_EEi"]
    pub fn cv_imreadmulti(
        filename: *const cv_String,
        mats: *mut std_vector,
        flags: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Saves an image to a specified file.\n\nThe function imwrite saves the image to the specified file. The image format is chosen based on the\nfilename extension (see cv::imread for the list of extensions). In general, only 8-bit\nsingle-channel or 3-channel (with 'BGR' channel order) images\ncan be saved using this function, with these exceptions:\n\n- 16-bit unsigned (CV_16U) images can be saved in the case of PNG, JPEG 2000, and TIFF formats\n- 32-bit float (CV_32F) images can be saved in PFM, TIFF, OpenEXR, and Radiance HDR formats;\n3-channel (CV_32FC3) TIFF images will be saved using the LogLuv high dynamic range encoding\n(4 bytes per pixel)\n- PNG images with an alpha channel can be saved using this function. To do this, create\n8-bit (or 16-bit) 4-channel image BGRA, where the alpha channel goes last. Fully transparent pixels\nshould have alpha set to 0, fully opaque pixels should have alpha set to 255/65535 (see the code sample below).\n\nIf the format, depth or channel order is different, use\nMat::convertTo and cv::cvtColor to convert it before saving. Or, use the universal FileStorage I/O\nfunctions to save the image to XML or YAML format.\n\nThe sample below shows how to create a BGRA image and save it to a PNG file. It also demonstrates how to set custom\ncompression parameters:\n@include snippets/imgcodecs_imwrite.cpp\n@param filename Name of the file.\n@param img Image to be saved.\n@param params Format-specific parameters encoded as pairs (paramId_1, paramValue_1, paramId_2, paramValue_2, ... .) see cv::ImwriteFlags"]
    #[link_name = "\u{1}_ZN2cv7imwriteERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_11_InputArrayERKSt6vectorIiSaIiEE"]
    pub fn cv_imwrite(
        filename: *const cv_String,
        img: cv_InputArray,
        params: *const std_vector,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Reads an image from a buffer in memory.\n\nThe function imdecode reads an image from the specified buffer in the memory. If the buffer is too short or\ncontains invalid data, the function returns an empty matrix ( Mat::data==NULL ).\n\nSee cv::imread for the list of supported formats and flags description.\n\n@note In the case of color images, the decoded images will have the channels stored in **B G R** order.\n@param buf Input array or vector of bytes.\n@param flags The same flags as in cv::imread, see cv::ImreadModes."]
    #[link_name = "\u{1}_ZN2cv8imdecodeERKNS_11_InputArrayEi"]
    pub fn cv_imdecode(buf: cv_InputArray, flags: ::std::os::raw::c_int) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @overload\n@param buf\n@param flags\n@param dst The optional output placeholder for the decoded matrix. It can save the image\nreallocations when the function is called repeatedly for images of the same size."]
    #[link_name = "\u{1}_ZN2cv8imdecodeERKNS_11_InputArrayEiPNS_3MatE"]
    pub fn cv_imdecode1(
        buf: cv_InputArray,
        flags: ::std::os::raw::c_int,
        dst: *mut cv_Mat,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Encodes an image into a memory buffer.\n\nThe function imencode compresses the image and stores it in the memory buffer that is resized to fit the\nresult. See cv::imwrite for the list of supported formats and flags description.\n\n@param ext File extension that defines the output format.\n@param img Image to be written.\n@param buf Output buffer resized to fit the compressed image.\n@param params Format-specific parameters. See cv::imwrite and cv::ImwriteFlags."]
    #[link_name = "\u{1}_ZN2cv8imencodeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_11_InputArrayERSt6vectorIhSaIhEERKSB_IiSaIiEE"]
    pub fn cv_imencode(
        ext: *const cv_String,
        img: cv_InputArray,
        buf: *mut std_vector,
        params: *const std_vector,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Returns true if the specified image can be decoded by OpenCV\n\n@param filename File name of the image"]
    #[link_name = "\u{1}_ZN2cv15haveImageReaderERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_haveImageReader(filename: *const cv_String) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Returns true if an image with the specified filename can be encoded by OpenCV\n\n@param filename File name of the image"]
    #[link_name = "\u{1}_ZN2cv15haveImageWriterERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_haveImageWriter(filename: *const cv_String) -> bool;
}
#[doc = "!< Auto detect == 0"]
pub const cv_VideoCaptureAPIs_CAP_ANY: cv_VideoCaptureAPIs = 0;
#[doc = "!< Video For Windows (obsolete, removed)"]
pub const cv_VideoCaptureAPIs_CAP_VFW: cv_VideoCaptureAPIs = 200;
#[doc = "!< V4L/V4L2 capturing support"]
pub const cv_VideoCaptureAPIs_CAP_V4L: cv_VideoCaptureAPIs = 200;
#[doc = "!< Same as CAP_V4L"]
pub const cv_VideoCaptureAPIs_CAP_V4L2: cv_VideoCaptureAPIs = 200;
#[doc = "!< IEEE 1394 drivers"]
pub const cv_VideoCaptureAPIs_CAP_FIREWIRE: cv_VideoCaptureAPIs = 300;
#[doc = "!< Same value as CAP_FIREWIRE"]
pub const cv_VideoCaptureAPIs_CAP_FIREWARE: cv_VideoCaptureAPIs = 300;
#[doc = "!< Same value as CAP_FIREWIRE"]
pub const cv_VideoCaptureAPIs_CAP_IEEE1394: cv_VideoCaptureAPIs = 300;
#[doc = "!< Same value as CAP_FIREWIRE"]
pub const cv_VideoCaptureAPIs_CAP_DC1394: cv_VideoCaptureAPIs = 300;
#[doc = "!< Same value as CAP_FIREWIRE"]
pub const cv_VideoCaptureAPIs_CAP_CMU1394: cv_VideoCaptureAPIs = 300;
#[doc = "!< QuickTime (obsolete, removed)"]
pub const cv_VideoCaptureAPIs_CAP_QT: cv_VideoCaptureAPIs = 500;
#[doc = "!< Unicap drivers (obsolete, removed)"]
pub const cv_VideoCaptureAPIs_CAP_UNICAP: cv_VideoCaptureAPIs = 600;
#[doc = "!< DirectShow (via videoInput)"]
pub const cv_VideoCaptureAPIs_CAP_DSHOW: cv_VideoCaptureAPIs = 700;
#[doc = "!< PvAPI, Prosilica GigE SDK"]
pub const cv_VideoCaptureAPIs_CAP_PVAPI: cv_VideoCaptureAPIs = 800;
#[doc = "!< OpenNI (for Kinect)"]
pub const cv_VideoCaptureAPIs_CAP_OPENNI: cv_VideoCaptureAPIs = 900;
#[doc = "!< OpenNI (for Asus Xtion)"]
pub const cv_VideoCaptureAPIs_CAP_OPENNI_ASUS: cv_VideoCaptureAPIs = 910;
#[doc = "!< Android - not used"]
pub const cv_VideoCaptureAPIs_CAP_ANDROID: cv_VideoCaptureAPIs = 1000;
#[doc = "!< XIMEA Camera API"]
pub const cv_VideoCaptureAPIs_CAP_XIAPI: cv_VideoCaptureAPIs = 1100;
#[doc = "!< AVFoundation framework for iOS (OS X Lion will have the same API)"]
pub const cv_VideoCaptureAPIs_CAP_AVFOUNDATION: cv_VideoCaptureAPIs = 1200;
#[doc = "!< Smartek Giganetix GigEVisionSDK"]
pub const cv_VideoCaptureAPIs_CAP_GIGANETIX: cv_VideoCaptureAPIs = 1300;
#[doc = "!< Microsoft Media Foundation (via videoInput)"]
pub const cv_VideoCaptureAPIs_CAP_MSMF: cv_VideoCaptureAPIs = 1400;
#[doc = "!< Microsoft Windows Runtime using Media Foundation"]
pub const cv_VideoCaptureAPIs_CAP_WINRT: cv_VideoCaptureAPIs = 1410;
#[doc = "!< RealSense (former Intel Perceptual Computing SDK)"]
pub const cv_VideoCaptureAPIs_CAP_INTELPERC: cv_VideoCaptureAPIs = 1500;
#[doc = "!< Synonym for CAP_INTELPERC"]
pub const cv_VideoCaptureAPIs_CAP_REALSENSE: cv_VideoCaptureAPIs = 1500;
#[doc = "!< OpenNI2 (for Kinect)"]
pub const cv_VideoCaptureAPIs_CAP_OPENNI2: cv_VideoCaptureAPIs = 1600;
#[doc = "!< OpenNI2 (for Asus Xtion and Occipital Structure sensors)"]
pub const cv_VideoCaptureAPIs_CAP_OPENNI2_ASUS: cv_VideoCaptureAPIs = 1610;
#[doc = "!< gPhoto2 connection"]
pub const cv_VideoCaptureAPIs_CAP_GPHOTO2: cv_VideoCaptureAPIs = 1700;
#[doc = "!< GStreamer"]
pub const cv_VideoCaptureAPIs_CAP_GSTREAMER: cv_VideoCaptureAPIs = 1800;
#[doc = "!< Open and record video file or stream using the FFMPEG library"]
pub const cv_VideoCaptureAPIs_CAP_FFMPEG: cv_VideoCaptureAPIs = 1900;
#[doc = "!< OpenCV Image Sequence (e.g. img_%02d.jpg)"]
pub const cv_VideoCaptureAPIs_CAP_IMAGES: cv_VideoCaptureAPIs = 2000;
#[doc = "!< Aravis SDK"]
pub const cv_VideoCaptureAPIs_CAP_ARAVIS: cv_VideoCaptureAPIs = 2100;
#[doc = "!< Built-in OpenCV MotionJPEG codec"]
pub const cv_VideoCaptureAPIs_CAP_OPENCV_MJPEG: cv_VideoCaptureAPIs = 2200;
#[doc = "!< Intel MediaSDK"]
pub const cv_VideoCaptureAPIs_CAP_INTEL_MFX: cv_VideoCaptureAPIs = 2300;
#[doc = "!< XINE engine (Linux)"]
pub const cv_VideoCaptureAPIs_CAP_XINE: cv_VideoCaptureAPIs = 2400;
#[doc = " @brief %VideoCapture API backends identifier.\n\nSelect preferred API for a capture object.\nTo be used in the VideoCapture::VideoCapture() constructor or VideoCapture::open()\n\n@note Backends are available only if they have been built with your OpenCV binaries.\nSee @ref videoio_overview for more information."]
pub type cv_VideoCaptureAPIs = ::std::os::raw::c_uint;
#[doc = "!< Current position of the video file in milliseconds."]
pub const cv_VideoCaptureProperties_CAP_PROP_POS_MSEC: cv_VideoCaptureProperties = 0;
#[doc = "!< 0-based index of the frame to be decoded/captured next."]
pub const cv_VideoCaptureProperties_CAP_PROP_POS_FRAMES: cv_VideoCaptureProperties = 1;
#[doc = "!< Relative position of the video file: 0=start of the film, 1=end of the film."]
pub const cv_VideoCaptureProperties_CAP_PROP_POS_AVI_RATIO: cv_VideoCaptureProperties = 2;
#[doc = "!< Width of the frames in the video stream."]
pub const cv_VideoCaptureProperties_CAP_PROP_FRAME_WIDTH: cv_VideoCaptureProperties = 3;
#[doc = "!< Height of the frames in the video stream."]
pub const cv_VideoCaptureProperties_CAP_PROP_FRAME_HEIGHT: cv_VideoCaptureProperties = 4;
#[doc = "!< Frame rate."]
pub const cv_VideoCaptureProperties_CAP_PROP_FPS: cv_VideoCaptureProperties = 5;
#[doc = "!< 4-character code of codec. see VideoWriter::fourcc ."]
pub const cv_VideoCaptureProperties_CAP_PROP_FOURCC: cv_VideoCaptureProperties = 6;
#[doc = "!< Number of frames in the video file."]
pub const cv_VideoCaptureProperties_CAP_PROP_FRAME_COUNT: cv_VideoCaptureProperties = 7;
#[doc = "!< Format of the %Mat objects (see Mat::type()) returned by VideoCapture::retrieve().\n!< Set value -1 to fetch undecoded RAW video streams (as Mat 8UC1)."]
pub const cv_VideoCaptureProperties_CAP_PROP_FORMAT: cv_VideoCaptureProperties = 8;
#[doc = "!< Backend-specific value indicating the current capture mode."]
pub const cv_VideoCaptureProperties_CAP_PROP_MODE: cv_VideoCaptureProperties = 9;
#[doc = "!< Brightness of the image (only for those cameras that support)."]
pub const cv_VideoCaptureProperties_CAP_PROP_BRIGHTNESS: cv_VideoCaptureProperties = 10;
#[doc = "!< Contrast of the image (only for cameras)."]
pub const cv_VideoCaptureProperties_CAP_PROP_CONTRAST: cv_VideoCaptureProperties = 11;
#[doc = "!< Saturation of the image (only for cameras)."]
pub const cv_VideoCaptureProperties_CAP_PROP_SATURATION: cv_VideoCaptureProperties = 12;
#[doc = "!< Hue of the image (only for cameras)."]
pub const cv_VideoCaptureProperties_CAP_PROP_HUE: cv_VideoCaptureProperties = 13;
#[doc = "!< Gain of the image (only for those cameras that support)."]
pub const cv_VideoCaptureProperties_CAP_PROP_GAIN: cv_VideoCaptureProperties = 14;
#[doc = "!< Exposure (only for those cameras that support)."]
pub const cv_VideoCaptureProperties_CAP_PROP_EXPOSURE: cv_VideoCaptureProperties = 15;
#[doc = "!< Boolean flags indicating whether images should be converted to RGB."]
pub const cv_VideoCaptureProperties_CAP_PROP_CONVERT_RGB: cv_VideoCaptureProperties = 16;
#[doc = "!< Currently unsupported."]
pub const cv_VideoCaptureProperties_CAP_PROP_WHITE_BALANCE_BLUE_U: cv_VideoCaptureProperties = 17;
#[doc = "!< Rectification flag for stereo cameras (note: only supported by DC1394 v 2.x backend currently)."]
pub const cv_VideoCaptureProperties_CAP_PROP_RECTIFICATION: cv_VideoCaptureProperties = 18;
pub const cv_VideoCaptureProperties_CAP_PROP_MONOCHROME: cv_VideoCaptureProperties = 19;
pub const cv_VideoCaptureProperties_CAP_PROP_SHARPNESS: cv_VideoCaptureProperties = 20;
#[doc = "!< DC1394: exposure control done by camera, user can adjust reference level using this feature."]
pub const cv_VideoCaptureProperties_CAP_PROP_AUTO_EXPOSURE: cv_VideoCaptureProperties = 21;
pub const cv_VideoCaptureProperties_CAP_PROP_GAMMA: cv_VideoCaptureProperties = 22;
pub const cv_VideoCaptureProperties_CAP_PROP_TEMPERATURE: cv_VideoCaptureProperties = 23;
pub const cv_VideoCaptureProperties_CAP_PROP_TRIGGER: cv_VideoCaptureProperties = 24;
pub const cv_VideoCaptureProperties_CAP_PROP_TRIGGER_DELAY: cv_VideoCaptureProperties = 25;
pub const cv_VideoCaptureProperties_CAP_PROP_WHITE_BALANCE_RED_V: cv_VideoCaptureProperties = 26;
pub const cv_VideoCaptureProperties_CAP_PROP_ZOOM: cv_VideoCaptureProperties = 27;
pub const cv_VideoCaptureProperties_CAP_PROP_FOCUS: cv_VideoCaptureProperties = 28;
pub const cv_VideoCaptureProperties_CAP_PROP_GUID: cv_VideoCaptureProperties = 29;
pub const cv_VideoCaptureProperties_CAP_PROP_ISO_SPEED: cv_VideoCaptureProperties = 30;
pub const cv_VideoCaptureProperties_CAP_PROP_BACKLIGHT: cv_VideoCaptureProperties = 32;
pub const cv_VideoCaptureProperties_CAP_PROP_PAN: cv_VideoCaptureProperties = 33;
pub const cv_VideoCaptureProperties_CAP_PROP_TILT: cv_VideoCaptureProperties = 34;
pub const cv_VideoCaptureProperties_CAP_PROP_ROLL: cv_VideoCaptureProperties = 35;
pub const cv_VideoCaptureProperties_CAP_PROP_IRIS: cv_VideoCaptureProperties = 36;
#[doc = "!< Pop up video/camera filter dialog (note: only supported by DSHOW backend currently. The property value is ignored)"]
pub const cv_VideoCaptureProperties_CAP_PROP_SETTINGS: cv_VideoCaptureProperties = 37;
pub const cv_VideoCaptureProperties_CAP_PROP_BUFFERSIZE: cv_VideoCaptureProperties = 38;
pub const cv_VideoCaptureProperties_CAP_PROP_AUTOFOCUS: cv_VideoCaptureProperties = 39;
#[doc = "!< Sample aspect ratio: num/den (num)"]
pub const cv_VideoCaptureProperties_CAP_PROP_SAR_NUM: cv_VideoCaptureProperties = 40;
#[doc = "!< Sample aspect ratio: num/den (den)"]
pub const cv_VideoCaptureProperties_CAP_PROP_SAR_DEN: cv_VideoCaptureProperties = 41;
#[doc = "!< Current backend (enum VideoCaptureAPIs). Read-only property"]
pub const cv_VideoCaptureProperties_CAP_PROP_BACKEND: cv_VideoCaptureProperties = 42;
#[doc = "!< Video input or Channel Number (only for those cameras that support)"]
pub const cv_VideoCaptureProperties_CAP_PROP_CHANNEL: cv_VideoCaptureProperties = 43;
#[doc = "!< enable/ disable auto white-balance"]
pub const cv_VideoCaptureProperties_CAP_PROP_AUTO_WB: cv_VideoCaptureProperties = 44;
#[doc = "!< white-balance color temperature"]
pub const cv_VideoCaptureProperties_CAP_PROP_WB_TEMPERATURE: cv_VideoCaptureProperties = 45;
#[doc = "!< (read-only) codec's pixel format. 4-character code - see VideoWriter::fourcc . Subset of [AV_PIX_FMT_*](https://github.com/FFmpeg/FFmpeg/blob/master/libavcodec/raw.c) or -1 if unknown"]
pub const cv_VideoCaptureProperties_CAP_PROP_CODEC_PIXEL_FORMAT: cv_VideoCaptureProperties = 46;
pub const cv_VideoCaptureProperties_CV__CAP_PROP_LATEST: cv_VideoCaptureProperties = 47;
#[doc = " @brief %VideoCapture generic properties identifier.\n\nReading / writing properties involves many layers. Some unexpected result might happens along this chain.\nEffective behaviour depends from device hardware, driver and API Backend.\n@sa videoio_flags_others, VideoCapture::get(), VideoCapture::set()"]
pub type cv_VideoCaptureProperties = ::std::os::raw::c_uint;
#[doc = "!< Current quality (0..100%) of the encoded videostream. Can be adjusted dynamically in some codecs."]
pub const cv_VideoWriterProperties_VIDEOWRITER_PROP_QUALITY: cv_VideoWriterProperties = 1;
#[doc = "!< (Read-only): Size of just encoded video frame. Note that the encoding order may be different from representation order."]
pub const cv_VideoWriterProperties_VIDEOWRITER_PROP_FRAMEBYTES: cv_VideoWriterProperties = 2;
#[doc = "!< Number of stripes for parallel encoding. -1 for auto detection."]
pub const cv_VideoWriterProperties_VIDEOWRITER_PROP_NSTRIPES: cv_VideoWriterProperties = 3;
#[doc = " @brief %VideoWriter generic properties identifier.\n@sa VideoWriter::get(), VideoWriter::set()"]
pub type cv_VideoWriterProperties = ::std::os::raw::c_uint;
#[doc = "!< turn the feature off (not controlled manually nor automatically)."]
pub const CAP_PROP_DC1394_OFF: cv__bindgen_ty_6 = -4;
#[doc = "!< set automatically when a value of the feature is set by the user."]
pub const CAP_PROP_DC1394_MODE_MANUAL: cv__bindgen_ty_6 = -3;
pub const CAP_PROP_DC1394_MODE_AUTO: cv__bindgen_ty_6 = -2;
pub const CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO: cv__bindgen_ty_6 = -1;
pub const CAP_PROP_DC1394_MAX: cv__bindgen_ty_6 = 31;
#[doc = " @brief Modes of the IEEE 1394 controlling registers\n(can be: auto, manual, auto single push, absolute Latter allowed with any other mode)\nevery feature can have only one mode turned on at a time"]
pub type cv__bindgen_ty_6 = ::std::os::raw::c_int;
pub const CAP_OPENNI_DEPTH_GENERATOR: cv__bindgen_ty_7 = -2147483648;
pub const CAP_OPENNI_IMAGE_GENERATOR: cv__bindgen_ty_7 = 1073741824;
pub const CAP_OPENNI_IR_GENERATOR: cv__bindgen_ty_7 = 536870912;
pub const CAP_OPENNI_GENERATORS_MASK: cv__bindgen_ty_7 = -536870912;
#[doc = "! OpenNI map generators"]
pub type cv__bindgen_ty_7 = ::std::os::raw::c_int;
pub const CAP_PROP_OPENNI_OUTPUT_MODE: cv__bindgen_ty_8 = 100;
#[doc = "!< In mm"]
pub const CAP_PROP_OPENNI_FRAME_MAX_DEPTH: cv__bindgen_ty_8 = 101;
#[doc = "!< In mm"]
pub const CAP_PROP_OPENNI_BASELINE: cv__bindgen_ty_8 = 102;
#[doc = "!< In pixels"]
pub const CAP_PROP_OPENNI_FOCAL_LENGTH: cv__bindgen_ty_8 = 103;
#[doc = "!< Flag that synchronizes the remapping depth map to image map\n!< by changing depth generator's view point (if the flag is \"on\") or\n!< sets this view point to its normal one (if the flag is \"off\")."]
pub const CAP_PROP_OPENNI_REGISTRATION: cv__bindgen_ty_8 = 104;
pub const CAP_PROP_OPENNI_REGISTRATION_ON: cv__bindgen_ty_8 = 104;
pub const CAP_PROP_OPENNI_APPROX_FRAME_SYNC: cv__bindgen_ty_8 = 105;
pub const CAP_PROP_OPENNI_MAX_BUFFER_SIZE: cv__bindgen_ty_8 = 106;
pub const CAP_PROP_OPENNI_CIRCLE_BUFFER: cv__bindgen_ty_8 = 107;
pub const CAP_PROP_OPENNI_MAX_TIME_DURATION: cv__bindgen_ty_8 = 108;
pub const CAP_PROP_OPENNI_GENERATOR_PRESENT: cv__bindgen_ty_8 = 109;
pub const CAP_PROP_OPENNI2_SYNC: cv__bindgen_ty_8 = 110;
pub const CAP_PROP_OPENNI2_MIRROR: cv__bindgen_ty_8 = 111;
#[doc = "! Properties of cameras available through OpenNI backend"]
pub type cv__bindgen_ty_8 = ::std::os::raw::c_uint;
pub const CAP_OPENNI_IMAGE_GENERATOR_PRESENT: cv__bindgen_ty_9 = 1073741933;
pub const CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE: cv__bindgen_ty_9 = 1073741924;
pub const CAP_OPENNI_DEPTH_GENERATOR_PRESENT: cv__bindgen_ty_9 = -2147483539;
pub const CAP_OPENNI_DEPTH_GENERATOR_BASELINE: cv__bindgen_ty_9 = -2147483546;
pub const CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH: cv__bindgen_ty_9 = -2147483545;
pub const CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION: cv__bindgen_ty_9 = -2147483544;
pub const CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON: cv__bindgen_ty_9 = -2147483544;
pub const CAP_OPENNI_IR_GENERATOR_PRESENT: cv__bindgen_ty_9 = 536871021;
#[doc = "! OpenNI shortcuts"]
pub type cv__bindgen_ty_9 = ::std::os::raw::c_int;
#[doc = "!< Depth values in mm (CV_16UC1)"]
pub const CAP_OPENNI_DEPTH_MAP: cv__bindgen_ty_10 = 0;
#[doc = "!< XYZ in meters (CV_32FC3)"]
pub const CAP_OPENNI_POINT_CLOUD_MAP: cv__bindgen_ty_10 = 1;
#[doc = "!< Disparity in pixels (CV_8UC1)"]
pub const CAP_OPENNI_DISPARITY_MAP: cv__bindgen_ty_10 = 2;
#[doc = "!< Disparity in pixels (CV_32FC1)"]
pub const CAP_OPENNI_DISPARITY_MAP_32F: cv__bindgen_ty_10 = 3;
#[doc = "!< CV_8UC1"]
pub const CAP_OPENNI_VALID_DEPTH_MASK: cv__bindgen_ty_10 = 4;
#[doc = "!< Data given from RGB image generator"]
pub const CAP_OPENNI_BGR_IMAGE: cv__bindgen_ty_10 = 5;
#[doc = "!< Data given from RGB image generator"]
pub const CAP_OPENNI_GRAY_IMAGE: cv__bindgen_ty_10 = 6;
#[doc = "!< Data given from IR image generator"]
pub const CAP_OPENNI_IR_IMAGE: cv__bindgen_ty_10 = 7;
#[doc = "! OpenNI data given from depth generator"]
pub type cv__bindgen_ty_10 = ::std::os::raw::c_uint;
pub const CAP_OPENNI_VGA_30HZ: cv__bindgen_ty_11 = 0;
pub const CAP_OPENNI_SXGA_15HZ: cv__bindgen_ty_11 = 1;
pub const CAP_OPENNI_SXGA_30HZ: cv__bindgen_ty_11 = 2;
pub const CAP_OPENNI_QVGA_30HZ: cv__bindgen_ty_11 = 3;
pub const CAP_OPENNI_QVGA_60HZ: cv__bindgen_ty_11 = 4;
#[doc = "! Supported output modes of OpenNI image generator"]
pub type cv__bindgen_ty_11 = ::std::os::raw::c_uint;
#[doc = "!< Default is 1"]
pub const CAP_PROP_GSTREAMER_QUEUE_LENGTH: cv__bindgen_ty_12 = 200;
#[doc = " @name GStreamer\n@{"]
pub type cv__bindgen_ty_12 = ::std::os::raw::c_uint;
#[doc = "!< IP for enable multicast master mode. 0 for disable multicast."]
pub const CAP_PROP_PVAPI_MULTICASTIP: cv__bindgen_ty_13 = 300;
#[doc = "!< FrameStartTriggerMode: Determines how a frame is initiated."]
pub const CAP_PROP_PVAPI_FRAMESTARTTRIGGERMODE: cv__bindgen_ty_13 = 301;
#[doc = "!< Horizontal sub-sampling of the image."]
pub const CAP_PROP_PVAPI_DECIMATIONHORIZONTAL: cv__bindgen_ty_13 = 302;
#[doc = "!< Vertical sub-sampling of the image."]
pub const CAP_PROP_PVAPI_DECIMATIONVERTICAL: cv__bindgen_ty_13 = 303;
#[doc = "!< Horizontal binning factor."]
pub const CAP_PROP_PVAPI_BINNINGX: cv__bindgen_ty_13 = 304;
#[doc = "!< Vertical binning factor."]
pub const CAP_PROP_PVAPI_BINNINGY: cv__bindgen_ty_13 = 305;
#[doc = "!< Pixel format."]
pub const CAP_PROP_PVAPI_PIXELFORMAT: cv__bindgen_ty_13 = 306;
#[doc = "! PVAPI"]
pub type cv__bindgen_ty_13 = ::std::os::raw::c_uint;
#[doc = "!< Freerun"]
pub const CAP_PVAPI_FSTRIGMODE_FREERUN: cv__bindgen_ty_14 = 0;
#[doc = "!< SyncIn1"]
pub const CAP_PVAPI_FSTRIGMODE_SYNCIN1: cv__bindgen_ty_14 = 1;
#[doc = "!< SyncIn2"]
pub const CAP_PVAPI_FSTRIGMODE_SYNCIN2: cv__bindgen_ty_14 = 2;
#[doc = "!< FixedRate"]
pub const CAP_PVAPI_FSTRIGMODE_FIXEDRATE: cv__bindgen_ty_14 = 3;
#[doc = "!< Software"]
pub const CAP_PVAPI_FSTRIGMODE_SOFTWARE: cv__bindgen_ty_14 = 4;
#[doc = "! PVAPI: FrameStartTriggerMode"]
pub type cv__bindgen_ty_14 = ::std::os::raw::c_uint;
#[doc = "!< Off"]
pub const CAP_PVAPI_DECIMATION_OFF: cv__bindgen_ty_15 = 1;
#[doc = "!< 2 out of 4 decimation"]
pub const CAP_PVAPI_DECIMATION_2OUTOF4: cv__bindgen_ty_15 = 2;
#[doc = "!< 2 out of 8 decimation"]
pub const CAP_PVAPI_DECIMATION_2OUTOF8: cv__bindgen_ty_15 = 4;
#[doc = "!< 2 out of 16 decimation"]
pub const CAP_PVAPI_DECIMATION_2OUTOF16: cv__bindgen_ty_15 = 8;
#[doc = "! PVAPI: DecimationHorizontal, DecimationVertical"]
pub type cv__bindgen_ty_15 = ::std::os::raw::c_uint;
#[doc = "!< Mono8"]
pub const CAP_PVAPI_PIXELFORMAT_MONO8: cv__bindgen_ty_16 = 1;
#[doc = "!< Mono16"]
pub const CAP_PVAPI_PIXELFORMAT_MONO16: cv__bindgen_ty_16 = 2;
#[doc = "!< Bayer8"]
pub const CAP_PVAPI_PIXELFORMAT_BAYER8: cv__bindgen_ty_16 = 3;
#[doc = "!< Bayer16"]
pub const CAP_PVAPI_PIXELFORMAT_BAYER16: cv__bindgen_ty_16 = 4;
#[doc = "!< Rgb24"]
pub const CAP_PVAPI_PIXELFORMAT_RGB24: cv__bindgen_ty_16 = 5;
#[doc = "!< Bgr24"]
pub const CAP_PVAPI_PIXELFORMAT_BGR24: cv__bindgen_ty_16 = 6;
#[doc = "!< Rgba32"]
pub const CAP_PVAPI_PIXELFORMAT_RGBA32: cv__bindgen_ty_16 = 7;
#[doc = "!< Bgra32"]
pub const CAP_PVAPI_PIXELFORMAT_BGRA32: cv__bindgen_ty_16 = 8;
#[doc = "! PVAPI: PixelFormat"]
pub type cv__bindgen_ty_16 = ::std::os::raw::c_uint;
#[doc = "!< Change image resolution by binning or skipping."]
pub const CAP_PROP_XI_DOWNSAMPLING: cv__bindgen_ty_17 = 400;
#[doc = "!< Output data format."]
pub const CAP_PROP_XI_DATA_FORMAT: cv__bindgen_ty_17 = 401;
#[doc = "!< Horizontal offset from the origin to the area of interest (in pixels)."]
pub const CAP_PROP_XI_OFFSET_X: cv__bindgen_ty_17 = 402;
#[doc = "!< Vertical offset from the origin to the area of interest (in pixels)."]
pub const CAP_PROP_XI_OFFSET_Y: cv__bindgen_ty_17 = 403;
#[doc = "!< Defines source of trigger."]
pub const CAP_PROP_XI_TRG_SOURCE: cv__bindgen_ty_17 = 404;
#[doc = "!< Generates an internal trigger. PRM_TRG_SOURCE must be set to TRG_SOFTWARE."]
pub const CAP_PROP_XI_TRG_SOFTWARE: cv__bindgen_ty_17 = 405;
#[doc = "!< Selects general purpose input."]
pub const CAP_PROP_XI_GPI_SELECTOR: cv__bindgen_ty_17 = 406;
#[doc = "!< Set general purpose input mode."]
pub const CAP_PROP_XI_GPI_MODE: cv__bindgen_ty_17 = 407;
#[doc = "!< Get general purpose level."]
pub const CAP_PROP_XI_GPI_LEVEL: cv__bindgen_ty_17 = 408;
#[doc = "!< Selects general purpose output."]
pub const CAP_PROP_XI_GPO_SELECTOR: cv__bindgen_ty_17 = 409;
#[doc = "!< Set general purpose output mode."]
pub const CAP_PROP_XI_GPO_MODE: cv__bindgen_ty_17 = 410;
#[doc = "!< Selects camera signalling LED."]
pub const CAP_PROP_XI_LED_SELECTOR: cv__bindgen_ty_17 = 411;
#[doc = "!< Define camera signalling LED functionality."]
pub const CAP_PROP_XI_LED_MODE: cv__bindgen_ty_17 = 412;
#[doc = "!< Calculates White Balance(must be called during acquisition)."]
pub const CAP_PROP_XI_MANUAL_WB: cv__bindgen_ty_17 = 413;
#[doc = "!< Automatic white balance."]
pub const CAP_PROP_XI_AUTO_WB: cv__bindgen_ty_17 = 414;
#[doc = "!< Automatic exposure/gain."]
pub const CAP_PROP_XI_AEAG: cv__bindgen_ty_17 = 415;
#[doc = "!< Exposure priority (0.5 - exposure 50%, gain 50%)."]
pub const CAP_PROP_XI_EXP_PRIORITY: cv__bindgen_ty_17 = 416;
#[doc = "!< Maximum limit of exposure in AEAG procedure."]
pub const CAP_PROP_XI_AE_MAX_LIMIT: cv__bindgen_ty_17 = 417;
#[doc = "!< Maximum limit of gain in AEAG procedure."]
pub const CAP_PROP_XI_AG_MAX_LIMIT: cv__bindgen_ty_17 = 418;
#[doc = "!< Average intensity of output signal AEAG should achieve(in %)."]
pub const CAP_PROP_XI_AEAG_LEVEL: cv__bindgen_ty_17 = 419;
#[doc = "!< Image capture timeout in milliseconds."]
pub const CAP_PROP_XI_TIMEOUT: cv__bindgen_ty_17 = 420;
#[doc = "!< Exposure time in microseconds."]
pub const CAP_PROP_XI_EXPOSURE: cv__bindgen_ty_17 = 421;
#[doc = "!< Sets the number of times of exposure in one frame."]
pub const CAP_PROP_XI_EXPOSURE_BURST_COUNT: cv__bindgen_ty_17 = 422;
#[doc = "!< Gain selector for parameter Gain allows to select different type of gains."]
pub const CAP_PROP_XI_GAIN_SELECTOR: cv__bindgen_ty_17 = 423;
#[doc = "!< Gain in dB."]
pub const CAP_PROP_XI_GAIN: cv__bindgen_ty_17 = 424;
#[doc = "!< Change image downsampling type."]
pub const CAP_PROP_XI_DOWNSAMPLING_TYPE: cv__bindgen_ty_17 = 426;
#[doc = "!< Binning engine selector."]
pub const CAP_PROP_XI_BINNING_SELECTOR: cv__bindgen_ty_17 = 427;
#[doc = "!< Vertical Binning - number of vertical photo-sensitive cells to combine together."]
pub const CAP_PROP_XI_BINNING_VERTICAL: cv__bindgen_ty_17 = 428;
#[doc = "!< Horizontal Binning - number of horizontal photo-sensitive cells to combine together."]
pub const CAP_PROP_XI_BINNING_HORIZONTAL: cv__bindgen_ty_17 = 429;
#[doc = "!< Binning pattern type."]
pub const CAP_PROP_XI_BINNING_PATTERN: cv__bindgen_ty_17 = 430;
#[doc = "!< Decimation engine selector."]
pub const CAP_PROP_XI_DECIMATION_SELECTOR: cv__bindgen_ty_17 = 431;
#[doc = "!< Vertical Decimation - vertical sub-sampling of the image - reduces the vertical resolution of the image by the specified vertical decimation factor."]
pub const CAP_PROP_XI_DECIMATION_VERTICAL: cv__bindgen_ty_17 = 432;
#[doc = "!< Horizontal Decimation - horizontal sub-sampling of the image - reduces the horizontal resolution of the image by the specified vertical decimation factor."]
pub const CAP_PROP_XI_DECIMATION_HORIZONTAL: cv__bindgen_ty_17 = 433;
#[doc = "!< Decimation pattern type."]
pub const CAP_PROP_XI_DECIMATION_PATTERN: cv__bindgen_ty_17 = 434;
#[doc = "!< Selects which test pattern generator is controlled by the TestPattern feature."]
pub const CAP_PROP_XI_TEST_PATTERN_GENERATOR_SELECTOR: cv__bindgen_ty_17 = 587;
#[doc = "!< Selects which test pattern type is generated by the selected generator."]
pub const CAP_PROP_XI_TEST_PATTERN: cv__bindgen_ty_17 = 588;
#[doc = "!< Output data format."]
pub const CAP_PROP_XI_IMAGE_DATA_FORMAT: cv__bindgen_ty_17 = 435;
#[doc = "!< Change sensor shutter type(CMOS sensor)."]
pub const CAP_PROP_XI_SHUTTER_TYPE: cv__bindgen_ty_17 = 436;
#[doc = "!< Number of taps."]
pub const CAP_PROP_XI_SENSOR_TAPS: cv__bindgen_ty_17 = 437;
#[doc = "!< Automatic exposure/gain ROI offset X."]
pub const CAP_PROP_XI_AEAG_ROI_OFFSET_X: cv__bindgen_ty_17 = 439;
#[doc = "!< Automatic exposure/gain ROI offset Y."]
pub const CAP_PROP_XI_AEAG_ROI_OFFSET_Y: cv__bindgen_ty_17 = 440;
#[doc = "!< Automatic exposure/gain ROI Width."]
pub const CAP_PROP_XI_AEAG_ROI_WIDTH: cv__bindgen_ty_17 = 441;
#[doc = "!< Automatic exposure/gain ROI Height."]
pub const CAP_PROP_XI_AEAG_ROI_HEIGHT: cv__bindgen_ty_17 = 442;
#[doc = "!< Correction of bad pixels."]
pub const CAP_PROP_XI_BPC: cv__bindgen_ty_17 = 445;
#[doc = "!< White balance red coefficient."]
pub const CAP_PROP_XI_WB_KR: cv__bindgen_ty_17 = 448;
#[doc = "!< White balance green coefficient."]
pub const CAP_PROP_XI_WB_KG: cv__bindgen_ty_17 = 449;
#[doc = "!< White balance blue coefficient."]
pub const CAP_PROP_XI_WB_KB: cv__bindgen_ty_17 = 450;
#[doc = "!< Width of the Image provided by the device (in pixels)."]
pub const CAP_PROP_XI_WIDTH: cv__bindgen_ty_17 = 451;
#[doc = "!< Height of the Image provided by the device (in pixels)."]
pub const CAP_PROP_XI_HEIGHT: cv__bindgen_ty_17 = 452;
#[doc = "!< Selects Region in Multiple ROI which parameters are set by width, height, ... ,region mode."]
pub const CAP_PROP_XI_REGION_SELECTOR: cv__bindgen_ty_17 = 589;
#[doc = "!< Activates/deactivates Region selected by Region Selector."]
pub const CAP_PROP_XI_REGION_MODE: cv__bindgen_ty_17 = 595;
#[doc = "!< Set/get bandwidth(datarate)(in Megabits)."]
pub const CAP_PROP_XI_LIMIT_BANDWIDTH: cv__bindgen_ty_17 = 459;
#[doc = "!< Sensor output data bit depth."]
pub const CAP_PROP_XI_SENSOR_DATA_BIT_DEPTH: cv__bindgen_ty_17 = 460;
#[doc = "!< Device output data bit depth."]
pub const CAP_PROP_XI_OUTPUT_DATA_BIT_DEPTH: cv__bindgen_ty_17 = 461;
#[doc = "!< bitdepth of data returned by function xiGetImage."]
pub const CAP_PROP_XI_IMAGE_DATA_BIT_DEPTH: cv__bindgen_ty_17 = 462;
#[doc = "!< Device output data packing (or grouping) enabled. Packing could be enabled if output_data_bit_depth > 8 and packing capability is available."]
pub const CAP_PROP_XI_OUTPUT_DATA_PACKING: cv__bindgen_ty_17 = 463;
#[doc = "!< Data packing type. Some cameras supports only specific packing type."]
pub const CAP_PROP_XI_OUTPUT_DATA_PACKING_TYPE: cv__bindgen_ty_17 = 464;
#[doc = "!< Returns 1 for cameras that support cooling."]
pub const CAP_PROP_XI_IS_COOLED: cv__bindgen_ty_17 = 465;
#[doc = "!< Start camera cooling."]
pub const CAP_PROP_XI_COOLING: cv__bindgen_ty_17 = 466;
#[doc = "!< Set sensor target temperature for cooling."]
pub const CAP_PROP_XI_TARGET_TEMP: cv__bindgen_ty_17 = 467;
#[doc = "!< Camera sensor temperature."]
pub const CAP_PROP_XI_CHIP_TEMP: cv__bindgen_ty_17 = 468;
#[doc = "!< Camera housing temperature."]
pub const CAP_PROP_XI_HOUS_TEMP: cv__bindgen_ty_17 = 469;
#[doc = "!< Camera housing back side temperature."]
pub const CAP_PROP_XI_HOUS_BACK_SIDE_TEMP: cv__bindgen_ty_17 = 590;
#[doc = "!< Camera sensor board temperature."]
pub const CAP_PROP_XI_SENSOR_BOARD_TEMP: cv__bindgen_ty_17 = 596;
#[doc = "!< Mode of color management system."]
pub const CAP_PROP_XI_CMS: cv__bindgen_ty_17 = 470;
#[doc = "!< Enable applying of CMS profiles to xiGetImage (see XI_PRM_INPUT_CMS_PROFILE, XI_PRM_OUTPUT_CMS_PROFILE)."]
pub const CAP_PROP_XI_APPLY_CMS: cv__bindgen_ty_17 = 471;
#[doc = "!< Returns 1 for color cameras."]
pub const CAP_PROP_XI_IMAGE_IS_COLOR: cv__bindgen_ty_17 = 474;
#[doc = "!< Returns color filter array type of RAW data."]
pub const CAP_PROP_XI_COLOR_FILTER_ARRAY: cv__bindgen_ty_17 = 475;
#[doc = "!< Luminosity gamma."]
pub const CAP_PROP_XI_GAMMAY: cv__bindgen_ty_17 = 476;
#[doc = "!< Chromaticity gamma."]
pub const CAP_PROP_XI_GAMMAC: cv__bindgen_ty_17 = 477;
#[doc = "!< Sharpness Strength."]
pub const CAP_PROP_XI_SHARPNESS: cv__bindgen_ty_17 = 478;
#[doc = "!< Color Correction Matrix element [0][0]."]
pub const CAP_PROP_XI_CC_MATRIX_00: cv__bindgen_ty_17 = 479;
#[doc = "!< Color Correction Matrix element [0][1]."]
pub const CAP_PROP_XI_CC_MATRIX_01: cv__bindgen_ty_17 = 480;
#[doc = "!< Color Correction Matrix element [0][2]."]
pub const CAP_PROP_XI_CC_MATRIX_02: cv__bindgen_ty_17 = 481;
#[doc = "!< Color Correction Matrix element [0][3]."]
pub const CAP_PROP_XI_CC_MATRIX_03: cv__bindgen_ty_17 = 482;
#[doc = "!< Color Correction Matrix element [1][0]."]
pub const CAP_PROP_XI_CC_MATRIX_10: cv__bindgen_ty_17 = 483;
#[doc = "!< Color Correction Matrix element [1][1]."]
pub const CAP_PROP_XI_CC_MATRIX_11: cv__bindgen_ty_17 = 484;
#[doc = "!< Color Correction Matrix element [1][2]."]
pub const CAP_PROP_XI_CC_MATRIX_12: cv__bindgen_ty_17 = 485;
#[doc = "!< Color Correction Matrix element [1][3]."]
pub const CAP_PROP_XI_CC_MATRIX_13: cv__bindgen_ty_17 = 486;
#[doc = "!< Color Correction Matrix element [2][0]."]
pub const CAP_PROP_XI_CC_MATRIX_20: cv__bindgen_ty_17 = 487;
#[doc = "!< Color Correction Matrix element [2][1]."]
pub const CAP_PROP_XI_CC_MATRIX_21: cv__bindgen_ty_17 = 488;
#[doc = "!< Color Correction Matrix element [2][2]."]
pub const CAP_PROP_XI_CC_MATRIX_22: cv__bindgen_ty_17 = 489;
#[doc = "!< Color Correction Matrix element [2][3]."]
pub const CAP_PROP_XI_CC_MATRIX_23: cv__bindgen_ty_17 = 490;
#[doc = "!< Color Correction Matrix element [3][0]."]
pub const CAP_PROP_XI_CC_MATRIX_30: cv__bindgen_ty_17 = 491;
#[doc = "!< Color Correction Matrix element [3][1]."]
pub const CAP_PROP_XI_CC_MATRIX_31: cv__bindgen_ty_17 = 492;
#[doc = "!< Color Correction Matrix element [3][2]."]
pub const CAP_PROP_XI_CC_MATRIX_32: cv__bindgen_ty_17 = 493;
#[doc = "!< Color Correction Matrix element [3][3]."]
pub const CAP_PROP_XI_CC_MATRIX_33: cv__bindgen_ty_17 = 494;
#[doc = "!< Set default Color Correction Matrix."]
pub const CAP_PROP_XI_DEFAULT_CC_MATRIX: cv__bindgen_ty_17 = 495;
#[doc = "!< Selects the type of trigger."]
pub const CAP_PROP_XI_TRG_SELECTOR: cv__bindgen_ty_17 = 498;
#[doc = "!< Sets number of frames acquired by burst. This burst is used only if trigger is set to FrameBurstStart."]
pub const CAP_PROP_XI_ACQ_FRAME_BURST_COUNT: cv__bindgen_ty_17 = 499;
#[doc = "!< Enable/Disable debounce to selected GPI."]
pub const CAP_PROP_XI_DEBOUNCE_EN: cv__bindgen_ty_17 = 507;
#[doc = "!< Debounce time (x * 10us)."]
pub const CAP_PROP_XI_DEBOUNCE_T0: cv__bindgen_ty_17 = 508;
#[doc = "!< Debounce time (x * 10us)."]
pub const CAP_PROP_XI_DEBOUNCE_T1: cv__bindgen_ty_17 = 509;
#[doc = "!< Debounce polarity (pol = 1 t0 - falling edge, t1 - rising edge)."]
pub const CAP_PROP_XI_DEBOUNCE_POL: cv__bindgen_ty_17 = 510;
#[doc = "!< Status of lens control interface. This shall be set to XI_ON before any Lens operations."]
pub const CAP_PROP_XI_LENS_MODE: cv__bindgen_ty_17 = 511;
#[doc = "!< Current lens aperture value in stops. Examples: 2.8, 4, 5.6, 8, 11."]
pub const CAP_PROP_XI_LENS_APERTURE_VALUE: cv__bindgen_ty_17 = 512;
#[doc = "!< Lens current focus movement value to be used by XI_PRM_LENS_FOCUS_MOVE in motor steps."]
pub const CAP_PROP_XI_LENS_FOCUS_MOVEMENT_VALUE: cv__bindgen_ty_17 = 513;
#[doc = "!< Moves lens focus motor by steps set in XI_PRM_LENS_FOCUS_MOVEMENT_VALUE."]
pub const CAP_PROP_XI_LENS_FOCUS_MOVE: cv__bindgen_ty_17 = 514;
#[doc = "!< Lens focus distance in cm."]
pub const CAP_PROP_XI_LENS_FOCUS_DISTANCE: cv__bindgen_ty_17 = 515;
#[doc = "!< Lens focal distance in mm."]
pub const CAP_PROP_XI_LENS_FOCAL_LENGTH: cv__bindgen_ty_17 = 516;
#[doc = "!< Selects the current feature which is accessible by XI_PRM_LENS_FEATURE."]
pub const CAP_PROP_XI_LENS_FEATURE_SELECTOR: cv__bindgen_ty_17 = 517;
#[doc = "!< Allows access to lens feature value currently selected by XI_PRM_LENS_FEATURE_SELECTOR."]
pub const CAP_PROP_XI_LENS_FEATURE: cv__bindgen_ty_17 = 518;
#[doc = "!< Returns device model id."]
pub const CAP_PROP_XI_DEVICE_MODEL_ID: cv__bindgen_ty_17 = 521;
#[doc = "!< Returns device serial number."]
pub const CAP_PROP_XI_DEVICE_SN: cv__bindgen_ty_17 = 522;
#[doc = "!< The alpha channel of RGB32 output image format."]
pub const CAP_PROP_XI_IMAGE_DATA_FORMAT_RGB32_ALPHA: cv__bindgen_ty_17 = 529;
#[doc = "!< Buffer size in bytes sufficient for output image returned by xiGetImage."]
pub const CAP_PROP_XI_IMAGE_PAYLOAD_SIZE: cv__bindgen_ty_17 = 530;
#[doc = "!< Current format of pixels on transport layer."]
pub const CAP_PROP_XI_TRANSPORT_PIXEL_FORMAT: cv__bindgen_ty_17 = 531;
#[doc = "!< Sensor clock frequency in Hz."]
pub const CAP_PROP_XI_SENSOR_CLOCK_FREQ_HZ: cv__bindgen_ty_17 = 532;
#[doc = "!< Sensor clock frequency index. Sensor with selected frequencies have possibility to set the frequency only by this index."]
pub const CAP_PROP_XI_SENSOR_CLOCK_FREQ_INDEX: cv__bindgen_ty_17 = 533;
#[doc = "!< Number of output channels from sensor used for data transfer."]
pub const CAP_PROP_XI_SENSOR_OUTPUT_CHANNEL_COUNT: cv__bindgen_ty_17 = 534;
#[doc = "!< Define framerate in Hz."]
pub const CAP_PROP_XI_FRAMERATE: cv__bindgen_ty_17 = 535;
#[doc = "!< Select counter."]
pub const CAP_PROP_XI_COUNTER_SELECTOR: cv__bindgen_ty_17 = 536;
#[doc = "!< Counter status."]
pub const CAP_PROP_XI_COUNTER_VALUE: cv__bindgen_ty_17 = 537;
#[doc = "!< Type of sensor frames timing."]
pub const CAP_PROP_XI_ACQ_TIMING_MODE: cv__bindgen_ty_17 = 538;
#[doc = "!< Calculate and returns available interface bandwidth(int Megabits)."]
pub const CAP_PROP_XI_AVAILABLE_BANDWIDTH: cv__bindgen_ty_17 = 539;
#[doc = "!< Data move policy."]
pub const CAP_PROP_XI_BUFFER_POLICY: cv__bindgen_ty_17 = 540;
#[doc = "!< Activates LUT."]
pub const CAP_PROP_XI_LUT_EN: cv__bindgen_ty_17 = 541;
#[doc = "!< Control the index (offset) of the coefficient to access in the LUT."]
pub const CAP_PROP_XI_LUT_INDEX: cv__bindgen_ty_17 = 542;
#[doc = "!< Value at entry LUTIndex of the LUT."]
pub const CAP_PROP_XI_LUT_VALUE: cv__bindgen_ty_17 = 543;
#[doc = "!< Specifies the delay in microseconds (us) to apply after the trigger reception before activating it."]
pub const CAP_PROP_XI_TRG_DELAY: cv__bindgen_ty_17 = 544;
#[doc = "!< Defines how time stamp reset engine will be armed."]
pub const CAP_PROP_XI_TS_RST_MODE: cv__bindgen_ty_17 = 545;
#[doc = "!< Defines which source will be used for timestamp reset. Writing this parameter will trigger settings of engine (arming)."]
pub const CAP_PROP_XI_TS_RST_SOURCE: cv__bindgen_ty_17 = 546;
#[doc = "!< Returns 1 if camera connected and works properly."]
pub const CAP_PROP_XI_IS_DEVICE_EXIST: cv__bindgen_ty_17 = 547;
#[doc = "!< Acquisition buffer size in buffer_size_unit. Default bytes."]
pub const CAP_PROP_XI_ACQ_BUFFER_SIZE: cv__bindgen_ty_17 = 548;
#[doc = "!< Acquisition buffer size unit in bytes. Default 1. E.g. Value 1024 means that buffer_size is in KiBytes."]
pub const CAP_PROP_XI_ACQ_BUFFER_SIZE_UNIT: cv__bindgen_ty_17 = 549;
#[doc = "!< Acquisition transport buffer size in bytes."]
pub const CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_SIZE: cv__bindgen_ty_17 = 550;
#[doc = "!< Queue of field/frame buffers."]
pub const CAP_PROP_XI_BUFFERS_QUEUE_SIZE: cv__bindgen_ty_17 = 551;
#[doc = "!< Number of buffers to commit to low level."]
pub const CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_COMMIT: cv__bindgen_ty_17 = 552;
#[doc = "!< GetImage returns most recent frame."]
pub const CAP_PROP_XI_RECENT_FRAME: cv__bindgen_ty_17 = 553;
#[doc = "!< Resets the camera to default state."]
pub const CAP_PROP_XI_DEVICE_RESET: cv__bindgen_ty_17 = 554;
#[doc = "!< Correction of column FPN."]
pub const CAP_PROP_XI_COLUMN_FPN_CORRECTION: cv__bindgen_ty_17 = 555;
#[doc = "!< Correction of row FPN."]
pub const CAP_PROP_XI_ROW_FPN_CORRECTION: cv__bindgen_ty_17 = 591;
#[doc = "!< Current sensor mode. Allows to select sensor mode by one integer. Setting of this parameter affects: image dimensions and downsampling."]
pub const CAP_PROP_XI_SENSOR_MODE: cv__bindgen_ty_17 = 558;
#[doc = "!< Enable High Dynamic Range feature."]
pub const CAP_PROP_XI_HDR: cv__bindgen_ty_17 = 559;
#[doc = "!< The number of kneepoints in the PWLR."]
pub const CAP_PROP_XI_HDR_KNEEPOINT_COUNT: cv__bindgen_ty_17 = 560;
#[doc = "!< Position of first kneepoint(in % of XI_PRM_EXPOSURE)."]
pub const CAP_PROP_XI_HDR_T1: cv__bindgen_ty_17 = 561;
#[doc = "!< Position of second kneepoint (in % of XI_PRM_EXPOSURE)."]
pub const CAP_PROP_XI_HDR_T2: cv__bindgen_ty_17 = 562;
#[doc = "!< Value of first kneepoint (% of sensor saturation)."]
pub const CAP_PROP_XI_KNEEPOINT1: cv__bindgen_ty_17 = 563;
#[doc = "!< Value of second kneepoint (% of sensor saturation)."]
pub const CAP_PROP_XI_KNEEPOINT2: cv__bindgen_ty_17 = 564;
#[doc = "!< Last image black level counts. Can be used for Offline processing to recall it."]
pub const CAP_PROP_XI_IMAGE_BLACK_LEVEL: cv__bindgen_ty_17 = 565;
#[doc = "!< Returns hardware revision number."]
pub const CAP_PROP_XI_HW_REVISION: cv__bindgen_ty_17 = 571;
#[doc = "!< Set debug level."]
pub const CAP_PROP_XI_DEBUG_LEVEL: cv__bindgen_ty_17 = 572;
#[doc = "!< Automatic bandwidth calculation."]
pub const CAP_PROP_XI_AUTO_BANDWIDTH_CALCULATION: cv__bindgen_ty_17 = 573;
#[doc = "!< File number."]
pub const CAP_PROP_XI_FFS_FILE_ID: cv__bindgen_ty_17 = 594;
#[doc = "!< Size of file."]
pub const CAP_PROP_XI_FFS_FILE_SIZE: cv__bindgen_ty_17 = 580;
#[doc = "!< Size of free camera FFS."]
pub const CAP_PROP_XI_FREE_FFS_SIZE: cv__bindgen_ty_17 = 581;
#[doc = "!< Size of used camera FFS."]
pub const CAP_PROP_XI_USED_FFS_SIZE: cv__bindgen_ty_17 = 582;
#[doc = "!< Setting of key enables file operations on some cameras."]
pub const CAP_PROP_XI_FFS_ACCESS_KEY: cv__bindgen_ty_17 = 583;
#[doc = "!< Selects the current feature which is accessible by XI_PRM_SENSOR_FEATURE_VALUE."]
pub const CAP_PROP_XI_SENSOR_FEATURE_SELECTOR: cv__bindgen_ty_17 = 585;
#[doc = "!< Allows access to sensor feature value currently selected by XI_PRM_SENSOR_FEATURE_SELECTOR."]
pub const CAP_PROP_XI_SENSOR_FEATURE_VALUE: cv__bindgen_ty_17 = 586;
#[doc = "! Properties of cameras available through XIMEA SDK backend"]
pub type cv__bindgen_ty_17 = ::std::os::raw::c_uint;
pub const CAP_PROP_IOS_DEVICE_FOCUS: cv__bindgen_ty_18 = 9001;
pub const CAP_PROP_IOS_DEVICE_EXPOSURE: cv__bindgen_ty_18 = 9002;
pub const CAP_PROP_IOS_DEVICE_FLASH: cv__bindgen_ty_18 = 9003;
pub const CAP_PROP_IOS_DEVICE_WHITEBALANCE: cv__bindgen_ty_18 = 9004;
pub const CAP_PROP_IOS_DEVICE_TORCH: cv__bindgen_ty_18 = 9005;
#[doc = "! Properties of cameras available through AVFOUNDATION backend"]
pub type cv__bindgen_ty_18 = ::std::os::raw::c_uint;
pub const CAP_PROP_GIGA_FRAME_OFFSET_X: cv__bindgen_ty_19 = 10001;
pub const CAP_PROP_GIGA_FRAME_OFFSET_Y: cv__bindgen_ty_19 = 10002;
pub const CAP_PROP_GIGA_FRAME_WIDTH_MAX: cv__bindgen_ty_19 = 10003;
pub const CAP_PROP_GIGA_FRAME_HEIGH_MAX: cv__bindgen_ty_19 = 10004;
pub const CAP_PROP_GIGA_FRAME_SENS_WIDTH: cv__bindgen_ty_19 = 10005;
pub const CAP_PROP_GIGA_FRAME_SENS_HEIGH: cv__bindgen_ty_19 = 10006;
pub type cv__bindgen_ty_19 = ::std::os::raw::c_uint;
pub const CAP_PROP_INTELPERC_PROFILE_COUNT: cv__bindgen_ty_20 = 11001;
pub const CAP_PROP_INTELPERC_PROFILE_IDX: cv__bindgen_ty_20 = 11002;
pub const CAP_PROP_INTELPERC_DEPTH_LOW_CONFIDENCE_VALUE: cv__bindgen_ty_20 = 11003;
pub const CAP_PROP_INTELPERC_DEPTH_SATURATION_VALUE: cv__bindgen_ty_20 = 11004;
pub const CAP_PROP_INTELPERC_DEPTH_CONFIDENCE_THRESHOLD: cv__bindgen_ty_20 = 11005;
pub const CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_HORZ: cv__bindgen_ty_20 = 11006;
pub const CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_VERT: cv__bindgen_ty_20 = 11007;
#[doc = " @name Intel Perceptual Computing SDK\n@{"]
pub type cv__bindgen_ty_20 = ::std::os::raw::c_uint;
pub const CAP_INTELPERC_DEPTH_GENERATOR: cv__bindgen_ty_21 = 536870912;
pub const CAP_INTELPERC_IMAGE_GENERATOR: cv__bindgen_ty_21 = 268435456;
pub const CAP_INTELPERC_IR_GENERATOR: cv__bindgen_ty_21 = 134217728;
pub const CAP_INTELPERC_GENERATORS_MASK: cv__bindgen_ty_21 = 939524096;
#[doc = "! Intel Perceptual Streams"]
pub type cv__bindgen_ty_21 = ::std::os::raw::c_uint;
#[doc = "!< Each pixel is a 16-bit integer. The value indicates the distance from an object to the camera's XY plane or the Cartesian depth."]
pub const CAP_INTELPERC_DEPTH_MAP: cv__bindgen_ty_22 = 0;
#[doc = "!< Each pixel contains two 32-bit floating point values in the range of 0-1, representing the mapping of depth coordinates to the color coordinates."]
pub const CAP_INTELPERC_UVDEPTH_MAP: cv__bindgen_ty_22 = 1;
#[doc = "!< Each pixel is a 16-bit integer. The value indicates the intensity of the reflected laser beam."]
pub const CAP_INTELPERC_IR_MAP: cv__bindgen_ty_22 = 2;
pub const CAP_INTELPERC_IMAGE: cv__bindgen_ty_22 = 3;
pub type cv__bindgen_ty_22 = ::std::os::raw::c_uint;
#[doc = "!< Capture only preview from liveview mode."]
pub const CAP_PROP_GPHOTO2_PREVIEW: cv__bindgen_ty_23 = 17001;
#[doc = "!< Readonly, returns (const char *)."]
pub const CAP_PROP_GPHOTO2_WIDGET_ENUMERATE: cv__bindgen_ty_23 = 17002;
#[doc = "!< Trigger, only by set. Reload camera settings."]
pub const CAP_PROP_GPHOTO2_RELOAD_CONFIG: cv__bindgen_ty_23 = 17003;
#[doc = "!< Reload all settings on set."]
pub const CAP_PROP_GPHOTO2_RELOAD_ON_CHANGE: cv__bindgen_ty_23 = 17004;
#[doc = "!< Collect messages with details."]
pub const CAP_PROP_GPHOTO2_COLLECT_MSGS: cv__bindgen_ty_23 = 17005;
#[doc = "!< Readonly, returns (const char *)."]
pub const CAP_PROP_GPHOTO2_FLUSH_MSGS: cv__bindgen_ty_23 = 17006;
#[doc = "!< Exposure speed. Can be readonly, depends on camera program."]
pub const CAP_PROP_SPEED: cv__bindgen_ty_23 = 17007;
#[doc = "!< Aperture. Can be readonly, depends on camera program."]
pub const CAP_PROP_APERTURE: cv__bindgen_ty_23 = 17008;
#[doc = "!< Camera exposure program."]
pub const CAP_PROP_EXPOSUREPROGRAM: cv__bindgen_ty_23 = 17009;
#[doc = "!< Enter liveview mode."]
pub const CAP_PROP_VIEWFINDER: cv__bindgen_ty_23 = 17010;
#[doc = " @brief gPhoto2 properties\n\nIf `propertyId` is less than 0 then work on widget with that __additive inversed__ camera setting ID\nGet IDs by using CAP_PROP_GPHOTO2_WIDGET_ENUMERATE.\n@see CvCaptureCAM_GPHOTO2 for more info"]
pub type cv__bindgen_ty_23 = ::std::os::raw::c_uint;
pub const CAP_PROP_IMAGES_BASE: cv__bindgen_ty_24 = 18000;
pub const CAP_PROP_IMAGES_LAST: cv__bindgen_ty_24 = 19000;
#[doc = " @brief Images backend properties"]
pub type cv__bindgen_ty_24 = ::std::os::raw::c_uint;
#[doc = "! @} videoio_flags_others"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_IVideoCapture {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct cv_VideoCapture__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief Class for video capturing from video files, image sequences or cameras.\n\nThe class provides C++ API for capturing video from cameras or for reading video files and image sequences.\n\nHere is how the class can be used:\n@include samples/cpp/videocapture_basic.cpp\n\n@note In @ref videoio_c \"C API\" the black-box structure `CvCapture` is used instead of %VideoCapture.\n@note\n-   (C++) A basic sample on using the %VideoCapture interface can be found at\n`OPENCV_SOURCE_CODE/samples/cpp/videocapture_starter.cpp`\n-   (Python) A basic sample on using the %VideoCapture interface can be found at\n`OPENCV_SOURCE_CODE/samples/python/video.py`\n-   (Python) A multi threaded video processing sample can be found at\n`OPENCV_SOURCE_CODE/samples/python/video_threaded.py`\n-   (Python) %VideoCapture sample showcasing some features of the Video4Linux2 backend\n`OPENCV_SOURCE_CODE/samples/python/video_v4l2.py`"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_VideoCapture {
    pub vtable_: *const cv_VideoCapture__bindgen_vtable,
    pub cap: cv_Ptr,
    pub icap: cv_Ptr,
    pub throwOnFail: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_VideoCapture"][::std::mem::size_of::<cv_VideoCapture>() - 48usize];
    ["Alignment of cv_VideoCapture"][::std::mem::align_of::<cv_VideoCapture>() - 8usize];
    ["Offset of field: cv_VideoCapture::cap"]
        [::std::mem::offset_of!(cv_VideoCapture, cap) - 8usize];
    ["Offset of field: cv_VideoCapture::icap"]
        [::std::mem::offset_of!(cv_VideoCapture, icap) - 24usize];
    ["Offset of field: cv_VideoCapture::throwOnFail"]
        [::std::mem::offset_of!(cv_VideoCapture, throwOnFail) - 40usize];
};
unsafe extern "C" {
    #[doc = " @brief Returns used backend API name\n\n@note Stream should be opened."]
    #[link_name = "\u{1}_ZNK2cv12VideoCapture14getBackendNameB5cxx11Ev"]
    pub fn cv_VideoCapture_getBackendName(this: *const cv_VideoCapture) -> cv_String;
}
unsafe extern "C" {
    #[doc = " @brief Wait for ready frames from VideoCapture.\n\n@param streams input video streams\n@param readyIndex stream indexes with grabbed frames (ready to use .retrieve() to fetch actual frame)\n@param timeoutNs number of nanoseconds (0 - infinite)\n@return `true` if streamReady is not empty\n\n@throws Exception %Exception on stream errors (check .isOpened() to filter out malformed streams) or VideoCapture type is not supported\n\nThe primary use of the function is in multi-camera environments.\nThe method fills the ready state vector, grabbs video frame, if camera is ready.\n\nAfter this call use VideoCapture::retrieve() to decode and fetch frame data."]
    #[link_name = "\u{1}_ZN2cv12VideoCapture7waitAnyERKSt6vectorIS0_SaIS0_EERS1_IiSaIiEEl"]
    pub fn cv_VideoCapture_waitAny(
        streams: *const std_vector,
        readyIndex: *mut std_vector,
        timeoutNs: int64,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Default constructor\n@note In @ref videoio_c \"C API\", when you finished working with video, release CvCapture structure with\ncvReleaseCapture(), or use Ptr\\<CvCapture\\> that calls cvReleaseCapture() automatically in the\ndestructor."]
    #[link_name = "\u{1}_ZN2cv12VideoCaptureC1Ev"]
    pub fn cv_VideoCapture_VideoCapture(this: *mut cv_VideoCapture);
}
unsafe extern "C" {
    #[doc = " @overload\n@brief  Opens a video file or a capturing device or an IP video stream for video capturing with API Preference\n\n@param filename it can be:\n- name of video file (eg. `video.avi`)\n- or image sequence (eg. `img_%02d.jpg`, which will read samples like `img_00.jpg, img_01.jpg, img_02.jpg, ...`)\n- or URL of video stream (eg. `protocol://host:port/script_name?script_params|auth`).\nNote that each video stream or IP camera feed has its own URL scheme. Please refer to the\ndocumentation of source stream to know the right URL.\n@param apiPreference preferred Capture API backends to use. Can be used to enforce a specific reader\nimplementation if multiple are available: e.g. cv::CAP_FFMPEG or cv::CAP_IMAGES or cv::CAP_DSHOW.\n@sa The list of supported API backends cv::VideoCaptureAPIs"]
    #[link_name = "\u{1}_ZN2cv12VideoCaptureC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
    pub fn cv_VideoCapture_VideoCapture1(
        this: *mut cv_VideoCapture,
        filename: *const cv_String,
        apiPreference: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@brief  Opens a camera for video capturing\n\n@param index id of the video capturing device to open. To open default camera using default backend just pass 0.\n(to backward compatibility usage of camera_id + domain_offset (CAP_*) is valid when apiPreference is CAP_ANY)\n@param apiPreference preferred Capture API backends to use. Can be used to enforce a specific reader\nimplementation if multiple are available: e.g. cv::CAP_DSHOW or cv::CAP_MSMF or cv::CAP_V4L.\n\n@sa The list of supported API backends cv::VideoCaptureAPIs"]
    #[link_name = "\u{1}_ZN2cv12VideoCaptureC1Eii"]
    pub fn cv_VideoCapture_VideoCapture2(
        this: *mut cv_VideoCapture,
        index: ::std::os::raw::c_int,
        apiPreference: ::std::os::raw::c_int,
    );
}
impl cv_VideoCapture {
    #[inline]
    pub unsafe fn getBackendName(&self) -> cv_String {
        cv_VideoCapture_getBackendName(self)
    }
    #[inline]
    pub unsafe fn waitAny(
        streams: *const std_vector,
        readyIndex: *mut std_vector,
        timeoutNs: int64,
    ) -> bool {
        cv_VideoCapture_waitAny(streams, readyIndex, timeoutNs)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_VideoCapture_VideoCapture(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(filename: *const cv_String, apiPreference: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_VideoCapture_VideoCapture1(__bindgen_tmp.as_mut_ptr(), filename, apiPreference);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(index: ::std::os::raw::c_int, apiPreference: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_VideoCapture_VideoCapture2(__bindgen_tmp.as_mut_ptr(), index, apiPreference);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[doc = " @brief Default destructor\n\nThe method first calls VideoCapture::release to close the already opened file or camera."]
    #[link_name = "\u{1}_ZN2cv12VideoCaptureD1Ev"]
    pub fn cv_VideoCapture_VideoCapture_destructor(this: *mut cv_VideoCapture);
}
unsafe extern "C" {
    #[doc = " @brief  Opens a video file or a capturing device or an IP video stream for video capturing.\n\n@overload\n\nParameters are same as the constructor VideoCapture(const String& filename, int apiPreference = CAP_ANY)\n@return `true` if the file has been successfully opened\n\nThe method first calls VideoCapture::release to close the already opened file or camera."]
    #[link_name = "\u{1}_ZN2cv12VideoCapture4openERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
    pub fn cv_VideoCapture_open(
        this: *mut ::std::os::raw::c_void,
        filename: *const cv_String,
        apiPreference: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief  Opens a camera for video capturing\n\n@overload\n\nParameters are same as the constructor VideoCapture(int index, int apiPreference = CAP_ANY)\n@return `true` if the camera has been successfully opened.\n\nThe method first calls VideoCapture::release to close the already opened file or camera."]
    #[link_name = "\u{1}_ZN2cv12VideoCapture4openEii"]
    pub fn cv_VideoCapture_open1(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
        apiPreference: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Returns true if video capturing has been initialized already.\n\nIf the previous call to VideoCapture constructor or VideoCapture::open() succeeded, the method returns\ntrue."]
    #[link_name = "\u{1}_ZNK2cv12VideoCapture8isOpenedEv"]
    pub fn cv_VideoCapture_isOpened(this: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Closes video file or capturing device.\n\nThe method is automatically called by subsequent VideoCapture::open and by VideoCapture\ndestructor.\n\nThe C function also deallocates memory and clears \\*capture pointer."]
    #[link_name = "\u{1}_ZN2cv12VideoCapture7releaseEv"]
    pub fn cv_VideoCapture_release(this: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " @brief Grabs the next frame from video file or capturing device.\n\n@return `true` (non-zero) in the case of success.\n\nThe method/function grabs the next frame from video file or camera and returns true (non-zero) in\nthe case of success.\n\nThe primary use of the function is in multi-camera environments, especially when the cameras do not\nhave hardware synchronization. That is, you call VideoCapture::grab() for each camera and after that\ncall the slower method VideoCapture::retrieve() to decode and get frame from each camera. This way\nthe overhead on demosaicing or motion jpeg decompression etc. is eliminated and the retrieved frames\nfrom different cameras will be closer in time.\n\nAlso, when a connected camera is multi-head (for example, a stereo camera or a Kinect device), the\ncorrect way of retrieving data from it is to call VideoCapture::grab() first and then call\nVideoCapture::retrieve() one or more times with different values of the channel parameter.\n\n@ref tutorial_kinect_openni"]
    #[link_name = "\u{1}_ZN2cv12VideoCapture4grabEv"]
    pub fn cv_VideoCapture_grab(this: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Decodes and returns the grabbed video frame.\n\n@param [out] image the video frame is returned here. If no frames has been grabbed the image will be empty.\n@param flag it could be a frame index or a driver specific flag\n@return `false` if no frames has been grabbed\n\nThe method decodes and returns the just grabbed frame. If no frames has been grabbed\n(camera has been disconnected, or there are no more frames in video file), the method returns false\nand the function returns an empty image (with %cv::Mat, test it with Mat::empty()).\n\n@sa read()\n\n@note In @ref videoio_c \"C API\", functions cvRetrieveFrame() and cv.RetrieveFrame() return image stored inside the video\ncapturing structure. It is not allowed to modify or release the image! You can copy the frame using\ncvCloneImage and then do whatever you want with the copy."]
    #[link_name = "\u{1}_ZN2cv12VideoCapture8retrieveERKNS_12_OutputArrayEi"]
    pub fn cv_VideoCapture_retrieve(
        this: *mut ::std::os::raw::c_void,
        image: cv_OutputArray,
        flag: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Grabs, decodes and returns the next video frame.\n\n@param [out] image the video frame is returned here. If no frames has been grabbed the image will be empty.\n@return `false` if no frames has been grabbed\n\nThe method/function combines VideoCapture::grab() and VideoCapture::retrieve() in one call. This is the\nmost convenient method for reading video files or capturing data from decode and returns the just\ngrabbed frame. If no frames has been grabbed (camera has been disconnected, or there are no more\nframes in video file), the method returns false and the function returns empty image (with %cv::Mat, test it with Mat::empty()).\n\n@note In @ref videoio_c \"C API\", functions cvRetrieveFrame() and cv.RetrieveFrame() return image stored inside the video\ncapturing structure. It is not allowed to modify or release the image! You can copy the frame using\ncvCloneImage and then do whatever you want with the copy."]
    #[link_name = "\u{1}_ZN2cv12VideoCapture4readERKNS_12_OutputArrayE"]
    pub fn cv_VideoCapture_read(this: *mut ::std::os::raw::c_void, image: cv_OutputArray) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Sets a property in the VideoCapture.\n\n@param propId Property identifier from cv::VideoCaptureProperties (eg. cv::CAP_PROP_POS_MSEC, cv::CAP_PROP_POS_FRAMES, ...)\nor one from @ref videoio_flags_others\n@param value Value of the property.\n@return `true` if the property is supported by backend used by the VideoCapture instance.\n@note Even if it returns `true` this doesn't ensure that the property\nvalue has been accepted by the capture device. See note in VideoCapture::get()"]
    #[link_name = "\u{1}_ZN2cv12VideoCapture3setEid"]
    pub fn cv_VideoCapture_set(
        this: *mut ::std::os::raw::c_void,
        propId: ::std::os::raw::c_int,
        value: f64,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Returns the specified VideoCapture property\n\n@param propId Property identifier from cv::VideoCaptureProperties (eg. cv::CAP_PROP_POS_MSEC, cv::CAP_PROP_POS_FRAMES, ...)\nor one from @ref videoio_flags_others\n@return Value for the specified property. Value 0 is returned when querying a property that is\nnot supported by the backend used by the VideoCapture instance.\n\n@note Reading / writing properties involves many layers. Some unexpected result might happens\nalong this chain.\n@code{.txt}\nVideoCapture -> API Backend -> Operating System -> Device Driver -> Device Hardware\n@endcode\nThe returned value might be different from what really used by the device or it could be encoded\nusing device dependent rules (eg. steps or percentage). Effective behaviour depends from device\ndriver and API Backend\n"]
    #[link_name = "\u{1}_ZNK2cv12VideoCapture3getEi"]
    pub fn cv_VideoCapture_get(
        this: *mut ::std::os::raw::c_void,
        propId: ::std::os::raw::c_int,
    ) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_IVideoWriter {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct cv_VideoWriter__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief Video writer class.\n\nThe class provides C++ API for writing video files or image sequences."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_VideoWriter {
    pub vtable_: *const cv_VideoWriter__bindgen_vtable,
    pub writer: cv_Ptr,
    pub iwriter: cv_Ptr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_VideoWriter"][::std::mem::size_of::<cv_VideoWriter>() - 40usize];
    ["Alignment of cv_VideoWriter"][::std::mem::align_of::<cv_VideoWriter>() - 8usize];
    ["Offset of field: cv_VideoWriter::writer"]
        [::std::mem::offset_of!(cv_VideoWriter, writer) - 8usize];
    ["Offset of field: cv_VideoWriter::iwriter"]
        [::std::mem::offset_of!(cv_VideoWriter, iwriter) - 24usize];
};
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv11VideoWriter4openERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiidNS_5Size_IiEEb"]
    pub fn cv_VideoWriter_open1(
        this: *mut cv_VideoWriter,
        filename: *const cv_String,
        apiPreference: ::std::os::raw::c_int,
        fourcc: ::std::os::raw::c_int,
        fps: f64,
        frameSize: cv_Size,
        isColor: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Concatenates 4 chars to a fourcc code\n\n@return a fourcc code\n\nThis static method constructs the fourcc code of the codec to be used in the constructor\nVideoWriter::VideoWriter or VideoWriter::open."]
    #[link_name = "\u{1}_ZN2cv11VideoWriter6fourccEcccc"]
    pub fn cv_VideoWriter_fourcc(
        c1: ::std::os::raw::c_char,
        c2: ::std::os::raw::c_char,
        c3: ::std::os::raw::c_char,
        c4: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Returns used backend API name\n\n@note Stream should be opened."]
    #[link_name = "\u{1}_ZNK2cv11VideoWriter14getBackendNameB5cxx11Ev"]
    pub fn cv_VideoWriter_getBackendName(this: *const cv_VideoWriter) -> cv_String;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv11VideoWriter6createERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEidNS_5Size_IiEEb"]
    pub fn cv_VideoWriter_create(
        filename: *const cv_String,
        fourcc: ::std::os::raw::c_int,
        fps: f64,
        frameSize: cv_Size,
        isColor: bool,
    ) -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Default constructors\n\nThe constructors/functions initialize video writers.\n-   On Linux FFMPEG is used to write videos;\n-   On Windows FFMPEG or MSWF or DSHOW is used;\n-   On MacOSX AVFoundation is used."]
    #[link_name = "\u{1}_ZN2cv11VideoWriterC1Ev"]
    pub fn cv_VideoWriter_VideoWriter(this: *mut cv_VideoWriter);
}
unsafe extern "C" {
    #[doc = " @overload\n@param filename Name of the output video file.\n@param fourcc 4-character code of codec used to compress the frames. For example,\nVideoWriter::fourcc('P','I','M','1') is a MPEG-1 codec, VideoWriter::fourcc('M','J','P','G') is a\nmotion-jpeg codec etc. List of codes can be obtained at [Video Codecs by\nFOURCC](http://www.fourcc.org/codecs.php) page. FFMPEG backend with MP4 container natively uses\nother values as fourcc code: see [ObjectType](http://www.mp4ra.org/codecs.html),\nso you may receive a warning message from OpenCV about fourcc code conversion.\n@param fps Framerate of the created video stream.\n@param frameSize Size of the video frames.\n@param isColor If it is not zero, the encoder will expect and encode color frames, otherwise it\nwill work with grayscale frames (the flag is currently supported on Windows only).\n\n@b Tips:\n- With some backends `fourcc=-1` pops up the codec selection dialog from the system.\n- To save image sequence use a proper filename (eg. `img_%02d.jpg`) and `fourcc=0`\nOR `fps=0`. Use uncompressed image format (eg. `img_%02d.BMP`) to save raw frames.\n- Most codecs are lossy. If you want lossless video file you need to use a lossless codecs\n(eg. FFMPEG FFV1, Huffman HFYU, Lagarith LAGS, etc...)\n- If FFMPEG is enabled, using `codec=0; fps=0;` you can create an uncompressed (raw) video file."]
    #[link_name = "\u{1}_ZN2cv11VideoWriterC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEidNS_5Size_IiEEb"]
    pub fn cv_VideoWriter_VideoWriter1(
        this: *mut cv_VideoWriter,
        filename: *const cv_String,
        fourcc: ::std::os::raw::c_int,
        fps: f64,
        frameSize: cv_Size,
        isColor: bool,
    );
}
unsafe extern "C" {
    #[doc = " @overload\nThe `apiPreference` parameter allows to specify API backends to use. Can be used to enforce a specific reader implementation\nif multiple are available: e.g. cv::CAP_FFMPEG or cv::CAP_GSTREAMER."]
    #[link_name = "\u{1}_ZN2cv11VideoWriterC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiidNS_5Size_IiEEb"]
    pub fn cv_VideoWriter_VideoWriter2(
        this: *mut cv_VideoWriter,
        filename: *const cv_String,
        apiPreference: ::std::os::raw::c_int,
        fourcc: ::std::os::raw::c_int,
        fps: f64,
        frameSize: cv_Size,
        isColor: bool,
    );
}
impl cv_VideoWriter {
    #[inline]
    pub unsafe fn open(
        &mut self,
        filename: *const cv_String,
        apiPreference: ::std::os::raw::c_int,
        fourcc: ::std::os::raw::c_int,
        fps: f64,
        frameSize: cv_Size,
        isColor: bool,
    ) -> bool {
        cv_VideoWriter_open1(
            self,
            filename,
            apiPreference,
            fourcc,
            fps,
            frameSize,
            isColor,
        )
    }
    #[inline]
    pub unsafe fn fourcc(
        c1: ::std::os::raw::c_char,
        c2: ::std::os::raw::c_char,
        c3: ::std::os::raw::c_char,
        c4: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        cv_VideoWriter_fourcc(c1, c2, c3, c4)
    }
    #[inline]
    pub unsafe fn getBackendName(&self) -> cv_String {
        cv_VideoWriter_getBackendName(self)
    }
    #[inline]
    pub unsafe fn create(
        filename: *const cv_String,
        fourcc: ::std::os::raw::c_int,
        fps: f64,
        frameSize: cv_Size,
        isColor: bool,
    ) -> cv_Ptr {
        cv_VideoWriter_create(filename, fourcc, fps, frameSize, isColor)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_VideoWriter_VideoWriter(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        filename: *const cv_String,
        fourcc: ::std::os::raw::c_int,
        fps: f64,
        frameSize: cv_Size,
        isColor: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_VideoWriter_VideoWriter1(
            __bindgen_tmp.as_mut_ptr(),
            filename,
            fourcc,
            fps,
            frameSize,
            isColor,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(
        filename: *const cv_String,
        apiPreference: ::std::os::raw::c_int,
        fourcc: ::std::os::raw::c_int,
        fps: f64,
        frameSize: cv_Size,
        isColor: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_VideoWriter_VideoWriter2(
            __bindgen_tmp.as_mut_ptr(),
            filename,
            apiPreference,
            fourcc,
            fps,
            frameSize,
            isColor,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[doc = " @brief Default destructor\n\nThe method first calls VideoWriter::release to close the already opened file."]
    #[link_name = "\u{1}_ZN2cv11VideoWriterD1Ev"]
    pub fn cv_VideoWriter_VideoWriter_destructor(this: *mut cv_VideoWriter);
}
unsafe extern "C" {
    #[doc = " @brief Initializes or reinitializes video writer.\n\nThe method opens video writer. Parameters are the same as in the constructor\nVideoWriter::VideoWriter.\n@return `true` if video writer has been successfully initialized\n\nThe method first calls VideoWriter::release to close the already opened file."]
    #[link_name = "\u{1}_ZN2cv11VideoWriter4openERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEidNS_5Size_IiEEb"]
    pub fn cv_VideoWriter_open(
        this: *mut ::std::os::raw::c_void,
        filename: *const cv_String,
        fourcc: ::std::os::raw::c_int,
        fps: f64,
        frameSize: cv_Size,
        isColor: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Returns true if video writer has been successfully initialized."]
    #[link_name = "\u{1}_ZNK2cv11VideoWriter8isOpenedEv"]
    pub fn cv_VideoWriter_isOpened(this: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Closes the video writer.\n\nThe method is automatically called by subsequent VideoWriter::open and by the VideoWriter\ndestructor."]
    #[link_name = "\u{1}_ZN2cv11VideoWriter7releaseEv"]
    pub fn cv_VideoWriter_release(this: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " @brief Writes the next video frame\n\n@param image The written frame. In general, color images are expected in BGR format.\n\nThe function/method writes the specified image to video file. It must have the same size as has\nbeen specified when opening the video writer."]
    #[link_name = "\u{1}_ZN2cv11VideoWriter5writeERKNS_11_InputArrayE"]
    pub fn cv_VideoWriter_write(this: *mut ::std::os::raw::c_void, image: cv_InputArray);
}
unsafe extern "C" {
    #[doc = " @brief Sets a property in the VideoWriter.\n\n@param propId Property identifier from cv::VideoWriterProperties (eg. cv::VIDEOWRITER_PROP_QUALITY)\nor one of @ref videoio_flags_others\n\n@param value Value of the property.\n@return  `true` if the property is supported by the backend used by the VideoWriter instance."]
    #[link_name = "\u{1}_ZN2cv11VideoWriter3setEid"]
    pub fn cv_VideoWriter_set(
        this: *mut ::std::os::raw::c_void,
        propId: ::std::os::raw::c_int,
        value: f64,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Returns the specified VideoWriter property\n\n@param propId Property identifier from cv::VideoWriterProperties (eg. cv::VIDEOWRITER_PROP_QUALITY)\nor one of @ref videoio_flags_others\n\n@return Value for the specified property. Value 0 is returned when querying a property that is\nnot supported by the backend used by the VideoWriter instance."]
    #[link_name = "\u{1}_ZNK2cv11VideoWriter3getEi"]
    pub fn cv_VideoWriter_get(
        this: *mut ::std::os::raw::c_void,
        propId: ::std::os::raw::c_int,
    ) -> f64;
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_DefaultDeleter_open0_CvCapture_close0"]
        [::std::mem::size_of::<cv_DefaultDeleter>() - 1usize];
    ["Align of template specialization: cv_DefaultDeleter_open0_CvCapture_close0"]
        [::std::mem::align_of::<cv_DefaultDeleter>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_DefaultDeleter_open0_CvVideoWriter_close0"]
        [::std::mem::size_of::<cv_DefaultDeleter>() - 1usize];
    ["Align of template specialization: cv_DefaultDeleter_open0_CvVideoWriter_close0"]
        [::std::mem::align_of::<cv_DefaultDeleter>() - 1usize];
};
#[doc = "!< the user can resize the window (no constraint) / also use to switch a fullscreen window to a normal size."]
pub const cv_WindowFlags_WINDOW_NORMAL: cv_WindowFlags = 0;
#[doc = "!< the user cannot resize the window, the size is constrainted by the image displayed."]
pub const cv_WindowFlags_WINDOW_AUTOSIZE: cv_WindowFlags = 1;
#[doc = "!< window with opengl support."]
pub const cv_WindowFlags_WINDOW_OPENGL: cv_WindowFlags = 4096;
#[doc = "!< change the window to fullscreen."]
pub const cv_WindowFlags_WINDOW_FULLSCREEN: cv_WindowFlags = 1;
#[doc = "!< the image expends as much as it can (no ratio constraint)."]
pub const cv_WindowFlags_WINDOW_FREERATIO: cv_WindowFlags = 256;
#[doc = "!< the ratio of the image is respected."]
pub const cv_WindowFlags_WINDOW_KEEPRATIO: cv_WindowFlags = 0;
#[doc = "!< status bar and tool bar"]
pub const cv_WindowFlags_WINDOW_GUI_EXPANDED: cv_WindowFlags = 0;
#[doc = "!< old fashious way"]
pub const cv_WindowFlags_WINDOW_GUI_NORMAL: cv_WindowFlags = 16;
#[doc = "! Flags for cv::namedWindow"]
pub type cv_WindowFlags = ::std::os::raw::c_uint;
#[doc = "!< fullscreen property    (can be WINDOW_NORMAL or WINDOW_FULLSCREEN)."]
pub const cv_WindowPropertyFlags_WND_PROP_FULLSCREEN: cv_WindowPropertyFlags = 0;
#[doc = "!< autosize property      (can be WINDOW_NORMAL or WINDOW_AUTOSIZE)."]
pub const cv_WindowPropertyFlags_WND_PROP_AUTOSIZE: cv_WindowPropertyFlags = 1;
#[doc = "!< window's aspect ration (can be set to WINDOW_FREERATIO or WINDOW_KEEPRATIO)."]
pub const cv_WindowPropertyFlags_WND_PROP_ASPECT_RATIO: cv_WindowPropertyFlags = 2;
#[doc = "!< opengl support."]
pub const cv_WindowPropertyFlags_WND_PROP_OPENGL: cv_WindowPropertyFlags = 3;
#[doc = "!< checks whether the window exists and is visible"]
pub const cv_WindowPropertyFlags_WND_PROP_VISIBLE: cv_WindowPropertyFlags = 4;
#[doc = "!< property to toggle normal window being topmost or not"]
pub const cv_WindowPropertyFlags_WND_PROP_TOPMOST: cv_WindowPropertyFlags = 5;
#[doc = "! Flags for cv::setWindowProperty / cv::getWindowProperty"]
pub type cv_WindowPropertyFlags = ::std::os::raw::c_uint;
#[doc = "!< indicates that the mouse pointer has moved over the window."]
pub const cv_MouseEventTypes_EVENT_MOUSEMOVE: cv_MouseEventTypes = 0;
#[doc = "!< indicates that the left mouse button is pressed."]
pub const cv_MouseEventTypes_EVENT_LBUTTONDOWN: cv_MouseEventTypes = 1;
#[doc = "!< indicates that the right mouse button is pressed."]
pub const cv_MouseEventTypes_EVENT_RBUTTONDOWN: cv_MouseEventTypes = 2;
#[doc = "!< indicates that the middle mouse button is pressed."]
pub const cv_MouseEventTypes_EVENT_MBUTTONDOWN: cv_MouseEventTypes = 3;
#[doc = "!< indicates that left mouse button is released."]
pub const cv_MouseEventTypes_EVENT_LBUTTONUP: cv_MouseEventTypes = 4;
#[doc = "!< indicates that right mouse button is released."]
pub const cv_MouseEventTypes_EVENT_RBUTTONUP: cv_MouseEventTypes = 5;
#[doc = "!< indicates that middle mouse button is released."]
pub const cv_MouseEventTypes_EVENT_MBUTTONUP: cv_MouseEventTypes = 6;
#[doc = "!< indicates that left mouse button is double clicked."]
pub const cv_MouseEventTypes_EVENT_LBUTTONDBLCLK: cv_MouseEventTypes = 7;
#[doc = "!< indicates that right mouse button is double clicked."]
pub const cv_MouseEventTypes_EVENT_RBUTTONDBLCLK: cv_MouseEventTypes = 8;
#[doc = "!< indicates that middle mouse button is double clicked."]
pub const cv_MouseEventTypes_EVENT_MBUTTONDBLCLK: cv_MouseEventTypes = 9;
#[doc = "!< positive and negative values mean forward and backward scrolling, respectively."]
pub const cv_MouseEventTypes_EVENT_MOUSEWHEEL: cv_MouseEventTypes = 10;
#[doc = "!< positive and negative values mean right and left scrolling, respectively."]
pub const cv_MouseEventTypes_EVENT_MOUSEHWHEEL: cv_MouseEventTypes = 11;
#[doc = "! Mouse Events see cv::MouseCallback"]
pub type cv_MouseEventTypes = ::std::os::raw::c_uint;
#[doc = "!< indicates that the left mouse button is down."]
pub const cv_MouseEventFlags_EVENT_FLAG_LBUTTON: cv_MouseEventFlags = 1;
#[doc = "!< indicates that the right mouse button is down."]
pub const cv_MouseEventFlags_EVENT_FLAG_RBUTTON: cv_MouseEventFlags = 2;
#[doc = "!< indicates that the middle mouse button is down."]
pub const cv_MouseEventFlags_EVENT_FLAG_MBUTTON: cv_MouseEventFlags = 4;
#[doc = "!< indicates that CTRL Key is pressed."]
pub const cv_MouseEventFlags_EVENT_FLAG_CTRLKEY: cv_MouseEventFlags = 8;
#[doc = "!< indicates that SHIFT Key is pressed."]
pub const cv_MouseEventFlags_EVENT_FLAG_SHIFTKEY: cv_MouseEventFlags = 16;
#[doc = "!< indicates that ALT Key is pressed."]
pub const cv_MouseEventFlags_EVENT_FLAG_ALTKEY: cv_MouseEventFlags = 32;
#[doc = "! Mouse Event Flags see cv::MouseCallback"]
pub type cv_MouseEventFlags = ::std::os::raw::c_uint;
#[doc = "!< Weight of 25"]
pub const cv_QtFontWeights_QT_FONT_LIGHT: cv_QtFontWeights = 25;
#[doc = "!< Weight of 50"]
pub const cv_QtFontWeights_QT_FONT_NORMAL: cv_QtFontWeights = 50;
#[doc = "!< Weight of 63"]
pub const cv_QtFontWeights_QT_FONT_DEMIBOLD: cv_QtFontWeights = 63;
#[doc = "!< Weight of 75"]
pub const cv_QtFontWeights_QT_FONT_BOLD: cv_QtFontWeights = 75;
#[doc = "!< Weight of 87"]
pub const cv_QtFontWeights_QT_FONT_BLACK: cv_QtFontWeights = 87;
#[doc = "! Qt font weight"]
pub type cv_QtFontWeights = ::std::os::raw::c_uint;
#[doc = "!< Normal font."]
pub const cv_QtFontStyles_QT_STYLE_NORMAL: cv_QtFontStyles = 0;
#[doc = "!< Italic font."]
pub const cv_QtFontStyles_QT_STYLE_ITALIC: cv_QtFontStyles = 1;
#[doc = "!< Oblique font."]
pub const cv_QtFontStyles_QT_STYLE_OBLIQUE: cv_QtFontStyles = 2;
#[doc = "! Qt font style"]
pub type cv_QtFontStyles = ::std::os::raw::c_uint;
#[doc = "!< Push button."]
pub const cv_QtButtonTypes_QT_PUSH_BUTTON: cv_QtButtonTypes = 0;
#[doc = "!< Checkbox button."]
pub const cv_QtButtonTypes_QT_CHECKBOX: cv_QtButtonTypes = 1;
#[doc = "!< Radiobox button."]
pub const cv_QtButtonTypes_QT_RADIOBOX: cv_QtButtonTypes = 2;
#[doc = "!< Button should create a new buttonbar"]
pub const cv_QtButtonTypes_QT_NEW_BUTTONBAR: cv_QtButtonTypes = 1024;
#[doc = "! Qt \"button\" type"]
pub type cv_QtButtonTypes = ::std::os::raw::c_uint;
#[doc = " @brief Callback function for mouse events. see cv::setMouseCallback\n@param event one of the cv::MouseEventTypes constants.\n@param x The x-coordinate of the mouse event.\n@param y The y-coordinate of the mouse event.\n@param flags one of the cv::MouseEventFlags constants.\n@param userdata The optional parameter."]
pub type cv_MouseCallback = ::std::option::Option<
    unsafe extern "C" fn(
        event: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief Callback function for Trackbar see cv::createTrackbar\n@param pos current position of the specified trackbar.\n@param userdata The optional parameter."]
pub type cv_TrackbarCallback = ::std::option::Option<
    unsafe extern "C" fn(pos: ::std::os::raw::c_int, userdata: *mut ::std::os::raw::c_void),
>;
#[doc = " @brief Callback function defined to be called every frame. See cv::setOpenGlDrawCallback\n@param userdata The optional parameter."]
pub type cv_OpenGlDrawCallback =
    ::std::option::Option<unsafe extern "C" fn(userdata: *mut ::std::os::raw::c_void)>;
#[doc = " @brief Callback function for a button created by cv::createButton\n@param state current state of the button. It could be -1 for a push button, 0 or 1 for a check/radio box button.\n@param userdata The optional parameter."]
pub type cv_ButtonCallback = ::std::option::Option<
    unsafe extern "C" fn(state: ::std::os::raw::c_int, userdata: *mut ::std::os::raw::c_void),
>;
unsafe extern "C" {
    #[doc = " @brief Creates a window.\n\nThe function namedWindow creates a window that can be used as a placeholder for images and\ntrackbars. Created windows are referred to by their names.\n\nIf a window with the same name already exists, the function does nothing.\n\nYou can call cv::destroyWindow or cv::destroyAllWindows to close the window and de-allocate any associated\nmemory usage. For a simple program, you do not really have to call these functions because all the\nresources and windows of the application are closed automatically by the operating system upon exit.\n\n@note\n\nQt backend supports additional flags:\n-   **WINDOW_NORMAL or WINDOW_AUTOSIZE:** WINDOW_NORMAL enables you to resize the\nwindow, whereas WINDOW_AUTOSIZE adjusts automatically the window size to fit the\ndisplayed image (see imshow ), and you cannot change the window size manually.\n-   **WINDOW_FREERATIO or WINDOW_KEEPRATIO:** WINDOW_FREERATIO adjusts the image\nwith no respect to its ratio, whereas WINDOW_KEEPRATIO keeps the image ratio.\n-   **WINDOW_GUI_NORMAL or WINDOW_GUI_EXPANDED:** WINDOW_GUI_NORMAL is the old way to draw the window\nwithout statusbar and toolbar, whereas WINDOW_GUI_EXPANDED is a new enhanced GUI.\nBy default, flags == WINDOW_AUTOSIZE | WINDOW_KEEPRATIO | WINDOW_GUI_EXPANDED\n\n@param winname Name of the window in the window caption that may be used as a window identifier.\n@param flags Flags of the window. The supported flags are: (cv::WindowFlags)"]
    #[link_name = "\u{1}_ZN2cv11namedWindowERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
    pub fn cv_namedWindow(winname: *const cv_String, flags: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @brief Destroys the specified window.\n\nThe function destroyWindow destroys the window with the given name.\n\n@param winname Name of the window to be destroyed."]
    #[link_name = "\u{1}_ZN2cv13destroyWindowERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_destroyWindow(winname: *const cv_String);
}
unsafe extern "C" {
    #[doc = " @brief Destroys all of the HighGUI windows.\n\nThe function destroyAllWindows destroys all of the opened HighGUI windows."]
    #[link_name = "\u{1}_ZN2cv17destroyAllWindowsEv"]
    pub fn cv_destroyAllWindows();
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17startWindowThreadEv"]
    pub fn cv_startWindowThread() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Similar to #waitKey, but returns full key code.\n\n@note\n\nKey code is implementation specific and depends on used backend: QT/GTK/Win32/etc"]
    #[link_name = "\u{1}_ZN2cv9waitKeyExEi"]
    pub fn cv_waitKeyEx(delay: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Waits for a pressed key.\n\nThe function waitKey waits for a key event infinitely (when \\f$\\texttt{delay}\\leq 0\\f$ ) or for delay\nmilliseconds, when it is positive. Since the OS has a minimum time between switching threads, the\nfunction will not wait exactly delay ms, it will wait at least delay ms, depending on what else is\nrunning on your computer at that time. It returns the code of the pressed key or -1 if no key was\npressed before the specified time had elapsed.\n\n@note\n\nThis function is the only method in HighGUI that can fetch and handle events, so it needs to be\ncalled periodically for normal event processing unless HighGUI is used within an environment that\ntakes care of event processing.\n\n@note\n\nThe function only works if there is at least one HighGUI window created and the window is active.\nIf there are several HighGUI windows, any of them can be active.\n\n@param delay Delay in milliseconds. 0 is the special value that means \"forever\"."]
    #[link_name = "\u{1}_ZN2cv7waitKeyEi"]
    pub fn cv_waitKey(delay: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Displays an image in the specified window.\n\nThe function imshow displays an image in the specified window. If the window was created with the\ncv::WINDOW_AUTOSIZE flag, the image is shown with its original size, however it is still limited by the screen resolution.\nOtherwise, the image is scaled to fit the window. The function may scale the image, depending on its depth:\n\n-   If the image is 8-bit unsigned, it is displayed as is.\n-   If the image is 16-bit unsigned or 32-bit integer, the pixels are divided by 256. That is, the\nvalue range [0,255\\*256] is mapped to [0,255].\n-   If the image is 32-bit or 64-bit floating-point, the pixel values are multiplied by 255. That is, the\nvalue range [0,1] is mapped to [0,255].\n\nIf window was created with OpenGL support, cv::imshow also support ogl::Buffer , ogl::Texture2D and\ncuda::GpuMat as input.\n\nIf the window was not created before this function, it is assumed creating a window with cv::WINDOW_AUTOSIZE.\n\nIf you need to show an image that is bigger than the screen resolution, you will need to call namedWindow(\"\", WINDOW_NORMAL) before the imshow.\n\n@note This function should be followed by cv::waitKey function which displays the image for specified\nmilliseconds. Otherwise, it won't display the image. For example, **waitKey(0)** will display the window\ninfinitely until any keypress (it is suitable for image display). **waitKey(25)** will display a frame\nfor 25 ms, after which display will be automatically closed. (If you put it in a loop to read\nvideos, it will display the video frame-by-frame)\n\n@note\n\n[__Windows Backend Only__] Pressing Ctrl+C will copy the image to the clipboard.\n\n[__Windows Backend Only__] Pressing Ctrl+S will show a dialog to save the image.\n\n@param winname Name of the window.\n@param mat Image to be shown."]
    #[link_name = "\u{1}_ZN2cv6imshowERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_11_InputArrayE"]
    pub fn cv_imshow(winname: *const cv_String, mat: cv_InputArray);
}
unsafe extern "C" {
    #[doc = " @brief Resizes window to the specified size\n\n@note\n\n-   The specified window size is for the image area. Toolbars are not counted.\n-   Only windows created without cv::WINDOW_AUTOSIZE flag can be resized.\n\n@param winname Window name.\n@param width The new window width.\n@param height The new window height."]
    #[link_name = "\u{1}_ZN2cv12resizeWindowERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEii"]
    pub fn cv_resizeWindow(
        winname: *const cv_String,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param winname Window name.\n@param size The new window size."]
    #[link_name = "\u{1}_ZN2cv12resizeWindowERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_5Size_IiEE"]
    pub fn cv_resizeWindow1(winname: *const cv_String, size: *const cv_Size);
}
unsafe extern "C" {
    #[doc = " @brief Moves window to the specified position\n\n@param winname Name of the window.\n@param x The new x-coordinate of the window.\n@param y The new y-coordinate of the window."]
    #[link_name = "\u{1}_ZN2cv10moveWindowERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEii"]
    pub fn cv_moveWindow(
        winname: *const cv_String,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Changes parameters of a window dynamically.\n\nThe function setWindowProperty enables changing properties of a window.\n\n@param winname Name of the window.\n@param prop_id Window property to edit. The supported operation flags are: (cv::WindowPropertyFlags)\n@param prop_value New value of the window property. The supported flags are: (cv::WindowFlags)"]
    #[link_name = "\u{1}_ZN2cv17setWindowPropertyERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEid"]
    pub fn cv_setWindowProperty(
        winname: *const cv_String,
        prop_id: ::std::os::raw::c_int,
        prop_value: f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Updates window title\n@param winname Name of the window.\n@param title New title."]
    #[link_name = "\u{1}_ZN2cv14setWindowTitleERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_"]
    pub fn cv_setWindowTitle(winname: *const cv_String, title: *const cv_String);
}
unsafe extern "C" {
    #[doc = " @brief Provides parameters of a window.\n\nThe function getWindowProperty returns properties of a window.\n\n@param winname Name of the window.\n@param prop_id Window property to retrieve. The following operation flags are available: (cv::WindowPropertyFlags)\n\n@sa setWindowProperty"]
    #[link_name = "\u{1}_ZN2cv17getWindowPropertyERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
    pub fn cv_getWindowProperty(winname: *const cv_String, prop_id: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Provides rectangle of image in the window.\n\nThe function getWindowImageRect returns the client screen coordinates, width and height of the image rendering area.\n\n@param winname Name of the window.\n\n@sa resizeWindow moveWindow"]
    #[link_name = "\u{1}_ZN2cv18getWindowImageRectERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_getWindowImageRect(winname: *const cv_String) -> cv_Rect;
}
unsafe extern "C" {
    #[doc = " @example samples/cpp/create_mask.cpp\nThis program demonstrates using mouse events and how to make and use a mask image (black and white) .\n/\n/** @brief Sets mouse handler for the specified window\n\n@param winname Name of the window.\n@param onMouse Callback function for mouse events. See OpenCV samples on how to specify and use the callback.\n@param userdata The optional parameter passed to the callback."]
    #[link_name = "\u{1}_ZN2cv16setMouseCallbackERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPFviiiiPvES8_"]
    pub fn cv_setMouseCallback(
        winname: *const cv_String,
        onMouse: cv_MouseCallback,
        userdata: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " @brief Gets the mouse-wheel motion delta, when handling mouse-wheel events cv::EVENT_MOUSEWHEEL and\ncv::EVENT_MOUSEHWHEEL.\n\nFor regular mice with a scroll-wheel, delta will be a multiple of 120. The value 120 corresponds to\na one notch rotation of the wheel or the threshold for action to be taken and one such action should\noccur for each delta. Some high-precision mice with higher-resolution freely-rotating wheels may\ngenerate smaller values.\n\nFor cv::EVENT_MOUSEWHEEL positive and negative values mean forward and backward scrolling,\nrespectively. For cv::EVENT_MOUSEHWHEEL, where available, positive and negative values mean right and\nleft scrolling, respectively.\n\nWith the C API, the macro CV_GET_WHEEL_DELTA(flags) can be used alternatively.\n\n@note\n\nMouse-wheel events are currently supported only on Windows.\n\n@param flags The mouse callback flags parameter."]
    #[link_name = "\u{1}_ZN2cv18getMouseWheelDeltaEi"]
    pub fn cv_getMouseWheelDelta(flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Selects ROI on the given image.\nFunction creates a window and allows user to select a ROI using mouse.\nControls: use `space` or `enter` to finish selection, use key `c` to cancel selection (function will return the zero cv::Rect).\n\n@param windowName name of the window where selection process will be shown.\n@param img image to select a ROI.\n@param showCrosshair if true crosshair of selection rectangle will be shown.\n@param fromCenter if true center of selection will match initial mouse position. In opposite case a corner of\nselection rectangle will correspont to the initial mouse position.\n@return selected ROI or empty rect if selection canceled.\n\n@note The function sets it's own mouse callback for specified window using cv::setMouseCallback(windowName, ...).\nAfter finish of work an empty callback will be set for the used window."]
    #[link_name = "\u{1}_ZN2cv9selectROIERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_11_InputArrayEbb"]
    pub fn cv_selectROI(
        windowName: *const cv_String,
        img: cv_InputArray,
        showCrosshair: bool,
        fromCenter: bool,
    ) -> cv_Rect;
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv9selectROIERKNS_11_InputArrayEbb"]
    pub fn cv_selectROI1(img: cv_InputArray, showCrosshair: bool, fromCenter: bool) -> cv_Rect;
}
unsafe extern "C" {
    #[doc = " @brief Selects ROIs on the given image.\nFunction creates a window and allows user to select a ROIs using mouse.\nControls: use `space` or `enter` to finish current selection and start a new one,\nuse `esc` to terminate multiple ROI selection process.\n\n@param windowName name of the window where selection process will be shown.\n@param img image to select a ROI.\n@param boundingBoxes selected ROIs.\n@param showCrosshair if true crosshair of selection rectangle will be shown.\n@param fromCenter if true center of selection will match initial mouse position. In opposite case a corner of\nselection rectangle will correspont to the initial mouse position.\n\n@note The function sets it's own mouse callback for specified window using cv::setMouseCallback(windowName, ...).\nAfter finish of work an empty callback will be set for the used window."]
    #[link_name = "\u{1}_ZN2cv10selectROIsERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_11_InputArrayERSt6vectorINS_5Rect_IiEESaISD_EEbb"]
    pub fn cv_selectROIs(
        windowName: *const cv_String,
        img: cv_InputArray,
        boundingBoxes: *mut std_vector,
        showCrosshair: bool,
        fromCenter: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief Creates a trackbar and attaches it to the specified window.\n\nThe function createTrackbar creates a trackbar (a slider or range control) with the specified name\nand range, assigns a variable value to be a position synchronized with the trackbar and specifies\nthe callback function onChange to be called on the trackbar position change. The created trackbar is\ndisplayed in the specified window winname.\n\n@note\n\n[__Qt Backend Only__] winname can be empty if the trackbar should be attached to the\ncontrol panel.\n\nClicking the label of each trackbar enables editing the trackbar values manually.\n\n@param trackbarname Name of the created trackbar.\n@param winname Name of the window that will be used as a parent of the created trackbar.\n@param value Optional pointer to an integer variable whose value reflects the position of the\nslider. Upon creation, the slider position is defined by this variable.\n@param count Maximal position of the slider. The minimal position is always 0.\n@param onChange Pointer to the function to be called every time the slider changes position. This\nfunction should be prototyped as void Foo(int,void\\*); , where the first parameter is the trackbar\nposition and the second parameter is the user data (see the next parameter). If the callback is\nthe NULL pointer, no callbacks are called, but only value is updated.\n@param userdata User data that is passed as is to the callback. It can be used to handle trackbar\nevents without using global variables."]
    #[link_name = "\u{1}_ZN2cv14createTrackbarERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_PiiPFviPvES9_"]
    pub fn cv_createTrackbar(
        trackbarname: *const cv_String,
        winname: *const cv_String,
        value: *mut ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        onChange: cv_TrackbarCallback,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Returns the trackbar position.\n\nThe function returns the current position of the specified trackbar.\n\n@note\n\n[__Qt Backend Only__] winname can be empty if the trackbar is attached to the control\npanel.\n\n@param trackbarname Name of the trackbar.\n@param winname Name of the window that is the parent of the trackbar."]
    #[link_name = "\u{1}_ZN2cv14getTrackbarPosERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_"]
    pub fn cv_getTrackbarPos(
        trackbarname: *const cv_String,
        winname: *const cv_String,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Sets the trackbar position.\n\nThe function sets the position of the specified trackbar in the specified window.\n\n@note\n\n[__Qt Backend Only__] winname can be empty if the trackbar is attached to the control\npanel.\n\n@param trackbarname Name of the trackbar.\n@param winname Name of the window that is the parent of trackbar.\n@param pos New position."]
    #[link_name = "\u{1}_ZN2cv14setTrackbarPosERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_i"]
    pub fn cv_setTrackbarPos(
        trackbarname: *const cv_String,
        winname: *const cv_String,
        pos: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Sets the trackbar maximum position.\n\nThe function sets the maximum position of the specified trackbar in the specified window.\n\n@note\n\n[__Qt Backend Only__] winname can be empty if the trackbar is attached to the control\npanel.\n\n@param trackbarname Name of the trackbar.\n@param winname Name of the window that is the parent of trackbar.\n@param maxval New maximum position."]
    #[link_name = "\u{1}_ZN2cv14setTrackbarMaxERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_i"]
    pub fn cv_setTrackbarMax(
        trackbarname: *const cv_String,
        winname: *const cv_String,
        maxval: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Sets the trackbar minimum position.\n\nThe function sets the minimum position of the specified trackbar in the specified window.\n\n@note\n\n[__Qt Backend Only__] winname can be empty if the trackbar is attached to the control\npanel.\n\n@param trackbarname Name of the trackbar.\n@param winname Name of the window that is the parent of trackbar.\n@param minval New minimum position."]
    #[link_name = "\u{1}_ZN2cv14setTrackbarMinERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_i"]
    pub fn cv_setTrackbarMin(
        trackbarname: *const cv_String,
        winname: *const cv_String,
        minval: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Displays OpenGL 2D texture in the specified window.\n\n@param winname Name of the window.\n@param tex OpenGL 2D texture data."]
    #[link_name = "\u{1}_ZN2cv6imshowERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_3ogl9Texture2DE"]
    pub fn cv_imshow1(winname: *const cv_String, tex: *const cv_ogl_Texture2D);
}
unsafe extern "C" {
    #[doc = " @brief Sets a callback function to be called to draw on top of displayed image.\n\nThe function setOpenGlDrawCallback can be used to draw 3D data on the window. See the example of\ncallback function below:\n@code\nvoid on_opengl(void* param)\n{\nglLoadIdentity();\n\nglTranslated(0.0, 0.0, -1.0);\n\nglRotatef( 55, 1, 0, 0 );\nglRotatef( 45, 0, 1, 0 );\nglRotatef( 0, 0, 0, 1 );\n\nstatic const int coords[6][4][3] = {\n{ { +1, -1, -1 }, { -1, -1, -1 }, { -1, +1, -1 }, { +1, +1, -1 } },\n{ { +1, +1, -1 }, { -1, +1, -1 }, { -1, +1, +1 }, { +1, +1, +1 } },\n{ { +1, -1, +1 }, { +1, -1, -1 }, { +1, +1, -1 }, { +1, +1, +1 } },\n{ { -1, -1, -1 }, { -1, -1, +1 }, { -1, +1, +1 }, { -1, +1, -1 } },\n{ { +1, -1, +1 }, { -1, -1, +1 }, { -1, -1, -1 }, { +1, -1, -1 } },\n{ { -1, -1, +1 }, { +1, -1, +1 }, { +1, +1, +1 }, { -1, +1, +1 } }\n};\n\nfor (int i = 0; i < 6; ++i) {\nglColor3ub( i*20, 100+i*10, i*42 );\nglBegin(GL_QUADS);\nfor (int j = 0; j < 4; ++j) {\nglVertex3d(0.2 * coords[i][j][0], 0.2 * coords[i][j][1], 0.2 * coords[i][j][2]);\n}\nglEnd();\n}\n}\n@endcode\n\n@param winname Name of the window.\n@param onOpenGlDraw Pointer to the function to be called every frame. This function should be\nprototyped as void Foo(void\\*) .\n@param userdata Pointer passed to the callback function.(__Optional__)"]
    #[link_name = "\u{1}_ZN2cv21setOpenGlDrawCallbackERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPFvPvES8_"]
    pub fn cv_setOpenGlDrawCallback(
        winname: *const cv_String,
        onOpenGlDraw: cv_OpenGlDrawCallback,
        userdata: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " @brief Sets the specified window as current OpenGL context.\n\n@param winname Name of the window."]
    #[link_name = "\u{1}_ZN2cv16setOpenGlContextERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_setOpenGlContext(winname: *const cv_String);
}
unsafe extern "C" {
    #[doc = " @brief Force window to redraw its context and call draw callback ( See cv::setOpenGlDrawCallback ).\n\n@param winname Name of the window."]
    #[link_name = "\u{1}_ZN2cv12updateWindowERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_updateWindow(winname: *const cv_String);
}
#[doc = " @brief QtFont available only for Qt. See cv::fontQt"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_QtFont {
    #[doc = "!< Name of the font"]
    pub nameFont: *const ::std::os::raw::c_char,
    #[doc = "!< Color of the font. Scalar(blue_component, green_component, red_component[, alpha_component])"]
    pub color: cv_Scalar,
    #[doc = "!< See cv::QtFontStyles"]
    pub font_face: ::std::os::raw::c_int,
    #[doc = "!< font data and metrics"]
    pub ascii: *const ::std::os::raw::c_int,
    pub greek: *const ::std::os::raw::c_int,
    pub cyrillic: *const ::std::os::raw::c_int,
    pub hscale: f32,
    pub vscale: f32,
    #[doc = "!< slope coefficient: 0 - normal, >0 - italic"]
    pub shear: f32,
    #[doc = "!< See cv::QtFontWeights"]
    pub thickness: ::std::os::raw::c_int,
    #[doc = "!< horizontal interval between letters"]
    pub dx: f32,
    #[doc = "!< PointSize"]
    pub line_type: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_QtFont"][::std::mem::size_of::<cv_QtFont>() - 96usize];
    ["Alignment of cv_QtFont"][::std::mem::align_of::<cv_QtFont>() - 8usize];
    ["Offset of field: cv_QtFont::nameFont"][::std::mem::offset_of!(cv_QtFont, nameFont) - 0usize];
    ["Offset of field: cv_QtFont::color"][::std::mem::offset_of!(cv_QtFont, color) - 8usize];
    ["Offset of field: cv_QtFont::font_face"]
        [::std::mem::offset_of!(cv_QtFont, font_face) - 40usize];
    ["Offset of field: cv_QtFont::ascii"][::std::mem::offset_of!(cv_QtFont, ascii) - 48usize];
    ["Offset of field: cv_QtFont::greek"][::std::mem::offset_of!(cv_QtFont, greek) - 56usize];
    ["Offset of field: cv_QtFont::cyrillic"][::std::mem::offset_of!(cv_QtFont, cyrillic) - 64usize];
    ["Offset of field: cv_QtFont::hscale"][::std::mem::offset_of!(cv_QtFont, hscale) - 72usize];
    ["Offset of field: cv_QtFont::vscale"][::std::mem::offset_of!(cv_QtFont, vscale) - 76usize];
    ["Offset of field: cv_QtFont::shear"][::std::mem::offset_of!(cv_QtFont, shear) - 80usize];
    ["Offset of field: cv_QtFont::thickness"]
        [::std::mem::offset_of!(cv_QtFont, thickness) - 84usize];
    ["Offset of field: cv_QtFont::dx"][::std::mem::offset_of!(cv_QtFont, dx) - 88usize];
    ["Offset of field: cv_QtFont::line_type"]
        [::std::mem::offset_of!(cv_QtFont, line_type) - 92usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates the font to draw a text on an image.\n\nThe function fontQt creates a cv::QtFont object. This cv::QtFont is not compatible with putText .\n\nA basic usage of this function is the following: :\n@code\nQtFont font = fontQt(\"Times\");\naddText( img1, \"Hello World !\", Point(50,50), font);\n@endcode\n\n@param nameFont Name of the font. The name should match the name of a system font (such as\nTimes*). If the font is not found, a default one is used.\n@param pointSize Size of the font. If not specified, equal zero or negative, the point size of the\nfont is set to a system-dependent default value. Generally, this is 12 points.\n@param color Color of the font in BGRA where A = 255 is fully transparent. Use the macro CV_RGB\nfor simplicity.\n@param weight Font weight. Available operation flags are : cv::QtFontWeights You can also specify a positive integer for better control.\n@param style Font style. Available operation flags are : cv::QtFontStyles\n@param spacing Spacing between characters. It can be negative or positive."]
    #[link_name = "\u{1}_ZN2cv6fontQtERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiNS_7Scalar_IdEEiii"]
    pub fn cv_fontQt(
        nameFont: *const cv_String,
        pointSize: ::std::os::raw::c_int,
        color: cv_Scalar,
        weight: ::std::os::raw::c_int,
        style: ::std::os::raw::c_int,
        spacing: ::std::os::raw::c_int,
    ) -> cv_QtFont;
}
unsafe extern "C" {
    #[doc = " @brief Draws a text on the image.\n\nThe function addText draws *text* on the image *img* using a specific font *font* (see example cv::fontQt\n)\n\n@param img 8-bit 3-channel image where the text should be drawn.\n@param text Text to write on an image.\n@param org Point(x,y) where the text should start on an image.\n@param font Font to use to draw a text."]
    #[link_name = "\u{1}_ZN2cv7addTextERKNS_3MatERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS_6Point_IiEERKNS_6QtFontE"]
    pub fn cv_addText(
        img: *const cv_Mat,
        text: *const cv_String,
        org: cv_Point,
        font: *const cv_QtFont,
    );
}
unsafe extern "C" {
    #[doc = " @brief Draws a text on the image.\n\n@param img 8-bit 3-channel image where the text should be drawn.\n@param text Text to write on an image.\n@param org Point(x,y) where the text should start on an image.\n@param nameFont Name of the font. The name should match the name of a system font (such as\nTimes*). If the font is not found, a default one is used.\n@param pointSize Size of the font. If not specified, equal zero or negative, the point size of the\nfont is set to a system-dependent default value. Generally, this is 12 points.\n@param color Color of the font in BGRA where A = 255 is fully transparent.\n@param weight Font weight. Available operation flags are : cv::QtFontWeights You can also specify a positive integer for better control.\n@param style Font style. Available operation flags are : cv::QtFontStyles\n@param spacing Spacing between characters. It can be negative or positive."]
    #[link_name = "\u{1}_ZN2cv7addTextERKNS_3MatERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS_6Point_IiEESA_iNS_7Scalar_IdEEiii"]
    pub fn cv_addText1(
        img: *const cv_Mat,
        text: *const cv_String,
        org: cv_Point,
        nameFont: *const cv_String,
        pointSize: ::std::os::raw::c_int,
        color: cv_Scalar,
        weight: ::std::os::raw::c_int,
        style: ::std::os::raw::c_int,
        spacing: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Displays a text on a window image as an overlay for a specified duration.\n\nThe function displayOverlay displays useful information/tips on top of the window for a certain\namount of time *delayms*. The function does not modify the image, displayed in the window, that is,\nafter the specified delay the original content of the window is restored.\n\n@param winname Name of the window.\n@param text Overlay text to write on a window image.\n@param delayms The period (in milliseconds), during which the overlay text is displayed. If this\nfunction is called before the previous overlay text timed out, the timer is restarted and the text\nis updated. If this value is zero, the text never disappears."]
    #[link_name = "\u{1}_ZN2cv14displayOverlayERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_i"]
    pub fn cv_displayOverlay(
        winname: *const cv_String,
        text: *const cv_String,
        delayms: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Displays a text on the window statusbar during the specified period of time.\n\nThe function displayStatusBar displays useful information/tips on top of the window for a certain\namount of time *delayms* . This information is displayed on the window statusbar (the window must be\ncreated with the CV_GUI_EXPANDED flags).\n\n@param winname Name of the window.\n@param text Text to write on the window statusbar.\n@param delayms Duration (in milliseconds) to display the text. If this function is called before\nthe previous text timed out, the timer is restarted and the text is updated. If this value is\nzero, the text never disappears."]
    #[link_name = "\u{1}_ZN2cv16displayStatusBarERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_i"]
    pub fn cv_displayStatusBar(
        winname: *const cv_String,
        text: *const cv_String,
        delayms: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Saves parameters of the specified window.\n\nThe function saveWindowParameters saves size, location, flags, trackbars value, zoom and panning\nlocation of the window windowName.\n\n@param windowName Name of the window."]
    #[link_name = "\u{1}_ZN2cv20saveWindowParametersERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_saveWindowParameters(windowName: *const cv_String);
}
unsafe extern "C" {
    #[doc = " @brief Loads parameters of the specified window.\n\nThe function loadWindowParameters loads size, location, flags, trackbars value, zoom and panning\nlocation of the window windowName.\n\n@param windowName Name of the window."]
    #[link_name = "\u{1}_ZN2cv20loadWindowParametersERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_loadWindowParameters(windowName: *const cv_String);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9startLoopEPFiiPPcEiS1_"]
    pub fn cv_startLoop(
        pt2Func: ::std::option::Option<
            unsafe extern "C" fn(
                argc: ::std::os::raw::c_int,
                argv: *mut *mut ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int,
        >,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8stopLoopEv"]
    pub fn cv_stopLoop();
}
unsafe extern "C" {
    #[doc = " @brief Attaches a button to the control panel.\n\nThe function createButton attaches a button to the control panel. Each button is added to a\nbuttonbar to the right of the last button. A new buttonbar is created if nothing was attached to the\ncontrol panel before, or if the last element attached to the control panel was a trackbar or if the\nQT_NEW_BUTTONBAR flag is added to the type.\n\nSee below various examples of the cv::createButton function call: :\n@code\ncreateButton(\"\",callbackButton);//create a push button \"button 0\", that will call callbackButton.\ncreateButton(\"button2\",callbackButton,NULL,QT_CHECKBOX,0);\ncreateButton(\"button3\",callbackButton,&value);\ncreateButton(\"button5\",callbackButton1,NULL,QT_RADIOBOX);\ncreateButton(\"button6\",callbackButton2,NULL,QT_PUSH_BUTTON,1);\ncreateButton(\"button6\",callbackButton2,NULL,QT_PUSH_BUTTON|QT_NEW_BUTTONBAR);// create a push button in a new row\n@endcode\n\n@param  bar_name Name of the button.\n@param on_change Pointer to the function to be called every time the button changes its state.\nThis function should be prototyped as void Foo(int state,\\*void); . *state* is the current state\nof the button. It could be -1 for a push button, 0 or 1 for a check/radio box button.\n@param userdata Pointer passed to the callback function.\n@param type Optional type of the button. Available types are: (cv::QtButtonTypes)\n@param initial_button_state Default state of the button. Use for checkbox and radiobox. Its\nvalue could be 0 or 1. (__Optional__)"]
    #[link_name = "\u{1}_ZN2cv12createButtonERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPFviPvES8_ib"]
    pub fn cv_createButton(
        bar_name: *const cv_String,
        on_change: cv_ButtonCallback,
        userdata: *mut ::std::os::raw::c_void,
        type_: ::std::os::raw::c_int,
        initial_button_state: bool,
    ) -> ::std::os::raw::c_int;
}
pub const cv_SpecialFilter_FILTER_SCHARR: cv_SpecialFilter = -1;
#[doc = "! @addtogroup imgproc_filter\n! @{"]
pub type cv_SpecialFilter = ::std::os::raw::c_int;
#[doc = "!< see #erode"]
pub const cv_MorphTypes_MORPH_ERODE: cv_MorphTypes = 0;
#[doc = "!< see #dilate"]
pub const cv_MorphTypes_MORPH_DILATE: cv_MorphTypes = 1;
#[doc = "!< an opening operation\n!< \\f[\\texttt{dst} = \\mathrm{open} ( \\texttt{src} , \\texttt{element} )= \\mathrm{dilate} ( \\mathrm{erode} ( \\texttt{src} , \\texttt{element} ))\\f]"]
pub const cv_MorphTypes_MORPH_OPEN: cv_MorphTypes = 2;
#[doc = "!< a closing operation\n!< \\f[\\texttt{dst} = \\mathrm{close} ( \\texttt{src} , \\texttt{element} )= \\mathrm{erode} ( \\mathrm{dilate} ( \\texttt{src} , \\texttt{element} ))\\f]"]
pub const cv_MorphTypes_MORPH_CLOSE: cv_MorphTypes = 3;
#[doc = "!< a morphological gradient\n!< \\f[\\texttt{dst} = \\mathrm{morph\\_grad} ( \\texttt{src} , \\texttt{element} )= \\mathrm{dilate} ( \\texttt{src} , \\texttt{element} )- \\mathrm{erode} ( \\texttt{src} , \\texttt{element} )\\f]"]
pub const cv_MorphTypes_MORPH_GRADIENT: cv_MorphTypes = 4;
#[doc = "!< \"top hat\"\n!< \\f[\\texttt{dst} = \\mathrm{tophat} ( \\texttt{src} , \\texttt{element} )= \\texttt{src} - \\mathrm{open} ( \\texttt{src} , \\texttt{element} )\\f]"]
pub const cv_MorphTypes_MORPH_TOPHAT: cv_MorphTypes = 5;
#[doc = "!< \"black hat\"\n!< \\f[\\texttt{dst} = \\mathrm{blackhat} ( \\texttt{src} , \\texttt{element} )= \\mathrm{close} ( \\texttt{src} , \\texttt{element} )- \\texttt{src}\\f]"]
pub const cv_MorphTypes_MORPH_BLACKHAT: cv_MorphTypes = 6;
#[doc = "!< \"hit or miss\"\n!<   .- Only supported for CV_8UC1 binary images. A tutorial can be found in the documentation"]
pub const cv_MorphTypes_MORPH_HITMISS: cv_MorphTypes = 7;
#[doc = "! type of morphological operation"]
pub type cv_MorphTypes = ::std::os::raw::c_uint;
#[doc = "!< a rectangular structuring element:  \\f[E_{ij}=1\\f]"]
pub const cv_MorphShapes_MORPH_RECT: cv_MorphShapes = 0;
#[doc = "!< a cross-shaped structuring element:\n!< \\f[E_{ij} =  \\fork{1}{if i=\\texttt{anchor.y} or j=\\texttt{anchor.x}}{0}{otherwise}\\f]"]
pub const cv_MorphShapes_MORPH_CROSS: cv_MorphShapes = 1;
#[doc = "!< an elliptic structuring element, that is, a filled ellipse inscribed\n!< into the rectangle Rect(0, 0, esize.width, 0.esize.height)"]
pub const cv_MorphShapes_MORPH_ELLIPSE: cv_MorphShapes = 2;
#[doc = "! shape of the structuring element"]
pub type cv_MorphShapes = ::std::os::raw::c_uint;
#[doc = " nearest neighbor interpolation"]
pub const cv_InterpolationFlags_INTER_NEAREST: cv_InterpolationFlags = 0;
#[doc = " bilinear interpolation"]
pub const cv_InterpolationFlags_INTER_LINEAR: cv_InterpolationFlags = 1;
#[doc = " bicubic interpolation"]
pub const cv_InterpolationFlags_INTER_CUBIC: cv_InterpolationFlags = 2;
#[doc = " resampling using pixel area relation. It may be a preferred method for image decimation, as\nit gives moire'-free results. But when the image is zoomed, it is similar to the INTER_NEAREST\nmethod."]
pub const cv_InterpolationFlags_INTER_AREA: cv_InterpolationFlags = 3;
#[doc = " Lanczos interpolation over 8x8 neighborhood"]
pub const cv_InterpolationFlags_INTER_LANCZOS4: cv_InterpolationFlags = 4;
#[doc = " Bit exact bilinear interpolation"]
pub const cv_InterpolationFlags_INTER_LINEAR_EXACT: cv_InterpolationFlags = 5;
#[doc = " mask for interpolation codes"]
pub const cv_InterpolationFlags_INTER_MAX: cv_InterpolationFlags = 7;
#[doc = " flag, fills all of the destination image pixels. If some of them correspond to outliers in the\nsource image, they are set to zero"]
pub const cv_InterpolationFlags_WARP_FILL_OUTLIERS: cv_InterpolationFlags = 8;
#[doc = " flag, inverse transformation\n\nFor example, #linearPolar or #logPolar transforms:\n- flag is __not__ set: \\f$dst( \\rho , \\phi ) = src(x,y)\\f$\n- flag is set: \\f$dst(x,y) = src( \\rho , \\phi )\\f$"]
pub const cv_InterpolationFlags_WARP_INVERSE_MAP: cv_InterpolationFlags = 16;
#[doc = "! interpolation algorithm"]
pub type cv_InterpolationFlags = ::std::os::raw::c_uint;
#[doc = "< Remaps an image to/from polar space."]
pub const cv_WarpPolarMode_WARP_POLAR_LINEAR: cv_WarpPolarMode = 0;
#[doc = "< Remaps an image to/from semilog-polar space."]
pub const cv_WarpPolarMode_WARP_POLAR_LOG: cv_WarpPolarMode = 256;
#[doc = " \\brief Specify the polar mapping mode\n@sa warpPolar"]
pub type cv_WarpPolarMode = ::std::os::raw::c_uint;
pub const cv_InterpolationMasks_INTER_BITS: cv_InterpolationMasks = 5;
pub const cv_InterpolationMasks_INTER_BITS2: cv_InterpolationMasks = 10;
pub const cv_InterpolationMasks_INTER_TAB_SIZE: cv_InterpolationMasks = 32;
pub const cv_InterpolationMasks_INTER_TAB_SIZE2: cv_InterpolationMasks = 1024;
pub type cv_InterpolationMasks = ::std::os::raw::c_uint;
#[doc = "!< User defined distance"]
pub const cv_DistanceTypes_DIST_USER: cv_DistanceTypes = -1;
#[doc = "!< distance = |x1-x2| + |y1-y2|"]
pub const cv_DistanceTypes_DIST_L1: cv_DistanceTypes = 1;
#[doc = "!< the simple euclidean distance"]
pub const cv_DistanceTypes_DIST_L2: cv_DistanceTypes = 2;
#[doc = "!< distance = max(|x1-x2|,|y1-y2|)"]
pub const cv_DistanceTypes_DIST_C: cv_DistanceTypes = 3;
#[doc = "!< L1-L2 metric: distance = 2(sqrt(1+x*x/2) - 1))"]
pub const cv_DistanceTypes_DIST_L12: cv_DistanceTypes = 4;
#[doc = "!< distance = c^2(|x|/c-log(1+|x|/c)), c = 1.3998"]
pub const cv_DistanceTypes_DIST_FAIR: cv_DistanceTypes = 5;
#[doc = "!< distance = c^2/2(1-exp(-(x/c)^2)), c = 2.9846"]
pub const cv_DistanceTypes_DIST_WELSCH: cv_DistanceTypes = 6;
#[doc = "!< distance = |x|<c ? x^2/2 : c(|x|-c/2), c=1.345"]
pub const cv_DistanceTypes_DIST_HUBER: cv_DistanceTypes = 7;
#[doc = "! Distance types for Distance Transform and M-estimators\n! @see distanceTransform, fitLine"]
pub type cv_DistanceTypes = ::std::os::raw::c_int;
#[doc = "!< mask=3"]
pub const cv_DistanceTransformMasks_DIST_MASK_3: cv_DistanceTransformMasks = 3;
#[doc = "!< mask=5"]
pub const cv_DistanceTransformMasks_DIST_MASK_5: cv_DistanceTransformMasks = 5;
#[doc = "!<"]
pub const cv_DistanceTransformMasks_DIST_MASK_PRECISE: cv_DistanceTransformMasks = 0;
#[doc = "! Mask size for distance transform"]
pub type cv_DistanceTransformMasks = ::std::os::raw::c_uint;
#[doc = "!< \\f[\\texttt{dst} (x,y) =  \\fork{\\texttt{maxval}}{if \\(\\texttt{src}(x,y) > \\texttt{thresh}\\)}{0}{otherwise}\\f]"]
pub const cv_ThresholdTypes_THRESH_BINARY: cv_ThresholdTypes = 0;
#[doc = "!< \\f[\\texttt{dst} (x,y) =  \\fork{0}{if \\(\\texttt{src}(x,y) > \\texttt{thresh}\\)}{\\texttt{maxval}}{otherwise}\\f]"]
pub const cv_ThresholdTypes_THRESH_BINARY_INV: cv_ThresholdTypes = 1;
#[doc = "!< \\f[\\texttt{dst} (x,y) =  \\fork{\\texttt{threshold}}{if \\(\\texttt{src}(x,y) > \\texttt{thresh}\\)}{\\texttt{src}(x,y)}{otherwise}\\f]"]
pub const cv_ThresholdTypes_THRESH_TRUNC: cv_ThresholdTypes = 2;
#[doc = "!< \\f[\\texttt{dst} (x,y) =  \\fork{\\texttt{src}(x,y)}{if \\(\\texttt{src}(x,y) > \\texttt{thresh}\\)}{0}{otherwise}\\f]"]
pub const cv_ThresholdTypes_THRESH_TOZERO: cv_ThresholdTypes = 3;
#[doc = "!< \\f[\\texttt{dst} (x,y) =  \\fork{0}{if \\(\\texttt{src}(x,y) > \\texttt{thresh}\\)}{\\texttt{src}(x,y)}{otherwise}\\f]"]
pub const cv_ThresholdTypes_THRESH_TOZERO_INV: cv_ThresholdTypes = 4;
pub const cv_ThresholdTypes_THRESH_MASK: cv_ThresholdTypes = 7;
#[doc = "!< flag, use Otsu algorithm to choose the optimal threshold value"]
pub const cv_ThresholdTypes_THRESH_OTSU: cv_ThresholdTypes = 8;
#[doc = "!< flag, use Triangle algorithm to choose the optimal threshold value"]
pub const cv_ThresholdTypes_THRESH_TRIANGLE: cv_ThresholdTypes = 16;
#[doc = "! type of the threshold operation\n! ![threshold types](pics/threshold.png)"]
pub type cv_ThresholdTypes = ::std::os::raw::c_uint;
#[doc = " the threshold value \\f$T(x,y)\\f$ is a mean of the \\f$\\texttt{blockSize} \\times\n\\texttt{blockSize}\\f$ neighborhood of \\f$(x, y)\\f$ minus C"]
pub const cv_AdaptiveThresholdTypes_ADAPTIVE_THRESH_MEAN_C: cv_AdaptiveThresholdTypes = 0;
#[doc = " the threshold value \\f$T(x, y)\\f$ is a weighted sum (cross-correlation with a Gaussian\nwindow) of the \\f$\\texttt{blockSize} \\times \\texttt{blockSize}\\f$ neighborhood of \\f$(x, y)\\f$\nminus C . The default sigma (standard deviation) is used for the specified blockSize . See\n#getGaussianKernel"]
pub const cv_AdaptiveThresholdTypes_ADAPTIVE_THRESH_GAUSSIAN_C: cv_AdaptiveThresholdTypes = 1;
#[doc = "! adaptive threshold algorithm\n! @see adaptiveThreshold"]
pub type cv_AdaptiveThresholdTypes = ::std::os::raw::c_uint;
#[doc = "!< an obvious background pixels"]
pub const cv_GrabCutClasses_GC_BGD: cv_GrabCutClasses = 0;
#[doc = "!< an obvious foreground (object) pixel"]
pub const cv_GrabCutClasses_GC_FGD: cv_GrabCutClasses = 1;
#[doc = "!< a possible background pixel"]
pub const cv_GrabCutClasses_GC_PR_BGD: cv_GrabCutClasses = 2;
#[doc = "!< a possible foreground pixel"]
pub const cv_GrabCutClasses_GC_PR_FGD: cv_GrabCutClasses = 3;
#[doc = "! class of the pixel in GrabCut algorithm"]
pub type cv_GrabCutClasses = ::std::os::raw::c_uint;
#[doc = " The function initializes the state and the mask using the provided rectangle. After that it\nruns iterCount iterations of the algorithm."]
pub const cv_GrabCutModes_GC_INIT_WITH_RECT: cv_GrabCutModes = 0;
#[doc = " The function initializes the state using the provided mask. Note that GC_INIT_WITH_RECT\nand GC_INIT_WITH_MASK can be combined. Then, all the pixels outside of the ROI are\nautomatically initialized with GC_BGD ."]
pub const cv_GrabCutModes_GC_INIT_WITH_MASK: cv_GrabCutModes = 1;
#[doc = " The value means that the algorithm should just resume."]
pub const cv_GrabCutModes_GC_EVAL: cv_GrabCutModes = 2;
#[doc = " The value means that the algorithm should just run the grabCut algorithm (a single iteration) with the fixed model"]
pub const cv_GrabCutModes_GC_EVAL_FREEZE_MODEL: cv_GrabCutModes = 3;
#[doc = "! GrabCut algorithm flags"]
pub type cv_GrabCutModes = ::std::os::raw::c_uint;
#[doc = " each connected component of zeros in src (as well as all the non-zero pixels closest to the\nconnected component) will be assigned the same label"]
pub const cv_DistanceTransformLabelTypes_DIST_LABEL_CCOMP: cv_DistanceTransformLabelTypes = 0;
#[doc = " each zero pixel (and all the non-zero pixels closest to it) gets its own label."]
pub const cv_DistanceTransformLabelTypes_DIST_LABEL_PIXEL: cv_DistanceTransformLabelTypes = 1;
#[doc = "! distanceTransform algorithm flags"]
pub type cv_DistanceTransformLabelTypes = ::std::os::raw::c_uint;
#[doc = " If set, the difference between the current pixel and seed pixel is considered. Otherwise,\nthe difference between neighbor pixels is considered (that is, the range is floating)."]
pub const cv_FloodFillFlags_FLOODFILL_FIXED_RANGE: cv_FloodFillFlags = 65536;
#[doc = " If set, the function does not change the image ( newVal is ignored), and only fills the\nmask with the value specified in bits 8-16 of flags as described above. This option only make\nsense in function variants that have the mask parameter."]
pub const cv_FloodFillFlags_FLOODFILL_MASK_ONLY: cv_FloodFillFlags = 131072;
#[doc = "! floodfill algorithm flags"]
pub type cv_FloodFillFlags = ::std::os::raw::c_uint;
#[doc = "!< The leftmost (x) coordinate which is the inclusive start of the bounding\n!< box in the horizontal direction."]
pub const cv_ConnectedComponentsTypes_CC_STAT_LEFT: cv_ConnectedComponentsTypes = 0;
#[doc = "!< The topmost (y) coordinate which is the inclusive start of the bounding\n!< box in the vertical direction."]
pub const cv_ConnectedComponentsTypes_CC_STAT_TOP: cv_ConnectedComponentsTypes = 1;
#[doc = "!< The horizontal size of the bounding box"]
pub const cv_ConnectedComponentsTypes_CC_STAT_WIDTH: cv_ConnectedComponentsTypes = 2;
#[doc = "!< The vertical size of the bounding box"]
pub const cv_ConnectedComponentsTypes_CC_STAT_HEIGHT: cv_ConnectedComponentsTypes = 3;
#[doc = "!< The total area (in pixels) of the connected component"]
pub const cv_ConnectedComponentsTypes_CC_STAT_AREA: cv_ConnectedComponentsTypes = 4;
#[doc = "!< Max enumeration value. Used internally only for memory allocation"]
pub const cv_ConnectedComponentsTypes_CC_STAT_MAX: cv_ConnectedComponentsTypes = 5;
#[doc = "! connected components algorithm output formats"]
pub type cv_ConnectedComponentsTypes = ::std::os::raw::c_uint;
#[doc = "!< SAUF algorithm for 8-way connectivity, SAUF algorithm for 4-way connectivity"]
pub const cv_ConnectedComponentsAlgorithmsTypes_CCL_WU: cv_ConnectedComponentsAlgorithmsTypes = 0;
#[doc = "!< BBDT algorithm for 8-way connectivity, SAUF algorithm for 4-way connectivity"]
pub const cv_ConnectedComponentsAlgorithmsTypes_CCL_DEFAULT: cv_ConnectedComponentsAlgorithmsTypes =
    -1;
#[doc = "!< BBDT algorithm for 8-way connectivity, SAUF algorithm for 4-way connectivity"]
pub const cv_ConnectedComponentsAlgorithmsTypes_CCL_GRANA: cv_ConnectedComponentsAlgorithmsTypes =
    1;
#[doc = "! connected components algorithm"]
pub type cv_ConnectedComponentsAlgorithmsTypes = ::std::os::raw::c_int;
#[doc = " retrieves only the extreme outer contours. It sets `hierarchy[i][2]=hierarchy[i][3]=-1` for\nall the contours."]
pub const cv_RetrievalModes_RETR_EXTERNAL: cv_RetrievalModes = 0;
#[doc = " retrieves all of the contours without establishing any hierarchical relationships."]
pub const cv_RetrievalModes_RETR_LIST: cv_RetrievalModes = 1;
#[doc = " retrieves all of the contours and organizes them into a two-level hierarchy. At the top\nlevel, there are external boundaries of the components. At the second level, there are\nboundaries of the holes. If there is another contour inside a hole of a connected component, it\nis still put at the top level."]
pub const cv_RetrievalModes_RETR_CCOMP: cv_RetrievalModes = 2;
#[doc = " retrieves all of the contours and reconstructs a full hierarchy of nested contours."]
pub const cv_RetrievalModes_RETR_TREE: cv_RetrievalModes = 3;
#[doc = "!<"]
pub const cv_RetrievalModes_RETR_FLOODFILL: cv_RetrievalModes = 4;
#[doc = "! mode of the contour retrieval algorithm"]
pub type cv_RetrievalModes = ::std::os::raw::c_uint;
#[doc = " stores absolutely all the contour points. That is, any 2 subsequent points (x1,y1) and\n(x2,y2) of the contour will be either horizontal, vertical or diagonal neighbors, that is,\nmax(abs(x1-x2),abs(y2-y1))==1."]
pub const cv_ContourApproximationModes_CHAIN_APPROX_NONE: cv_ContourApproximationModes = 1;
#[doc = " compresses horizontal, vertical, and diagonal segments and leaves only their end points.\nFor example, an up-right rectangular contour is encoded with 4 points."]
pub const cv_ContourApproximationModes_CHAIN_APPROX_SIMPLE: cv_ContourApproximationModes = 2;
#[doc = " applies one of the flavors of the Teh-Chin chain approximation algorithm @cite TehChin89"]
pub const cv_ContourApproximationModes_CHAIN_APPROX_TC89_L1: cv_ContourApproximationModes = 3;
#[doc = " applies one of the flavors of the Teh-Chin chain approximation algorithm @cite TehChin89"]
pub const cv_ContourApproximationModes_CHAIN_APPROX_TC89_KCOS: cv_ContourApproximationModes = 4;
#[doc = "! the contour approximation algorithm"]
pub type cv_ContourApproximationModes = ::std::os::raw::c_uint;
#[doc = "!< \\f[I_1(A,B) =  \\sum _{i=1...7}  \\left |  \\frac{1}{m^A_i} -  \\frac{1}{m^B_i} \\right |\\f]"]
pub const cv_ShapeMatchModes_CONTOURS_MATCH_I1: cv_ShapeMatchModes = 1;
#[doc = "!< \\f[I_2(A,B) =  \\sum _{i=1...7}  \\left | m^A_i - m^B_i  \\right |\\f]"]
pub const cv_ShapeMatchModes_CONTOURS_MATCH_I2: cv_ShapeMatchModes = 2;
#[doc = "!< \\f[I_3(A,B) =  \\max _{i=1...7}  \\frac{ \\left| m^A_i - m^B_i \\right| }{ \\left| m^A_i \\right| }\\f]"]
pub const cv_ShapeMatchModes_CONTOURS_MATCH_I3: cv_ShapeMatchModes = 3;
#[doc = " @brief Shape matching methods\n\n\\f$A\\f$ denotes object1,\\f$B\\f$ denotes object2\n\n\\f$\\begin{array}{l} m^A_i =  \\mathrm{sign} (h^A_i)  \\cdot \\log{h^A_i} \\\\ m^B_i =  \\mathrm{sign} (h^B_i)  \\cdot \\log{h^B_i} \\end{array}\\f$\n\nand \\f$h^A_i, h^B_i\\f$ are the Hu moments of \\f$A\\f$ and \\f$B\\f$ , respectively."]
pub type cv_ShapeMatchModes = ::std::os::raw::c_uint;
#[doc = " classical or standard Hough transform. Every line is represented by two floating-point\nnumbers \\f$(\\rho, \\theta)\\f$ , where \\f$\\rho\\f$ is a distance between (0,0) point and the line,\nand \\f$\\theta\\f$ is the angle between x-axis and the normal to the line. Thus, the matrix must\nbe (the created sequence will be) of CV_32FC2 type"]
pub const cv_HoughModes_HOUGH_STANDARD: cv_HoughModes = 0;
#[doc = " probabilistic Hough transform (more efficient in case if the picture contains a few long\nlinear segments). It returns line segments rather than the whole line. Each segment is\nrepresented by starting and ending points, and the matrix must be (the created sequence will\nbe) of the CV_32SC4 type."]
pub const cv_HoughModes_HOUGH_PROBABILISTIC: cv_HoughModes = 1;
#[doc = " multi-scale variant of the classical Hough transform. The lines are encoded the same way as\nHOUGH_STANDARD."]
pub const cv_HoughModes_HOUGH_MULTI_SCALE: cv_HoughModes = 2;
#[doc = "!< basically *21HT*, described in @cite Yuen90"]
pub const cv_HoughModes_HOUGH_GRADIENT: cv_HoughModes = 3;
#[doc = "! Variants of a Hough transform"]
pub type cv_HoughModes = ::std::os::raw::c_uint;
#[doc = "!< No refinement applied"]
pub const cv_LineSegmentDetectorModes_LSD_REFINE_NONE: cv_LineSegmentDetectorModes = 0;
#[doc = "!< Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations."]
pub const cv_LineSegmentDetectorModes_LSD_REFINE_STD: cv_LineSegmentDetectorModes = 1;
#[doc = "!< Advanced refinement. Number of false alarms is calculated, lines are\n!< refined through increase of precision, decrement in size, etc."]
pub const cv_LineSegmentDetectorModes_LSD_REFINE_ADV: cv_LineSegmentDetectorModes = 2;
#[doc = "! Variants of Line Segment %Detector"]
pub type cv_LineSegmentDetectorModes = ::std::os::raw::c_uint;
#[doc = " Correlation\n\\f[d(H_1,H_2) =  \\frac{\\sum_I (H_1(I) - \\bar{H_1}) (H_2(I) - \\bar{H_2})}{\\sqrt{\\sum_I(H_1(I) - \\bar{H_1})^2 \\sum_I(H_2(I) - \\bar{H_2})^2}}\\f]\nwhere\n\\f[\\bar{H_k} =  \\frac{1}{N} \\sum _J H_k(J)\\f]\nand \\f$N\\f$ is a total number of histogram bins."]
pub const cv_HistCompMethods_HISTCMP_CORREL: cv_HistCompMethods = 0;
#[doc = " Chi-Square\n\\f[d(H_1,H_2) =  \\sum _I  \\frac{\\left(H_1(I)-H_2(I)\\right)^2}{H_1(I)}\\f]"]
pub const cv_HistCompMethods_HISTCMP_CHISQR: cv_HistCompMethods = 1;
#[doc = " Intersection\n\\f[d(H_1,H_2) =  \\sum _I  \\min (H_1(I), H_2(I))\\f]"]
pub const cv_HistCompMethods_HISTCMP_INTERSECT: cv_HistCompMethods = 2;
#[doc = " Bhattacharyya distance\n(In fact, OpenCV computes Hellinger distance, which is related to Bhattacharyya coefficient.)\n\\f[d(H_1,H_2) =  \\sqrt{1 - \\frac{1}{\\sqrt{\\bar{H_1} \\bar{H_2} N^2}} \\sum_I \\sqrt{H_1(I) \\cdot H_2(I)}}\\f]"]
pub const cv_HistCompMethods_HISTCMP_BHATTACHARYYA: cv_HistCompMethods = 3;
#[doc = "!< Synonym for HISTCMP_BHATTACHARYYA"]
pub const cv_HistCompMethods_HISTCMP_HELLINGER: cv_HistCompMethods = 3;
#[doc = " Alternative Chi-Square\n\\f[d(H_1,H_2) =  2 * \\sum _I  \\frac{\\left(H_1(I)-H_2(I)\\right)^2}{H_1(I)+H_2(I)}\\f]\nThis alternative formula is regularly used for texture comparison. See e.g. @cite Puzicha1997"]
pub const cv_HistCompMethods_HISTCMP_CHISQR_ALT: cv_HistCompMethods = 4;
#[doc = " Kullback-Leibler divergence\n\\f[d(H_1,H_2) = \\sum _I H_1(I) \\log \\left(\\frac{H_1(I)}{H_2(I)}\\right)\\f]"]
pub const cv_HistCompMethods_HISTCMP_KL_DIV: cv_HistCompMethods = 5;
#[doc = " Histogram comparison methods\n@ingroup imgproc_hist"]
pub type cv_HistCompMethods = ::std::os::raw::c_uint;
#[doc = "!< add alpha channel to RGB or BGR image"]
pub const cv_ColorConversionCodes_COLOR_BGR2BGRA: cv_ColorConversionCodes = 0;
pub const cv_ColorConversionCodes_COLOR_RGB2RGBA: cv_ColorConversionCodes = 0;
#[doc = "!< remove alpha channel from RGB or BGR image"]
pub const cv_ColorConversionCodes_COLOR_BGRA2BGR: cv_ColorConversionCodes = 1;
pub const cv_ColorConversionCodes_COLOR_RGBA2RGB: cv_ColorConversionCodes = 1;
#[doc = "!< convert between RGB and BGR color spaces (with or without alpha channel)"]
pub const cv_ColorConversionCodes_COLOR_BGR2RGBA: cv_ColorConversionCodes = 2;
pub const cv_ColorConversionCodes_COLOR_RGB2BGRA: cv_ColorConversionCodes = 2;
pub const cv_ColorConversionCodes_COLOR_RGBA2BGR: cv_ColorConversionCodes = 3;
pub const cv_ColorConversionCodes_COLOR_BGRA2RGB: cv_ColorConversionCodes = 3;
pub const cv_ColorConversionCodes_COLOR_BGR2RGB: cv_ColorConversionCodes = 4;
pub const cv_ColorConversionCodes_COLOR_RGB2BGR: cv_ColorConversionCodes = 4;
pub const cv_ColorConversionCodes_COLOR_BGRA2RGBA: cv_ColorConversionCodes = 5;
pub const cv_ColorConversionCodes_COLOR_RGBA2BGRA: cv_ColorConversionCodes = 5;
#[doc = "!< convert between RGB/BGR and grayscale, @ref color_convert_rgb_gray \"color conversions\""]
pub const cv_ColorConversionCodes_COLOR_BGR2GRAY: cv_ColorConversionCodes = 6;
pub const cv_ColorConversionCodes_COLOR_RGB2GRAY: cv_ColorConversionCodes = 7;
pub const cv_ColorConversionCodes_COLOR_GRAY2BGR: cv_ColorConversionCodes = 8;
pub const cv_ColorConversionCodes_COLOR_GRAY2RGB: cv_ColorConversionCodes = 8;
pub const cv_ColorConversionCodes_COLOR_GRAY2BGRA: cv_ColorConversionCodes = 9;
pub const cv_ColorConversionCodes_COLOR_GRAY2RGBA: cv_ColorConversionCodes = 9;
pub const cv_ColorConversionCodes_COLOR_BGRA2GRAY: cv_ColorConversionCodes = 10;
pub const cv_ColorConversionCodes_COLOR_RGBA2GRAY: cv_ColorConversionCodes = 11;
#[doc = "!< convert between RGB/BGR and BGR565 (16-bit images)"]
pub const cv_ColorConversionCodes_COLOR_BGR2BGR565: cv_ColorConversionCodes = 12;
pub const cv_ColorConversionCodes_COLOR_RGB2BGR565: cv_ColorConversionCodes = 13;
pub const cv_ColorConversionCodes_COLOR_BGR5652BGR: cv_ColorConversionCodes = 14;
pub const cv_ColorConversionCodes_COLOR_BGR5652RGB: cv_ColorConversionCodes = 15;
pub const cv_ColorConversionCodes_COLOR_BGRA2BGR565: cv_ColorConversionCodes = 16;
pub const cv_ColorConversionCodes_COLOR_RGBA2BGR565: cv_ColorConversionCodes = 17;
pub const cv_ColorConversionCodes_COLOR_BGR5652BGRA: cv_ColorConversionCodes = 18;
pub const cv_ColorConversionCodes_COLOR_BGR5652RGBA: cv_ColorConversionCodes = 19;
#[doc = "!< convert between grayscale to BGR565 (16-bit images)"]
pub const cv_ColorConversionCodes_COLOR_GRAY2BGR565: cv_ColorConversionCodes = 20;
pub const cv_ColorConversionCodes_COLOR_BGR5652GRAY: cv_ColorConversionCodes = 21;
#[doc = "!< convert between RGB/BGR and BGR555 (16-bit images)"]
pub const cv_ColorConversionCodes_COLOR_BGR2BGR555: cv_ColorConversionCodes = 22;
pub const cv_ColorConversionCodes_COLOR_RGB2BGR555: cv_ColorConversionCodes = 23;
pub const cv_ColorConversionCodes_COLOR_BGR5552BGR: cv_ColorConversionCodes = 24;
pub const cv_ColorConversionCodes_COLOR_BGR5552RGB: cv_ColorConversionCodes = 25;
pub const cv_ColorConversionCodes_COLOR_BGRA2BGR555: cv_ColorConversionCodes = 26;
pub const cv_ColorConversionCodes_COLOR_RGBA2BGR555: cv_ColorConversionCodes = 27;
pub const cv_ColorConversionCodes_COLOR_BGR5552BGRA: cv_ColorConversionCodes = 28;
pub const cv_ColorConversionCodes_COLOR_BGR5552RGBA: cv_ColorConversionCodes = 29;
#[doc = "!< convert between grayscale and BGR555 (16-bit images)"]
pub const cv_ColorConversionCodes_COLOR_GRAY2BGR555: cv_ColorConversionCodes = 30;
pub const cv_ColorConversionCodes_COLOR_BGR5552GRAY: cv_ColorConversionCodes = 31;
#[doc = "!< convert RGB/BGR to CIE XYZ, @ref color_convert_rgb_xyz \"color conversions\""]
pub const cv_ColorConversionCodes_COLOR_BGR2XYZ: cv_ColorConversionCodes = 32;
pub const cv_ColorConversionCodes_COLOR_RGB2XYZ: cv_ColorConversionCodes = 33;
pub const cv_ColorConversionCodes_COLOR_XYZ2BGR: cv_ColorConversionCodes = 34;
pub const cv_ColorConversionCodes_COLOR_XYZ2RGB: cv_ColorConversionCodes = 35;
#[doc = "!< convert RGB/BGR to luma-chroma (aka YCC), @ref color_convert_rgb_ycrcb \"color conversions\""]
pub const cv_ColorConversionCodes_COLOR_BGR2YCrCb: cv_ColorConversionCodes = 36;
pub const cv_ColorConversionCodes_COLOR_RGB2YCrCb: cv_ColorConversionCodes = 37;
pub const cv_ColorConversionCodes_COLOR_YCrCb2BGR: cv_ColorConversionCodes = 38;
pub const cv_ColorConversionCodes_COLOR_YCrCb2RGB: cv_ColorConversionCodes = 39;
#[doc = "!< convert RGB/BGR to HSV (hue saturation value), @ref color_convert_rgb_hsv \"color conversions\""]
pub const cv_ColorConversionCodes_COLOR_BGR2HSV: cv_ColorConversionCodes = 40;
pub const cv_ColorConversionCodes_COLOR_RGB2HSV: cv_ColorConversionCodes = 41;
#[doc = "!< convert RGB/BGR to CIE Lab, @ref color_convert_rgb_lab \"color conversions\""]
pub const cv_ColorConversionCodes_COLOR_BGR2Lab: cv_ColorConversionCodes = 44;
pub const cv_ColorConversionCodes_COLOR_RGB2Lab: cv_ColorConversionCodes = 45;
#[doc = "!< convert RGB/BGR to CIE Luv, @ref color_convert_rgb_luv \"color conversions\""]
pub const cv_ColorConversionCodes_COLOR_BGR2Luv: cv_ColorConversionCodes = 50;
pub const cv_ColorConversionCodes_COLOR_RGB2Luv: cv_ColorConversionCodes = 51;
#[doc = "!< convert RGB/BGR to HLS (hue lightness saturation), @ref color_convert_rgb_hls \"color conversions\""]
pub const cv_ColorConversionCodes_COLOR_BGR2HLS: cv_ColorConversionCodes = 52;
pub const cv_ColorConversionCodes_COLOR_RGB2HLS: cv_ColorConversionCodes = 53;
#[doc = "!< backward conversions to RGB/BGR"]
pub const cv_ColorConversionCodes_COLOR_HSV2BGR: cv_ColorConversionCodes = 54;
pub const cv_ColorConversionCodes_COLOR_HSV2RGB: cv_ColorConversionCodes = 55;
pub const cv_ColorConversionCodes_COLOR_Lab2BGR: cv_ColorConversionCodes = 56;
pub const cv_ColorConversionCodes_COLOR_Lab2RGB: cv_ColorConversionCodes = 57;
pub const cv_ColorConversionCodes_COLOR_Luv2BGR: cv_ColorConversionCodes = 58;
pub const cv_ColorConversionCodes_COLOR_Luv2RGB: cv_ColorConversionCodes = 59;
pub const cv_ColorConversionCodes_COLOR_HLS2BGR: cv_ColorConversionCodes = 60;
pub const cv_ColorConversionCodes_COLOR_HLS2RGB: cv_ColorConversionCodes = 61;
pub const cv_ColorConversionCodes_COLOR_BGR2HSV_FULL: cv_ColorConversionCodes = 66;
pub const cv_ColorConversionCodes_COLOR_RGB2HSV_FULL: cv_ColorConversionCodes = 67;
pub const cv_ColorConversionCodes_COLOR_BGR2HLS_FULL: cv_ColorConversionCodes = 68;
pub const cv_ColorConversionCodes_COLOR_RGB2HLS_FULL: cv_ColorConversionCodes = 69;
pub const cv_ColorConversionCodes_COLOR_HSV2BGR_FULL: cv_ColorConversionCodes = 70;
pub const cv_ColorConversionCodes_COLOR_HSV2RGB_FULL: cv_ColorConversionCodes = 71;
pub const cv_ColorConversionCodes_COLOR_HLS2BGR_FULL: cv_ColorConversionCodes = 72;
pub const cv_ColorConversionCodes_COLOR_HLS2RGB_FULL: cv_ColorConversionCodes = 73;
pub const cv_ColorConversionCodes_COLOR_LBGR2Lab: cv_ColorConversionCodes = 74;
pub const cv_ColorConversionCodes_COLOR_LRGB2Lab: cv_ColorConversionCodes = 75;
pub const cv_ColorConversionCodes_COLOR_LBGR2Luv: cv_ColorConversionCodes = 76;
pub const cv_ColorConversionCodes_COLOR_LRGB2Luv: cv_ColorConversionCodes = 77;
pub const cv_ColorConversionCodes_COLOR_Lab2LBGR: cv_ColorConversionCodes = 78;
pub const cv_ColorConversionCodes_COLOR_Lab2LRGB: cv_ColorConversionCodes = 79;
pub const cv_ColorConversionCodes_COLOR_Luv2LBGR: cv_ColorConversionCodes = 80;
pub const cv_ColorConversionCodes_COLOR_Luv2LRGB: cv_ColorConversionCodes = 81;
#[doc = "!< convert between RGB/BGR and YUV"]
pub const cv_ColorConversionCodes_COLOR_BGR2YUV: cv_ColorConversionCodes = 82;
pub const cv_ColorConversionCodes_COLOR_RGB2YUV: cv_ColorConversionCodes = 83;
pub const cv_ColorConversionCodes_COLOR_YUV2BGR: cv_ColorConversionCodes = 84;
pub const cv_ColorConversionCodes_COLOR_YUV2RGB: cv_ColorConversionCodes = 85;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGB_NV12: cv_ColorConversionCodes = 90;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGR_NV12: cv_ColorConversionCodes = 91;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGB_NV21: cv_ColorConversionCodes = 92;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGR_NV21: cv_ColorConversionCodes = 93;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV420sp2RGB: cv_ColorConversionCodes = 92;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV420sp2BGR: cv_ColorConversionCodes = 93;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGBA_NV12: cv_ColorConversionCodes = 94;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGRA_NV12: cv_ColorConversionCodes = 95;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGBA_NV21: cv_ColorConversionCodes = 96;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGRA_NV21: cv_ColorConversionCodes = 97;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV420sp2RGBA: cv_ColorConversionCodes = 96;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV420sp2BGRA: cv_ColorConversionCodes = 97;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGB_YV12: cv_ColorConversionCodes = 98;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGR_YV12: cv_ColorConversionCodes = 99;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGB_IYUV: cv_ColorConversionCodes = 100;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGR_IYUV: cv_ColorConversionCodes = 101;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGB_I420: cv_ColorConversionCodes = 100;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGR_I420: cv_ColorConversionCodes = 101;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV420p2RGB: cv_ColorConversionCodes = 98;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV420p2BGR: cv_ColorConversionCodes = 99;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGBA_YV12: cv_ColorConversionCodes = 102;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGRA_YV12: cv_ColorConversionCodes = 103;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGBA_IYUV: cv_ColorConversionCodes = 104;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGRA_IYUV: cv_ColorConversionCodes = 105;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGBA_I420: cv_ColorConversionCodes = 104;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGRA_I420: cv_ColorConversionCodes = 105;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV420p2RGBA: cv_ColorConversionCodes = 102;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV420p2BGRA: cv_ColorConversionCodes = 103;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2GRAY_420: cv_ColorConversionCodes = 106;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2GRAY_NV21: cv_ColorConversionCodes = 106;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2GRAY_NV12: cv_ColorConversionCodes = 106;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2GRAY_YV12: cv_ColorConversionCodes = 106;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2GRAY_IYUV: cv_ColorConversionCodes = 106;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2GRAY_I420: cv_ColorConversionCodes = 106;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV420sp2GRAY: cv_ColorConversionCodes = 106;
#[doc = "! YUV 4:2:0 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV420p2GRAY: cv_ColorConversionCodes = 106;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGB_UYVY: cv_ColorConversionCodes = 107;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGR_UYVY: cv_ColorConversionCodes = 108;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGB_Y422: cv_ColorConversionCodes = 107;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGR_Y422: cv_ColorConversionCodes = 108;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGB_UYNV: cv_ColorConversionCodes = 107;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGR_UYNV: cv_ColorConversionCodes = 108;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGBA_UYVY: cv_ColorConversionCodes = 111;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGRA_UYVY: cv_ColorConversionCodes = 112;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGBA_Y422: cv_ColorConversionCodes = 111;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGRA_Y422: cv_ColorConversionCodes = 112;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGBA_UYNV: cv_ColorConversionCodes = 111;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGRA_UYNV: cv_ColorConversionCodes = 112;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGB_YUY2: cv_ColorConversionCodes = 115;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGR_YUY2: cv_ColorConversionCodes = 116;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGB_YVYU: cv_ColorConversionCodes = 117;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGR_YVYU: cv_ColorConversionCodes = 118;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGB_YUYV: cv_ColorConversionCodes = 115;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGR_YUYV: cv_ColorConversionCodes = 116;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGB_YUNV: cv_ColorConversionCodes = 115;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGR_YUNV: cv_ColorConversionCodes = 116;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGBA_YUY2: cv_ColorConversionCodes = 119;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGRA_YUY2: cv_ColorConversionCodes = 120;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGBA_YVYU: cv_ColorConversionCodes = 121;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGRA_YVYU: cv_ColorConversionCodes = 122;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGBA_YUYV: cv_ColorConversionCodes = 119;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGRA_YUYV: cv_ColorConversionCodes = 120;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2RGBA_YUNV: cv_ColorConversionCodes = 119;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2BGRA_YUNV: cv_ColorConversionCodes = 120;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2GRAY_UYVY: cv_ColorConversionCodes = 123;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2GRAY_YUY2: cv_ColorConversionCodes = 124;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2GRAY_Y422: cv_ColorConversionCodes = 123;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2GRAY_UYNV: cv_ColorConversionCodes = 123;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2GRAY_YVYU: cv_ColorConversionCodes = 124;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2GRAY_YUYV: cv_ColorConversionCodes = 124;
#[doc = "! YUV 4:2:2 family to RGB"]
pub const cv_ColorConversionCodes_COLOR_YUV2GRAY_YUNV: cv_ColorConversionCodes = 124;
#[doc = "! alpha premultiplication"]
pub const cv_ColorConversionCodes_COLOR_RGBA2mRGBA: cv_ColorConversionCodes = 125;
#[doc = "! alpha premultiplication"]
pub const cv_ColorConversionCodes_COLOR_mRGBA2RGBA: cv_ColorConversionCodes = 126;
#[doc = "! RGB to YUV 4:2:0 family"]
pub const cv_ColorConversionCodes_COLOR_RGB2YUV_I420: cv_ColorConversionCodes = 127;
#[doc = "! RGB to YUV 4:2:0 family"]
pub const cv_ColorConversionCodes_COLOR_BGR2YUV_I420: cv_ColorConversionCodes = 128;
#[doc = "! RGB to YUV 4:2:0 family"]
pub const cv_ColorConversionCodes_COLOR_RGB2YUV_IYUV: cv_ColorConversionCodes = 127;
#[doc = "! RGB to YUV 4:2:0 family"]
pub const cv_ColorConversionCodes_COLOR_BGR2YUV_IYUV: cv_ColorConversionCodes = 128;
#[doc = "! RGB to YUV 4:2:0 family"]
pub const cv_ColorConversionCodes_COLOR_RGBA2YUV_I420: cv_ColorConversionCodes = 129;
#[doc = "! RGB to YUV 4:2:0 family"]
pub const cv_ColorConversionCodes_COLOR_BGRA2YUV_I420: cv_ColorConversionCodes = 130;
#[doc = "! RGB to YUV 4:2:0 family"]
pub const cv_ColorConversionCodes_COLOR_RGBA2YUV_IYUV: cv_ColorConversionCodes = 129;
#[doc = "! RGB to YUV 4:2:0 family"]
pub const cv_ColorConversionCodes_COLOR_BGRA2YUV_IYUV: cv_ColorConversionCodes = 130;
#[doc = "! RGB to YUV 4:2:0 family"]
pub const cv_ColorConversionCodes_COLOR_RGB2YUV_YV12: cv_ColorConversionCodes = 131;
#[doc = "! RGB to YUV 4:2:0 family"]
pub const cv_ColorConversionCodes_COLOR_BGR2YUV_YV12: cv_ColorConversionCodes = 132;
#[doc = "! RGB to YUV 4:2:0 family"]
pub const cv_ColorConversionCodes_COLOR_RGBA2YUV_YV12: cv_ColorConversionCodes = 133;
#[doc = "! RGB to YUV 4:2:0 family"]
pub const cv_ColorConversionCodes_COLOR_BGRA2YUV_YV12: cv_ColorConversionCodes = 134;
#[doc = "! Demosaicing"]
pub const cv_ColorConversionCodes_COLOR_BayerBG2BGR: cv_ColorConversionCodes = 46;
#[doc = "! Demosaicing"]
pub const cv_ColorConversionCodes_COLOR_BayerGB2BGR: cv_ColorConversionCodes = 47;
#[doc = "! Demosaicing"]
pub const cv_ColorConversionCodes_COLOR_BayerRG2BGR: cv_ColorConversionCodes = 48;
#[doc = "! Demosaicing"]
pub const cv_ColorConversionCodes_COLOR_BayerGR2BGR: cv_ColorConversionCodes = 49;
#[doc = "! Demosaicing"]
pub const cv_ColorConversionCodes_COLOR_BayerBG2RGB: cv_ColorConversionCodes = 48;
#[doc = "! Demosaicing"]
pub const cv_ColorConversionCodes_COLOR_BayerGB2RGB: cv_ColorConversionCodes = 49;
#[doc = "! Demosaicing"]
pub const cv_ColorConversionCodes_COLOR_BayerRG2RGB: cv_ColorConversionCodes = 46;
#[doc = "! Demosaicing"]
pub const cv_ColorConversionCodes_COLOR_BayerGR2RGB: cv_ColorConversionCodes = 47;
#[doc = "! Demosaicing"]
pub const cv_ColorConversionCodes_COLOR_BayerBG2GRAY: cv_ColorConversionCodes = 86;
#[doc = "! Demosaicing"]
pub const cv_ColorConversionCodes_COLOR_BayerGB2GRAY: cv_ColorConversionCodes = 87;
#[doc = "! Demosaicing"]
pub const cv_ColorConversionCodes_COLOR_BayerRG2GRAY: cv_ColorConversionCodes = 88;
#[doc = "! Demosaicing"]
pub const cv_ColorConversionCodes_COLOR_BayerGR2GRAY: cv_ColorConversionCodes = 89;
#[doc = "! Demosaicing using Variable Number of Gradients"]
pub const cv_ColorConversionCodes_COLOR_BayerBG2BGR_VNG: cv_ColorConversionCodes = 62;
#[doc = "! Demosaicing using Variable Number of Gradients"]
pub const cv_ColorConversionCodes_COLOR_BayerGB2BGR_VNG: cv_ColorConversionCodes = 63;
#[doc = "! Demosaicing using Variable Number of Gradients"]
pub const cv_ColorConversionCodes_COLOR_BayerRG2BGR_VNG: cv_ColorConversionCodes = 64;
#[doc = "! Demosaicing using Variable Number of Gradients"]
pub const cv_ColorConversionCodes_COLOR_BayerGR2BGR_VNG: cv_ColorConversionCodes = 65;
#[doc = "! Demosaicing using Variable Number of Gradients"]
pub const cv_ColorConversionCodes_COLOR_BayerBG2RGB_VNG: cv_ColorConversionCodes = 64;
#[doc = "! Demosaicing using Variable Number of Gradients"]
pub const cv_ColorConversionCodes_COLOR_BayerGB2RGB_VNG: cv_ColorConversionCodes = 65;
#[doc = "! Demosaicing using Variable Number of Gradients"]
pub const cv_ColorConversionCodes_COLOR_BayerRG2RGB_VNG: cv_ColorConversionCodes = 62;
#[doc = "! Demosaicing using Variable Number of Gradients"]
pub const cv_ColorConversionCodes_COLOR_BayerGR2RGB_VNG: cv_ColorConversionCodes = 63;
#[doc = "! Edge-Aware Demosaicing"]
pub const cv_ColorConversionCodes_COLOR_BayerBG2BGR_EA: cv_ColorConversionCodes = 135;
#[doc = "! Edge-Aware Demosaicing"]
pub const cv_ColorConversionCodes_COLOR_BayerGB2BGR_EA: cv_ColorConversionCodes = 136;
#[doc = "! Edge-Aware Demosaicing"]
pub const cv_ColorConversionCodes_COLOR_BayerRG2BGR_EA: cv_ColorConversionCodes = 137;
#[doc = "! Edge-Aware Demosaicing"]
pub const cv_ColorConversionCodes_COLOR_BayerGR2BGR_EA: cv_ColorConversionCodes = 138;
#[doc = "! Edge-Aware Demosaicing"]
pub const cv_ColorConversionCodes_COLOR_BayerBG2RGB_EA: cv_ColorConversionCodes = 137;
#[doc = "! Edge-Aware Demosaicing"]
pub const cv_ColorConversionCodes_COLOR_BayerGB2RGB_EA: cv_ColorConversionCodes = 138;
#[doc = "! Edge-Aware Demosaicing"]
pub const cv_ColorConversionCodes_COLOR_BayerRG2RGB_EA: cv_ColorConversionCodes = 135;
#[doc = "! Edge-Aware Demosaicing"]
pub const cv_ColorConversionCodes_COLOR_BayerGR2RGB_EA: cv_ColorConversionCodes = 136;
#[doc = "! Demosaicing with alpha channel"]
pub const cv_ColorConversionCodes_COLOR_BayerBG2BGRA: cv_ColorConversionCodes = 139;
#[doc = "! Demosaicing with alpha channel"]
pub const cv_ColorConversionCodes_COLOR_BayerGB2BGRA: cv_ColorConversionCodes = 140;
#[doc = "! Demosaicing with alpha channel"]
pub const cv_ColorConversionCodes_COLOR_BayerRG2BGRA: cv_ColorConversionCodes = 141;
#[doc = "! Demosaicing with alpha channel"]
pub const cv_ColorConversionCodes_COLOR_BayerGR2BGRA: cv_ColorConversionCodes = 142;
#[doc = "! Demosaicing with alpha channel"]
pub const cv_ColorConversionCodes_COLOR_BayerBG2RGBA: cv_ColorConversionCodes = 141;
#[doc = "! Demosaicing with alpha channel"]
pub const cv_ColorConversionCodes_COLOR_BayerGB2RGBA: cv_ColorConversionCodes = 142;
#[doc = "! Demosaicing with alpha channel"]
pub const cv_ColorConversionCodes_COLOR_BayerRG2RGBA: cv_ColorConversionCodes = 139;
#[doc = "! Demosaicing with alpha channel"]
pub const cv_ColorConversionCodes_COLOR_BayerGR2RGBA: cv_ColorConversionCodes = 140;
#[doc = "! Demosaicing with alpha channel"]
pub const cv_ColorConversionCodes_COLOR_COLORCVT_MAX: cv_ColorConversionCodes = 143;
#[doc = " the color conversion codes\n@see @ref imgproc_color_conversions\n@ingroup imgproc_color_conversions"]
pub type cv_ColorConversionCodes = ::std::os::raw::c_uint;
#[doc = "!< No intersection"]
pub const cv_RectanglesIntersectTypes_INTERSECT_NONE: cv_RectanglesIntersectTypes = 0;
#[doc = "!< There is a partial intersection"]
pub const cv_RectanglesIntersectTypes_INTERSECT_PARTIAL: cv_RectanglesIntersectTypes = 1;
#[doc = "!< One of the rectangle is fully enclosed in the other"]
pub const cv_RectanglesIntersectTypes_INTERSECT_FULL: cv_RectanglesIntersectTypes = 2;
#[doc = "! types of intersection between rectangles"]
pub type cv_RectanglesIntersectTypes = ::std::os::raw::c_uint;
pub const cv_LineTypes_FILLED: cv_LineTypes = -1;
#[doc = "!< 4-connected line"]
pub const cv_LineTypes_LINE_4: cv_LineTypes = 4;
#[doc = "!< 8-connected line"]
pub const cv_LineTypes_LINE_8: cv_LineTypes = 8;
#[doc = "!< antialiased line"]
pub const cv_LineTypes_LINE_AA: cv_LineTypes = 16;
#[doc = " types of line\n@ingroup imgproc_draw"]
pub type cv_LineTypes = ::std::os::raw::c_int;
#[doc = "!< normal size sans-serif font"]
pub const cv_HersheyFonts_FONT_HERSHEY_SIMPLEX: cv_HersheyFonts = 0;
#[doc = "!< small size sans-serif font"]
pub const cv_HersheyFonts_FONT_HERSHEY_PLAIN: cv_HersheyFonts = 1;
#[doc = "!< normal size sans-serif font (more complex than FONT_HERSHEY_SIMPLEX)"]
pub const cv_HersheyFonts_FONT_HERSHEY_DUPLEX: cv_HersheyFonts = 2;
#[doc = "!< normal size serif font"]
pub const cv_HersheyFonts_FONT_HERSHEY_COMPLEX: cv_HersheyFonts = 3;
#[doc = "!< normal size serif font (more complex than FONT_HERSHEY_COMPLEX)"]
pub const cv_HersheyFonts_FONT_HERSHEY_TRIPLEX: cv_HersheyFonts = 4;
#[doc = "!< smaller version of FONT_HERSHEY_COMPLEX"]
pub const cv_HersheyFonts_FONT_HERSHEY_COMPLEX_SMALL: cv_HersheyFonts = 5;
#[doc = "!< hand-writing style font"]
pub const cv_HersheyFonts_FONT_HERSHEY_SCRIPT_SIMPLEX: cv_HersheyFonts = 6;
#[doc = "!< more complex variant of FONT_HERSHEY_SCRIPT_SIMPLEX"]
pub const cv_HersheyFonts_FONT_HERSHEY_SCRIPT_COMPLEX: cv_HersheyFonts = 7;
#[doc = "!< flag for italic font"]
pub const cv_HersheyFonts_FONT_ITALIC: cv_HersheyFonts = 16;
#[doc = " Only a subset of Hershey fonts <https://en.wikipedia.org/wiki/Hershey_fonts> are supported\n@ingroup imgproc_draw"]
pub type cv_HersheyFonts = ::std::os::raw::c_uint;
#[doc = "!< A crosshair marker shape"]
pub const cv_MarkerTypes_MARKER_CROSS: cv_MarkerTypes = 0;
#[doc = "!< A 45 degree tilted crosshair marker shape"]
pub const cv_MarkerTypes_MARKER_TILTED_CROSS: cv_MarkerTypes = 1;
#[doc = "!< A star marker shape, combination of cross and tilted cross"]
pub const cv_MarkerTypes_MARKER_STAR: cv_MarkerTypes = 2;
#[doc = "!< A diamond marker shape"]
pub const cv_MarkerTypes_MARKER_DIAMOND: cv_MarkerTypes = 3;
#[doc = "!< A square marker shape"]
pub const cv_MarkerTypes_MARKER_SQUARE: cv_MarkerTypes = 4;
#[doc = "!< An upwards pointing triangle marker shape"]
pub const cv_MarkerTypes_MARKER_TRIANGLE_UP: cv_MarkerTypes = 5;
#[doc = "!< A downwards pointing triangle marker shape"]
pub const cv_MarkerTypes_MARKER_TRIANGLE_DOWN: cv_MarkerTypes = 6;
#[doc = " Possible set of marker types used for the cv::drawMarker function\n@ingroup imgproc_draw"]
pub type cv_MarkerTypes = ::std::os::raw::c_uint;
#[doc = " @brief finds arbitrary template in the grayscale image using Generalized Hough Transform"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_GeneralizedHough {
    pub _base: cv_Algorithm,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_GeneralizedHough"][::std::mem::size_of::<cv_GeneralizedHough>() - 8usize];
    ["Alignment of cv_GeneralizedHough"][::std::mem::align_of::<cv_GeneralizedHough>() - 8usize];
};
#[doc = " @brief finds arbitrary template in the grayscale image using Generalized Hough Transform\n\nDetects position only without translation and rotation @cite Ballard1981 ."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_GeneralizedHoughBallard {
    pub _base: cv_GeneralizedHough,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_GeneralizedHoughBallard"]
        [::std::mem::size_of::<cv_GeneralizedHoughBallard>() - 8usize];
    ["Alignment of cv_GeneralizedHoughBallard"]
        [::std::mem::align_of::<cv_GeneralizedHoughBallard>() - 8usize];
};
#[doc = " @brief finds arbitrary template in the grayscale image using Generalized Hough Transform\n\nDetects position, translation and rotation @cite Guil1999 ."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_GeneralizedHoughGuil {
    pub _base: cv_GeneralizedHough,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_GeneralizedHoughGuil"][::std::mem::size_of::<cv_GeneralizedHoughGuil>() - 8usize];
    ["Alignment of cv_GeneralizedHoughGuil"]
        [::std::mem::align_of::<cv_GeneralizedHoughGuil>() - 8usize];
};
#[doc = " @brief Base class for Contrast Limited Adaptive Histogram Equalization."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_CLAHE {
    pub _base: cv_Algorithm,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_CLAHE"][::std::mem::size_of::<cv_CLAHE>() - 8usize];
    ["Alignment of cv_CLAHE"][::std::mem::align_of::<cv_CLAHE>() - 8usize];
};
#[doc = "! @addtogroup imgproc_subdiv2d\n! @{"]
#[repr(C)]
pub struct cv_Subdiv2D {
    #[doc = "! All of the vertices"]
    pub vtx: std_vector,
    #[doc = "! All of the edges"]
    pub qedges: std_vector,
    pub freeQEdge: ::std::os::raw::c_int,
    pub freePoint: ::std::os::raw::c_int,
    pub validGeometry: bool,
    pub recentEdge: ::std::os::raw::c_int,
    #[doc = "! Top left corner of the bounding rect"]
    pub topLeft: cv_Point2f,
    #[doc = "! Bottom right corner of the bounding rect"]
    pub bottomRight: cv_Point2f,
}
#[doc = "!< Point location error"]
pub const cv_Subdiv2D_PTLOC_ERROR: cv_Subdiv2D__bindgen_ty_1 = -2;
#[doc = "!< Point outside the subdivision bounding rect"]
pub const cv_Subdiv2D_PTLOC_OUTSIDE_RECT: cv_Subdiv2D__bindgen_ty_1 = -1;
#[doc = "!< Point inside some facet"]
pub const cv_Subdiv2D_PTLOC_INSIDE: cv_Subdiv2D__bindgen_ty_1 = 0;
#[doc = "!< Point coincides with one of the subdivision vertices"]
pub const cv_Subdiv2D_PTLOC_VERTEX: cv_Subdiv2D__bindgen_ty_1 = 1;
#[doc = "!< Point on some edge"]
pub const cv_Subdiv2D_PTLOC_ON_EDGE: cv_Subdiv2D__bindgen_ty_1 = 2;
#[doc = " Subdiv2D point location cases"]
pub type cv_Subdiv2D__bindgen_ty_1 = ::std::os::raw::c_int;
pub const cv_Subdiv2D_NEXT_AROUND_ORG: cv_Subdiv2D__bindgen_ty_2 = 0;
pub const cv_Subdiv2D_NEXT_AROUND_DST: cv_Subdiv2D__bindgen_ty_2 = 34;
pub const cv_Subdiv2D_PREV_AROUND_ORG: cv_Subdiv2D__bindgen_ty_2 = 17;
pub const cv_Subdiv2D_PREV_AROUND_DST: cv_Subdiv2D__bindgen_ty_2 = 51;
pub const cv_Subdiv2D_NEXT_AROUND_LEFT: cv_Subdiv2D__bindgen_ty_2 = 19;
pub const cv_Subdiv2D_NEXT_AROUND_RIGHT: cv_Subdiv2D__bindgen_ty_2 = 49;
pub const cv_Subdiv2D_PREV_AROUND_LEFT: cv_Subdiv2D__bindgen_ty_2 = 32;
pub const cv_Subdiv2D_PREV_AROUND_RIGHT: cv_Subdiv2D__bindgen_ty_2 = 2;
#[doc = " Subdiv2D edge type navigation (see: getEdge())"]
pub type cv_Subdiv2D__bindgen_ty_2 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_Subdiv2D_Vertex {
    pub firstEdge: ::std::os::raw::c_int,
    pub type_: ::std::os::raw::c_int,
    pub pt: cv_Point2f,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_Subdiv2D_Vertex"][::std::mem::size_of::<cv_Subdiv2D_Vertex>() - 16usize];
    ["Alignment of cv_Subdiv2D_Vertex"][::std::mem::align_of::<cv_Subdiv2D_Vertex>() - 4usize];
    ["Offset of field: cv_Subdiv2D_Vertex::firstEdge"]
        [::std::mem::offset_of!(cv_Subdiv2D_Vertex, firstEdge) - 0usize];
    ["Offset of field: cv_Subdiv2D_Vertex::type_"]
        [::std::mem::offset_of!(cv_Subdiv2D_Vertex, type_) - 4usize];
    ["Offset of field: cv_Subdiv2D_Vertex::pt"]
        [::std::mem::offset_of!(cv_Subdiv2D_Vertex, pt) - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv8Subdiv2D6Vertex9isvirtualEv"]
    pub fn cv_Subdiv2D_Vertex_isvirtual(this: *const cv_Subdiv2D_Vertex) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv8Subdiv2D6Vertex6isfreeEv"]
    pub fn cv_Subdiv2D_Vertex_isfree(this: *const cv_Subdiv2D_Vertex) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8Subdiv2D6VertexC1Ev"]
    pub fn cv_Subdiv2D_Vertex_Vertex(this: *mut cv_Subdiv2D_Vertex);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8Subdiv2D6VertexC1ENS_6Point_IfEEbi"]
    pub fn cv_Subdiv2D_Vertex_Vertex1(
        this: *mut cv_Subdiv2D_Vertex,
        pt: cv_Point2f,
        _isvirtual: bool,
        _firstEdge: ::std::os::raw::c_int,
    );
}
impl cv_Subdiv2D_Vertex {
    #[inline]
    pub unsafe fn isvirtual(&self) -> bool {
        cv_Subdiv2D_Vertex_isvirtual(self)
    }
    #[inline]
    pub unsafe fn isfree(&self) -> bool {
        cv_Subdiv2D_Vertex_isfree(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_Subdiv2D_Vertex_Vertex(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        pt: cv_Point2f,
        _isvirtual: bool,
        _firstEdge: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_Subdiv2D_Vertex_Vertex1(__bindgen_tmp.as_mut_ptr(), pt, _isvirtual, _firstEdge);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_Subdiv2D_QuadEdge {
    pub next: [::std::os::raw::c_int; 4usize],
    pub pt: [::std::os::raw::c_int; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_Subdiv2D_QuadEdge"][::std::mem::size_of::<cv_Subdiv2D_QuadEdge>() - 32usize];
    ["Alignment of cv_Subdiv2D_QuadEdge"][::std::mem::align_of::<cv_Subdiv2D_QuadEdge>() - 4usize];
    ["Offset of field: cv_Subdiv2D_QuadEdge::next"]
        [::std::mem::offset_of!(cv_Subdiv2D_QuadEdge, next) - 0usize];
    ["Offset of field: cv_Subdiv2D_QuadEdge::pt"]
        [::std::mem::offset_of!(cv_Subdiv2D_QuadEdge, pt) - 16usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv8Subdiv2D8QuadEdge6isfreeEv"]
    pub fn cv_Subdiv2D_QuadEdge_isfree(this: *const cv_Subdiv2D_QuadEdge) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8Subdiv2D8QuadEdgeC1Ev"]
    pub fn cv_Subdiv2D_QuadEdge_QuadEdge(this: *mut cv_Subdiv2D_QuadEdge);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8Subdiv2D8QuadEdgeC1Ei"]
    pub fn cv_Subdiv2D_QuadEdge_QuadEdge1(
        this: *mut cv_Subdiv2D_QuadEdge,
        edgeidx: ::std::os::raw::c_int,
    );
}
impl cv_Subdiv2D_QuadEdge {
    #[inline]
    pub unsafe fn isfree(&self) -> bool {
        cv_Subdiv2D_QuadEdge_isfree(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_Subdiv2D_QuadEdge_QuadEdge(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(edgeidx: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_Subdiv2D_QuadEdge_QuadEdge1(__bindgen_tmp.as_mut_ptr(), edgeidx);
        __bindgen_tmp.assume_init()
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_Subdiv2D"][::std::mem::size_of::<cv_Subdiv2D>() - 80usize];
    ["Alignment of cv_Subdiv2D"][::std::mem::align_of::<cv_Subdiv2D>() - 8usize];
    ["Offset of field: cv_Subdiv2D::vtx"][::std::mem::offset_of!(cv_Subdiv2D, vtx) - 0usize];
    ["Offset of field: cv_Subdiv2D::qedges"][::std::mem::offset_of!(cv_Subdiv2D, qedges) - 24usize];
    ["Offset of field: cv_Subdiv2D::freeQEdge"]
        [::std::mem::offset_of!(cv_Subdiv2D, freeQEdge) - 48usize];
    ["Offset of field: cv_Subdiv2D::freePoint"]
        [::std::mem::offset_of!(cv_Subdiv2D, freePoint) - 52usize];
    ["Offset of field: cv_Subdiv2D::validGeometry"]
        [::std::mem::offset_of!(cv_Subdiv2D, validGeometry) - 56usize];
    ["Offset of field: cv_Subdiv2D::recentEdge"]
        [::std::mem::offset_of!(cv_Subdiv2D, recentEdge) - 60usize];
    ["Offset of field: cv_Subdiv2D::topLeft"]
        [::std::mem::offset_of!(cv_Subdiv2D, topLeft) - 64usize];
    ["Offset of field: cv_Subdiv2D::bottomRight"]
        [::std::mem::offset_of!(cv_Subdiv2D, bottomRight) - 72usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates a new empty Delaunay subdivision\n\n@param rect Rectangle that includes all of the 2D points that are to be added to the subdivision.\n"]
    #[link_name = "\u{1}_ZN2cv8Subdiv2D12initDelaunayENS_5Rect_IiEE"]
    pub fn cv_Subdiv2D_initDelaunay(this: *mut cv_Subdiv2D, rect: cv_Rect);
}
unsafe extern "C" {
    #[doc = " @brief Insert a single point into a Delaunay triangulation.\n\n@param pt Point to insert.\n\nThe function inserts a single point into a subdivision and modifies the subdivision topology\nappropriately. If a point with the same coordinates exists already, no new point is added.\n@returns the ID of the point.\n\n@note If the point is outside of the triangulation specified rect a runtime error is raised."]
    #[link_name = "\u{1}_ZN2cv8Subdiv2D6insertENS_6Point_IfEE"]
    pub fn cv_Subdiv2D_insert(this: *mut cv_Subdiv2D, pt: cv_Point2f) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Insert multiple points into a Delaunay triangulation.\n\n@param ptvec Points to insert.\n\nThe function inserts a vector of points into a subdivision and modifies the subdivision topology\nappropriately."]
    #[link_name = "\u{1}_ZN2cv8Subdiv2D6insertERKSt6vectorINS_6Point_IfEESaIS3_EE"]
    pub fn cv_Subdiv2D_insert1(this: *mut cv_Subdiv2D, ptvec: *const std_vector);
}
unsafe extern "C" {
    #[doc = " @brief Returns the location of a point within a Delaunay triangulation.\n\n@param pt Point to locate.\n@param edge Output edge that the point belongs to or is located to the right of it.\n@param vertex Optional output vertex the input point coincides with.\n\nThe function locates the input point within the subdivision and gives one of the triangle edges\nor vertices.\n\n@returns an integer which specify one of the following five cases for point location:\n-  The point falls into some facet. The function returns #PTLOC_INSIDE and edge will contain one of\nedges of the facet.\n-  The point falls onto the edge. The function returns #PTLOC_ON_EDGE and edge will contain this edge.\n-  The point coincides with one of the subdivision vertices. The function returns #PTLOC_VERTEX and\nvertex will contain a pointer to the vertex.\n-  The point is outside the subdivision reference rectangle. The function returns #PTLOC_OUTSIDE_RECT\nand no pointers are filled.\n-  One of input arguments is invalid. A runtime error is raised or, if silent or \"parent\" error\nprocessing mode is selected, #PTLOC_ERROR is returned."]
    #[link_name = "\u{1}_ZN2cv8Subdiv2D6locateENS_6Point_IfEERiS3_"]
    pub fn cv_Subdiv2D_locate(
        this: *mut cv_Subdiv2D,
        pt: cv_Point2f,
        edge: *mut ::std::os::raw::c_int,
        vertex: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Finds the subdivision vertex closest to the given point.\n\n@param pt Input point.\n@param nearestPt Output subdivision vertex point.\n\nThe function is another function that locates the input point within the subdivision. It finds the\nsubdivision vertex that is the closest to the input point. It is not necessarily one of vertices\nof the facet containing the input point, though the facet (located using locate() ) is used as a\nstarting point.\n\n@returns vertex ID."]
    #[link_name = "\u{1}_ZN2cv8Subdiv2D11findNearestENS_6Point_IfEEPS2_"]
    pub fn cv_Subdiv2D_findNearest(
        this: *mut cv_Subdiv2D,
        pt: cv_Point2f,
        nearestPt: *mut cv_Point2f,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Returns a list of all edges.\n\n@param edgeList Output vector.\n\nThe function gives each edge as a 4 numbers vector, where each two are one of the edge\nvertices. i.e. org_x = v[0], org_y = v[1], dst_x = v[2], dst_y = v[3]."]
    #[link_name = "\u{1}_ZNK2cv8Subdiv2D11getEdgeListERSt6vectorINS_3VecIfLi4EEESaIS3_EE"]
    pub fn cv_Subdiv2D_getEdgeList(this: *const cv_Subdiv2D, edgeList: *mut std_vector);
}
unsafe extern "C" {
    #[doc = " @brief Returns a list of the leading edge ID connected to each triangle.\n\n@param leadingEdgeList Output vector.\n\nThe function gives one edge ID for each triangle."]
    #[link_name = "\u{1}_ZNK2cv8Subdiv2D18getLeadingEdgeListERSt6vectorIiSaIiEE"]
    pub fn cv_Subdiv2D_getLeadingEdgeList(
        this: *const cv_Subdiv2D,
        leadingEdgeList: *mut std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @brief Returns a list of all triangles.\n\n@param triangleList Output vector.\n\nThe function gives each triangle as a 6 numbers vector, where each two are one of the triangle\nvertices. i.e. p1_x = v[0], p1_y = v[1], p2_x = v[2], p2_y = v[3], p3_x = v[4], p3_y = v[5]."]
    #[link_name = "\u{1}_ZNK2cv8Subdiv2D15getTriangleListERSt6vectorINS_3VecIfLi6EEESaIS3_EE"]
    pub fn cv_Subdiv2D_getTriangleList(this: *const cv_Subdiv2D, triangleList: *mut std_vector);
}
unsafe extern "C" {
    #[doc = " @brief Returns a list of all Voronoi facets.\n\n@param idx Vector of vertices IDs to consider. For all vertices you can pass empty vector.\n@param facetList Output vector of the Voronoi facets.\n@param facetCenters Output vector of the Voronoi facets center points.\n"]
    #[link_name = "\u{1}_ZN2cv8Subdiv2D19getVoronoiFacetListERKSt6vectorIiSaIiEERS1_IS1_INS_6Point_IfEESaIS7_EESaIS9_EERS9_"]
    pub fn cv_Subdiv2D_getVoronoiFacetList(
        this: *mut cv_Subdiv2D,
        idx: *const std_vector,
        facetList: *mut std_vector,
        facetCenters: *mut std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @brief Returns vertex location from vertex ID.\n\n@param vertex vertex ID.\n@param firstEdge Optional. The first edge ID which is connected to the vertex.\n@returns vertex (x,y)\n"]
    #[link_name = "\u{1}_ZNK2cv8Subdiv2D9getVertexEiPi"]
    pub fn cv_Subdiv2D_getVertex(
        this: *const cv_Subdiv2D,
        vertex: ::std::os::raw::c_int,
        firstEdge: *mut ::std::os::raw::c_int,
    ) -> cv_Point2f;
}
unsafe extern "C" {
    #[doc = " @brief Returns one of the edges related to the given edge.\n\n@param edge Subdivision edge ID.\n@param nextEdgeType Parameter specifying which of the related edges to return.\nThe following values are possible:\n-   NEXT_AROUND_ORG next around the edge origin ( eOnext on the picture below if e is the input edge)\n-   NEXT_AROUND_DST next around the edge vertex ( eDnext )\n-   PREV_AROUND_ORG previous around the edge origin (reversed eRnext )\n-   PREV_AROUND_DST previous around the edge destination (reversed eLnext )\n-   NEXT_AROUND_LEFT next around the left facet ( eLnext )\n-   NEXT_AROUND_RIGHT next around the right facet ( eRnext )\n-   PREV_AROUND_LEFT previous around the left facet (reversed eOnext )\n-   PREV_AROUND_RIGHT previous around the right facet (reversed eDnext )\n\n[sample output](pics/quadedge.png)\n\n@returns edge ID related to the input edge."]
    #[link_name = "\u{1}_ZNK2cv8Subdiv2D7getEdgeEii"]
    pub fn cv_Subdiv2D_getEdge(
        this: *const cv_Subdiv2D,
        edge: ::std::os::raw::c_int,
        nextEdgeType: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Returns next edge around the edge origin.\n\n@param edge Subdivision edge ID.\n\n@returns an integer which is next edge ID around the edge origin: eOnext on the\npicture above if e is the input edge)."]
    #[link_name = "\u{1}_ZNK2cv8Subdiv2D8nextEdgeEi"]
    pub fn cv_Subdiv2D_nextEdge(
        this: *const cv_Subdiv2D,
        edge: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Returns another edge of the same quad-edge.\n\n@param edge Subdivision edge ID.\n@param rotate Parameter specifying which of the edges of the same quad-edge as the input\none to return. The following values are possible:\n-   0 - the input edge ( e on the picture below if e is the input edge)\n-   1 - the rotated edge ( eRot )\n-   2 - the reversed edge (reversed e (in green))\n-   3 - the reversed rotated edge (reversed eRot (in green))\n\n@returns one of the edges ID of the same quad-edge as the input edge."]
    #[link_name = "\u{1}_ZNK2cv8Subdiv2D10rotateEdgeEii"]
    pub fn cv_Subdiv2D_rotateEdge(
        this: *const cv_Subdiv2D,
        edge: ::std::os::raw::c_int,
        rotate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv8Subdiv2D7symEdgeEi"]
    pub fn cv_Subdiv2D_symEdge(
        this: *const cv_Subdiv2D,
        edge: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Returns the edge origin.\n\n@param edge Subdivision edge ID.\n@param orgpt Output vertex location.\n\n@returns vertex ID."]
    #[link_name = "\u{1}_ZNK2cv8Subdiv2D7edgeOrgEiPNS_6Point_IfEE"]
    pub fn cv_Subdiv2D_edgeOrg(
        this: *const cv_Subdiv2D,
        edge: ::std::os::raw::c_int,
        orgpt: *mut cv_Point2f,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Returns the edge destination.\n\n@param edge Subdivision edge ID.\n@param dstpt Output vertex location.\n\n@returns vertex ID."]
    #[link_name = "\u{1}_ZNK2cv8Subdiv2D7edgeDstEiPNS_6Point_IfEE"]
    pub fn cv_Subdiv2D_edgeDst(
        this: *const cv_Subdiv2D,
        edge: ::std::os::raw::c_int,
        dstpt: *mut cv_Point2f,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8Subdiv2D7newEdgeEv"]
    pub fn cv_Subdiv2D_newEdge(this: *mut cv_Subdiv2D) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8Subdiv2D10deleteEdgeEi"]
    pub fn cv_Subdiv2D_deleteEdge(this: *mut cv_Subdiv2D, edge: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8Subdiv2D8newPointENS_6Point_IfEEbi"]
    pub fn cv_Subdiv2D_newPoint(
        this: *mut cv_Subdiv2D,
        pt: cv_Point2f,
        isvirtual: bool,
        firstEdge: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8Subdiv2D11deletePointEi"]
    pub fn cv_Subdiv2D_deletePoint(this: *mut cv_Subdiv2D, vtx: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8Subdiv2D13setEdgePointsEiii"]
    pub fn cv_Subdiv2D_setEdgePoints(
        this: *mut cv_Subdiv2D,
        edge: ::std::os::raw::c_int,
        orgPt: ::std::os::raw::c_int,
        dstPt: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8Subdiv2D6spliceEii"]
    pub fn cv_Subdiv2D_splice(
        this: *mut cv_Subdiv2D,
        edgeA: ::std::os::raw::c_int,
        edgeB: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8Subdiv2D12connectEdgesEii"]
    pub fn cv_Subdiv2D_connectEdges(
        this: *mut cv_Subdiv2D,
        edgeA: ::std::os::raw::c_int,
        edgeB: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8Subdiv2D9swapEdgesEi"]
    pub fn cv_Subdiv2D_swapEdges(this: *mut cv_Subdiv2D, edge: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv8Subdiv2D9isRightOfENS_6Point_IfEEi"]
    pub fn cv_Subdiv2D_isRightOf(
        this: *const cv_Subdiv2D,
        pt: cv_Point2f,
        edge: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8Subdiv2D11calcVoronoiEv"]
    pub fn cv_Subdiv2D_calcVoronoi(this: *mut cv_Subdiv2D);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8Subdiv2D12clearVoronoiEv"]
    pub fn cv_Subdiv2D_clearVoronoi(this: *mut cv_Subdiv2D);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv8Subdiv2D11checkSubdivEv"]
    pub fn cv_Subdiv2D_checkSubdiv(this: *const cv_Subdiv2D);
}
unsafe extern "C" {
    #[doc = " creates an empty Subdiv2D object.\nTo create a new empty Delaunay subdivision you need to use the #initDelaunay function."]
    #[link_name = "\u{1}_ZN2cv8Subdiv2DC1Ev"]
    pub fn cv_Subdiv2D_Subdiv2D(this: *mut cv_Subdiv2D);
}
unsafe extern "C" {
    #[doc = " @overload\n\n@param rect Rectangle that includes all of the 2D points that are to be added to the subdivision.\n\nThe function creates an empty Delaunay subdivision where 2D points can be added using the function\ninsert() . All of the points to be added must be within the specified rectangle, otherwise a runtime\nerror is raised."]
    #[link_name = "\u{1}_ZN2cv8Subdiv2DC1ENS_5Rect_IiEE"]
    pub fn cv_Subdiv2D_Subdiv2D1(this: *mut cv_Subdiv2D, rect: cv_Rect);
}
impl cv_Subdiv2D {
    #[inline]
    pub unsafe fn initDelaunay(&mut self, rect: cv_Rect) {
        cv_Subdiv2D_initDelaunay(self, rect)
    }
    #[inline]
    pub unsafe fn insert(&mut self, pt: cv_Point2f) -> ::std::os::raw::c_int {
        cv_Subdiv2D_insert(self, pt)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, ptvec: *const std_vector) {
        cv_Subdiv2D_insert1(self, ptvec)
    }
    #[inline]
    pub unsafe fn locate(
        &mut self,
        pt: cv_Point2f,
        edge: *mut ::std::os::raw::c_int,
        vertex: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        cv_Subdiv2D_locate(self, pt, edge, vertex)
    }
    #[inline]
    pub unsafe fn findNearest(
        &mut self,
        pt: cv_Point2f,
        nearestPt: *mut cv_Point2f,
    ) -> ::std::os::raw::c_int {
        cv_Subdiv2D_findNearest(self, pt, nearestPt)
    }
    #[inline]
    pub unsafe fn getEdgeList(&self, edgeList: *mut std_vector) {
        cv_Subdiv2D_getEdgeList(self, edgeList)
    }
    #[inline]
    pub unsafe fn getLeadingEdgeList(&self, leadingEdgeList: *mut std_vector) {
        cv_Subdiv2D_getLeadingEdgeList(self, leadingEdgeList)
    }
    #[inline]
    pub unsafe fn getTriangleList(&self, triangleList: *mut std_vector) {
        cv_Subdiv2D_getTriangleList(self, triangleList)
    }
    #[inline]
    pub unsafe fn getVoronoiFacetList(
        &mut self,
        idx: *const std_vector,
        facetList: *mut std_vector,
        facetCenters: *mut std_vector,
    ) {
        cv_Subdiv2D_getVoronoiFacetList(self, idx, facetList, facetCenters)
    }
    #[inline]
    pub unsafe fn getVertex(
        &self,
        vertex: ::std::os::raw::c_int,
        firstEdge: *mut ::std::os::raw::c_int,
    ) -> cv_Point2f {
        cv_Subdiv2D_getVertex(self, vertex, firstEdge)
    }
    #[inline]
    pub unsafe fn getEdge(
        &self,
        edge: ::std::os::raw::c_int,
        nextEdgeType: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        cv_Subdiv2D_getEdge(self, edge, nextEdgeType)
    }
    #[inline]
    pub unsafe fn nextEdge(&self, edge: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        cv_Subdiv2D_nextEdge(self, edge)
    }
    #[inline]
    pub unsafe fn rotateEdge(
        &self,
        edge: ::std::os::raw::c_int,
        rotate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        cv_Subdiv2D_rotateEdge(self, edge, rotate)
    }
    #[inline]
    pub unsafe fn symEdge(&self, edge: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        cv_Subdiv2D_symEdge(self, edge)
    }
    #[inline]
    pub unsafe fn edgeOrg(
        &self,
        edge: ::std::os::raw::c_int,
        orgpt: *mut cv_Point2f,
    ) -> ::std::os::raw::c_int {
        cv_Subdiv2D_edgeOrg(self, edge, orgpt)
    }
    #[inline]
    pub unsafe fn edgeDst(
        &self,
        edge: ::std::os::raw::c_int,
        dstpt: *mut cv_Point2f,
    ) -> ::std::os::raw::c_int {
        cv_Subdiv2D_edgeDst(self, edge, dstpt)
    }
    #[inline]
    pub unsafe fn newEdge(&mut self) -> ::std::os::raw::c_int {
        cv_Subdiv2D_newEdge(self)
    }
    #[inline]
    pub unsafe fn deleteEdge(&mut self, edge: ::std::os::raw::c_int) {
        cv_Subdiv2D_deleteEdge(self, edge)
    }
    #[inline]
    pub unsafe fn newPoint(
        &mut self,
        pt: cv_Point2f,
        isvirtual: bool,
        firstEdge: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        cv_Subdiv2D_newPoint(self, pt, isvirtual, firstEdge)
    }
    #[inline]
    pub unsafe fn deletePoint(&mut self, vtx: ::std::os::raw::c_int) {
        cv_Subdiv2D_deletePoint(self, vtx)
    }
    #[inline]
    pub unsafe fn setEdgePoints(
        &mut self,
        edge: ::std::os::raw::c_int,
        orgPt: ::std::os::raw::c_int,
        dstPt: ::std::os::raw::c_int,
    ) {
        cv_Subdiv2D_setEdgePoints(self, edge, orgPt, dstPt)
    }
    #[inline]
    pub unsafe fn splice(&mut self, edgeA: ::std::os::raw::c_int, edgeB: ::std::os::raw::c_int) {
        cv_Subdiv2D_splice(self, edgeA, edgeB)
    }
    #[inline]
    pub unsafe fn connectEdges(
        &mut self,
        edgeA: ::std::os::raw::c_int,
        edgeB: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        cv_Subdiv2D_connectEdges(self, edgeA, edgeB)
    }
    #[inline]
    pub unsafe fn swapEdges(&mut self, edge: ::std::os::raw::c_int) {
        cv_Subdiv2D_swapEdges(self, edge)
    }
    #[inline]
    pub unsafe fn isRightOf(
        &self,
        pt: cv_Point2f,
        edge: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        cv_Subdiv2D_isRightOf(self, pt, edge)
    }
    #[inline]
    pub unsafe fn calcVoronoi(&mut self) {
        cv_Subdiv2D_calcVoronoi(self)
    }
    #[inline]
    pub unsafe fn clearVoronoi(&mut self) {
        cv_Subdiv2D_clearVoronoi(self)
    }
    #[inline]
    pub unsafe fn checkSubdiv(&self) {
        cv_Subdiv2D_checkSubdiv(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_Subdiv2D_Subdiv2D(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(rect: cv_Rect) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_Subdiv2D_Subdiv2D1(__bindgen_tmp.as_mut_ptr(), rect);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief Line segment detector class\n\nfollowing the algorithm described at @cite Rafael12 .\n\n@note Implementation has been removed due original code license conflict"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_LineSegmentDetector {
    pub _base: cv_Algorithm,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_LineSegmentDetector"][::std::mem::size_of::<cv_LineSegmentDetector>() - 8usize];
    ["Alignment of cv_LineSegmentDetector"]
        [::std::mem::align_of::<cv_LineSegmentDetector>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates a smart pointer to a LineSegmentDetector object and initializes it.\n\nThe LineSegmentDetector algorithm is defined using the standard values. Only advanced users may want\nto edit those, as to tailor it for their own application.\n\n@param _refine The way found lines will be refined, see #LineSegmentDetectorModes\n@param _scale The scale of the image that will be used to find the lines. Range (0..1].\n@param _sigma_scale Sigma for Gaussian filter. It is computed as sigma = _sigma_scale/_scale.\n@param _quant Bound to the quantization error on the gradient norm.\n@param _ang_th Gradient angle tolerance in degrees.\n@param _log_eps Detection threshold: -log10(NFA) \\> log_eps. Used only when advance refinement\nis chosen.\n@param _density_th Minimal density of aligned region points in the enclosing rectangle.\n@param _n_bins Number of bins in pseudo-ordering of gradient modulus.\n\n@note Implementation has been removed due original code license conflict"]
    #[link_name = "\u{1}_ZN2cv25createLineSegmentDetectorEiddddddi"]
    pub fn cv_createLineSegmentDetector(
        _refine: ::std::os::raw::c_int,
        _scale: f64,
        _sigma_scale: f64,
        _quant: f64,
        _ang_th: f64,
        _log_eps: f64,
        _density_th: f64,
        _n_bins: ::std::os::raw::c_int,
    ) -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Returns Gaussian filter coefficients.\n\nThe function computes and returns the \\f$\\texttt{ksize} \\times 1\\f$ matrix of Gaussian filter\ncoefficients:\n\n\\f[G_i= \\alpha *e^{-(i-( \\texttt{ksize} -1)/2)^2/(2* \\texttt{sigma}^2)},\\f]\n\nwhere \\f$i=0..\\texttt{ksize}-1\\f$ and \\f$\\alpha\\f$ is the scale factor chosen so that \\f$\\sum_i G_i=1\\f$.\n\nTwo of such generated kernels can be passed to sepFilter2D. Those functions automatically recognize\nsmoothing kernels (a symmetrical kernel with sum of weights equal to 1) and handle them accordingly.\nYou may also use the higher-level GaussianBlur.\n@param ksize Aperture size. It should be odd ( \\f$\\texttt{ksize} \\mod 2 = 1\\f$ ) and positive.\n@param sigma Gaussian standard deviation. If it is non-positive, it is computed from ksize as\n`sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8`.\n@param ktype Type of filter coefficients. It can be CV_32F or CV_64F .\n@sa  sepFilter2D, getDerivKernels, getStructuringElement, GaussianBlur"]
    #[link_name = "\u{1}_ZN2cv17getGaussianKernelEidi"]
    pub fn cv_getGaussianKernel(
        ksize: ::std::os::raw::c_int,
        sigma: f64,
        ktype: ::std::os::raw::c_int,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Returns filter coefficients for computing spatial image derivatives.\n\nThe function computes and returns the filter coefficients for spatial image derivatives. When\n`ksize=FILTER_SCHARR`, the Scharr \\f$3 \\times 3\\f$ kernels are generated (see #Scharr). Otherwise, Sobel\nkernels are generated (see #Sobel). The filters are normally passed to #sepFilter2D or to\n\n@param kx Output matrix of row filter coefficients. It has the type ktype .\n@param ky Output matrix of column filter coefficients. It has the type ktype .\n@param dx Derivative order in respect of x.\n@param dy Derivative order in respect of y.\n@param ksize Aperture size. It can be FILTER_SCHARR, 1, 3, 5, or 7.\n@param normalize Flag indicating whether to normalize (scale down) the filter coefficients or not.\nTheoretically, the coefficients should have the denominator \\f$=2^{ksize*2-dx-dy-2}\\f$. If you are\ngoing to filter floating-point images, you are likely to use the normalized kernels. But if you\ncompute derivatives of an 8-bit image, store the results in a 16-bit image, and wish to preserve\nall the fractional bits, you may want to set normalize=false .\n@param ktype Type of filter coefficients. It can be CV_32f or CV_64F ."]
    #[link_name = "\u{1}_ZN2cv15getDerivKernelsERKNS_12_OutputArrayES2_iiibi"]
    pub fn cv_getDerivKernels(
        kx: cv_OutputArray,
        ky: cv_OutputArray,
        dx: ::std::os::raw::c_int,
        dy: ::std::os::raw::c_int,
        ksize: ::std::os::raw::c_int,
        normalize: bool,
        ktype: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Returns Gabor filter coefficients.\n\nFor more details about gabor filter equations and parameters, see: [Gabor\nFilter](http://en.wikipedia.org/wiki/Gabor_filter).\n\n@param ksize Size of the filter returned.\n@param sigma Standard deviation of the gaussian envelope.\n@param theta Orientation of the normal to the parallel stripes of a Gabor function.\n@param lambd Wavelength of the sinusoidal factor.\n@param gamma Spatial aspect ratio.\n@param psi Phase offset.\n@param ktype Type of filter coefficients. It can be CV_32F or CV_64F ."]
    #[link_name = "\u{1}_ZN2cv14getGaborKernelENS_5Size_IiEEdddddi"]
    pub fn cv_getGaborKernel(
        ksize: cv_Size,
        sigma: f64,
        theta: f64,
        lambd: f64,
        gamma: f64,
        psi: f64,
        ktype: ::std::os::raw::c_int,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Returns a structuring element of the specified size and shape for morphological operations.\n\nThe function constructs and returns the structuring element that can be further passed to #erode,\n#dilate or #morphologyEx. But you can also construct an arbitrary binary mask yourself and use it as\nthe structuring element.\n\n@param shape Element shape that could be one of #MorphShapes\n@param ksize Size of the structuring element.\n@param anchor Anchor position within the element. The default value \\f$(-1, -1)\\f$ means that the\nanchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor\nposition. In other cases the anchor just regulates how much the result of the morphological\noperation is shifted."]
    #[link_name = "\u{1}_ZN2cv21getStructuringElementEiNS_5Size_IiEENS_6Point_IiEE"]
    pub fn cv_getStructuringElement(
        shape: ::std::os::raw::c_int,
        ksize: cv_Size,
        anchor: cv_Point,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Blurs an image using the median filter.\n\nThe function smoothes an image using the median filter with the \\f$\\texttt{ksize} \\times\n\\texttt{ksize}\\f$ aperture. Each channel of a multi-channel image is processed independently.\nIn-place operation is supported.\n\n@note The median filter uses #BORDER_REPLICATE internally to cope with border pixels, see #BorderTypes\n\n@param src input 1-, 3-, or 4-channel image; when ksize is 3 or 5, the image depth should be\nCV_8U, CV_16U, or CV_32F, for larger aperture sizes, it can only be CV_8U.\n@param dst destination array of the same size and type as src.\n@param ksize aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ...\n@sa  bilateralFilter, blur, boxFilter, GaussianBlur"]
    #[link_name = "\u{1}_ZN2cv10medianBlurERKNS_11_InputArrayERKNS_12_OutputArrayEi"]
    pub fn cv_medianBlur(src: cv_InputArray, dst: cv_OutputArray, ksize: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @brief Blurs an image using a Gaussian filter.\n\nThe function convolves the source image with the specified Gaussian kernel. In-place filtering is\nsupported.\n\n@param src input image; the image can have any number of channels, which are processed\nindependently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.\n@param dst output image of the same size and type as src.\n@param ksize Gaussian kernel size. ksize.width and ksize.height can differ but they both must be\npositive and odd. Or, they can be zero's and then they are computed from sigma.\n@param sigmaX Gaussian kernel standard deviation in X direction.\n@param sigmaY Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be\nequal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height,\nrespectively (see #getGaussianKernel for details); to fully control the result regardless of\npossible future modifications of all this semantics, it is recommended to specify all of ksize,\nsigmaX, and sigmaY.\n@param borderType pixel extrapolation method, see #BorderTypes\n\n@sa  sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur"]
    #[link_name = "\u{1}_ZN2cv12GaussianBlurERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Size_IiEEddi"]
    pub fn cv_GaussianBlur(
        src: cv_InputArray,
        dst: cv_OutputArray,
        ksize: cv_Size,
        sigmaX: f64,
        sigmaY: f64,
        borderType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Applies the bilateral filter to an image.\n\nThe function applies bilateral filtering to the input image, as described in\nhttp://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html\nbilateralFilter can reduce unwanted noise very well while keeping edges fairly sharp. However, it is\nvery slow compared to most filters.\n\n_Sigma values_: For simplicity, you can set the 2 sigma values to be the same. If they are small (\\<\n10), the filter will not have much effect, whereas if they are large (\\> 150), they will have a very\nstrong effect, making the image look \"cartoonish\".\n\n_Filter size_: Large filters (d \\> 5) are very slow, so it is recommended to use d=5 for real-time\napplications, and perhaps d=9 for offline applications that need heavy noise filtering.\n\nThis filter does not work inplace.\n@param src Source 8-bit or floating-point, 1-channel or 3-channel image.\n@param dst Destination image of the same size and type as src .\n@param d Diameter of each pixel neighborhood that is used during filtering. If it is non-positive,\nit is computed from sigmaSpace.\n@param sigmaColor Filter sigma in the color space. A larger value of the parameter means that\nfarther colors within the pixel neighborhood (see sigmaSpace) will be mixed together, resulting\nin larger areas of semi-equal color.\n@param sigmaSpace Filter sigma in the coordinate space. A larger value of the parameter means that\nfarther pixels will influence each other as long as their colors are close enough (see sigmaColor\n). When d\\>0, it specifies the neighborhood size regardless of sigmaSpace. Otherwise, d is\nproportional to sigmaSpace.\n@param borderType border mode used to extrapolate pixels outside of the image, see #BorderTypes"]
    #[link_name = "\u{1}_ZN2cv15bilateralFilterERKNS_11_InputArrayERKNS_12_OutputArrayEiddi"]
    pub fn cv_bilateralFilter(
        src: cv_InputArray,
        dst: cv_OutputArray,
        d: ::std::os::raw::c_int,
        sigmaColor: f64,
        sigmaSpace: f64,
        borderType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Blurs an image using the box filter.\n\nThe function smooths an image using the kernel:\n\n\\f[\\texttt{K} =  \\alpha \\begin{bmatrix} 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\ 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\ \\hdotsfor{6} \\\\ 1 & 1 & 1 &  \\cdots & 1 & 1 \\end{bmatrix}\\f]\n\nwhere\n\n\\f[\\alpha = \\fork{\\frac{1}{\\texttt{ksize.width*ksize.height}}}{when \\texttt{normalize=true}}{1}{otherwise}\\f]\n\nUnnormalized box filter is useful for computing various integral characteristics over each pixel\nneighborhood, such as covariance matrices of image derivatives (used in dense optical flow\nalgorithms, and so on). If you need to compute pixel sums over variable-size windows, use #integral.\n\n@param src input image.\n@param dst output image of the same size and type as src.\n@param ddepth the output image depth (-1 to use src.depth()).\n@param ksize blurring kernel size.\n@param anchor anchor point; default value Point(-1,-1) means that the anchor is at the kernel\ncenter.\n@param normalize flag, specifying whether the kernel is normalized by its area or not.\n@param borderType border mode used to extrapolate pixels outside of the image, see #BorderTypes\n@sa  blur, bilateralFilter, GaussianBlur, medianBlur, integral"]
    #[link_name = "\u{1}_ZN2cv9boxFilterERKNS_11_InputArrayERKNS_12_OutputArrayEiNS_5Size_IiEENS_6Point_IiEEbi"]
    pub fn cv_boxFilter(
        src: cv_InputArray,
        dst: cv_OutputArray,
        ddepth: ::std::os::raw::c_int,
        ksize: cv_Size,
        anchor: cv_Point,
        normalize: bool,
        borderType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the normalized sum of squares of the pixel values overlapping the filter.\n\nFor every pixel \\f$ (x, y) \\f$ in the source image, the function calculates the sum of squares of those neighboring\npixel values which overlap the filter placed over the pixel \\f$ (x, y) \\f$.\n\nThe unnormalized square box filter can be useful in computing local image statistics such as the the local\nvariance and standard deviation around the neighborhood of a pixel.\n\n@param src input image\n@param dst output image of the same size and type as _src\n@param ddepth the output image depth (-1 to use src.depth())\n@param ksize kernel size\n@param anchor kernel anchor point. The default value of Point(-1, -1) denotes that the anchor is at the kernel\ncenter.\n@param normalize flag, specifying whether the kernel is to be normalized by it's area or not.\n@param borderType border mode used to extrapolate pixels outside of the image, see #BorderTypes\n@sa boxFilter"]
    #[link_name = "\u{1}_ZN2cv12sqrBoxFilterERKNS_11_InputArrayERKNS_12_OutputArrayEiNS_5Size_IiEENS_6Point_IiEEbi"]
    pub fn cv_sqrBoxFilter(
        src: cv_InputArray,
        dst: cv_OutputArray,
        ddepth: ::std::os::raw::c_int,
        ksize: cv_Size,
        anchor: cv_Point,
        normalize: bool,
        borderType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Blurs an image using the normalized box filter.\n\nThe function smooths an image using the kernel:\n\n\\f[\\texttt{K} =  \\frac{1}{\\texttt{ksize.width*ksize.height}} \\begin{bmatrix} 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\ 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\ \\hdotsfor{6} \\\\ 1 & 1 & 1 &  \\cdots & 1 & 1  \\\\ \\end{bmatrix}\\f]\n\nThe call `blur(src, dst, ksize, anchor, borderType)` is equivalent to `boxFilter(src, dst, src.type(),\nanchor, true, borderType)`.\n\n@param src input image; it can have any number of channels, which are processed independently, but\nthe depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.\n@param dst output image of the same size and type as src.\n@param ksize blurring kernel size.\n@param anchor anchor point; default value Point(-1,-1) means that the anchor is at the kernel\ncenter.\n@param borderType border mode used to extrapolate pixels outside of the image, see #BorderTypes\n@sa  boxFilter, bilateralFilter, GaussianBlur, medianBlur"]
    #[link_name = "\u{1}_ZN2cv4blurERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Size_IiEENS_6Point_IiEEi"]
    pub fn cv_blur(
        src: cv_InputArray,
        dst: cv_OutputArray,
        ksize: cv_Size,
        anchor: cv_Point,
        borderType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Convolves an image with the kernel.\n\nThe function applies an arbitrary linear filter to an image. In-place operation is supported. When\nthe aperture is partially outside the image, the function interpolates outlier pixel values\naccording to the specified border mode.\n\nThe function does actually compute correlation, not the convolution:\n\n\\f[\\texttt{dst} (x,y) =  \\sum _{ \\stackrel{0\\leq x' < \\texttt{kernel.cols},}{0\\leq y' < \\texttt{kernel.rows}} }  \\texttt{kernel} (x',y')* \\texttt{src} (x+x'- \\texttt{anchor.x} ,y+y'- \\texttt{anchor.y} )\\f]\n\nThat is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip\nthe kernel using #flip and set the new anchor to `(kernel.cols - anchor.x - 1, kernel.rows -\nanchor.y - 1)`.\n\nThe function uses the DFT-based algorithm in case of sufficiently large kernels (~`11 x 11` or\nlarger) and the direct algorithm for small kernels.\n\n@param src input image.\n@param dst output image of the same size and the same number of channels as src.\n@param ddepth desired depth of the destination image, see @ref filter_depths \"combinations\"\n@param kernel convolution kernel (or rather a correlation kernel), a single-channel floating point\nmatrix; if you want to apply different kernels to different channels, split the image into\nseparate color planes using split and process them individually.\n@param anchor anchor of the kernel that indicates the relative position of a filtered point within\nthe kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor\nis at the kernel center.\n@param delta optional value added to the filtered pixels before storing them in dst.\n@param borderType pixel extrapolation method, see #BorderTypes\n@sa  sepFilter2D, dft, matchTemplate"]
    #[link_name = "\u{1}_ZN2cv8filter2DERKNS_11_InputArrayERKNS_12_OutputArrayEiS2_NS_6Point_IiEEdi"]
    pub fn cv_filter2D(
        src: cv_InputArray,
        dst: cv_OutputArray,
        ddepth: ::std::os::raw::c_int,
        kernel: cv_InputArray,
        anchor: cv_Point,
        delta: f64,
        borderType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Applies a separable linear filter to an image.\n\nThe function applies a separable linear filter to the image. That is, first, every row of src is\nfiltered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D\nkernel kernelY. The final result shifted by delta is stored in dst .\n\n@param src Source image.\n@param dst Destination image of the same size and the same number of channels as src .\n@param ddepth Destination image depth, see @ref filter_depths \"combinations\"\n@param kernelX Coefficients for filtering each row.\n@param kernelY Coefficients for filtering each column.\n@param anchor Anchor position within the kernel. The default value \\f$(-1,-1)\\f$ means that the anchor\nis at the kernel center.\n@param delta Value added to the filtered results before storing them.\n@param borderType Pixel extrapolation method, see #BorderTypes\n@sa  filter2D, Sobel, GaussianBlur, boxFilter, blur"]
    #[link_name = "\u{1}_ZN2cv11sepFilter2DERKNS_11_InputArrayERKNS_12_OutputArrayEiS2_S2_NS_6Point_IiEEdi"]
    pub fn cv_sepFilter2D(
        src: cv_InputArray,
        dst: cv_OutputArray,
        ddepth: ::std::os::raw::c_int,
        kernelX: cv_InputArray,
        kernelY: cv_InputArray,
        anchor: cv_Point,
        delta: f64,
        borderType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.\n\nIn all cases except one, the \\f$\\texttt{ksize} \\times \\texttt{ksize}\\f$ separable kernel is used to\ncalculate the derivative. When \\f$\\texttt{ksize = 1}\\f$, the \\f$3 \\times 1\\f$ or \\f$1 \\times 3\\f$\nkernel is used (that is, no Gaussian smoothing is done). `ksize = 1` can only be used for the first\nor the second x- or y- derivatives.\n\nThere is also the special value `ksize = #FILTER_SCHARR (-1)` that corresponds to the \\f$3\\times3\\f$ Scharr\nfilter that may give more accurate results than the \\f$3\\times3\\f$ Sobel. The Scharr aperture is\n\n\\f[\\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3}\\f]\n\nfor the x-derivative, or transposed for the y-derivative.\n\nThe function calculates an image derivative by convolving the image with the appropriate kernel:\n\n\\f[\\texttt{dst} =  \\frac{\\partial^{xorder+yorder} \\texttt{src}}{\\partial x^{xorder} \\partial y^{yorder}}\\f]\n\nThe Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less\nresistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3)\nor ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first\ncase corresponds to a kernel of:\n\n\\f[\\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1}\\f]\n\nThe second case corresponds to a kernel of:\n\n\\f[\\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1}\\f]\n\n@param src input image.\n@param dst output image of the same size and the same number of channels as src .\n@param ddepth output image depth, see @ref filter_depths \"combinations\"; in the case of\n8-bit input images it will result in truncated derivatives.\n@param dx order of the derivative x.\n@param dy order of the derivative y.\n@param ksize size of the extended Sobel kernel; it must be 1, 3, 5, or 7.\n@param scale optional scale factor for the computed derivative values; by default, no scaling is\napplied (see #getDerivKernels for details).\n@param delta optional delta value that is added to the results prior to storing them in dst.\n@param borderType pixel extrapolation method, see #BorderTypes\n@sa  Scharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolar"]
    #[link_name = "\u{1}_ZN2cv5SobelERKNS_11_InputArrayERKNS_12_OutputArrayEiiiiddi"]
    pub fn cv_Sobel(
        src: cv_InputArray,
        dst: cv_OutputArray,
        ddepth: ::std::os::raw::c_int,
        dx: ::std::os::raw::c_int,
        dy: ::std::os::raw::c_int,
        ksize: ::std::os::raw::c_int,
        scale: f64,
        delta: f64,
        borderType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the first order image derivative in both x and y using a Sobel operator\n\nEquivalent to calling:\n\n@code\nSobel( src, dx, CV_16SC1, 1, 0, 3 );\nSobel( src, dy, CV_16SC1, 0, 1, 3 );\n@endcode\n\n@param src input image.\n@param dx output image with first-order derivative in x.\n@param dy output image with first-order derivative in y.\n@param ksize size of Sobel kernel. It must be 3.\n@param borderType pixel extrapolation method, see #BorderTypes\n\n@sa Sobel"]
    #[link_name = "\u{1}_ZN2cv15spatialGradientERKNS_11_InputArrayERKNS_12_OutputArrayES5_ii"]
    pub fn cv_spatialGradient(
        src: cv_InputArray,
        dx: cv_OutputArray,
        dy: cv_OutputArray,
        ksize: ::std::os::raw::c_int,
        borderType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the first x- or y- image derivative using Scharr operator.\n\nThe function computes the first x- or y- spatial image derivative using the Scharr operator. The\ncall\n\n\\f[\\texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)}\\f]\n\nis equivalent to\n\n\\f[\\texttt{Sobel(src, dst, ddepth, dx, dy, FILTER_SCHARR, scale, delta, borderType)} .\\f]\n\n@param src input image.\n@param dst output image of the same size and the same number of channels as src.\n@param ddepth output image depth, see @ref filter_depths \"combinations\"\n@param dx order of the derivative x.\n@param dy order of the derivative y.\n@param scale optional scale factor for the computed derivative values; by default, no scaling is\napplied (see #getDerivKernels for details).\n@param delta optional delta value that is added to the results prior to storing them in dst.\n@param borderType pixel extrapolation method, see #BorderTypes\n@sa  cartToPolar"]
    #[link_name = "\u{1}_ZN2cv6ScharrERKNS_11_InputArrayERKNS_12_OutputArrayEiiiddi"]
    pub fn cv_Scharr(
        src: cv_InputArray,
        dst: cv_OutputArray,
        ddepth: ::std::os::raw::c_int,
        dx: ::std::os::raw::c_int,
        dy: ::std::os::raw::c_int,
        scale: f64,
        delta: f64,
        borderType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the Laplacian of an image.\n\nThe function calculates the Laplacian of the source image by adding up the second x and y\nderivatives calculated using the Sobel operator:\n\n\\f[\\texttt{dst} =  \\Delta \\texttt{src} =  \\frac{\\partial^2 \\texttt{src}}{\\partial x^2} +  \\frac{\\partial^2 \\texttt{src}}{\\partial y^2}\\f]\n\nThis is done when `ksize > 1`. When `ksize == 1`, the Laplacian is computed by filtering the image\nwith the following \\f$3 \\times 3\\f$ aperture:\n\n\\f[\\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0}\\f]\n\n@param src Source image.\n@param dst Destination image of the same size and the same number of channels as src .\n@param ddepth Desired depth of the destination image.\n@param ksize Aperture size used to compute the second-derivative filters. See #getDerivKernels for\ndetails. The size must be positive and odd.\n@param scale Optional scale factor for the computed Laplacian values. By default, no scaling is\napplied. See #getDerivKernels for details.\n@param delta Optional delta value that is added to the results prior to storing them in dst .\n@param borderType Pixel extrapolation method, see #BorderTypes\n@sa  Sobel, Scharr"]
    #[link_name = "\u{1}_ZN2cv9LaplacianERKNS_11_InputArrayERKNS_12_OutputArrayEiiddi"]
    pub fn cv_Laplacian(
        src: cv_InputArray,
        dst: cv_OutputArray,
        ddepth: ::std::os::raw::c_int,
        ksize: ::std::os::raw::c_int,
        scale: f64,
        delta: f64,
        borderType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Finds edges in an image using the Canny algorithm @cite Canny86 .\n\nThe function finds edges in the input image and marks them in the output map edges using the\nCanny algorithm. The smallest value between threshold1 and threshold2 is used for edge linking. The\nlargest value is used to find initial segments of strong edges. See\n<http://en.wikipedia.org/wiki/Canny_edge_detector>\n\n@param image 8-bit input image.\n@param edges output edge map; single channels 8-bit image, which has the same size as image .\n@param threshold1 first threshold for the hysteresis procedure.\n@param threshold2 second threshold for the hysteresis procedure.\n@param apertureSize aperture size for the Sobel operator.\n@param L2gradient a flag, indicating whether a more accurate \\f$L_2\\f$ norm\n\\f$=\\sqrt{(dI/dx)^2 + (dI/dy)^2}\\f$ should be used to calculate the image gradient magnitude (\nL2gradient=true ), or whether the default \\f$L_1\\f$ norm \\f$=|dI/dx|+|dI/dy|\\f$ is enough (\nL2gradient=false )."]
    #[link_name = "\u{1}_ZN2cv5CannyERKNS_11_InputArrayERKNS_12_OutputArrayEddib"]
    pub fn cv_Canny(
        image: cv_InputArray,
        edges: cv_OutputArray,
        threshold1: f64,
        threshold2: f64,
        apertureSize: ::std::os::raw::c_int,
        L2gradient: bool,
    );
}
unsafe extern "C" {
    #[doc = " \\overload\n\nFinds edges in an image using the Canny algorithm with custom image gradient.\n\n@param dx 16-bit x derivative of input image (CV_16SC1 or CV_16SC3).\n@param dy 16-bit y derivative of input image (same type as dx).\n@param edges output edge map; single channels 8-bit image, which has the same size as image .\n@param threshold1 first threshold for the hysteresis procedure.\n@param threshold2 second threshold for the hysteresis procedure.\n@param L2gradient a flag, indicating whether a more accurate \\f$L_2\\f$ norm\n\\f$=\\sqrt{(dI/dx)^2 + (dI/dy)^2}\\f$ should be used to calculate the image gradient magnitude (\nL2gradient=true ), or whether the default \\f$L_1\\f$ norm \\f$=|dI/dx|+|dI/dy|\\f$ is enough (\nL2gradient=false )."]
    #[link_name = "\u{1}_ZN2cv5CannyERKNS_11_InputArrayES2_RKNS_12_OutputArrayEddb"]
    pub fn cv_Canny1(
        dx: cv_InputArray,
        dy: cv_InputArray,
        edges: cv_OutputArray,
        threshold1: f64,
        threshold2: f64,
        L2gradient: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the minimal eigenvalue of gradient matrices for corner detection.\n\nThe function is similar to cornerEigenValsAndVecs but it calculates and stores only the minimal\neigenvalue of the covariance matrix of derivatives, that is, \\f$\\min(\\lambda_1, \\lambda_2)\\f$ in terms\nof the formulae in the cornerEigenValsAndVecs description.\n\n@param src Input single-channel 8-bit or floating-point image.\n@param dst Image to store the minimal eigenvalues. It has the type CV_32FC1 and the same size as\nsrc .\n@param blockSize Neighborhood size (see the details on #cornerEigenValsAndVecs ).\n@param ksize Aperture parameter for the Sobel operator.\n@param borderType Pixel extrapolation method. See #BorderTypes."]
    #[link_name = "\u{1}_ZN2cv17cornerMinEigenValERKNS_11_InputArrayERKNS_12_OutputArrayEiii"]
    pub fn cv_cornerMinEigenVal(
        src: cv_InputArray,
        dst: cv_OutputArray,
        blockSize: ::std::os::raw::c_int,
        ksize: ::std::os::raw::c_int,
        borderType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Harris corner detector.\n\nThe function runs the Harris corner detector on the image. Similarly to cornerMinEigenVal and\ncornerEigenValsAndVecs , for each pixel \\f$(x, y)\\f$ it calculates a \\f$2\\times2\\f$ gradient covariance\nmatrix \\f$M^{(x,y)}\\f$ over a \\f$\\texttt{blockSize} \\times \\texttt{blockSize}\\f$ neighborhood. Then, it\ncomputes the following characteristic:\n\n\\f[\\texttt{dst} (x,y) =  \\mathrm{det} M^{(x,y)} - k  \\cdot \\left ( \\mathrm{tr} M^{(x,y)} \\right )^2\\f]\n\nCorners in the image can be found as the local maxima of this response map.\n\n@param src Input single-channel 8-bit or floating-point image.\n@param dst Image to store the Harris detector responses. It has the type CV_32FC1 and the same\nsize as src .\n@param blockSize Neighborhood size (see the details on #cornerEigenValsAndVecs ).\n@param ksize Aperture parameter for the Sobel operator.\n@param k Harris detector free parameter. See the formula above.\n@param borderType Pixel extrapolation method. See #BorderTypes."]
    #[link_name = "\u{1}_ZN2cv12cornerHarrisERKNS_11_InputArrayERKNS_12_OutputArrayEiidi"]
    pub fn cv_cornerHarris(
        src: cv_InputArray,
        dst: cv_OutputArray,
        blockSize: ::std::os::raw::c_int,
        ksize: ::std::os::raw::c_int,
        k: f64,
        borderType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates eigenvalues and eigenvectors of image blocks for corner detection.\n\nFor every pixel \\f$p\\f$ , the function cornerEigenValsAndVecs considers a blockSize \\f$\\times\\f$ blockSize\nneighborhood \\f$S(p)\\f$ . It calculates the covariation matrix of derivatives over the neighborhood as:\n\n\\f[M =  \\begin{bmatrix} \\sum _{S(p)}(dI/dx)^2 &  \\sum _{S(p)}dI/dx dI/dy  \\\\ \\sum _{S(p)}dI/dx dI/dy &  \\sum _{S(p)}(dI/dy)^2 \\end{bmatrix}\\f]\n\nwhere the derivatives are computed using the Sobel operator.\n\nAfter that, it finds eigenvectors and eigenvalues of \\f$M\\f$ and stores them in the destination image as\n\\f$(\\lambda_1, \\lambda_2, x_1, y_1, x_2, y_2)\\f$ where\n\n-   \\f$\\lambda_1, \\lambda_2\\f$ are the non-sorted eigenvalues of \\f$M\\f$\n-   \\f$x_1, y_1\\f$ are the eigenvectors corresponding to \\f$\\lambda_1\\f$\n-   \\f$x_2, y_2\\f$ are the eigenvectors corresponding to \\f$\\lambda_2\\f$\n\nThe output of the function can be used for robust edge or corner detection.\n\n@param src Input single-channel 8-bit or floating-point image.\n@param dst Image to store the results. It has the same size as src and the type CV_32FC(6) .\n@param blockSize Neighborhood size (see details below).\n@param ksize Aperture parameter for the Sobel operator.\n@param borderType Pixel extrapolation method. See #BorderTypes.\n\n@sa  cornerMinEigenVal, cornerHarris, preCornerDetect"]
    #[link_name = "\u{1}_ZN2cv22cornerEigenValsAndVecsERKNS_11_InputArrayERKNS_12_OutputArrayEiii"]
    pub fn cv_cornerEigenValsAndVecs(
        src: cv_InputArray,
        dst: cv_OutputArray,
        blockSize: ::std::os::raw::c_int,
        ksize: ::std::os::raw::c_int,
        borderType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates a feature map for corner detection.\n\nThe function calculates the complex spatial derivative-based function of the source image\n\n\\f[\\texttt{dst} = (D_x  \\texttt{src} )^2  \\cdot D_{yy}  \\texttt{src} + (D_y  \\texttt{src} )^2  \\cdot D_{xx}  \\texttt{src} - 2 D_x  \\texttt{src} \\cdot D_y  \\texttt{src} \\cdot D_{xy}  \\texttt{src}\\f]\n\nwhere \\f$D_x\\f$,\\f$D_y\\f$ are the first image derivatives, \\f$D_{xx}\\f$,\\f$D_{yy}\\f$ are the second image\nderivatives, and \\f$D_{xy}\\f$ is the mixed derivative.\n\nThe corners can be found as local maximums of the functions, as shown below:\n@code\nMat corners, dilated_corners;\npreCornerDetect(image, corners, 3);\n// dilation with 3x3 rectangular structuring element\ndilate(corners, dilated_corners, Mat(), 1);\nMat corner_mask = corners == dilated_corners;\n@endcode\n\n@param src Source single-channel 8-bit of floating-point image.\n@param dst Output image that has the type CV_32F and the same size as src .\n@param ksize %Aperture size of the Sobel .\n@param borderType Pixel extrapolation method. See #BorderTypes."]
    #[link_name = "\u{1}_ZN2cv15preCornerDetectERKNS_11_InputArrayERKNS_12_OutputArrayEii"]
    pub fn cv_preCornerDetect(
        src: cv_InputArray,
        dst: cv_OutputArray,
        ksize: ::std::os::raw::c_int,
        borderType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Refines the corner locations.\n\nThe function iterates to find the sub-pixel accurate location of corners or radial saddle points, as\nshown on the figure below.\n\n[image](pics/cornersubpix.png)\n\nSub-pixel accurate corner locator is based on the observation that every vector from the center \\f$q\\f$\nto a point \\f$p\\f$ located within a neighborhood of \\f$q\\f$ is orthogonal to the image gradient at \\f$p\\f$\nsubject to image and measurement noise. Consider the expression:\n\n\\f[\\epsilon _i = {DI_{p_i}}^T  \\cdot (q - p_i)\\f]\n\nwhere \\f${DI_{p_i}}\\f$ is an image gradient at one of the points \\f$p_i\\f$ in a neighborhood of \\f$q\\f$ . The\nvalue of \\f$q\\f$ is to be found so that \\f$\\epsilon_i\\f$ is minimized. A system of equations may be set up\nwith \\f$\\epsilon_i\\f$ set to zero:\n\n\\f[\\sum _i(DI_{p_i}  \\cdot {DI_{p_i}}^T) \\cdot q -  \\sum _i(DI_{p_i}  \\cdot {DI_{p_i}}^T  \\cdot p_i)\\f]\n\nwhere the gradients are summed within a neighborhood (\"search window\") of \\f$q\\f$ . Calling the first\ngradient term \\f$G\\f$ and the second gradient term \\f$b\\f$ gives:\n\n\\f[q = G^{-1}  \\cdot b\\f]\n\nThe algorithm sets the center of the neighborhood window at this new center \\f$q\\f$ and then iterates\nuntil the center stays within a set threshold.\n\n@param image Input single-channel, 8-bit or float image.\n@param corners Initial coordinates of the input corners and refined coordinates provided for\noutput.\n@param winSize Half of the side length of the search window. For example, if winSize=Size(5,5) ,\nthen a \\f$(5*2+1) \\times (5*2+1) = 11 \\times 11\\f$ search window is used.\n@param zeroZone Half of the size of the dead region in the middle of the search zone over which\nthe summation in the formula below is not done. It is used sometimes to avoid possible\nsingularities of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such\na size.\n@param criteria Criteria for termination of the iterative process of corner refinement. That is,\nthe process of corner position refinement stops either after criteria.maxCount iterations or when\nthe corner position moves by less than criteria.epsilon on some iteration."]
    #[link_name = "\u{1}_ZN2cv12cornerSubPixERKNS_11_InputArrayERKNS_17_InputOutputArrayENS_5Size_IiEES7_NS_12TermCriteriaE"]
    pub fn cv_cornerSubPix(
        image: cv_InputArray,
        corners: cv_InputOutputArray,
        winSize: cv_Size,
        zeroZone: cv_Size,
        criteria: cv_TermCriteria,
    );
}
unsafe extern "C" {
    #[doc = " @brief Determines strong corners on an image.\n\nThe function finds the most prominent corners in the image or in the specified image region, as\ndescribed in @cite Shi94\n\n-   Function calculates the corner quality measure at every source image pixel using the\n#cornerMinEigenVal or #cornerHarris .\n-   Function performs a non-maximum suppression (the local maximums in *3 x 3* neighborhood are\nretained).\n-   The corners with the minimal eigenvalue less than\n\\f$\\texttt{qualityLevel} \\cdot \\max_{x,y} qualityMeasureMap(x,y)\\f$ are rejected.\n-   The remaining corners are sorted by the quality measure in the descending order.\n-   Function throws away each corner for which there is a stronger corner at a distance less than\nmaxDistance.\n\nThe function can be used to initialize a point-based tracker of an object.\n\n@note If the function is called with different values A and B of the parameter qualityLevel , and\nA \\> B, the vector of returned corners with qualityLevel=A will be the prefix of the output vector\nwith qualityLevel=B .\n\n@param image Input 8-bit or floating-point 32-bit, single-channel image.\n@param corners Output vector of detected corners.\n@param maxCorners Maximum number of corners to return. If there are more corners than are found,\nthe strongest of them is returned. `maxCorners <= 0` implies that no limit on the maximum is set\nand all detected corners are returned.\n@param qualityLevel Parameter characterizing the minimal accepted quality of image corners. The\nparameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue\n(see #cornerMinEigenVal ) or the Harris function response (see #cornerHarris ). The corners with the\nquality measure less than the product are rejected. For example, if the best corner has the\nquality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure\nless than 15 are rejected.\n@param minDistance Minimum possible Euclidean distance between the returned corners.\n@param mask Optional region of interest. If the image is not empty (it needs to have the type\nCV_8UC1 and the same size as image ), it specifies the region in which the corners are detected.\n@param blockSize Size of an average block for computing a derivative covariation matrix over each\npixel neighborhood. See cornerEigenValsAndVecs .\n@param useHarrisDetector Parameter indicating whether to use a Harris detector (see #cornerHarris)\nor #cornerMinEigenVal.\n@param k Free parameter of the Harris detector.\n\n@sa  cornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, estimateRigidTransform,"]
    #[link_name = "\u{1}_ZN2cv19goodFeaturesToTrackERKNS_11_InputArrayERKNS_12_OutputArrayEiddS2_ibd"]
    pub fn cv_goodFeaturesToTrack(
        image: cv_InputArray,
        corners: cv_OutputArray,
        maxCorners: ::std::os::raw::c_int,
        qualityLevel: f64,
        minDistance: f64,
        mask: cv_InputArray,
        blockSize: ::std::os::raw::c_int,
        useHarrisDetector: bool,
        k: f64,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv19goodFeaturesToTrackERKNS_11_InputArrayERKNS_12_OutputArrayEiddS2_iibd"]
    pub fn cv_goodFeaturesToTrack1(
        image: cv_InputArray,
        corners: cv_OutputArray,
        maxCorners: ::std::os::raw::c_int,
        qualityLevel: f64,
        minDistance: f64,
        mask: cv_InputArray,
        blockSize: ::std::os::raw::c_int,
        gradientSize: ::std::os::raw::c_int,
        useHarrisDetector: bool,
        k: f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Finds lines in a binary image using the standard Hough transform.\n\nThe function implements the standard or standard multi-scale Hough transform algorithm for line\ndetection. See <http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm> for a good explanation of Hough\ntransform.\n\n@param image 8-bit, single-channel binary source image. The image may be modified by the function.\n@param lines Output vector of lines. Each line is represented by a 2 or 3 element vector\n\\f$(\\rho, \\theta)\\f$ or \\f$(\\rho, \\theta, \\textrm{votes})\\f$ . \\f$\\rho\\f$ is the distance from the coordinate origin \\f$(0,0)\\f$ (top-left corner of\nthe image). \\f$\\theta\\f$ is the line rotation angle in radians (\n\\f$0 \\sim \\textrm{vertical line}, \\pi/2 \\sim \\textrm{horizontal line}\\f$ ).\n\\f$\\textrm{votes}\\f$ is the value of accumulator.\n@param rho Distance resolution of the accumulator in pixels.\n@param theta Angle resolution of the accumulator in radians.\n@param threshold Accumulator threshold parameter. Only those lines are returned that get enough\nvotes ( \\f$>\\texttt{threshold}\\f$ ).\n@param srn For the multi-scale Hough transform, it is a divisor for the distance resolution rho .\nThe coarse accumulator distance resolution is rho and the accurate accumulator resolution is\nrho/srn . If both srn=0 and stn=0 , the classical Hough transform is used. Otherwise, both these\nparameters should be positive.\n@param stn For the multi-scale Hough transform, it is a divisor for the distance resolution theta.\n@param min_theta For standard and multi-scale Hough transform, minimum angle to check for lines.\nMust fall between 0 and max_theta.\n@param max_theta For standard and multi-scale Hough transform, maximum angle to check for lines.\nMust fall between min_theta and CV_PI."]
    #[link_name = "\u{1}_ZN2cv10HoughLinesERKNS_11_InputArrayERKNS_12_OutputArrayEddidddd"]
    pub fn cv_HoughLines(
        image: cv_InputArray,
        lines: cv_OutputArray,
        rho: f64,
        theta: f64,
        threshold: ::std::os::raw::c_int,
        srn: f64,
        stn: f64,
        min_theta: f64,
        max_theta: f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Finds line segments in a binary image using the probabilistic Hough transform.\n\nThe function implements the probabilistic Hough transform algorithm for line detection, described\nin @cite Matas00\n\nSee the line detection example below:\n@include snippets/imgproc_HoughLinesP.cpp\nThis is a sample picture the function parameters have been tuned for:\n\n[image](pics/building.jpg)\n\nAnd this is the output of the above program in case of the probabilistic Hough transform:\n\n[image](pics/houghp.png)\n\n@param image 8-bit, single-channel binary source image. The image may be modified by the function.\n@param lines Output vector of lines. Each line is represented by a 4-element vector\n\\f$(x_1, y_1, x_2, y_2)\\f$ , where \\f$(x_1,y_1)\\f$ and \\f$(x_2, y_2)\\f$ are the ending points of each detected\nline segment.\n@param rho Distance resolution of the accumulator in pixels.\n@param theta Angle resolution of the accumulator in radians.\n@param threshold Accumulator threshold parameter. Only those lines are returned that get enough\nvotes ( \\f$>\\texttt{threshold}\\f$ ).\n@param minLineLength Minimum line length. Line segments shorter than that are rejected.\n@param maxLineGap Maximum allowed gap between points on the same line to link them.\n\n@sa LineSegmentDetector"]
    #[link_name = "\u{1}_ZN2cv11HoughLinesPERKNS_11_InputArrayERKNS_12_OutputArrayEddidd"]
    pub fn cv_HoughLinesP(
        image: cv_InputArray,
        lines: cv_OutputArray,
        rho: f64,
        theta: f64,
        threshold: ::std::os::raw::c_int,
        minLineLength: f64,
        maxLineGap: f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Finds lines in a set of points using the standard Hough transform.\n\nThe function finds lines in a set of points using a modification of the Hough transform.\n@include snippets/imgproc_HoughLinesPointSet.cpp\n@param _point Input vector of points. Each vector must be encoded as a Point vector \\f$(x,y)\\f$. Type must be CV_32FC2 or CV_32SC2.\n@param _lines Output vector of found lines. Each vector is encoded as a vector<Vec3d> \\f$(votes, rho, theta)\\f$.\nThe larger the value of 'votes', the higher the reliability of the Hough line.\n@param lines_max Max count of hough lines.\n@param threshold Accumulator threshold parameter. Only those lines are returned that get enough\nvotes ( \\f$>\\texttt{threshold}\\f$ )\n@param min_rho Minimum Distance value of the accumulator in pixels.\n@param max_rho Maximum Distance value of the accumulator in pixels.\n@param rho_step Distance resolution of the accumulator in pixels.\n@param min_theta Minimum angle value of the accumulator in radians.\n@param max_theta Maximum angle value of the accumulator in radians.\n@param theta_step Angle resolution of the accumulator in radians."]
    #[link_name = "\u{1}_ZN2cv18HoughLinesPointSetERKNS_11_InputArrayERKNS_12_OutputArrayEiidddddd"]
    pub fn cv_HoughLinesPointSet(
        _point: cv_InputArray,
        _lines: cv_OutputArray,
        lines_max: ::std::os::raw::c_int,
        threshold: ::std::os::raw::c_int,
        min_rho: f64,
        max_rho: f64,
        rho_step: f64,
        min_theta: f64,
        max_theta: f64,
        theta_step: f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Finds circles in a grayscale image using the Hough transform.\n\nThe function finds circles in a grayscale image using a modification of the Hough transform.\n\nExample: :\n@include snippets/imgproc_HoughLinesCircles.cpp\n\n@note Usually the function detects the centers of circles well. However, it may fail to find correct\nradii. You can assist to the function by specifying the radius range ( minRadius and maxRadius ) if\nyou know it. Or, you may set maxRadius to a negative number to return centers only without radius\nsearch, and find the correct radius using an additional procedure.\n\n@param image 8-bit, single-channel, grayscale input image.\n@param circles Output vector of found circles. Each vector is encoded as  3 or 4 element\nfloating-point vector \\f$(x, y, radius)\\f$ or \\f$(x, y, radius, votes)\\f$ .\n@param method Detection method, see #HoughModes. Currently, the only implemented method is #HOUGH_GRADIENT\n@param dp Inverse ratio of the accumulator resolution to the image resolution. For example, if\ndp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has\nhalf as big width and height.\n@param minDist Minimum distance between the centers of the detected circles. If the parameter is\ntoo small, multiple neighbor circles may be falsely detected in addition to a true one. If it is\ntoo large, some circles may be missed.\n@param param1 First method-specific parameter. In case of #HOUGH_GRADIENT , it is the higher\nthreshold of the two passed to the Canny edge detector (the lower one is twice smaller).\n@param param2 Second method-specific parameter. In case of #HOUGH_GRADIENT , it is the\naccumulator threshold for the circle centers at the detection stage. The smaller it is, the more\nfalse circles may be detected. Circles, corresponding to the larger accumulator values, will be\nreturned first.\n@param minRadius Minimum circle radius.\n@param maxRadius Maximum circle radius. If <= 0, uses the maximum image dimension. If < 0, returns\ncenters without finding the radius.\n\n@sa fitEllipse, minEnclosingCircle"]
    #[link_name = "\u{1}_ZN2cv12HoughCirclesERKNS_11_InputArrayERKNS_12_OutputArrayEiddddii"]
    pub fn cv_HoughCircles(
        image: cv_InputArray,
        circles: cv_OutputArray,
        method: ::std::os::raw::c_int,
        dp: f64,
        minDist: f64,
        param1: f64,
        param2: f64,
        minRadius: ::std::os::raw::c_int,
        maxRadius: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Erodes an image by using a specific structuring element.\n\nThe function erodes the source image using the specified structuring element that determines the\nshape of a pixel neighborhood over which the minimum is taken:\n\n\\f[\\texttt{dst} (x,y) =  \\min _{(x',y'):  \\, \\texttt{element} (x',y') \\ne0 } \\texttt{src} (x+x',y+y')\\f]\n\nThe function supports the in-place mode. Erosion can be applied several ( iterations ) times. In\ncase of multi-channel images, each channel is processed independently.\n\n@param src input image; the number of channels can be arbitrary, but the depth should be one of\nCV_8U, CV_16U, CV_16S, CV_32F or CV_64F.\n@param dst output image of the same size and type as src.\n@param kernel structuring element used for erosion; if `element=Mat()`, a `3 x 3` rectangular\nstructuring element is used. Kernel can be created using #getStructuringElement.\n@param anchor position of the anchor within the element; default value (-1, -1) means that the\nanchor is at the element center.\n@param iterations number of times erosion is applied.\n@param borderType pixel extrapolation method, see #BorderTypes\n@param borderValue border value in case of a constant border\n@sa  dilate, morphologyEx, getStructuringElement"]
    #[link_name = "\u{1}_ZN2cv5erodeERKNS_11_InputArrayERKNS_12_OutputArrayES2_NS_6Point_IiEEiiRKNS_7Scalar_IdEE"]
    pub fn cv_erode(
        src: cv_InputArray,
        dst: cv_OutputArray,
        kernel: cv_InputArray,
        anchor: cv_Point,
        iterations: ::std::os::raw::c_int,
        borderType: ::std::os::raw::c_int,
        borderValue: *const cv_Scalar,
    );
}
unsafe extern "C" {
    #[doc = " @brief Dilates an image by using a specific structuring element.\n\nThe function dilates the source image using the specified structuring element that determines the\nshape of a pixel neighborhood over which the maximum is taken:\n\\f[\\texttt{dst} (x,y) =  \\max _{(x',y'):  \\, \\texttt{element} (x',y') \\ne0 } \\texttt{src} (x+x',y+y')\\f]\n\nThe function supports the in-place mode. Dilation can be applied several ( iterations ) times. In\ncase of multi-channel images, each channel is processed independently.\n\n@param src input image; the number of channels can be arbitrary, but the depth should be one of\nCV_8U, CV_16U, CV_16S, CV_32F or CV_64F.\n@param dst output image of the same size and type as src.\n@param kernel structuring element used for dilation; if elemenat=Mat(), a 3 x 3 rectangular\nstructuring element is used. Kernel can be created using #getStructuringElement\n@param anchor position of the anchor within the element; default value (-1, -1) means that the\nanchor is at the element center.\n@param iterations number of times dilation is applied.\n@param borderType pixel extrapolation method, see #BorderTypes\n@param borderValue border value in case of a constant border\n@sa  erode, morphologyEx, getStructuringElement"]
    #[link_name = "\u{1}_ZN2cv6dilateERKNS_11_InputArrayERKNS_12_OutputArrayES2_NS_6Point_IiEEiiRKNS_7Scalar_IdEE"]
    pub fn cv_dilate(
        src: cv_InputArray,
        dst: cv_OutputArray,
        kernel: cv_InputArray,
        anchor: cv_Point,
        iterations: ::std::os::raw::c_int,
        borderType: ::std::os::raw::c_int,
        borderValue: *const cv_Scalar,
    );
}
unsafe extern "C" {
    #[doc = " @brief Performs advanced morphological transformations.\n\nThe function cv::morphologyEx can perform advanced morphological transformations using an erosion and dilation as\nbasic operations.\n\nAny of the operations can be done in-place. In case of multi-channel images, each channel is\nprocessed independently.\n\n@param src Source image. The number of channels can be arbitrary. The depth should be one of\nCV_8U, CV_16U, CV_16S, CV_32F or CV_64F.\n@param dst Destination image of the same size and type as source image.\n@param op Type of a morphological operation, see #MorphTypes\n@param kernel Structuring element. It can be created using #getStructuringElement.\n@param anchor Anchor position with the kernel. Negative values mean that the anchor is at the\nkernel center.\n@param iterations Number of times erosion and dilation are applied.\n@param borderType Pixel extrapolation method, see #BorderTypes\n@param borderValue Border value in case of a constant border. The default value has a special\nmeaning.\n@sa  dilate, erode, getStructuringElement\n@note The number of iterations is the number of times erosion or dilatation operation will be applied.\nFor instance, an opening operation (#MORPH_OPEN) with two iterations is equivalent to apply\nsuccessively: erode -> erode -> dilate -> dilate (and not erode -> dilate -> erode -> dilate)."]
    #[link_name = "\u{1}_ZN2cv12morphologyExERKNS_11_InputArrayERKNS_12_OutputArrayEiS2_NS_6Point_IiEEiiRKNS_7Scalar_IdEE"]
    pub fn cv_morphologyEx(
        src: cv_InputArray,
        dst: cv_OutputArray,
        op: ::std::os::raw::c_int,
        kernel: cv_InputArray,
        anchor: cv_Point,
        iterations: ::std::os::raw::c_int,
        borderType: ::std::os::raw::c_int,
        borderValue: *const cv_Scalar,
    );
}
unsafe extern "C" {
    #[doc = " @brief Resizes an image.\n\nThe function resize resizes the image src down to or up to the specified size. Note that the\ninitial dst type or size are not taken into account. Instead, the size and type are derived from\nthe `src`,`dsize`,`fx`, and `fy`. If you want to resize src so that it fits the pre-created dst,\nyou may call the function as follows:\n@code\n// explicitly specify dsize=dst.size(); fx and fy will be computed from that.\nresize(src, dst, dst.size(), 0, 0, interpolation);\n@endcode\nIf you want to decimate the image by factor of 2 in each direction, you can call the function this\nway:\n@code\n// specify fx and fy and let the function compute the destination image size.\nresize(src, dst, Size(), 0.5, 0.5, interpolation);\n@endcode\nTo shrink an image, it will generally look best with #INTER_AREA interpolation, whereas to\nenlarge an image, it will generally look best with c#INTER_CUBIC (slow) or #INTER_LINEAR\n(faster but still looks OK).\n\n@param src input image.\n@param dst output image; it has the size dsize (when it is non-zero) or the size computed from\nsrc.size(), fx, and fy; the type of dst is the same as of src.\n@param dsize output image size; if it equals zero, it is computed as:\n\\f[\\texttt{dsize = Size(round(fx*src.cols), round(fy*src.rows))}\\f]\nEither dsize or both fx and fy must be non-zero.\n@param fx scale factor along the horizontal axis; when it equals 0, it is computed as\n\\f[\\texttt{(double)dsize.width/src.cols}\\f]\n@param fy scale factor along the vertical axis; when it equals 0, it is computed as\n\\f[\\texttt{(double)dsize.height/src.rows}\\f]\n@param interpolation interpolation method, see #InterpolationFlags\n\n@sa  warpAffine, warpPerspective, remap"]
    #[link_name = "\u{1}_ZN2cv6resizeERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Size_IiEEddi"]
    pub fn cv_resize(
        src: cv_InputArray,
        dst: cv_OutputArray,
        dsize: cv_Size,
        fx: f64,
        fy: f64,
        interpolation: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Applies an affine transformation to an image.\n\nThe function warpAffine transforms the source image using the specified matrix:\n\n\\f[\\texttt{dst} (x,y) =  \\texttt{src} ( \\texttt{M} _{11} x +  \\texttt{M} _{12} y +  \\texttt{M} _{13}, \\texttt{M} _{21} x +  \\texttt{M} _{22} y +  \\texttt{M} _{23})\\f]\n\nwhen the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted\nwith #invertAffineTransform and then put in the formula above instead of M. The function cannot\noperate in-place.\n\n@param src input image.\n@param dst output image that has the size dsize and the same type as src .\n@param M \\f$2\\times 3\\f$ transformation matrix.\n@param dsize size of the output image.\n@param flags combination of interpolation methods (see #InterpolationFlags) and the optional\nflag #WARP_INVERSE_MAP that means that M is the inverse transformation (\n\\f$\\texttt{dst}\\rightarrow\\texttt{src}\\f$ ).\n@param borderMode pixel extrapolation method (see #BorderTypes); when\nborderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image corresponding to\nthe \"outliers\" in the source image are not modified by the function.\n@param borderValue value used in case of a constant border; by default, it is 0.\n\n@sa  warpPerspective, resize, remap, getRectSubPix, transform"]
    #[link_name = "\u{1}_ZN2cv10warpAffineERKNS_11_InputArrayERKNS_12_OutputArrayES2_NS_5Size_IiEEiiRKNS_7Scalar_IdEE"]
    pub fn cv_warpAffine(
        src: cv_InputArray,
        dst: cv_OutputArray,
        M: cv_InputArray,
        dsize: cv_Size,
        flags: ::std::os::raw::c_int,
        borderMode: ::std::os::raw::c_int,
        borderValue: *const cv_Scalar,
    );
}
unsafe extern "C" {
    #[doc = " @brief Applies a perspective transformation to an image.\n\nThe function warpPerspective transforms the source image using the specified matrix:\n\n\\f[\\texttt{dst} (x,y) =  \\texttt{src} \\left ( \\frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} ,\n\\frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \\right )\\f]\n\nwhen the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted with invert\nand then put in the formula above instead of M. The function cannot operate in-place.\n\n@param src input image.\n@param dst output image that has the size dsize and the same type as src .\n@param M \\f$3\\times 3\\f$ transformation matrix.\n@param dsize size of the output image.\n@param flags combination of interpolation methods (#INTER_LINEAR or #INTER_NEAREST) and the\noptional flag #WARP_INVERSE_MAP, that sets M as the inverse transformation (\n\\f$\\texttt{dst}\\rightarrow\\texttt{src}\\f$ ).\n@param borderMode pixel extrapolation method (#BORDER_CONSTANT or #BORDER_REPLICATE).\n@param borderValue value used in case of a constant border; by default, it equals 0.\n\n@sa  warpAffine, resize, remap, getRectSubPix, perspectiveTransform"]
    #[link_name = "\u{1}_ZN2cv15warpPerspectiveERKNS_11_InputArrayERKNS_12_OutputArrayES2_NS_5Size_IiEEiiRKNS_7Scalar_IdEE"]
    pub fn cv_warpPerspective(
        src: cv_InputArray,
        dst: cv_OutputArray,
        M: cv_InputArray,
        dsize: cv_Size,
        flags: ::std::os::raw::c_int,
        borderMode: ::std::os::raw::c_int,
        borderValue: *const cv_Scalar,
    );
}
unsafe extern "C" {
    #[doc = " @brief Applies a generic geometrical transformation to an image.\n\nThe function remap transforms the source image using the specified map:\n\n\\f[\\texttt{dst} (x,y) =  \\texttt{src} (map_x(x,y),map_y(x,y))\\f]\n\nwhere values of pixels with non-integer coordinates are computed using one of available\ninterpolation methods. \\f$map_x\\f$ and \\f$map_y\\f$ can be encoded as separate floating-point maps\nin \\f$map_1\\f$ and \\f$map_2\\f$ respectively, or interleaved floating-point maps of \\f$(x,y)\\f$ in\n\\f$map_1\\f$, or fixed-point maps created by using convertMaps. The reason you might want to\nconvert from floating to fixed-point representations of a map is that they can yield much faster\n(\\~2x) remapping operations. In the converted case, \\f$map_1\\f$ contains pairs (cvFloor(x),\ncvFloor(y)) and \\f$map_2\\f$ contains indices in a table of interpolation coefficients.\n\nThis function cannot operate in-place.\n\n@param src Source image.\n@param dst Destination image. It has the same size as map1 and the same type as src .\n@param map1 The first map of either (x,y) points or just x values having the type CV_16SC2 ,\nCV_32FC1, or CV_32FC2. See convertMaps for details on converting a floating point\nrepresentation to fixed-point for speed.\n@param map2 The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map\nif map1 is (x,y) points), respectively.\n@param interpolation Interpolation method (see #InterpolationFlags). The method #INTER_AREA is\nnot supported by this function.\n@param borderMode Pixel extrapolation method (see #BorderTypes). When\nborderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image that\ncorresponds to the \"outliers\" in the source image are not modified by the function.\n@param borderValue Value used in case of a constant border. By default, it is 0.\n@note\nDue to current implementation limitations the size of an input and output images should be less than 32767x32767."]
    #[link_name = "\u{1}_ZN2cv5remapERKNS_11_InputArrayERKNS_12_OutputArrayES2_S2_iiRKNS_7Scalar_IdEE"]
    pub fn cv_remap(
        src: cv_InputArray,
        dst: cv_OutputArray,
        map1: cv_InputArray,
        map2: cv_InputArray,
        interpolation: ::std::os::raw::c_int,
        borderMode: ::std::os::raw::c_int,
        borderValue: *const cv_Scalar,
    );
}
unsafe extern "C" {
    #[doc = " @brief Converts image transformation maps from one representation to another.\n\nThe function converts a pair of maps for remap from one representation to another. The following\noptions ( (map1.type(), map2.type()) \\f$\\rightarrow\\f$ (dstmap1.type(), dstmap2.type()) ) are\nsupported:\n\n- \\f$\\texttt{(CV_32FC1, CV_32FC1)} \\rightarrow \\texttt{(CV_16SC2, CV_16UC1)}\\f$. This is the\nmost frequently used conversion operation, in which the original floating-point maps (see remap )\nare converted to a more compact and much faster fixed-point representation. The first output array\ncontains the rounded coordinates and the second array (created only when nninterpolation=false )\ncontains indices in the interpolation tables.\n\n- \\f$\\texttt{(CV_32FC2)} \\rightarrow \\texttt{(CV_16SC2, CV_16UC1)}\\f$. The same as above but\nthe original maps are stored in one 2-channel matrix.\n\n- Reverse conversion. Obviously, the reconstructed floating-point maps will not be exactly the same\nas the originals.\n\n@param map1 The first input map of type CV_16SC2, CV_32FC1, or CV_32FC2 .\n@param map2 The second input map of type CV_16UC1, CV_32FC1, or none (empty matrix),\nrespectively.\n@param dstmap1 The first output map that has the type dstmap1type and the same size as src .\n@param dstmap2 The second output map.\n@param dstmap1type Type of the first output map that should be CV_16SC2, CV_32FC1, or\nCV_32FC2 .\n@param nninterpolation Flag indicating whether the fixed-point maps are used for the\nnearest-neighbor or for a more complex interpolation.\n\n@sa  remap, undistort, initUndistortRectifyMap"]
    #[link_name = "\u{1}_ZN2cv11convertMapsERKNS_11_InputArrayES2_RKNS_12_OutputArrayES5_ib"]
    pub fn cv_convertMaps(
        map1: cv_InputArray,
        map2: cv_InputArray,
        dstmap1: cv_OutputArray,
        dstmap2: cv_OutputArray,
        dstmap1type: ::std::os::raw::c_int,
        nninterpolation: bool,
    );
}
unsafe extern "C" {
    #[doc = " @sa getRotationMatrix2D"]
    #[link_name = "\u{1}_ZN2cv20getRotationMatrix2D_ENS_6Point_IfEEdd"]
    pub fn cv_getRotationMatrix2D_(center: cv_Point2f, angle: f64, scale: f64) -> cv_Matx23d;
}
unsafe extern "C" {
    #[doc = " @brief Calculates an affine transform from three pairs of the corresponding points.\n\nThe function calculates the \\f$2 \\times 3\\f$ matrix of an affine transform so that:\n\n\\f[\\begin{bmatrix} x'_i \\\\ y'_i \\end{bmatrix} = \\texttt{map_matrix} \\cdot \\begin{bmatrix} x_i \\\\ y_i \\\\ 1 \\end{bmatrix}\\f]\n\nwhere\n\n\\f[dst(i)=(x'_i,y'_i), src(i)=(x_i, y_i), i=0,1,2\\f]\n\n@param src Coordinates of triangle vertices in the source image.\n@param dst Coordinates of the corresponding triangle vertices in the destination image.\n\n@sa  warpAffine, transform"]
    #[link_name = "\u{1}_ZN2cv18getAffineTransformEPKNS_6Point_IfEES3_"]
    pub fn cv_getAffineTransform(src: *const cv_Point2f, dst: *const cv_Point2f) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Inverts an affine transformation.\n\nThe function computes an inverse affine transformation represented by \\f$2 \\times 3\\f$ matrix M:\n\n\\f[\\begin{bmatrix} a_{11} & a_{12} & b_1  \\\\ a_{21} & a_{22} & b_2 \\end{bmatrix}\\f]\n\nThe result is also a \\f$2 \\times 3\\f$ matrix of the same type as M.\n\n@param M Original affine transformation.\n@param iM Output reverse affine transformation."]
    #[link_name = "\u{1}_ZN2cv21invertAffineTransformERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_invertAffineTransform(M: cv_InputArray, iM: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief Calculates a perspective transform from four pairs of the corresponding points.\n\nThe function calculates the \\f$3 \\times 3\\f$ matrix of a perspective transform so that:\n\n\\f[\\begin{bmatrix} t_i x'_i \\\\ t_i y'_i \\\\ t_i \\end{bmatrix} = \\texttt{map_matrix} \\cdot \\begin{bmatrix} x_i \\\\ y_i \\\\ 1 \\end{bmatrix}\\f]\n\nwhere\n\n\\f[dst(i)=(x'_i,y'_i), src(i)=(x_i, y_i), i=0,1,2,3\\f]\n\n@param src Coordinates of quadrangle vertices in the source image.\n@param dst Coordinates of the corresponding quadrangle vertices in the destination image.\n@param solveMethod method passed to cv::solve (#DecompTypes)\n\n@sa  findHomography, warpPerspective, perspectiveTransform"]
    #[link_name = "\u{1}_ZN2cv23getPerspectiveTransformERKNS_11_InputArrayES2_i"]
    pub fn cv_getPerspectiveTransform(
        src: cv_InputArray,
        dst: cv_InputArray,
        solveMethod: ::std::os::raw::c_int,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv23getPerspectiveTransformEPKNS_6Point_IfEES3_i"]
    pub fn cv_getPerspectiveTransform1(
        src: *const cv_Point2f,
        dst: *const cv_Point2f,
        solveMethod: ::std::os::raw::c_int,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv18getAffineTransformERKNS_11_InputArrayES2_"]
    pub fn cv_getAffineTransform1(src: cv_InputArray, dst: cv_InputArray) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Retrieves a pixel rectangle from an image with sub-pixel accuracy.\n\nThe function getRectSubPix extracts pixels from src:\n\n\\f[patch(x, y) = src(x +  \\texttt{center.x} - ( \\texttt{dst.cols} -1)*0.5, y +  \\texttt{center.y} - ( \\texttt{dst.rows} -1)*0.5)\\f]\n\nwhere the values of the pixels at non-integer coordinates are retrieved using bilinear\ninterpolation. Every channel of multi-channel images is processed independently. Also\nthe image should be a single channel or three channel image. While the center of the\nrectangle must be inside the image, parts of the rectangle may be outside.\n\n@param image Source image.\n@param patchSize Size of the extracted patch.\n@param center Floating point coordinates of the center of the extracted rectangle within the\nsource image. The center must be inside the image.\n@param patch Extracted patch that has the size patchSize and the same number of channels as src .\n@param patchType Depth of the extracted pixels. By default, they have the same depth as src .\n\n@sa  warpAffine, warpPerspective"]
    #[link_name = "\u{1}_ZN2cv13getRectSubPixERKNS_11_InputArrayENS_5Size_IiEENS_6Point_IfEERKNS_12_OutputArrayEi"]
    pub fn cv_getRectSubPix(
        image: cv_InputArray,
        patchSize: cv_Size,
        center: cv_Point2f,
        patch: cv_OutputArray,
        patchType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Remaps an image to semilog-polar coordinates space.\n\n@deprecated This function produces same result as cv::warpPolar(src, dst, src.size(), center, maxRadius, flags+WARP_POLAR_LOG);\n\n@internal\nTransform the source image using the following transformation (See @ref polar_remaps_reference_image \"Polar remaps reference image d)\"):\n\\f[\\begin{array}{l}\ndst( \\rho , \\phi ) = src(x,y) \\\\\ndst.size() \\leftarrow src.size()\n\\end{array}\\f]\n\nwhere\n\\f[\\begin{array}{l}\nI = (dx,dy) = (x - center.x,y - center.y) \\\\\n\\rho = M \\cdot log_e(\\texttt{magnitude} (I)) ,\\\\\n\\phi = Kangle \\cdot \\texttt{angle} (I) \\\\\n\\end{array}\\f]\n\nand\n\\f[\\begin{array}{l}\nM = src.cols / log_e(maxRadius) \\\\\nKangle = src.rows / 2\\Pi \\\\\n\\end{array}\\f]\n\nThe function emulates the human \"foveal\" vision and can be used for fast scale and\nrotation-invariant template matching, for object tracking and so forth.\n@param src Source image\n@param dst Destination image. It will have same size and type as src.\n@param center The transformation center; where the output precision is maximal\n@param M Magnitude scale parameter. It determines the radius of the bounding circle to transform too.\n@param flags A combination of interpolation methods, see #InterpolationFlags\n\n@note\n-   The function can not operate in-place.\n-   To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.\n\n@sa cv::linearPolar\n@endinternal"]
    #[link_name = "\u{1}_ZN2cv8logPolarERKNS_11_InputArrayERKNS_12_OutputArrayENS_6Point_IfEEdi"]
    pub fn cv_logPolar(
        src: cv_InputArray,
        dst: cv_OutputArray,
        center: cv_Point2f,
        M: f64,
        flags: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Remaps an image to polar coordinates space.\n\n@deprecated This function produces same result as cv::warpPolar(src, dst, src.size(), center, maxRadius, flags)\n\n@internal\nTransform the source image using the following transformation (See @ref polar_remaps_reference_image \"Polar remaps reference image c)\"):\n\\f[\\begin{array}{l}\ndst( \\rho , \\phi ) = src(x,y) \\\\\ndst.size() \\leftarrow src.size()\n\\end{array}\\f]\n\nwhere\n\\f[\\begin{array}{l}\nI = (dx,dy) = (x - center.x,y - center.y) \\\\\n\\rho = Kmag \\cdot \\texttt{magnitude} (I) ,\\\\\n\\phi = angle \\cdot \\texttt{angle} (I)\n\\end{array}\\f]\n\nand\n\\f[\\begin{array}{l}\nKx = src.cols / maxRadius \\\\\nKy = src.rows / 2\\Pi\n\\end{array}\\f]\n\n\n@param src Source image\n@param dst Destination image. It will have same size and type as src.\n@param center The transformation center;\n@param maxRadius The radius of the bounding circle to transform. It determines the inverse magnitude scale parameter too.\n@param flags A combination of interpolation methods, see #InterpolationFlags\n\n@note\n-   The function can not operate in-place.\n-   To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.\n\n@sa cv::logPolar\n@endinternal"]
    #[link_name = "\u{1}_ZN2cv11linearPolarERKNS_11_InputArrayERKNS_12_OutputArrayENS_6Point_IfEEdi"]
    pub fn cv_linearPolar(
        src: cv_InputArray,
        dst: cv_OutputArray,
        center: cv_Point2f,
        maxRadius: f64,
        flags: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " \\brief Remaps an image to polar or semilog-polar coordinates space\n\n@anchor polar_remaps_reference_image\n[Polar remaps reference](pics/polar_remap_doc.png)\n\nTransform the source image using the following transformation:\n\\f[\ndst(\\rho , \\phi ) = src(x,y)\n\\f]\n\nwhere\n\\f[\n\\begin{array}{l}\n\\vec{I} = (x - center.x, \\;y - center.y) \\\\\n\\phi = Kangle \\cdot \\texttt{angle} (\\vec{I}) \\\\\n\\rho = \\left\\{\\begin{matrix}\nKlin \\cdot \\texttt{magnitude} (\\vec{I}) & default \\\\\nKlog \\cdot log_e(\\texttt{magnitude} (\\vec{I})) & if \\; semilog \\\\\n\\end{matrix}\\right.\n\\end{array}\n\\f]\n\nand\n\\f[\n\\begin{array}{l}\nKangle = dsize.height / 2\\Pi \\\\\nKlin = dsize.width / maxRadius \\\\\nKlog = dsize.width / log_e(maxRadius) \\\\\n\\end{array}\n\\f]\n\n\n\\par Linear vs semilog mapping\n\nPolar mapping can be linear or semi-log. Add one of #WarpPolarMode to `flags` to specify the polar mapping mode.\n\nLinear is the default mode.\n\nThe semilog mapping emulates the human \"foveal\" vision that permit very high acuity on the line of sight (central vision)\nin contrast to peripheral vision where acuity is minor.\n\n\\par Option on `dsize`:\n\n- if both values in `dsize <=0 ` (default),\nthe destination image will have (almost) same area of source bounding circle:\n\\f[\\begin{array}{l}\ndsize.area  \\leftarrow (maxRadius^2 \\cdot \\Pi) \\\\\ndsize.width = \\texttt{cvRound}(maxRadius) \\\\\ndsize.height = \\texttt{cvRound}(maxRadius \\cdot \\Pi) \\\\\n\\end{array}\\f]\n\n\n- if only `dsize.height <= 0`,\nthe destination image area will be proportional to the bounding circle area but scaled by `Kx * Kx`:\n\\f[\\begin{array}{l}\ndsize.height = \\texttt{cvRound}(dsize.width \\cdot \\Pi) \\\\\n\\end{array}\n\\f]\n\n- if both values in `dsize > 0 `,\nthe destination image will have the given size therefore the area of the bounding circle will be scaled to `dsize`.\n\n\n\\par Reverse mapping\n\nYou can get reverse mapping adding #WARP_INVERSE_MAP to `flags`\n\\snippet polar_transforms.cpp InverseMap\n\nIn addiction, to calculate the original coordinate from a polar mapped coordinate \\f$(rho, phi)->(x, y)\\f$:\n\\snippet polar_transforms.cpp InverseCoordinate\n\n@param src Source image.\n@param dst Destination image. It will have same type as src.\n@param dsize The destination image size (see description for valid options).\n@param center The transformation center.\n@param maxRadius The radius of the bounding circle to transform. It determines the inverse magnitude scale parameter too.\n@param flags A combination of interpolation methods, #InterpolationFlags + #WarpPolarMode.\n- Add #WARP_POLAR_LINEAR to select linear polar mapping (default)\n- Add #WARP_POLAR_LOG to select semilog polar mapping\n- Add #WARP_INVERSE_MAP for reverse mapping.\n@note\n-  The function can not operate in-place.\n-  To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.\n-  This function uses #remap. Due to current implementation limitations the size of an input and output images should be less than 32767x32767.\n\n@sa cv::remap"]
    #[link_name = "\u{1}_ZN2cv9warpPolarERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Size_IiEENS_6Point_IfEEdi"]
    pub fn cv_warpPolar(
        src: cv_InputArray,
        dst: cv_OutputArray,
        dsize: cv_Size,
        center: cv_Point2f,
        maxRadius: f64,
        flags: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv8integralERKNS_11_InputArrayERKNS_12_OutputArrayEi"]
    pub fn cv_integral(src: cv_InputArray, sum: cv_OutputArray, sdepth: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv8integralERKNS_11_InputArrayERKNS_12_OutputArrayES5_ii"]
    pub fn cv_integral1(
        src: cv_InputArray,
        sum: cv_OutputArray,
        sqsum: cv_OutputArray,
        sdepth: ::std::os::raw::c_int,
        sqdepth: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the integral of an image.\n\nThe function calculates one or more integral images for the source image as follows:\n\n\\f[\\texttt{sum} (X,Y) =  \\sum _{x<X,y<Y}  \\texttt{image} (x,y)\\f]\n\n\\f[\\texttt{sqsum} (X,Y) =  \\sum _{x<X,y<Y}  \\texttt{image} (x,y)^2\\f]\n\n\\f[\\texttt{tilted} (X,Y) =  \\sum _{y<Y,abs(x-X+1) \\leq Y-y-1}  \\texttt{image} (x,y)\\f]\n\nUsing these integral images, you can calculate sum, mean, and standard deviation over a specific\nup-right or rotated rectangular region of the image in a constant time, for example:\n\n\\f[\\sum _{x_1 \\leq x < x_2,  \\, y_1  \\leq y < y_2}  \\texttt{image} (x,y) =  \\texttt{sum} (x_2,y_2)- \\texttt{sum} (x_1,y_2)- \\texttt{sum} (x_2,y_1)+ \\texttt{sum} (x_1,y_1)\\f]\n\nIt makes possible to do a fast blurring or fast block correlation with a variable window size, for\nexample. In case of multi-channel images, sums for each channel are accumulated independently.\n\nAs a practical example, the next figure shows the calculation of the integral of a straight\nrectangle Rect(3,3,3,2) and of a tilted rectangle Rect(5,1,2,3) . The selected pixels in the\noriginal image are shown, as well as the relative pixels in the integral images sum and tilted .\n\n[integral calculation example](pics/integral.png)\n\n@param src input image as \\f$W \\times H\\f$, 8-bit or floating-point (32f or 64f).\n@param sum integral image as \\f$(W+1)\\times (H+1)\\f$ , 32-bit integer or floating-point (32f or 64f).\n@param sqsum integral image for squared pixel values; it is \\f$(W+1)\\times (H+1)\\f$, double-precision\nfloating-point (64f) array.\n@param tilted integral for the image rotated by 45 degrees; it is \\f$(W+1)\\times (H+1)\\f$ array with\nthe same data type as sum.\n@param sdepth desired depth of the integral and the tilted integral images, CV_32S, CV_32F, or\nCV_64F.\n@param sqdepth desired depth of the integral image of squared pixel values, CV_32F or CV_64F."]
    #[link_name = "\u{1}_ZN2cv8integralERKNS_11_InputArrayERKNS_12_OutputArrayES5_S5_ii"]
    pub fn cv_integral2(
        src: cv_InputArray,
        sum: cv_OutputArray,
        sqsum: cv_OutputArray,
        tilted: cv_OutputArray,
        sdepth: ::std::os::raw::c_int,
        sqdepth: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Adds an image to the accumulator image.\n\nThe function adds src or some of its elements to dst :\n\n\\f[\\texttt{dst} (x,y)  \\leftarrow \\texttt{dst} (x,y) +  \\texttt{src} (x,y)  \\quad \\text{if} \\quad \\texttt{mask} (x,y)  \\ne 0\\f]\n\nThe function supports multi-channel images. Each channel is processed independently.\n\nThe function cv::accumulate can be used, for example, to collect statistics of a scene background\nviewed by a still camera and for the further foreground-background segmentation.\n\n@param src Input image of type CV_8UC(n), CV_16UC(n), CV_32FC(n) or CV_64FC(n), where n is a positive integer.\n@param dst %Accumulator image with the same number of channels as input image, and a depth of CV_32F or CV_64F.\n@param mask Optional operation mask.\n\n@sa  accumulateSquare, accumulateProduct, accumulateWeighted"]
    #[link_name = "\u{1}_ZN2cv10accumulateERKNS_11_InputArrayERKNS_17_InputOutputArrayES2_"]
    pub fn cv_accumulate(src: cv_InputArray, dst: cv_InputOutputArray, mask: cv_InputArray);
}
unsafe extern "C" {
    #[doc = " @brief Adds the square of a source image to the accumulator image.\n\nThe function adds the input image src or its selected region, raised to a power of 2, to the\naccumulator dst :\n\n\\f[\\texttt{dst} (x,y)  \\leftarrow \\texttt{dst} (x,y) +  \\texttt{src} (x,y)^2  \\quad \\text{if} \\quad \\texttt{mask} (x,y)  \\ne 0\\f]\n\nThe function supports multi-channel images. Each channel is processed independently.\n\n@param src Input image as 1- or 3-channel, 8-bit or 32-bit floating point.\n@param dst %Accumulator image with the same number of channels as input image, 32-bit or 64-bit\nfloating-point.\n@param mask Optional operation mask.\n\n@sa  accumulateSquare, accumulateProduct, accumulateWeighted"]
    #[link_name = "\u{1}_ZN2cv16accumulateSquareERKNS_11_InputArrayERKNS_17_InputOutputArrayES2_"]
    pub fn cv_accumulateSquare(src: cv_InputArray, dst: cv_InputOutputArray, mask: cv_InputArray);
}
unsafe extern "C" {
    #[doc = " @brief Adds the per-element product of two input images to the accumulator image.\n\nThe function adds the product of two images or their selected regions to the accumulator dst :\n\n\\f[\\texttt{dst} (x,y)  \\leftarrow \\texttt{dst} (x,y) +  \\texttt{src1} (x,y)  \\cdot \\texttt{src2} (x,y)  \\quad \\text{if} \\quad \\texttt{mask} (x,y)  \\ne 0\\f]\n\nThe function supports multi-channel images. Each channel is processed independently.\n\n@param src1 First input image, 1- or 3-channel, 8-bit or 32-bit floating point.\n@param src2 Second input image of the same type and the same size as src1 .\n@param dst %Accumulator image with the same number of channels as input images, 32-bit or 64-bit\nfloating-point.\n@param mask Optional operation mask.\n\n@sa  accumulate, accumulateSquare, accumulateWeighted"]
    #[link_name = "\u{1}_ZN2cv17accumulateProductERKNS_11_InputArrayES2_RKNS_17_InputOutputArrayES2_"]
    pub fn cv_accumulateProduct(
        src1: cv_InputArray,
        src2: cv_InputArray,
        dst: cv_InputOutputArray,
        mask: cv_InputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Updates a running average.\n\nThe function calculates the weighted sum of the input image src and the accumulator dst so that dst\nbecomes a running average of a frame sequence:\n\n\\f[\\texttt{dst} (x,y)  \\leftarrow (1- \\texttt{alpha} )  \\cdot \\texttt{dst} (x,y) +  \\texttt{alpha} \\cdot \\texttt{src} (x,y)  \\quad \\text{if} \\quad \\texttt{mask} (x,y)  \\ne 0\\f]\n\nThat is, alpha regulates the update speed (how fast the accumulator \"forgets\" about earlier images).\nThe function supports multi-channel images. Each channel is processed independently.\n\n@param src Input image as 1- or 3-channel, 8-bit or 32-bit floating point.\n@param dst %Accumulator image with the same number of channels as input image, 32-bit or 64-bit\nfloating-point.\n@param alpha Weight of the input image.\n@param mask Optional operation mask.\n\n@sa  accumulate, accumulateSquare, accumulateProduct"]
    #[link_name = "\u{1}_ZN2cv18accumulateWeightedERKNS_11_InputArrayERKNS_17_InputOutputArrayEdS2_"]
    pub fn cv_accumulateWeighted(
        src: cv_InputArray,
        dst: cv_InputOutputArray,
        alpha: f64,
        mask: cv_InputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief The function is used to detect translational shifts that occur between two images.\n\nThe operation takes advantage of the Fourier shift theorem for detecting the translational shift in\nthe frequency domain. It can be used for fast image registration as well as motion estimation. For\nmore information please see <http://en.wikipedia.org/wiki/Phase_correlation>\n\nCalculates the cross-power spectrum of two supplied source arrays. The arrays are padded if needed\nwith getOptimalDFTSize.\n\nThe function performs the following equations:\n- First it applies a Hanning window (see <http://en.wikipedia.org/wiki/Hann_function>) to each\nimage to remove possible edge effects. This window is cached until the array size changes to speed\nup processing time.\n- Next it computes the forward DFTs of each source array:\n\\f[\\mathbf{G}_a = \\mathcal{F}\\{src_1\\}, \\; \\mathbf{G}_b = \\mathcal{F}\\{src_2\\}\\f]\nwhere \\f$\\mathcal{F}\\f$ is the forward DFT.\n- It then computes the cross-power spectrum of each frequency domain array:\n\\f[R = \\frac{ \\mathbf{G}_a \\mathbf{G}_b^*}{|\\mathbf{G}_a \\mathbf{G}_b^*|}\\f]\n- Next the cross-correlation is converted back into the time domain via the inverse DFT:\n\\f[r = \\mathcal{F}^{-1}\\{R\\}\\f]\n- Finally, it computes the peak location and computes a 5x5 weighted centroid around the peak to\nachieve sub-pixel accuracy.\n\\f[(\\Delta x, \\Delta y) = \\texttt{weightedCentroid} \\{\\arg \\max_{(x, y)}\\{r\\}\\}\\f]\n- If non-zero, the response parameter is computed as the sum of the elements of r within the 5x5\ncentroid around the peak location. It is normalized to a maximum of 1 (meaning there is a single\npeak) and will be smaller when there are multiple peaks.\n\n@param src1 Source floating point array (CV_32FC1 or CV_64FC1)\n@param src2 Source floating point array (CV_32FC1 or CV_64FC1)\n@param window Floating point array with windowing coefficients to reduce edge effects (optional).\n@param response Signal power within the 5x5 centroid around the peak, between 0 and 1 (optional).\n@returns detected phase shift (sub-pixel) between the two arrays.\n\n@sa dft, getOptimalDFTSize, idft, mulSpectrums createHanningWindow"]
    #[link_name = "\u{1}_ZN2cv14phaseCorrelateERKNS_11_InputArrayES2_S2_Pd"]
    pub fn cv_phaseCorrelate(
        src1: cv_InputArray,
        src2: cv_InputArray,
        window: cv_InputArray,
        response: *mut f64,
    ) -> cv_Point2d;
}
unsafe extern "C" {
    #[doc = " @brief This function computes a Hanning window coefficients in two dimensions.\n\nSee (http://en.wikipedia.org/wiki/Hann_function) and (http://en.wikipedia.org/wiki/Window_function)\nfor more information.\n\nAn example is shown below:\n@code\n// create hanning window of size 100x100 and type CV_32F\nMat hann;\ncreateHanningWindow(hann, Size(100, 100), CV_32F);\n@endcode\n@param dst Destination array to place Hann coefficients in\n@param winSize The window size specifications (both width and height must be > 1)\n@param type Created array type"]
    #[link_name = "\u{1}_ZN2cv19createHanningWindowERKNS_12_OutputArrayENS_5Size_IiEEi"]
    pub fn cv_createHanningWindow(
        dst: cv_OutputArray,
        winSize: cv_Size,
        type_: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Applies a fixed-level threshold to each array element.\n\nThe function applies fixed-level thresholding to a multiple-channel array. The function is typically\nused to get a bi-level (binary) image out of a grayscale image ( #compare could be also used for\nthis purpose) or for removing a noise, that is, filtering out pixels with too small or too large\nvalues. There are several types of thresholding supported by the function. They are determined by\ntype parameter.\n\nAlso, the special values #THRESH_OTSU or #THRESH_TRIANGLE may be combined with one of the\nabove values. In these cases, the function determines the optimal threshold value using the Otsu's\nor Triangle algorithm and uses it instead of the specified thresh.\n\n@note Currently, the Otsu's and Triangle methods are implemented only for 8-bit single-channel images.\n\n@param src input array (multiple-channel, 8-bit or 32-bit floating point).\n@param dst output array of the same size  and type and the same number of channels as src.\n@param thresh threshold value.\n@param maxval maximum value to use with the #THRESH_BINARY and #THRESH_BINARY_INV thresholding\ntypes.\n@param type thresholding type (see #ThresholdTypes).\n@return the computed threshold value if Otsu's or Triangle methods used.\n\n@sa  adaptiveThreshold, findContours, compare, min, max"]
    #[link_name = "\u{1}_ZN2cv9thresholdERKNS_11_InputArrayERKNS_12_OutputArrayEddi"]
    pub fn cv_threshold(
        src: cv_InputArray,
        dst: cv_OutputArray,
        thresh: f64,
        maxval: f64,
        type_: ::std::os::raw::c_int,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Applies an adaptive threshold to an array.\n\nThe function transforms a grayscale image to a binary image according to the formulae:\n-   **THRESH_BINARY**\n\\f[dst(x,y) =  \\fork{\\texttt{maxValue}}{if \\(src(x,y) > T(x,y)\\)}{0}{otherwise}\\f]\n-   **THRESH_BINARY_INV**\n\\f[dst(x,y) =  \\fork{0}{if \\(src(x,y) > T(x,y)\\)}{\\texttt{maxValue}}{otherwise}\\f]\nwhere \\f$T(x,y)\\f$ is a threshold calculated individually for each pixel (see adaptiveMethod parameter).\n\nThe function can process the image in-place.\n\n@param src Source 8-bit single-channel image.\n@param dst Destination image of the same size and the same type as src.\n@param maxValue Non-zero value assigned to the pixels for which the condition is satisfied\n@param adaptiveMethod Adaptive thresholding algorithm to use, see #AdaptiveThresholdTypes.\nThe #BORDER_REPLICATE | #BORDER_ISOLATED is used to process boundaries.\n@param thresholdType Thresholding type that must be either #THRESH_BINARY or #THRESH_BINARY_INV,\nsee #ThresholdTypes.\n@param blockSize Size of a pixel neighborhood that is used to calculate a threshold value for the\npixel: 3, 5, 7, and so on.\n@param C Constant subtracted from the mean or weighted mean (see the details below). Normally, it\nis positive but may be zero or negative as well.\n\n@sa  threshold, blur, GaussianBlur"]
    #[link_name = "\u{1}_ZN2cv17adaptiveThresholdERKNS_11_InputArrayERKNS_12_OutputArrayEdiiid"]
    pub fn cv_adaptiveThreshold(
        src: cv_InputArray,
        dst: cv_OutputArray,
        maxValue: f64,
        adaptiveMethod: ::std::os::raw::c_int,
        thresholdType: ::std::os::raw::c_int,
        blockSize: ::std::os::raw::c_int,
        C: f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Blurs an image and downsamples it.\n\nBy default, size of the output image is computed as `Size((src.cols+1)/2, (src.rows+1)/2)`, but in\nany case, the following conditions should be satisfied:\n\n\\f[\\begin{array}{l} | \\texttt{dstsize.width} *2-src.cols| \\leq 2 \\\\ | \\texttt{dstsize.height} *2-src.rows| \\leq 2 \\end{array}\\f]\n\nThe function performs the downsampling step of the Gaussian pyramid construction. First, it\nconvolves the source image with the kernel:\n\n\\f[\\frac{1}{256} \\begin{bmatrix} 1 & 4 & 6 & 4 & 1  \\\\ 4 & 16 & 24 & 16 & 4  \\\\ 6 & 24 & 36 & 24 & 6  \\\\ 4 & 16 & 24 & 16 & 4  \\\\ 1 & 4 & 6 & 4 & 1 \\end{bmatrix}\\f]\n\nThen, it downsamples the image by rejecting even rows and columns.\n\n@param src input image.\n@param dst output image; it has the specified size and the same type as src.\n@param dstsize size of the output image.\n@param borderType Pixel extrapolation method, see #BorderTypes (#BORDER_CONSTANT isn't supported)"]
    #[link_name = "\u{1}_ZN2cv7pyrDownERKNS_11_InputArrayERKNS_12_OutputArrayERKNS_5Size_IiEEi"]
    pub fn cv_pyrDown(
        src: cv_InputArray,
        dst: cv_OutputArray,
        dstsize: *const cv_Size,
        borderType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Upsamples an image and then blurs it.\n\nBy default, size of the output image is computed as `Size(src.cols\\*2, (src.rows\\*2)`, but in any\ncase, the following conditions should be satisfied:\n\n\\f[\\begin{array}{l} | \\texttt{dstsize.width} -src.cols*2| \\leq  ( \\texttt{dstsize.width}   \\mod  2)  \\\\ | \\texttt{dstsize.height} -src.rows*2| \\leq  ( \\texttt{dstsize.height}   \\mod  2) \\end{array}\\f]\n\nThe function performs the upsampling step of the Gaussian pyramid construction, though it can\nactually be used to construct the Laplacian pyramid. First, it upsamples the source image by\ninjecting even zero rows and columns and then convolves the result with the same kernel as in\npyrDown multiplied by 4.\n\n@param src input image.\n@param dst output image. It has the specified size and the same type as src .\n@param dstsize size of the output image.\n@param borderType Pixel extrapolation method, see #BorderTypes (only #BORDER_DEFAULT is supported)"]
    #[link_name = "\u{1}_ZN2cv5pyrUpERKNS_11_InputArrayERKNS_12_OutputArrayERKNS_5Size_IiEEi"]
    pub fn cv_pyrUp(
        src: cv_InputArray,
        dst: cv_OutputArray,
        dstsize: *const cv_Size,
        borderType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Constructs the Gaussian pyramid for an image.\n\nThe function constructs a vector of images and builds the Gaussian pyramid by recursively applying\npyrDown to the previously built pyramid layers, starting from `dst[0]==src`.\n\n@param src Source image. Check pyrDown for the list of supported types.\n@param dst Destination vector of maxlevel+1 images of the same type as src. dst[0] will be the\nsame as src. dst[1] is the next pyramid layer, a smoothed and down-sized src, and so on.\n@param maxlevel 0-based index of the last (the smallest) pyramid layer. It must be non-negative.\n@param borderType Pixel extrapolation method, see #BorderTypes (#BORDER_CONSTANT isn't supported)"]
    #[link_name = "\u{1}_ZN2cv12buildPyramidERKNS_11_InputArrayERKNS_12_OutputArrayEii"]
    pub fn cv_buildPyramid(
        src: cv_InputArray,
        dst: cv_OutputArrayOfArrays,
        maxlevel: ::std::os::raw::c_int,
        borderType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates a histogram of a set of arrays.\n\nThe function cv::calcHist calculates the histogram of one or more arrays. The elements of a tuple used\nto increment a histogram bin are taken from the corresponding input arrays at the same location. The\nsample below shows how to compute a 2D Hue-Saturation histogram for a color image. :\n@include snippets/imgproc_calcHist.cpp\n\n@param images Source arrays. They all should have the same depth, CV_8U, CV_16U or CV_32F , and the same\nsize. Each of them can have an arbitrary number of channels.\n@param nimages Number of source images.\n@param channels List of the dims channels used to compute the histogram. The first array channels\nare numerated from 0 to images[0].channels()-1 , the second array channels are counted from\nimages[0].channels() to images[0].channels() + images[1].channels()-1, and so on.\n@param mask Optional mask. If the matrix is not empty, it must be an 8-bit array of the same size\nas images[i] . The non-zero mask elements mark the array elements counted in the histogram.\n@param hist Output histogram, which is a dense or sparse dims -dimensional array.\n@param dims Histogram dimensionality that must be positive and not greater than CV_MAX_DIMS\n(equal to 32 in the current OpenCV version).\n@param histSize Array of histogram sizes in each dimension.\n@param ranges Array of the dims arrays of the histogram bin boundaries in each dimension. When the\nhistogram is uniform ( uniform =true), then for each dimension i it is enough to specify the lower\n(inclusive) boundary \\f$L_0\\f$ of the 0-th histogram bin and the upper (exclusive) boundary\n\\f$U_{\\texttt{histSize}[i]-1}\\f$ for the last histogram bin histSize[i]-1 . That is, in case of a\nuniform histogram each of ranges[i] is an array of 2 elements. When the histogram is not uniform (\nuniform=false ), then each of ranges[i] contains histSize[i]+1 elements:\n\\f$L_0, U_0=L_1, U_1=L_2, ..., U_{\\texttt{histSize[i]}-2}=L_{\\texttt{histSize[i]}-1}, U_{\\texttt{histSize[i]}-1}\\f$\n. The array elements, that are not between \\f$L_0\\f$ and \\f$U_{\\texttt{histSize[i]}-1}\\f$ , are not\ncounted in the histogram.\n@param uniform Flag indicating whether the histogram is uniform or not (see above).\n@param accumulate Accumulation flag. If it is set, the histogram is not cleared in the beginning\nwhen it is allocated. This feature enables you to compute a single histogram from several sets of\narrays, or to update the histogram in time."]
    #[link_name = "\u{1}_ZN2cv8calcHistEPKNS_3MatEiPKiRKNS_11_InputArrayERKNS_12_OutputArrayEiS4_PPKfbb"]
    pub fn cv_calcHist(
        images: *const cv_Mat,
        nimages: ::std::os::raw::c_int,
        channels: *const ::std::os::raw::c_int,
        mask: cv_InputArray,
        hist: cv_OutputArray,
        dims: ::std::os::raw::c_int,
        histSize: *const ::std::os::raw::c_int,
        ranges: *mut *const f32,
        uniform: bool,
        accumulate: bool,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n\nthis variant uses %SparseMat for output"]
    #[link_name = "\u{1}_ZN2cv8calcHistEPKNS_3MatEiPKiRKNS_11_InputArrayERNS_9SparseMatEiS4_PPKfbb"]
    pub fn cv_calcHist1(
        images: *const cv_Mat,
        nimages: ::std::os::raw::c_int,
        channels: *const ::std::os::raw::c_int,
        mask: cv_InputArray,
        hist: *mut cv_SparseMat,
        dims: ::std::os::raw::c_int,
        histSize: *const ::std::os::raw::c_int,
        ranges: *mut *const f32,
        uniform: bool,
        accumulate: bool,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv8calcHistERKNS_11_InputArrayERKSt6vectorIiSaIiEES2_RKNS_12_OutputArrayES7_RKS3_IfSaIfEEb"]
    pub fn cv_calcHist2(
        images: cv_InputArrayOfArrays,
        channels: *const std_vector,
        mask: cv_InputArray,
        hist: cv_OutputArray,
        histSize: *const std_vector,
        ranges: *const std_vector,
        accumulate: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the back projection of a histogram.\n\nThe function cv::calcBackProject calculates the back project of the histogram. That is, similarly to\n#calcHist , at each location (x, y) the function collects the values from the selected channels\nin the input images and finds the corresponding histogram bin. But instead of incrementing it, the\nfunction reads the bin value, scales it by scale , and stores in backProject(x,y) . In terms of\nstatistics, the function computes probability of each element value in respect with the empirical\nprobability distribution represented by the histogram. See how, for example, you can find and track\na bright-colored object in a scene:\n\n- Before tracking, show the object to the camera so that it covers almost the whole frame.\nCalculate a hue histogram. The histogram may have strong maximums, corresponding to the dominant\ncolors in the object.\n\n- When tracking, calculate a back projection of a hue plane of each input video frame using that\npre-computed histogram. Threshold the back projection to suppress weak colors. It may also make\nsense to suppress pixels with non-sufficient color saturation and too dark or too bright pixels.\n\n- Find connected components in the resulting picture and choose, for example, the largest\ncomponent.\n\nThis is an approximate algorithm of the CamShift color object tracker.\n\n@param images Source arrays. They all should have the same depth, CV_8U, CV_16U or CV_32F , and the same\nsize. Each of them can have an arbitrary number of channels.\n@param nimages Number of source images.\n@param channels The list of channels used to compute the back projection. The number of channels\nmust match the histogram dimensionality. The first array channels are numerated from 0 to\nimages[0].channels()-1 , the second array channels are counted from images[0].channels() to\nimages[0].channels() + images[1].channels()-1, and so on.\n@param hist Input histogram that can be dense or sparse.\n@param backProject Destination back projection array that is a single-channel array of the same\nsize and depth as images[0] .\n@param ranges Array of arrays of the histogram bin boundaries in each dimension. See #calcHist .\n@param scale Optional scale factor for the output back projection.\n@param uniform Flag indicating whether the histogram is uniform or not (see above).\n\n@sa calcHist, compareHist"]
    #[link_name = "\u{1}_ZN2cv15calcBackProjectEPKNS_3MatEiPKiRKNS_11_InputArrayERKNS_12_OutputArrayEPPKfdb"]
    pub fn cv_calcBackProject(
        images: *const cv_Mat,
        nimages: ::std::os::raw::c_int,
        channels: *const ::std::os::raw::c_int,
        hist: cv_InputArray,
        backProject: cv_OutputArray,
        ranges: *mut *const f32,
        scale: f64,
        uniform: bool,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv15calcBackProjectEPKNS_3MatEiPKiRKNS_9SparseMatERKNS_12_OutputArrayEPPKfdb"]
    pub fn cv_calcBackProject1(
        images: *const cv_Mat,
        nimages: ::std::os::raw::c_int,
        channels: *const ::std::os::raw::c_int,
        hist: *const cv_SparseMat,
        backProject: cv_OutputArray,
        ranges: *mut *const f32,
        scale: f64,
        uniform: bool,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv15calcBackProjectERKNS_11_InputArrayERKSt6vectorIiSaIiEES2_RKNS_12_OutputArrayERKS3_IfSaIfEEd"]
    pub fn cv_calcBackProject2(
        images: cv_InputArrayOfArrays,
        channels: *const std_vector,
        hist: cv_InputArray,
        dst: cv_OutputArray,
        ranges: *const std_vector,
        scale: f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Compares two histograms.\n\nThe function cv::compareHist compares two dense or two sparse histograms using the specified method.\n\nThe function returns \\f$d(H_1, H_2)\\f$ .\n\nWhile the function works well with 1-, 2-, 3-dimensional dense histograms, it may not be suitable\nfor high-dimensional sparse histograms. In such histograms, because of aliasing and sampling\nproblems, the coordinates of non-zero histogram bins can slightly shift. To compare such histograms\nor more general sparse configurations of weighted points, consider using the #EMD function.\n\n@param H1 First compared histogram.\n@param H2 Second compared histogram of the same size as H1 .\n@param method Comparison method, see #HistCompMethods"]
    #[link_name = "\u{1}_ZN2cv11compareHistERKNS_11_InputArrayES2_i"]
    pub fn cv_compareHist(
        H1: cv_InputArray,
        H2: cv_InputArray,
        method: ::std::os::raw::c_int,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv11compareHistERKNS_9SparseMatES2_i"]
    pub fn cv_compareHist1(
        H1: *const cv_SparseMat,
        H2: *const cv_SparseMat,
        method: ::std::os::raw::c_int,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Equalizes the histogram of a grayscale image.\n\nThe function equalizes the histogram of the input image using the following algorithm:\n\n- Calculate the histogram \\f$H\\f$ for src .\n- Normalize the histogram so that the sum of histogram bins is 255.\n- Compute the integral of the histogram:\n\\f[H'_i =  \\sum _{0  \\le j < i} H(j)\\f]\n- Transform the image using \\f$H'\\f$ as a look-up table: \\f$\\texttt{dst}(x,y) = H'(\\texttt{src}(x,y))\\f$\n\nThe algorithm normalizes the brightness and increases the contrast of the image.\n\n@param src Source 8-bit single channel image.\n@param dst Destination image of the same size and type as src ."]
    #[link_name = "\u{1}_ZN2cv12equalizeHistERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_equalizeHist(src: cv_InputArray, dst: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief Creates a smart pointer to a cv::CLAHE class and initializes it.\n\n@param clipLimit Threshold for contrast limiting.\n@param tileGridSize Size of grid for histogram equalization. Input image will be divided into\nequally sized rectangular tiles. tileGridSize defines the number of tiles in row and column."]
    #[link_name = "\u{1}_ZN2cv11createCLAHEEdNS_5Size_IiEE"]
    pub fn cv_createCLAHE(clipLimit: f64, tileGridSize: cv_Size) -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Computes the \"minimal work\" distance between two weighted point configurations.\n\nThe function computes the earth mover distance and/or a lower boundary of the distance between the\ntwo weighted point configurations. One of the applications described in @cite RubnerSept98,\n@cite Rubner2000 is multi-dimensional histogram comparison for image retrieval. EMD is a transportation\nproblem that is solved using some modification of a simplex algorithm, thus the complexity is\nexponential in the worst case, though, on average it is much faster. In the case of a real metric\nthe lower boundary can be calculated even faster (using linear-time algorithm) and it can be used\nto determine roughly whether the two signatures are far enough so that they cannot relate to the\nsame object.\n\n@param signature1 First signature, a \\f$\\texttt{size1}\\times \\texttt{dims}+1\\f$ floating-point matrix.\nEach row stores the point weight followed by the point coordinates. The matrix is allowed to have\na single column (weights only) if the user-defined cost matrix is used. The weights must be\nnon-negative and have at least one non-zero value.\n@param signature2 Second signature of the same format as signature1 , though the number of rows\nmay be different. The total weights may be different. In this case an extra \"dummy\" point is added\nto either signature1 or signature2. The weights must be non-negative and have at least one non-zero\nvalue.\n@param distType Used metric. See #DistanceTypes.\n@param cost User-defined \\f$\\texttt{size1}\\times \\texttt{size2}\\f$ cost matrix. Also, if a cost matrix\nis used, lower boundary lowerBound cannot be calculated because it needs a metric function.\n@param lowerBound Optional input/output parameter: lower boundary of a distance between the two\nsignatures that is a distance between mass centers. The lower boundary may not be calculated if\nthe user-defined cost matrix is used, the total weights of point configurations are not equal, or\nif the signatures consist of weights only (the signature matrices have a single column). You\nmust** initialize \\*lowerBound . If the calculated distance between mass centers is greater or\nequal to \\*lowerBound (it means that the signatures are far enough), the function does not\ncalculate EMD. In any case \\*lowerBound is set to the calculated distance between mass centers on\nreturn. Thus, if you want to calculate both distance between mass centers and EMD, \\*lowerBound\nshould be set to 0.\n@param flow Resultant \\f$\\texttt{size1} \\times \\texttt{size2}\\f$ flow matrix: \\f$\\texttt{flow}_{i,j}\\f$ is\na flow from \\f$i\\f$ -th point of signature1 to \\f$j\\f$ -th point of signature2 ."]
    #[link_name = "\u{1}_ZN2cv3EMDERKNS_11_InputArrayES2_iS2_PfRKNS_12_OutputArrayE"]
    pub fn cv_EMD(
        signature1: cv_InputArray,
        signature2: cv_InputArray,
        distType: ::std::os::raw::c_int,
        cost: cv_InputArray,
        lowerBound: *mut f32,
        flow: cv_OutputArray,
    ) -> f32;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv10wrapperEMDERKNS_11_InputArrayES2_iS2_NS_3PtrIfEERKNS_12_OutputArrayE"]
    pub fn cv_wrapperEMD(
        signature1: cv_InputArray,
        signature2: cv_InputArray,
        distType: ::std::os::raw::c_int,
        cost: cv_InputArray,
        lowerBound: cv_Ptr,
        flow: cv_OutputArray,
    ) -> f32;
}
unsafe extern "C" {
    #[doc = " @brief Performs a marker-based image segmentation using the watershed algorithm.\n\nThe function implements one of the variants of watershed, non-parametric marker-based segmentation\nalgorithm, described in @cite Meyer92 .\n\nBefore passing the image to the function, you have to roughly outline the desired regions in the\nimage markers with positive (\\>0) indices. So, every region is represented as one or more connected\ncomponents with the pixel values 1, 2, 3, and so on. Such markers can be retrieved from a binary\nmask using #findContours and #drawContours (see the watershed.cpp demo). The markers are \"seeds\" of\nthe future image regions. All the other pixels in markers , whose relation to the outlined regions\nis not known and should be defined by the algorithm, should be set to 0's. In the function output,\neach pixel in markers is set to a value of the \"seed\" components or to -1 at boundaries between the\nregions.\n\n@note Any two neighbor connected components are not necessarily separated by a watershed boundary\n(-1's pixels); for example, they can touch each other in the initial marker image passed to the\nfunction.\n\n@param image Input 8-bit 3-channel image.\n@param markers Input/output 32-bit single-channel image (map) of markers. It should have the same\nsize as image .\n\n@sa findContours\n\n@ingroup imgproc_misc"]
    #[link_name = "\u{1}_ZN2cv9watershedERKNS_11_InputArrayERKNS_17_InputOutputArrayE"]
    pub fn cv_watershed(image: cv_InputArray, markers: cv_InputOutputArray);
}
unsafe extern "C" {
    #[doc = " @brief Performs initial step of meanshift segmentation of an image.\n\nThe function implements the filtering stage of meanshift segmentation, that is, the output of the\nfunction is the filtered \"posterized\" image with color gradients and fine-grain texture flattened.\nAt every pixel (X,Y) of the input image (or down-sized input image, see below) the function executes\nmeanshift iterations, that is, the pixel (X,Y) neighborhood in the joint space-color hyperspace is\nconsidered:\n\n\\f[(x,y): X- \\texttt{sp} \\le x  \\le X+ \\texttt{sp} , Y- \\texttt{sp} \\le y  \\le Y+ \\texttt{sp} , ||(R,G,B)-(r,g,b)||   \\le \\texttt{sr}\\f]\n\nwhere (R,G,B) and (r,g,b) are the vectors of color components at (X,Y) and (x,y), respectively\n(though, the algorithm does not depend on the color space used, so any 3-component color space can\nbe used instead). Over the neighborhood the average spatial value (X',Y') and average color vector\n(R',G',B') are found and they act as the neighborhood center on the next iteration:\n\n\\f[(X,Y)~(X',Y'), (R,G,B)~(R',G',B').\\f]\n\nAfter the iterations over, the color components of the initial pixel (that is, the pixel from where\nthe iterations started) are set to the final value (average color at the last iteration):\n\n\\f[I(X,Y) <- (R*,G*,B*)\\f]\n\nWhen maxLevel \\> 0, the gaussian pyramid of maxLevel+1 levels is built, and the above procedure is\nrun on the smallest layer first. After that, the results are propagated to the larger layer and the\niterations are run again only on those pixels where the layer colors differ by more than sr from the\nlower-resolution layer of the pyramid. That makes boundaries of color regions sharper. Note that the\nresults will be actually different from the ones obtained by running the meanshift procedure on the\nwhole original image (i.e. when maxLevel==0).\n\n@param src The source 8-bit, 3-channel image.\n@param dst The destination image of the same format and the same size as the source.\n@param sp The spatial window radius.\n@param sr The color window radius.\n@param maxLevel Maximum level of the pyramid for the segmentation.\n@param termcrit Termination criteria: when to stop meanshift iterations."]
    #[link_name = "\u{1}_ZN2cv21pyrMeanShiftFilteringERKNS_11_InputArrayERKNS_12_OutputArrayEddiNS_12TermCriteriaE"]
    pub fn cv_pyrMeanShiftFiltering(
        src: cv_InputArray,
        dst: cv_OutputArray,
        sp: f64,
        sr: f64,
        maxLevel: ::std::os::raw::c_int,
        termcrit: cv_TermCriteria,
    );
}
unsafe extern "C" {
    #[doc = " @brief Runs the GrabCut algorithm.\n\nThe function implements the [GrabCut image segmentation algorithm](http://en.wikipedia.org/wiki/GrabCut).\n\n@param img Input 8-bit 3-channel image.\n@param mask Input/output 8-bit single-channel mask. The mask is initialized by the function when\nmode is set to #GC_INIT_WITH_RECT. Its elements may have one of the #GrabCutClasses.\n@param rect ROI containing a segmented object. The pixels outside of the ROI are marked as\n\"obvious background\". The parameter is only used when mode==#GC_INIT_WITH_RECT .\n@param bgdModel Temporary array for the background model. Do not modify it while you are\nprocessing the same image.\n@param fgdModel Temporary arrays for the foreground model. Do not modify it while you are\nprocessing the same image.\n@param iterCount Number of iterations the algorithm should make before returning the result. Note\nthat the result can be refined with further calls with mode==#GC_INIT_WITH_MASK or\nmode==GC_EVAL .\n@param mode Operation mode that could be one of the #GrabCutModes"]
    #[link_name = "\u{1}_ZN2cv7grabCutERKNS_11_InputArrayERKNS_17_InputOutputArrayENS_5Rect_IiEES5_S5_ii"]
    pub fn cv_grabCut(
        img: cv_InputArray,
        mask: cv_InputOutputArray,
        rect: cv_Rect,
        bgdModel: cv_InputOutputArray,
        fgdModel: cv_InputOutputArray,
        iterCount: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the distance to the closest zero pixel for each pixel of the source image.\n\nThe function cv::distanceTransform calculates the approximate or precise distance from every binary\nimage pixel to the nearest zero pixel. For zero image pixels, the distance will obviously be zero.\n\nWhen maskSize == #DIST_MASK_PRECISE and distanceType == #DIST_L2 , the function runs the\nalgorithm described in @cite Felzenszwalb04 . This algorithm is parallelized with the TBB library.\n\nIn other cases, the algorithm @cite Borgefors86 is used. This means that for a pixel the function\nfinds the shortest path to the nearest zero pixel consisting of basic shifts: horizontal, vertical,\ndiagonal, or knight's move (the latest is available for a \\f$5\\times 5\\f$ mask). The overall\ndistance is calculated as a sum of these basic distances. Since the distance function should be\nsymmetric, all of the horizontal and vertical shifts must have the same cost (denoted as a ), all\nthe diagonal shifts must have the same cost (denoted as `b`), and all knight's moves must have the\nsame cost (denoted as `c`). For the #DIST_C and #DIST_L1 types, the distance is calculated\nprecisely, whereas for #DIST_L2 (Euclidean distance) the distance can be calculated only with a\nrelative error (a \\f$5\\times 5\\f$ mask gives more accurate results). For `a`,`b`, and `c`, OpenCV\nuses the values suggested in the original paper:\n- DIST_L1: `a = 1, b = 2`\n- DIST_L2:\n- `3 x 3`: `a=0.955, b=1.3693`\n- `5 x 5`: `a=1, b=1.4, c=2.1969`\n- DIST_C: `a = 1, b = 1`\n\nTypically, for a fast, coarse distance estimation #DIST_L2, a \\f$3\\times 3\\f$ mask is used. For a\nmore accurate distance estimation #DIST_L2, a \\f$5\\times 5\\f$ mask or the precise algorithm is used.\nNote that both the precise and the approximate algorithms are linear on the number of pixels.\n\nThis variant of the function does not only compute the minimum distance for each pixel \\f$(x, y)\\f$\nbut also identifies the nearest connected component consisting of zero pixels\n(labelType==#DIST_LABEL_CCOMP) or the nearest zero pixel (labelType==#DIST_LABEL_PIXEL). Index of the\ncomponent/pixel is stored in `labels(x, y)`. When labelType==#DIST_LABEL_CCOMP, the function\nautomatically finds connected components of zero pixels in the input image and marks them with\ndistinct labels. When labelType==#DIST_LABEL_CCOMP, the function scans through the input image and\nmarks all the zero pixels with distinct labels.\n\nIn this mode, the complexity is still linear. That is, the function provides a very fast way to\ncompute the Voronoi diagram for a binary image. Currently, the second variant can use only the\napproximate distance transform algorithm, i.e. maskSize=#DIST_MASK_PRECISE is not supported\nyet.\n\n@param src 8-bit, single-channel (binary) source image.\n@param dst Output image with calculated distances. It is a 8-bit or 32-bit floating-point,\nsingle-channel image of the same size as src.\n@param labels Output 2D array of labels (the discrete Voronoi diagram). It has the type\nCV_32SC1 and the same size as src.\n@param distanceType Type of distance, see #DistanceTypes\n@param maskSize Size of the distance transform mask, see #DistanceTransformMasks.\n#DIST_MASK_PRECISE is not supported by this variant. In case of the #DIST_L1 or #DIST_C distance type,\nthe parameter is forced to 3 because a \\f$3\\times 3\\f$ mask gives the same result as \\f$5\\times\n5\\f$ or any larger aperture.\n@param labelType Type of the label array to build, see #DistanceTransformLabelTypes."]
    #[link_name = "\u{1}_ZN2cv17distanceTransformERKNS_11_InputArrayERKNS_12_OutputArrayES5_iii"]
    pub fn cv_distanceTransform(
        src: cv_InputArray,
        dst: cv_OutputArray,
        labels: cv_OutputArray,
        distanceType: ::std::os::raw::c_int,
        maskSize: ::std::os::raw::c_int,
        labelType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param src 8-bit, single-channel (binary) source image.\n@param dst Output image with calculated distances. It is a 8-bit or 32-bit floating-point,\nsingle-channel image of the same size as src .\n@param distanceType Type of distance, see #DistanceTypes\n@param maskSize Size of the distance transform mask, see #DistanceTransformMasks. In case of the\n#DIST_L1 or #DIST_C distance type, the parameter is forced to 3 because a \\f$3\\times 3\\f$ mask gives\nthe same result as \\f$5\\times 5\\f$ or any larger aperture.\n@param dstType Type of output image. It can be CV_8U or CV_32F. Type CV_8U can be used only for\nthe first variant of the function and distanceType == #DIST_L1."]
    #[link_name = "\u{1}_ZN2cv17distanceTransformERKNS_11_InputArrayERKNS_12_OutputArrayEiii"]
    pub fn cv_distanceTransform1(
        src: cv_InputArray,
        dst: cv_OutputArray,
        distanceType: ::std::os::raw::c_int,
        maskSize: ::std::os::raw::c_int,
        dstType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n\nvariant without `mask` parameter"]
    #[link_name = "\u{1}_ZN2cv9floodFillERKNS_17_InputOutputArrayENS_6Point_IiEENS_7Scalar_IdEEPNS_5Rect_IiEES6_S6_i"]
    pub fn cv_floodFill(
        image: cv_InputOutputArray,
        seedPoint: cv_Point,
        newVal: cv_Scalar,
        rect: *mut cv_Rect,
        loDiff: cv_Scalar,
        upDiff: cv_Scalar,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Fills a connected component with the given color.\n\nThe function cv::floodFill fills a connected component starting from the seed point with the specified\ncolor. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The\npixel at \\f$(x,y)\\f$ is considered to belong to the repainted domain if:\n\n- in case of a grayscale image and floating range\n\\f[\\texttt{src} (x',y')- \\texttt{loDiff} \\leq \\texttt{src} (x,y)  \\leq \\texttt{src} (x',y')+ \\texttt{upDiff}\\f]\n\n\n- in case of a grayscale image and fixed range\n\\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)- \\texttt{loDiff} \\leq \\texttt{src} (x,y)  \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)+ \\texttt{upDiff}\\f]\n\n\n- in case of a color image and floating range\n\\f[\\texttt{src} (x',y')_r- \\texttt{loDiff} _r \\leq \\texttt{src} (x,y)_r \\leq \\texttt{src} (x',y')_r+ \\texttt{upDiff} _r,\\f]\n\\f[\\texttt{src} (x',y')_g- \\texttt{loDiff} _g \\leq \\texttt{src} (x,y)_g \\leq \\texttt{src} (x',y')_g+ \\texttt{upDiff} _g\\f]\nand\n\\f[\\texttt{src} (x',y')_b- \\texttt{loDiff} _b \\leq \\texttt{src} (x,y)_b \\leq \\texttt{src} (x',y')_b+ \\texttt{upDiff} _b\\f]\n\n\n- in case of a color image and fixed range\n\\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_r- \\texttt{loDiff} _r \\leq \\texttt{src} (x,y)_r \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_r+ \\texttt{upDiff} _r,\\f]\n\\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_g- \\texttt{loDiff} _g \\leq \\texttt{src} (x,y)_g \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_g+ \\texttt{upDiff} _g\\f]\nand\n\\f[\\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_b- \\texttt{loDiff} _b \\leq \\texttt{src} (x,y)_b \\leq \\texttt{src} ( \\texttt{seedPoint} .x, \\texttt{seedPoint} .y)_b+ \\texttt{upDiff} _b\\f]\n\n\nwhere \\f$src(x',y')\\f$ is the value of one of pixel neighbors that is already known to belong to the\ncomponent. That is, to be added to the connected component, a color/brightness of the pixel should\nbe close enough to:\n- Color/brightness of one of its neighbors that already belong to the connected component in case\nof a floating range.\n- Color/brightness of the seed point in case of a fixed range.\n\nUse these functions to either mark a connected component with the specified color in-place, or build\na mask and then extract the contour, or copy the region to another image, and so on.\n\n@param image Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the\nfunction unless the #FLOODFILL_MASK_ONLY flag is set in the second variant of the function. See\nthe details below.\n@param mask Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels\ntaller than image. Since this is both an input and output parameter, you must take responsibility\nof initializing it. Flood-filling cannot go across non-zero pixels in the input mask. For example,\nan edge detector output can be used as a mask to stop filling at edges. On output, pixels in the\nmask corresponding to filled pixels in the image are set to 1 or to the a value specified in flags\nas described below. Additionally, the function fills the border of the mask with ones to simplify\ninternal processing. It is therefore possible to use the same mask in multiple calls to the function\nto make sure the filled areas do not overlap.\n@param seedPoint Starting point.\n@param newVal New value of the repainted domain pixels.\n@param loDiff Maximal lower brightness/color difference between the currently observed pixel and\none of its neighbors belonging to the component, or a seed pixel being added to the component.\n@param upDiff Maximal upper brightness/color difference between the currently observed pixel and\none of its neighbors belonging to the component, or a seed pixel being added to the component.\n@param rect Optional output parameter set by the function to the minimum bounding rectangle of the\nrepainted domain.\n@param flags Operation flags. The first 8 bits contain a connectivity value. The default value of\n4 means that only the four nearest neighbor pixels (those that share an edge) are considered. A\nconnectivity value of 8 means that the eight nearest neighbor pixels (those that share a corner)\nwill be considered. The next 8 bits (8-16) contain a value between 1 and 255 with which to fill\nthe mask (the default value is 1). For example, 4 | ( 255 \\<\\< 8 ) will consider 4 nearest\nneighbours and fill the mask with a value of 255. The following additional options occupy higher\nbits and therefore may be further combined with the connectivity and mask fill values using\nbit-wise or (|), see #FloodFillFlags.\n\n@note Since the mask is larger than the filled image, a pixel \\f$(x, y)\\f$ in image corresponds to the\npixel \\f$(x+1, y+1)\\f$ in the mask .\n\n@sa findContours"]
    #[link_name = "\u{1}_ZN2cv9floodFillERKNS_17_InputOutputArrayES2_NS_6Point_IiEENS_7Scalar_IdEEPNS_5Rect_IiEES6_S6_i"]
    pub fn cv_floodFill1(
        image: cv_InputOutputArray,
        mask: cv_InputOutputArray,
        seedPoint: cv_Point,
        newVal: cv_Scalar,
        rect: *mut cv_Rect,
        loDiff: cv_Scalar,
        upDiff: cv_Scalar,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! Performs linear blending of two images:\n! \\f[ \\texttt{dst}(i,j) = \\texttt{weights1}(i,j)*\\texttt{src1}(i,j) + \\texttt{weights2}(i,j)*\\texttt{src2}(i,j) \\f]\n! @param src1 It has a type of CV_8UC(n) or CV_32FC(n), where n is a positive integer.\n! @param src2 It has the same type and size as src1.\n! @param weights1 It has a type of CV_32FC1 and the same size with src1.\n! @param weights2 It has a type of CV_32FC1 and the same size with src1.\n! @param dst It is created if it does not have the same size and type with src1."]
    #[link_name = "\u{1}_ZN2cv11blendLinearERKNS_11_InputArrayES2_S2_S2_RKNS_12_OutputArrayE"]
    pub fn cv_blendLinear(
        src1: cv_InputArray,
        src2: cv_InputArray,
        weights1: cv_InputArray,
        weights2: cv_InputArray,
        dst: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Converts an image from one color space to another.\n\nThe function converts an input image from one color space to another. In case of a transformation\nto-from RGB color space, the order of the channels should be specified explicitly (RGB or BGR). Note\nthat the default color format in OpenCV is often referred to as RGB but it is actually BGR (the\nbytes are reversed). So the first byte in a standard (24-bit) color image will be an 8-bit Blue\ncomponent, the second byte will be Green, and the third byte will be Red. The fourth, fifth, and\nsixth bytes would then be the second pixel (Blue, then Green, then Red), and so on.\n\nThe conventional ranges for R, G, and B channel values are:\n-   0 to 255 for CV_8U images\n-   0 to 65535 for CV_16U images\n-   0 to 1 for CV_32F images\n\nIn case of linear transformations, the range does not matter. But in case of a non-linear\ntransformation, an input RGB image should be normalized to the proper value range to get the correct\nresults, for example, for RGB \\f$\\rightarrow\\f$ L\\*u\\*v\\* transformation. For example, if you have a\n32-bit floating-point image directly converted from an 8-bit image without any scaling, then it will\nhave the 0..255 value range instead of 0..1 assumed by the function. So, before calling #cvtColor ,\nyou need first to scale the image down:\n@code\nimg *= 1./255;\ncvtColor(img, img, COLOR_BGR2Luv);\n@endcode\nIf you use #cvtColor with 8-bit images, the conversion will have some information lost. For many\napplications, this will not be noticeable but it is recommended to use 32-bit images in applications\nthat need the full range of colors or that convert an image before an operation and then convert\nback.\n\nIf conversion adds the alpha channel, its value will set to the maximum of corresponding channel\nrange: 255 for CV_8U, 65535 for CV_16U, 1 for CV_32F.\n\n@param src input image: 8-bit unsigned, 16-bit unsigned ( CV_16UC... ), or single-precision\nfloating-point.\n@param dst output image of the same size and depth as src.\n@param code color space conversion code (see #ColorConversionCodes).\n@param dstCn number of channels in the destination image; if the parameter is 0, the number of the\nchannels is derived automatically from src and code.\n\n@see @ref imgproc_color_conversions"]
    #[link_name = "\u{1}_ZN2cv8cvtColorERKNS_11_InputArrayERKNS_12_OutputArrayEii"]
    pub fn cv_cvtColor(
        src: cv_InputArray,
        dst: cv_OutputArray,
        code: ::std::os::raw::c_int,
        dstCn: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Converts an image from one color space to another where the source image is\nstored in two planes.\n\nThis function only supports YUV420 to RGB conversion as of now.\n\n@param src1: 8-bit image (#CV_8U) of the Y plane.\n@param src2: image containing interleaved U/V plane.\n@param dst: output image.\n@param code: Specifies the type of conversion. It can take any of the following values:\n- #COLOR_YUV2BGR_NV12\n- #COLOR_YUV2RGB_NV12\n- #COLOR_YUV2BGRA_NV12\n- #COLOR_YUV2RGBA_NV12\n- #COLOR_YUV2BGR_NV21\n- #COLOR_YUV2RGB_NV21\n- #COLOR_YUV2BGRA_NV21\n- #COLOR_YUV2RGBA_NV21"]
    #[link_name = "\u{1}_ZN2cv16cvtColorTwoPlaneERKNS_11_InputArrayES2_RKNS_12_OutputArrayEi"]
    pub fn cv_cvtColorTwoPlane(
        src1: cv_InputArray,
        src2: cv_InputArray,
        dst: cv_OutputArray,
        code: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief main function for all demosaicing processes\n\n@param src input image: 8-bit unsigned or 16-bit unsigned.\n@param dst output image of the same size and depth as src.\n@param code Color space conversion code (see the description below).\n@param dstCn number of channels in the destination image; if the parameter is 0, the number of the\nchannels is derived automatically from src and code.\n\nThe function can do the following transformations:\n\n-   Demosaicing using bilinear interpolation\n\n#COLOR_BayerBG2BGR , #COLOR_BayerGB2BGR , #COLOR_BayerRG2BGR , #COLOR_BayerGR2BGR\n\n#COLOR_BayerBG2GRAY , #COLOR_BayerGB2GRAY , #COLOR_BayerRG2GRAY , #COLOR_BayerGR2GRAY\n\n-   Demosaicing using Variable Number of Gradients.\n\n#COLOR_BayerBG2BGR_VNG , #COLOR_BayerGB2BGR_VNG , #COLOR_BayerRG2BGR_VNG , #COLOR_BayerGR2BGR_VNG\n\n-   Edge-Aware Demosaicing.\n\n#COLOR_BayerBG2BGR_EA , #COLOR_BayerGB2BGR_EA , #COLOR_BayerRG2BGR_EA , #COLOR_BayerGR2BGR_EA\n\n-   Demosaicing with alpha channel\n\n#COLOR_BayerBG2BGRA , #COLOR_BayerGB2BGRA , #COLOR_BayerRG2BGRA , #COLOR_BayerGR2BGRA\n\n@sa cvtColor"]
    #[link_name = "\u{1}_ZN2cv11demosaicingERKNS_11_InputArrayERKNS_12_OutputArrayEii"]
    pub fn cv_demosaicing(
        src: cv_InputArray,
        dst: cv_OutputArray,
        code: ::std::os::raw::c_int,
        dstCn: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates all of the moments up to the third order of a polygon or rasterized shape.\n\nThe function computes moments, up to the 3rd order, of a vector shape or a rasterized shape. The\nresults are returned in the structure cv::Moments.\n\n@param array Raster image (single-channel, 8-bit or floating-point 2D array) or an array (\n\\f$1 \\times N\\f$ or \\f$N \\times 1\\f$ ) of 2D points (Point or Point2f ).\n@param binaryImage If it is true, all non-zero image pixels are treated as 1's. The parameter is\nused for images only.\n@returns moments.\n\n@note Only applicable to contour moments calculations from Python bindings: Note that the numpy\ntype for the input array should be either np.int32 or np.float32.\n\n@sa  contourArea, arcLength"]
    #[link_name = "\u{1}_ZN2cv7momentsERKNS_11_InputArrayEb"]
    pub fn cv_moments(array: cv_InputArray, binaryImage: bool) -> cv_Moments;
}
unsafe extern "C" {
    #[doc = " @brief Calculates seven Hu invariants.\n\nThe function calculates seven Hu invariants (introduced in @cite Hu62; see also\n<http://en.wikipedia.org/wiki/Image_moment>) defined as:\n\n\\f[\\begin{array}{l} hu[0]= \\eta _{20}+ \\eta _{02} \\\\ hu[1]=( \\eta _{20}- \\eta _{02})^{2}+4 \\eta _{11}^{2} \\\\ hu[2]=( \\eta _{30}-3 \\eta _{12})^{2}+ (3 \\eta _{21}- \\eta _{03})^{2} \\\\ hu[3]=( \\eta _{30}+ \\eta _{12})^{2}+ ( \\eta _{21}+ \\eta _{03})^{2} \\\\ hu[4]=( \\eta _{30}-3 \\eta _{12})( \\eta _{30}+ \\eta _{12})[( \\eta _{30}+ \\eta _{12})^{2}-3( \\eta _{21}+ \\eta _{03})^{2}]+(3 \\eta _{21}- \\eta _{03})( \\eta _{21}+ \\eta _{03})[3( \\eta _{30}+ \\eta _{12})^{2}-( \\eta _{21}+ \\eta _{03})^{2}] \\\\ hu[5]=( \\eta _{20}- \\eta _{02})[( \\eta _{30}+ \\eta _{12})^{2}- ( \\eta _{21}+ \\eta _{03})^{2}]+4 \\eta _{11}( \\eta _{30}+ \\eta _{12})( \\eta _{21}+ \\eta _{03}) \\\\ hu[6]=(3 \\eta _{21}- \\eta _{03})( \\eta _{21}+ \\eta _{03})[3( \\eta _{30}+ \\eta _{12})^{2}-( \\eta _{21}+ \\eta _{03})^{2}]-( \\eta _{30}-3 \\eta _{12})( \\eta _{21}+ \\eta _{03})[3( \\eta _{30}+ \\eta _{12})^{2}-( \\eta _{21}+ \\eta _{03})^{2}] \\\\ \\end{array}\\f]\n\nwhere \\f$\\eta_{ji}\\f$ stands for \\f$\\texttt{Moments::nu}_{ji}\\f$ .\n\nThese values are proved to be invariants to the image scale, rotation, and reflection except the\nseventh one, whose sign is changed by reflection. This invariance is proved with the assumption of\ninfinite image resolution. In case of raster images, the computed Hu invariants for the original and\ntransformed images are a bit different.\n\n@param moments Input moments computed with moments .\n@param hu Output Hu invariants.\n\n@sa matchShapes"]
    #[link_name = "\u{1}_ZN2cv9HuMomentsERKNS_7MomentsEPd"]
    pub fn cv_HuMoments(moments: *const cv_Moments, hu: *mut f64);
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv9HuMomentsERKNS_7MomentsERKNS_12_OutputArrayE"]
    pub fn cv_HuMoments1(m: *const cv_Moments, hu: cv_OutputArray);
}
#[doc = "!< \\f[R(x,y)= \\sum _{x',y'} (T(x',y')-I(x+x',y+y'))^2\\f]"]
pub const cv_TemplateMatchModes_TM_SQDIFF: cv_TemplateMatchModes = 0;
#[doc = "!< \\f[R(x,y)= \\frac{\\sum_{x',y'} (T(x',y')-I(x+x',y+y'))^2}{\\sqrt{\\sum_{x',y'}T(x',y')^2 \\cdot \\sum_{x',y'} I(x+x',y+y')^2}}\\f]"]
pub const cv_TemplateMatchModes_TM_SQDIFF_NORMED: cv_TemplateMatchModes = 1;
#[doc = "!< \\f[R(x,y)= \\sum _{x',y'} (T(x',y')  \\cdot I(x+x',y+y'))\\f]"]
pub const cv_TemplateMatchModes_TM_CCORR: cv_TemplateMatchModes = 2;
#[doc = "!< \\f[R(x,y)= \\frac{\\sum_{x',y'} (T(x',y') \\cdot I(x+x',y+y'))}{\\sqrt{\\sum_{x',y'}T(x',y')^2 \\cdot \\sum_{x',y'} I(x+x',y+y')^2}}\\f]"]
pub const cv_TemplateMatchModes_TM_CCORR_NORMED: cv_TemplateMatchModes = 3;
#[doc = "!< \\f[R(x,y)= \\sum _{x',y'} (T'(x',y')  \\cdot I'(x+x',y+y'))\\f]\n!< where\n!< \\f[\\begin{array}{l} T'(x',y')=T(x',y') - 1/(w  \\cdot h)  \\cdot \\sum _{x'',y''} T(x'',y'') \\\\ I'(x+x',y+y')=I(x+x',y+y') - 1/(w  \\cdot h)  \\cdot \\sum _{x'',y''} I(x+x'',y+y'') \\end{array}\\f]"]
pub const cv_TemplateMatchModes_TM_CCOEFF: cv_TemplateMatchModes = 4;
#[doc = "!< \\f[R(x,y)= \\frac{ \\sum_{x',y'} (T'(x',y') \\cdot I'(x+x',y+y')) }{ \\sqrt{\\sum_{x',y'}T'(x',y')^2 \\cdot \\sum_{x',y'} I'(x+x',y+y')^2} }\\f]"]
pub const cv_TemplateMatchModes_TM_CCOEFF_NORMED: cv_TemplateMatchModes = 5;
#[doc = "! type of the template matching operation"]
pub type cv_TemplateMatchModes = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Compares a template against overlapped image regions.\n\nThe function slides through image , compares the overlapped patches of size \\f$w \\times h\\f$ against\ntempl using the specified method and stores the comparison results in result . Here are the formulae\nfor the available comparison methods ( \\f$I\\f$ denotes image, \\f$T\\f$ template, \\f$R\\f$ result ). The summation\nis done over template and/or the image patch: \\f$x' = 0...w-1, y' = 0...h-1\\f$\n\nAfter the function finishes the comparison, the best matches can be found as global minimums (when\n#TM_SQDIFF was used) or maximums (when #TM_CCORR or #TM_CCOEFF was used) using the\n#minMaxLoc function. In case of a color image, template summation in the numerator and each sum in\nthe denominator is done over all of the channels and separate mean values are used for each channel.\nThat is, the function can take a color template and a color image. The result will still be a\nsingle-channel image, which is easier to analyze.\n\n@param image Image where the search is running. It must be 8-bit or 32-bit floating-point.\n@param templ Searched template. It must be not greater than the source image and have the same\ndata type.\n@param result Map of comparison results. It must be single-channel 32-bit floating-point. If image\nis \\f$W \\times H\\f$ and templ is \\f$w \\times h\\f$ , then result is \\f$(W-w+1) \\times (H-h+1)\\f$ .\n@param method Parameter specifying the comparison method, see #TemplateMatchModes\n@param mask Mask of searched template. It must have the same datatype and size with templ. It is\nnot set by default. Currently, only the #TM_SQDIFF and #TM_CCORR_NORMED methods are supported."]
    #[link_name = "\u{1}_ZN2cv13matchTemplateERKNS_11_InputArrayES2_RKNS_12_OutputArrayEiS2_"]
    pub fn cv_matchTemplate(
        image: cv_InputArray,
        templ: cv_InputArray,
        result: cv_OutputArray,
        method: ::std::os::raw::c_int,
        mask: cv_InputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief computes the connected components labeled image of boolean image\n\nimage with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0\nrepresents the background label. ltype specifies the output label image type, an important\nconsideration based on the total number of labels or alternatively the total number of pixels in\nthe source image. ccltype specifies the connected components labeling algorithm to use, currently\nGrana (BBDT) and Wu's (SAUF) algorithms are supported, see the #ConnectedComponentsAlgorithmsTypes\nfor details. Note that SAUF algorithm forces a row major ordering of labels while BBDT does not.\nThis function uses parallel version of both Grana and Wu's algorithms if at least one allowed\nparallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs.\n\n@param image the 8-bit single-channel image to be labeled\n@param labels destination labeled image\n@param connectivity 8 or 4 for 8-way or 4-way connectivity respectively\n@param ltype output image label type. Currently CV_32S and CV_16U are supported.\n@param ccltype connected components algorithm type (see the #ConnectedComponentsAlgorithmsTypes)."]
    #[link_name = "\u{1}_ZN2cv19connectedComponentsERKNS_11_InputArrayERKNS_12_OutputArrayEiii"]
    pub fn cv_connectedComponents(
        image: cv_InputArray,
        labels: cv_OutputArray,
        connectivity: ::std::os::raw::c_int,
        ltype: ::std::os::raw::c_int,
        ccltype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @overload\n\n@param image the 8-bit single-channel image to be labeled\n@param labels destination labeled image\n@param connectivity 8 or 4 for 8-way or 4-way connectivity respectively\n@param ltype output image label type. Currently CV_32S and CV_16U are supported."]
    #[link_name = "\u{1}_ZN2cv19connectedComponentsERKNS_11_InputArrayERKNS_12_OutputArrayEii"]
    pub fn cv_connectedComponents1(
        image: cv_InputArray,
        labels: cv_OutputArray,
        connectivity: ::std::os::raw::c_int,
        ltype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief computes the connected components labeled image of boolean image and also produces a statistics output for each label\n\nimage with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0\nrepresents the background label. ltype specifies the output label image type, an important\nconsideration based on the total number of labels or alternatively the total number of pixels in\nthe source image. ccltype specifies the connected components labeling algorithm to use, currently\nGrana's (BBDT) and Wu's (SAUF) algorithms are supported, see the #ConnectedComponentsAlgorithmsTypes\nfor details. Note that SAUF algorithm forces a row major ordering of labels while BBDT does not.\nThis function uses parallel version of both Grana and Wu's algorithms (statistics included) if at least one allowed\nparallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs.\n\n@param image the 8-bit single-channel image to be labeled\n@param labels destination labeled image\n@param stats statistics output for each label, including the background label, see below for\navailable statistics. Statistics are accessed via stats(label, COLUMN) where COLUMN is one of\n#ConnectedComponentsTypes. The data type is CV_32S.\n@param centroids centroid output for each label, including the background label. Centroids are\naccessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F.\n@param connectivity 8 or 4 for 8-way or 4-way connectivity respectively\n@param ltype output image label type. Currently CV_32S and CV_16U are supported.\n@param ccltype connected components algorithm type (see #ConnectedComponentsAlgorithmsTypes)."]
    #[link_name = "\u{1}_ZN2cv28connectedComponentsWithStatsERKNS_11_InputArrayERKNS_12_OutputArrayES5_S5_iii"]
    pub fn cv_connectedComponentsWithStats(
        image: cv_InputArray,
        labels: cv_OutputArray,
        stats: cv_OutputArray,
        centroids: cv_OutputArray,
        connectivity: ::std::os::raw::c_int,
        ltype: ::std::os::raw::c_int,
        ccltype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @overload\n@param image the 8-bit single-channel image to be labeled\n@param labels destination labeled image\n@param stats statistics output for each label, including the background label, see below for\navailable statistics. Statistics are accessed via stats(label, COLUMN) where COLUMN is one of\n#ConnectedComponentsTypes. The data type is CV_32S.\n@param centroids centroid output for each label, including the background label. Centroids are\naccessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F.\n@param connectivity 8 or 4 for 8-way or 4-way connectivity respectively\n@param ltype output image label type. Currently CV_32S and CV_16U are supported."]
    #[link_name = "\u{1}_ZN2cv28connectedComponentsWithStatsERKNS_11_InputArrayERKNS_12_OutputArrayES5_S5_ii"]
    pub fn cv_connectedComponentsWithStats1(
        image: cv_InputArray,
        labels: cv_OutputArray,
        stats: cv_OutputArray,
        centroids: cv_OutputArray,
        connectivity: ::std::os::raw::c_int,
        ltype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Finds contours in a binary image.\n\nThe function retrieves contours from the binary image using the algorithm @cite Suzuki85 . The contours\nare a useful tool for shape analysis and object detection and recognition. See squares.cpp in the\nOpenCV sample directory.\n@note Since opencv 3.2 source image is not modified by this function.\n\n@param image Source, an 8-bit single-channel image. Non-zero pixels are treated as 1's. Zero\npixels remain 0's, so the image is treated as binary . You can use #compare, #inRange, #threshold ,\n#adaptiveThreshold, #Canny, and others to create a binary image out of a grayscale or color one.\nIf mode equals to #RETR_CCOMP or #RETR_FLOODFILL, the input can also be a 32-bit integer image of labels (CV_32SC1).\n@param contours Detected contours. Each contour is stored as a vector of points (e.g.\nstd::vector<std::vector<cv::Point> >).\n@param hierarchy Optional output vector (e.g. std::vector<cv::Vec4i>), containing information about the image topology. It has\nas many elements as the number of contours. For each i-th contour contours[i], the elements\nhierarchy[i][0] , hierarchy[i][1] , hierarchy[i][2] , and hierarchy[i][3] are set to 0-based indices\nin contours of the next and previous contours at the same hierarchical level, the first child\ncontour and the parent contour, respectively. If for the contour i there are no next, previous,\nparent, or nested contours, the corresponding elements of hierarchy[i] will be negative.\n@param mode Contour retrieval mode, see #RetrievalModes\n@param method Contour approximation method, see #ContourApproximationModes\n@param offset Optional offset by which every contour point is shifted. This is useful if the\ncontours are extracted from the image ROI and then they should be analyzed in the whole image\ncontext."]
    #[link_name = "\u{1}_ZN2cv12findContoursERKNS_11_InputArrayERKNS_12_OutputArrayES5_iiNS_6Point_IiEE"]
    pub fn cv_findContours(
        image: cv_InputArray,
        contours: cv_OutputArrayOfArrays,
        hierarchy: cv_OutputArray,
        mode: ::std::os::raw::c_int,
        method: ::std::os::raw::c_int,
        offset: cv_Point,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv12findContoursERKNS_11_InputArrayERKNS_12_OutputArrayEiiNS_6Point_IiEE"]
    pub fn cv_findContours1(
        image: cv_InputArray,
        contours: cv_OutputArrayOfArrays,
        mode: ::std::os::raw::c_int,
        method: ::std::os::raw::c_int,
        offset: cv_Point,
    );
}
unsafe extern "C" {
    #[doc = " @brief Approximates a polygonal curve(s) with the specified precision.\n\nThe function cv::approxPolyDP approximates a curve or a polygon with another curve/polygon with less\nvertices so that the distance between them is less or equal to the specified precision. It uses the\nDouglas-Peucker algorithm <http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm>\n\n@param curve Input vector of a 2D point stored in std::vector or Mat\n@param approxCurve Result of the approximation. The type should match the type of the input curve.\n@param epsilon Parameter specifying the approximation accuracy. This is the maximum distance\nbetween the original curve and its approximation.\n@param closed If true, the approximated curve is closed (its first and last vertices are\nconnected). Otherwise, it is not closed."]
    #[link_name = "\u{1}_ZN2cv12approxPolyDPERKNS_11_InputArrayERKNS_12_OutputArrayEdb"]
    pub fn cv_approxPolyDP(
        curve: cv_InputArray,
        approxCurve: cv_OutputArray,
        epsilon: f64,
        closed: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates a contour perimeter or a curve length.\n\nThe function computes a curve length or a closed contour perimeter.\n\n@param curve Input vector of 2D points, stored in std::vector or Mat.\n@param closed Flag indicating whether the curve is closed or not."]
    #[link_name = "\u{1}_ZN2cv9arcLengthERKNS_11_InputArrayEb"]
    pub fn cv_arcLength(curve: cv_InputArray, closed: bool) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Calculates the up-right bounding rectangle of a point set or non-zero pixels of gray-scale image.\n\nThe function calculates and returns the minimal up-right bounding rectangle for the specified point set or\nnon-zero pixels of gray-scale image.\n\n@param array Input gray-scale image or 2D point set, stored in std::vector or Mat."]
    #[link_name = "\u{1}_ZN2cv12boundingRectERKNS_11_InputArrayE"]
    pub fn cv_boundingRect(array: cv_InputArray) -> cv_Rect;
}
unsafe extern "C" {
    #[doc = " @brief Calculates a contour area.\n\nThe function computes a contour area. Similarly to moments , the area is computed using the Green\nformula. Thus, the returned area and the number of non-zero pixels, if you draw the contour using\n#drawContours or #fillPoly , can be different. Also, the function will most certainly give a wrong\nresults for contours with self-intersections.\n\nExample:\n@code\nvector<Point> contour;\ncontour.push_back(Point2f(0, 0));\ncontour.push_back(Point2f(10, 0));\ncontour.push_back(Point2f(10, 10));\ncontour.push_back(Point2f(5, 4));\n\ndouble area0 = contourArea(contour);\nvector<Point> approx;\napproxPolyDP(contour, approx, 5, true);\ndouble area1 = contourArea(approx);\n\ncout << \"area0 =\" << area0 << endl <<\n\"area1 =\" << area1 << endl <<\n\"approx poly vertices\" << approx.size() << endl;\n@endcode\n@param contour Input vector of 2D points (contour vertices), stored in std::vector or Mat.\n@param oriented Oriented area flag. If it is true, the function returns a signed area value,\ndepending on the contour orientation (clockwise or counter-clockwise). Using this feature you can\ndetermine orientation of a contour by taking the sign of an area. By default, the parameter is\nfalse, which means that the absolute value is returned."]
    #[link_name = "\u{1}_ZN2cv11contourAreaERKNS_11_InputArrayEb"]
    pub fn cv_contourArea(contour: cv_InputArray, oriented: bool) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Finds a rotated rectangle of the minimum area enclosing the input 2D point set.\n\nThe function calculates and returns the minimum-area bounding rectangle (possibly rotated) for a\nspecified point set. Developer should keep in mind that the returned RotatedRect can contain negative\nindices when data is close to the containing Mat element boundary.\n\n@param points Input vector of 2D points, stored in std::vector\\<\\> or Mat"]
    #[link_name = "\u{1}_ZN2cv11minAreaRectERKNS_11_InputArrayE"]
    pub fn cv_minAreaRect(points: cv_InputArray) -> cv_RotatedRect;
}
unsafe extern "C" {
    #[doc = " @brief Finds the four vertices of a rotated rect. Useful to draw the rotated rectangle.\n\nThe function finds the four vertices of a rotated rectangle. This function is useful to draw the\nrectangle. In C++, instead of using this function, you can directly use RotatedRect::points method. Please\nvisit the @ref tutorial_bounding_rotated_ellipses \"tutorial on Creating Bounding rotated boxes and ellipses for contours\" for more information.\n\n@param box The input rotated rectangle. It may be the output of\n@param points The output array of four vertices of rectangles."]
    #[link_name = "\u{1}_ZN2cv9boxPointsENS_11RotatedRectERKNS_12_OutputArrayE"]
    pub fn cv_boxPoints(box_: cv_RotatedRect, points: cv_OutputArray);
}
unsafe extern "C" {
    #[doc = " @brief Finds a circle of the minimum area enclosing a 2D point set.\n\nThe function finds the minimal enclosing circle of a 2D point set using an iterative algorithm.\n\n@param points Input vector of 2D points, stored in std::vector\\<\\> or Mat\n@param center Output center of the circle.\n@param radius Output radius of the circle."]
    #[link_name = "\u{1}_ZN2cv18minEnclosingCircleERKNS_11_InputArrayERNS_6Point_IfEERf"]
    pub fn cv_minEnclosingCircle(points: cv_InputArray, center: *mut cv_Point2f, radius: *mut f32);
}
unsafe extern "C" {
    #[doc = " @brief Finds a triangle of minimum area enclosing a 2D point set and returns its area.\n\nThe function finds a triangle of minimum area enclosing the given set of 2D points and returns its\narea. The output for a given 2D point set is shown in the image below. 2D points are depicted in\nred* and the enclosing triangle in *yellow*.\n\n[Sample output of the minimum enclosing triangle function](pics/minenclosingtriangle.png)\n\nThe implementation of the algorithm is based on O'Rourke's @cite ORourke86 and Klee and Laskowski's\n@cite KleeLaskowski85 papers. O'Rourke provides a \\f$\\theta(n)\\f$ algorithm for finding the minimal\nenclosing triangle of a 2D convex polygon with n vertices. Since the #minEnclosingTriangle function\ntakes a 2D point set as input an additional preprocessing step of computing the convex hull of the\n2D point set is required. The complexity of the #convexHull function is \\f$O(n log(n))\\f$ which is higher\nthan \\f$\\theta(n)\\f$. Thus the overall complexity of the function is \\f$O(n log(n))\\f$.\n\n@param points Input vector of 2D points with depth CV_32S or CV_32F, stored in std::vector\\<\\> or Mat\n@param triangle Output vector of three 2D points defining the vertices of the triangle. The depth\nof the OutputArray must be CV_32F."]
    #[link_name = "\u{1}_ZN2cv20minEnclosingTriangleERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_minEnclosingTriangle(points: cv_InputArray, triangle: cv_OutputArray) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Compares two shapes.\n\nThe function compares two shapes. All three implemented methods use the Hu invariants (see #HuMoments)\n\n@param contour1 First contour or grayscale image.\n@param contour2 Second contour or grayscale image.\n@param method Comparison method, see #ShapeMatchModes\n@param parameter Method-specific parameter (not supported now)."]
    #[link_name = "\u{1}_ZN2cv11matchShapesERKNS_11_InputArrayES2_id"]
    pub fn cv_matchShapes(
        contour1: cv_InputArray,
        contour2: cv_InputArray,
        method: ::std::os::raw::c_int,
        parameter: f64,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Finds the convex hull of a point set.\n\nThe function cv::convexHull finds the convex hull of a 2D point set using the Sklansky's algorithm @cite Sklansky82\nthat has *O(N logN)* complexity in the current implementation.\n\n@param points Input 2D point set, stored in std::vector or Mat.\n@param hull Output convex hull. It is either an integer vector of indices or vector of points. In\nthe first case, the hull elements are 0-based indices of the convex hull points in the original\narray (since the set of convex hull points is a subset of the original point set). In the second\ncase, hull elements are the convex hull points themselves.\n@param clockwise Orientation flag. If it is true, the output convex hull is oriented clockwise.\nOtherwise, it is oriented counter-clockwise. The assumed coordinate system has its X axis pointing\nto the right, and its Y axis pointing upwards.\n@param returnPoints Operation flag. In case of a matrix, when the flag is true, the function\nreturns convex hull points. Otherwise, it returns indices of the convex hull points. When the\noutput array is std::vector, the flag is ignored, and the output depends on the type of the\nvector: std::vector\\<int\\> implies returnPoints=false, std::vector\\<Point\\> implies\nreturnPoints=true.\n\n@note `points` and `hull` should be different arrays, inplace processing isn't supported.\n\nCheck @ref tutorial_hull \"the corresponding tutorial\" for more details.\n\nuseful links:\n\nhttps://www.learnopencv.com/convex-hull-using-opencv-in-python-and-c/"]
    #[link_name = "\u{1}_ZN2cv10convexHullERKNS_11_InputArrayERKNS_12_OutputArrayEbb"]
    pub fn cv_convexHull(
        points: cv_InputArray,
        hull: cv_OutputArray,
        clockwise: bool,
        returnPoints: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief Finds the convexity defects of a contour.\n\nThe figure below displays convexity defects of a hand contour:\n\n[image](pics/defects.png)\n\n@param contour Input contour.\n@param convexhull Convex hull obtained using convexHull that should contain indices of the contour\npoints that make the hull.\n@param convexityDefects The output vector of convexity defects. In C++ and the new Python/Java\ninterface each convexity defect is represented as 4-element integer vector (a.k.a. #Vec4i):\n(start_index, end_index, farthest_pt_index, fixpt_depth), where indices are 0-based indices\nin the original contour of the convexity defect beginning, end and the farthest point, and\nfixpt_depth is fixed-point approximation (with 8 fractional bits) of the distance between the\nfarthest contour point and the hull. That is, to get the floating-point value of the depth will be\nfixpt_depth/256.0."]
    #[link_name = "\u{1}_ZN2cv16convexityDefectsERKNS_11_InputArrayES2_RKNS_12_OutputArrayE"]
    pub fn cv_convexityDefects(
        contour: cv_InputArray,
        convexhull: cv_InputArray,
        convexityDefects: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Tests a contour convexity.\n\nThe function tests whether the input contour is convex or not. The contour must be simple, that is,\nwithout self-intersections. Otherwise, the function output is undefined.\n\n@param contour Input vector of 2D points, stored in std::vector\\<\\> or Mat"]
    #[link_name = "\u{1}_ZN2cv15isContourConvexERKNS_11_InputArrayE"]
    pub fn cv_isContourConvex(contour: cv_InputArray) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Finds intersection of two convex polygons\n\n@param _p1 First polygon\n@param _p2 Second polygon\n@param _p12 Output polygon describing the intersecting area\n@param handleNested When true, an intersection is found if one of the polygons is fully enclosed in the other.\nWhen false, no intersection is found. If the polygons share a side or the vertex of one polygon lies on an edge\nof the other, they are not considered nested and an intersection will be found regardless of the value of handleNested.\n\n@returns Absolute value of area of intersecting polygon\n\n@note intersectConvexConvex doesn't confirm that both polygons are convex and will return invalid results if they aren't."]
    #[link_name = "\u{1}_ZN2cv21intersectConvexConvexERKNS_11_InputArrayES2_RKNS_12_OutputArrayEb"]
    pub fn cv_intersectConvexConvex(
        _p1: cv_InputArray,
        _p2: cv_InputArray,
        _p12: cv_OutputArray,
        handleNested: bool,
    ) -> f32;
}
unsafe extern "C" {
    #[doc = " @brief Fits an ellipse around a set of 2D points.\n\nThe function calculates the ellipse that fits (in a least-squares sense) a set of 2D points best of\nall. It returns the rotated rectangle in which the ellipse is inscribed. The first algorithm described by @cite Fitzgibbon95\nis used. Developer should keep in mind that it is possible that the returned\nellipse/rotatedRect data contains negative indices, due to the data points being close to the\nborder of the containing Mat element.\n\n@param points Input 2D point set, stored in std::vector\\<\\> or Mat"]
    #[link_name = "\u{1}_ZN2cv10fitEllipseERKNS_11_InputArrayE"]
    pub fn cv_fitEllipse(points: cv_InputArray) -> cv_RotatedRect;
}
unsafe extern "C" {
    #[doc = " @brief Fits an ellipse around a set of 2D points.\n\nThe function calculates the ellipse that fits a set of 2D points.\nIt returns the rotated rectangle in which the ellipse is inscribed.\nThe Approximate Mean Square (AMS) proposed by @cite Taubin1991 is used.\n\nFor an ellipse, this basis set is \\f$ \\chi= \\left(x^2, x y, y^2, x, y, 1\\right) \\f$,\nwhich is a set of six free coefficients \\f$ A^T=\\left\\{A_{\\text{xx}},A_{\\text{xy}},A_{\\text{yy}},A_x,A_y,A_0\\right\\} \\f$.\nHowever, to specify an ellipse, all that is needed is five numbers; the major and minor axes lengths \\f$ (a,b) \\f$,\nthe position \\f$ (x_0,y_0) \\f$, and the orientation \\f$ \\theta \\f$. This is because the basis set includes lines,\nquadratics, parabolic and hyperbolic functions as well as elliptical functions as possible fits.\nIf the fit is found to be a parabolic or hyperbolic function then the standard #fitEllipse method is used.\nThe AMS method restricts the fit to parabolic, hyperbolic and elliptical curves\nby imposing the condition that \\f$ A^T ( D_x^T D_x  +   D_y^T D_y) A = 1 \\f$ where\nthe matrices \\f$ Dx \\f$ and \\f$ Dy \\f$ are the partial derivatives of the design matrix \\f$ D \\f$ with\nrespect to x and y. The matrices are formed row by row applying the following to\neach of the points in the set:\n\\f{align*}{\nD(i,:)&=\\left\\{x_i^2, x_i y_i, y_i^2, x_i, y_i, 1\\right\\} &\nD_x(i,:)&=\\left\\{2 x_i,y_i,0,1,0,0\\right\\} &\nD_y(i,:)&=\\left\\{0,x_i,2 y_i,0,1,0\\right\\}\n\\f}\nThe AMS method minimizes the cost function\n\\f{equation*}{\n\\epsilon ^2=\\frac{ A^T D^T D A }{ A^T (D_x^T D_x +  D_y^T D_y) A^T }\n\\f}\n\nThe minimum cost is found by solving the generalized eigenvalue problem.\n\n\\f{equation*}{\nD^T D A = \\lambda  \\left( D_x^T D_x +  D_y^T D_y\\right) A\n\\f}\n\n@param points Input 2D point set, stored in std::vector\\<\\> or Mat"]
    #[link_name = "\u{1}_ZN2cv13fitEllipseAMSERKNS_11_InputArrayE"]
    pub fn cv_fitEllipseAMS(points: cv_InputArray) -> cv_RotatedRect;
}
unsafe extern "C" {
    #[doc = " @brief Fits an ellipse around a set of 2D points.\n\nThe function calculates the ellipse that fits a set of 2D points.\nIt returns the rotated rectangle in which the ellipse is inscribed.\nThe Direct least square (Direct) method by @cite Fitzgibbon1999 is used.\n\nFor an ellipse, this basis set is \\f$ \\chi= \\left(x^2, x y, y^2, x, y, 1\\right) \\f$,\nwhich is a set of six free coefficients \\f$ A^T=\\left\\{A_{\\text{xx}},A_{\\text{xy}},A_{\\text{yy}},A_x,A_y,A_0\\right\\} \\f$.\nHowever, to specify an ellipse, all that is needed is five numbers; the major and minor axes lengths \\f$ (a,b) \\f$,\nthe position \\f$ (x_0,y_0) \\f$, and the orientation \\f$ \\theta \\f$. This is because the basis set includes lines,\nquadratics, parabolic and hyperbolic functions as well as elliptical functions as possible fits.\nThe Direct method confines the fit to ellipses by ensuring that \\f$ 4 A_{xx} A_{yy}- A_{xy}^2 > 0 \\f$.\nThe condition imposed is that \\f$ 4 A_{xx} A_{yy}- A_{xy}^2=1 \\f$ which satisfies the inequality\nand as the coefficients can be arbitrarily scaled is not overly restrictive.\n\n\\f{equation*}{\n\\epsilon ^2= A^T D^T D A \\quad \\text{with} \\quad A^T C A =1 \\quad \\text{and} \\quad C=\\left(\\begin{matrix}\n0 & 0  & 2  & 0  & 0  &  0  \\\\\n0 & -1  & 0  & 0  & 0  &  0 \\\\\n2 & 0  & 0  & 0  & 0  &  0 \\\\\n0 & 0  & 0  & 0  & 0  &  0 \\\\\n0 & 0  & 0  & 0  & 0  &  0 \\\\\n0 & 0  & 0  & 0  & 0  &  0\n\\end{matrix} \\right)\n\\f}\n\nThe minimum cost is found by solving the generalized eigenvalue problem.\n\n\\f{equation*}{\nD^T D A = \\lambda  \\left( C\\right) A\n\\f}\n\nThe system produces only one positive eigenvalue \\f$ \\lambda\\f$ which is chosen as the solution\nwith its eigenvector \\f$\\mathbf{u}\\f$. These are used to find the coefficients\n\n\\f{equation*}{\nA = \\sqrt{\\frac{1}{\\mathbf{u}^T C \\mathbf{u}}}  \\mathbf{u}\n\\f}\nThe scaling factor guarantees that  \\f$A^T C A =1\\f$.\n\n@param points Input 2D point set, stored in std::vector\\<\\> or Mat"]
    #[link_name = "\u{1}_ZN2cv16fitEllipseDirectERKNS_11_InputArrayE"]
    pub fn cv_fitEllipseDirect(points: cv_InputArray) -> cv_RotatedRect;
}
unsafe extern "C" {
    #[doc = " @brief Fits a line to a 2D or 3D point set.\n\nThe function fitLine fits a line to a 2D or 3D point set by minimizing \\f$\\sum_i \\rho(r_i)\\f$ where\n\\f$r_i\\f$ is a distance between the \\f$i^{th}\\f$ point, the line and \\f$\\rho(r)\\f$ is a distance function, one\nof the following:\n-  DIST_L2\n\\f[\\rho (r) = r^2/2  \\quad \\text{(the simplest and the fastest least-squares method)}\\f]\n- DIST_L1\n\\f[\\rho (r) = r\\f]\n- DIST_L12\n\\f[\\rho (r) = 2  \\cdot ( \\sqrt{1 + \\frac{r^2}{2}} - 1)\\f]\n- DIST_FAIR\n\\f[\\rho \\left (r \\right ) = C^2  \\cdot \\left (  \\frac{r}{C} -  \\log{\\left(1 + \\frac{r}{C}\\right)} \\right )  \\quad \\text{where} \\quad C=1.3998\\f]\n- DIST_WELSCH\n\\f[\\rho \\left (r \\right ) =  \\frac{C^2}{2} \\cdot \\left ( 1 -  \\exp{\\left(-\\left(\\frac{r}{C}\\right)^2\\right)} \\right )  \\quad \\text{where} \\quad C=2.9846\\f]\n- DIST_HUBER\n\\f[\\rho (r) =  \\fork{r^2/2}{if \\(r < C\\)}{C \\cdot (r-C/2)}{otherwise} \\quad \\text{where} \\quad C=1.345\\f]\n\nThe algorithm is based on the M-estimator ( <http://en.wikipedia.org/wiki/M-estimator> ) technique\nthat iteratively fits the line using the weighted least-squares algorithm. After each iteration the\nweights \\f$w_i\\f$ are adjusted to be inversely proportional to \\f$\\rho(r_i)\\f$ .\n\n@param points Input vector of 2D or 3D points, stored in std::vector\\<\\> or Mat.\n@param line Output line parameters. In case of 2D fitting, it should be a vector of 4 elements\n(like Vec4f) - (vx, vy, x0, y0), where (vx, vy) is a normalized vector collinear to the line and\n(x0, y0) is a point on the line. In case of 3D fitting, it should be a vector of 6 elements (like\nVec6f) - (vx, vy, vz, x0, y0, z0), where (vx, vy, vz) is a normalized vector collinear to the line\nand (x0, y0, z0) is a point on the line.\n@param distType Distance used by the M-estimator, see #DistanceTypes\n@param param Numerical parameter ( C ) for some types of distances. If it is 0, an optimal value\nis chosen.\n@param reps Sufficient accuracy for the radius (distance between the coordinate origin and the line).\n@param aeps Sufficient accuracy for the angle. 0.01 would be a good default value for reps and aeps."]
    #[link_name = "\u{1}_ZN2cv7fitLineERKNS_11_InputArrayERKNS_12_OutputArrayEiddd"]
    pub fn cv_fitLine(
        points: cv_InputArray,
        line: cv_OutputArray,
        distType: ::std::os::raw::c_int,
        param: f64,
        reps: f64,
        aeps: f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Performs a point-in-contour test.\n\nThe function determines whether the point is inside a contour, outside, or lies on an edge (or\ncoincides with a vertex). It returns positive (inside), negative (outside), or zero (on an edge)\nvalue, correspondingly. When measureDist=false , the return value is +1, -1, and 0, respectively.\nOtherwise, the return value is a signed distance between the point and the nearest contour edge.\n\nSee below a sample output of the function where each image pixel is tested against the contour:\n\n[sample output](pics/pointpolygon.png)\n\n@param contour Input contour.\n@param pt Point tested against the contour.\n@param measureDist If true, the function estimates the signed distance from the point to the\nnearest contour edge. Otherwise, the function only checks if the point is inside a contour or not."]
    #[link_name = "\u{1}_ZN2cv16pointPolygonTestERKNS_11_InputArrayENS_6Point_IfEEb"]
    pub fn cv_pointPolygonTest(contour: cv_InputArray, pt: cv_Point2f, measureDist: bool) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Finds out if there is any intersection between two rotated rectangles.\n\nIf there is then the vertices of the intersecting region are returned as well.\n\nBelow are some examples of intersection configurations. The hatched pattern indicates the\nintersecting region and the red vertices are returned by the function.\n\n[intersection examples](pics/intersection.png)\n\n@param rect1 First rectangle\n@param rect2 Second rectangle\n@param intersectingRegion The output array of the vertices of the intersecting region. It returns\nat most 8 vertices. Stored as std::vector\\<cv::Point2f\\> or cv::Mat as Mx1 of type CV_32FC2.\n@returns One of #RectanglesIntersectTypes"]
    #[link_name = "\u{1}_ZN2cv28rotatedRectangleIntersectionERKNS_11RotatedRectES2_RKNS_12_OutputArrayE"]
    pub fn cv_rotatedRectangleIntersection(
        rect1: *const cv_RotatedRect,
        rect2: *const cv_RotatedRect,
        intersectingRegion: cv_OutputArray,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Creates a smart pointer to a cv::GeneralizedHoughBallard class and initializes it."]
    #[link_name = "\u{1}_ZN2cv29createGeneralizedHoughBallardEv"]
    pub fn cv_createGeneralizedHoughBallard() -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Creates a smart pointer to a cv::GeneralizedHoughGuil class and initializes it."]
    #[link_name = "\u{1}_ZN2cv26createGeneralizedHoughGuilEv"]
    pub fn cv_createGeneralizedHoughGuil() -> cv_Ptr;
}
#[doc = "!< ![autumn](pics/colormaps/colorscale_autumn.jpg)"]
pub const cv_ColormapTypes_COLORMAP_AUTUMN: cv_ColormapTypes = 0;
#[doc = "!< ![bone](pics/colormaps/colorscale_bone.jpg)"]
pub const cv_ColormapTypes_COLORMAP_BONE: cv_ColormapTypes = 1;
#[doc = "!< ![jet](pics/colormaps/colorscale_jet.jpg)"]
pub const cv_ColormapTypes_COLORMAP_JET: cv_ColormapTypes = 2;
#[doc = "!< ![winter](pics/colormaps/colorscale_winter.jpg)"]
pub const cv_ColormapTypes_COLORMAP_WINTER: cv_ColormapTypes = 3;
#[doc = "!< ![rainbow](pics/colormaps/colorscale_rainbow.jpg)"]
pub const cv_ColormapTypes_COLORMAP_RAINBOW: cv_ColormapTypes = 4;
#[doc = "!< ![ocean](pics/colormaps/colorscale_ocean.jpg)"]
pub const cv_ColormapTypes_COLORMAP_OCEAN: cv_ColormapTypes = 5;
#[doc = "!< ![summer](pics/colormaps/colorscale_summer.jpg)"]
pub const cv_ColormapTypes_COLORMAP_SUMMER: cv_ColormapTypes = 6;
#[doc = "!< ![spring](pics/colormaps/colorscale_spring.jpg)"]
pub const cv_ColormapTypes_COLORMAP_SPRING: cv_ColormapTypes = 7;
#[doc = "!< ![cool](pics/colormaps/colorscale_cool.jpg)"]
pub const cv_ColormapTypes_COLORMAP_COOL: cv_ColormapTypes = 8;
#[doc = "!< ![HSV](pics/colormaps/colorscale_hsv.jpg)"]
pub const cv_ColormapTypes_COLORMAP_HSV: cv_ColormapTypes = 9;
#[doc = "!< ![pink](pics/colormaps/colorscale_pink.jpg)"]
pub const cv_ColormapTypes_COLORMAP_PINK: cv_ColormapTypes = 10;
#[doc = "!< ![hot](pics/colormaps/colorscale_hot.jpg)"]
pub const cv_ColormapTypes_COLORMAP_HOT: cv_ColormapTypes = 11;
#[doc = "!< ![parula](pics/colormaps/colorscale_parula.jpg)"]
pub const cv_ColormapTypes_COLORMAP_PARULA: cv_ColormapTypes = 12;
#[doc = "!< ![magma](pics/colormaps/colorscale_magma.jpg)"]
pub const cv_ColormapTypes_COLORMAP_MAGMA: cv_ColormapTypes = 13;
#[doc = "!< ![inferno](pics/colormaps/colorscale_inferno.jpg)"]
pub const cv_ColormapTypes_COLORMAP_INFERNO: cv_ColormapTypes = 14;
#[doc = "!< ![plasma](pics/colormaps/colorscale_plasma.jpg)"]
pub const cv_ColormapTypes_COLORMAP_PLASMA: cv_ColormapTypes = 15;
#[doc = "!< ![viridis](pics/colormaps/colorscale_viridis.jpg)"]
pub const cv_ColormapTypes_COLORMAP_VIRIDIS: cv_ColormapTypes = 16;
#[doc = "!< ![cividis](pics/colormaps/colorscale_cividis.jpg)"]
pub const cv_ColormapTypes_COLORMAP_CIVIDIS: cv_ColormapTypes = 17;
#[doc = "!< ![twilight](pics/colormaps/colorscale_twilight.jpg)"]
pub const cv_ColormapTypes_COLORMAP_TWILIGHT: cv_ColormapTypes = 18;
#[doc = "!< ![twilight shifted](pics/colormaps/colorscale_twilight_shifted.jpg)"]
pub const cv_ColormapTypes_COLORMAP_TWILIGHT_SHIFTED: cv_ColormapTypes = 19;
#[doc = "!< ![turbo](pics/colormaps/colorscale_turbo.jpg)"]
pub const cv_ColormapTypes_COLORMAP_TURBO: cv_ColormapTypes = 20;
#[doc = "! GNU Octave/MATLAB equivalent colormaps"]
pub type cv_ColormapTypes = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Applies a GNU Octave/MATLAB equivalent colormap on a given image.\n\n@param src The source image, grayscale or colored of type CV_8UC1 or CV_8UC3.\n@param dst The result is the colormapped source image. Note: Mat::create is called on dst.\n@param colormap The colormap to apply, see #ColormapTypes"]
    #[link_name = "\u{1}_ZN2cv13applyColorMapERKNS_11_InputArrayERKNS_12_OutputArrayEi"]
    pub fn cv_applyColorMap(
        src: cv_InputArray,
        dst: cv_OutputArray,
        colormap: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Applies a user colormap on a given image.\n\n@param src The source image, grayscale or colored of type CV_8UC1 or CV_8UC3.\n@param dst The result is the colormapped source image. Note: Mat::create is called on dst.\n@param userColor The colormap to apply of type CV_8UC1 or CV_8UC3 and size 256"]
    #[link_name = "\u{1}_ZN2cv13applyColorMapERKNS_11_InputArrayERKNS_12_OutputArrayES2_"]
    pub fn cv_applyColorMap1(src: cv_InputArray, dst: cv_OutputArray, userColor: cv_InputArray);
}
unsafe extern "C" {
    #[doc = " @brief Draws a line segment connecting two points.\n\nThe function line draws the line segment between pt1 and pt2 points in the image. The line is\nclipped by the image boundaries. For non-antialiased lines with integer coordinates, the 8-connected\nor 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased\nlines are drawn using Gaussian filtering.\n\n@param img Image.\n@param pt1 First point of the line segment.\n@param pt2 Second point of the line segment.\n@param color Line color.\n@param thickness Line thickness.\n@param lineType Type of the line. See #LineTypes.\n@param shift Number of fractional bits in the point coordinates."]
    #[link_name = "\u{1}_ZN2cv4lineERKNS_17_InputOutputArrayENS_6Point_IiEES4_RKNS_7Scalar_IdEEiii"]
    pub fn cv_line(
        img: cv_InputOutputArray,
        pt1: cv_Point,
        pt2: cv_Point,
        color: *const cv_Scalar,
        thickness: ::std::os::raw::c_int,
        lineType: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Draws a arrow segment pointing from the first point to the second one.\n\nThe function cv::arrowedLine draws an arrow between pt1 and pt2 points in the image. See also #line.\n\n@param img Image.\n@param pt1 The point the arrow starts from.\n@param pt2 The point the arrow points to.\n@param color Line color.\n@param thickness Line thickness.\n@param line_type Type of the line. See #LineTypes\n@param shift Number of fractional bits in the point coordinates.\n@param tipLength The length of the arrow tip in relation to the arrow length"]
    #[link_name = "\u{1}_ZN2cv11arrowedLineERKNS_17_InputOutputArrayENS_6Point_IiEES4_RKNS_7Scalar_IdEEiiid"]
    pub fn cv_arrowedLine(
        img: cv_InputOutputArray,
        pt1: cv_Point,
        pt2: cv_Point,
        color: *const cv_Scalar,
        thickness: ::std::os::raw::c_int,
        line_type: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
        tipLength: f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Draws a simple, thick, or filled up-right rectangle.\n\nThe function cv::rectangle draws a rectangle outline or a filled rectangle whose two opposite corners\nare pt1 and pt2.\n\n@param img Image.\n@param pt1 Vertex of the rectangle.\n@param pt2 Vertex of the rectangle opposite to pt1 .\n@param color Rectangle color or brightness (grayscale image).\n@param thickness Thickness of lines that make up the rectangle. Negative values, like #FILLED,\nmean that the function has to draw a filled rectangle.\n@param lineType Type of the line. See #LineTypes\n@param shift Number of fractional bits in the point coordinates."]
    #[link_name = "\u{1}_ZN2cv9rectangleERKNS_17_InputOutputArrayENS_6Point_IiEES4_RKNS_7Scalar_IdEEiii"]
    pub fn cv_rectangle(
        img: cv_InputOutputArray,
        pt1: cv_Point,
        pt2: cv_Point,
        color: *const cv_Scalar,
        thickness: ::std::os::raw::c_int,
        lineType: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n\nuse `rec` parameter as alternative specification of the drawn rectangle: `r.tl() and\nr.br()-Point(1,1)` are opposite corners"]
    #[link_name = "\u{1}_ZN2cv9rectangleERKNS_17_InputOutputArrayENS_5Rect_IiEERKNS_7Scalar_IdEEiii"]
    pub fn cv_rectangle1(
        img: cv_InputOutputArray,
        rec: cv_Rect,
        color: *const cv_Scalar,
        thickness: ::std::os::raw::c_int,
        lineType: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Draws a circle.\n\nThe function cv::circle draws a simple or filled circle with a given center and radius.\n@param img Image where the circle is drawn.\n@param center Center of the circle.\n@param radius Radius of the circle.\n@param color Circle color.\n@param thickness Thickness of the circle outline, if positive. Negative values, like #FILLED,\nmean that a filled circle is to be drawn.\n@param lineType Type of the circle boundary. See #LineTypes\n@param shift Number of fractional bits in the coordinates of the center and in the radius value."]
    #[link_name = "\u{1}_ZN2cv6circleERKNS_17_InputOutputArrayENS_6Point_IiEEiRKNS_7Scalar_IdEEiii"]
    pub fn cv_circle(
        img: cv_InputOutputArray,
        center: cv_Point,
        radius: ::std::os::raw::c_int,
        color: *const cv_Scalar,
        thickness: ::std::os::raw::c_int,
        lineType: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Draws a simple or thick elliptic arc or fills an ellipse sector.\n\nThe function cv::ellipse with more parameters draws an ellipse outline, a filled ellipse, an elliptic\narc, or a filled ellipse sector. The drawing code uses general parametric form.\nA piecewise-linear curve is used to approximate the elliptic arc\nboundary. If you need more control of the ellipse rendering, you can retrieve the curve using\n#ellipse2Poly and then render it with #polylines or fill it with #fillPoly. If you use the first\nvariant of the function and want to draw the whole ellipse, not an arc, pass `startAngle=0` and\n`endAngle=360`. If `startAngle` is greater than `endAngle`, they are swapped. The figure below explains\nthe meaning of the parameters to draw the blue arc.\n\n[Parameters of Elliptic Arc](pics/ellipse.svg)\n\n@param img Image.\n@param center Center of the ellipse.\n@param axes Half of the size of the ellipse main axes.\n@param angle Ellipse rotation angle in degrees.\n@param startAngle Starting angle of the elliptic arc in degrees.\n@param endAngle Ending angle of the elliptic arc in degrees.\n@param color Ellipse color.\n@param thickness Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that\na filled ellipse sector is to be drawn.\n@param lineType Type of the ellipse boundary. See #LineTypes\n@param shift Number of fractional bits in the coordinates of the center and values of axes."]
    #[link_name = "\u{1}_ZN2cv7ellipseERKNS_17_InputOutputArrayENS_6Point_IiEENS_5Size_IiEEdddRKNS_7Scalar_IdEEiii"]
    pub fn cv_ellipse(
        img: cv_InputOutputArray,
        center: cv_Point,
        axes: cv_Size,
        angle: f64,
        startAngle: f64,
        endAngle: f64,
        color: *const cv_Scalar,
        thickness: ::std::os::raw::c_int,
        lineType: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param img Image.\n@param box Alternative ellipse representation via RotatedRect. This means that the function draws\nan ellipse inscribed in the rotated rectangle.\n@param color Ellipse color.\n@param thickness Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that\na filled ellipse sector is to be drawn.\n@param lineType Type of the ellipse boundary. See #LineTypes"]
    #[link_name = "\u{1}_ZN2cv7ellipseERKNS_17_InputOutputArrayERKNS_11RotatedRectERKNS_7Scalar_IdEEii"]
    pub fn cv_ellipse1(
        img: cv_InputOutputArray,
        box_: *const cv_RotatedRect,
        color: *const cv_Scalar,
        thickness: ::std::os::raw::c_int,
        lineType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Draws a marker on a predefined position in an image.\n\nThe function cv::drawMarker draws a marker on a given position in the image. For the moment several\nmarker types are supported, see #MarkerTypes for more information.\n\n@param img Image.\n@param position The point where the crosshair is positioned.\n@param color Line color.\n@param markerType The specific type of marker you want to use, see #MarkerTypes\n@param thickness Line thickness.\n@param line_type Type of the line, See #LineTypes\n@param markerSize The length of the marker axis [default = 20 pixels]"]
    #[link_name = "\u{1}_ZN2cv10drawMarkerERKNS_17_InputOutputArrayENS_6Point_IiEERKNS_7Scalar_IdEEiiii"]
    pub fn cv_drawMarker(
        img: cv_InputOutputArray,
        position: cv_Point,
        color: *const cv_Scalar,
        markerType: ::std::os::raw::c_int,
        markerSize: ::std::os::raw::c_int,
        thickness: ::std::os::raw::c_int,
        line_type: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv14fillConvexPolyERKNS_17_InputOutputArrayEPKNS_6Point_IiEEiRKNS_7Scalar_IdEEii"]
    pub fn cv_fillConvexPoly(
        img: cv_InputOutputArray,
        pts: *const cv_Point,
        npts: ::std::os::raw::c_int,
        color: *const cv_Scalar,
        lineType: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Fills a convex polygon.\n\nThe function cv::fillConvexPoly draws a filled convex polygon. This function is much faster than the\nfunction #fillPoly . It can fill not only convex polygons but any monotonic polygon without\nself-intersections, that is, a polygon whose contour intersects every horizontal line (scan line)\ntwice at the most (though, its top-most and/or the bottom edge could be horizontal).\n\n@param img Image.\n@param points Polygon vertices.\n@param color Polygon color.\n@param lineType Type of the polygon boundaries. See #LineTypes\n@param shift Number of fractional bits in the vertex coordinates."]
    #[link_name = "\u{1}_ZN2cv14fillConvexPolyERKNS_17_InputOutputArrayERKNS_11_InputArrayERKNS_7Scalar_IdEEii"]
    pub fn cv_fillConvexPoly1(
        img: cv_InputOutputArray,
        points: cv_InputArray,
        color: *const cv_Scalar,
        lineType: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv8fillPolyERKNS_17_InputOutputArrayEPPKNS_6Point_IiEEPKiiRKNS_7Scalar_IdEEiiS4_"]
    pub fn cv_fillPoly(
        img: cv_InputOutputArray,
        pts: *mut *const cv_Point,
        npts: *const ::std::os::raw::c_int,
        ncontours: ::std::os::raw::c_int,
        color: *const cv_Scalar,
        lineType: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
        offset: cv_Point,
    );
}
unsafe extern "C" {
    #[doc = " @brief Fills the area bounded by one or more polygons.\n\nThe function cv::fillPoly fills an area bounded by several polygonal contours. The function can fill\ncomplex areas, for example, areas with holes, contours with self-intersections (some of their\nparts), and so forth.\n\n@param img Image.\n@param pts Array of polygons where each polygon is represented as an array of points.\n@param color Polygon color.\n@param lineType Type of the polygon boundaries. See #LineTypes\n@param shift Number of fractional bits in the vertex coordinates.\n@param offset Optional offset of all points of the contours."]
    #[link_name = "\u{1}_ZN2cv8fillPolyERKNS_17_InputOutputArrayERKNS_11_InputArrayERKNS_7Scalar_IdEEiiNS_6Point_IiEE"]
    pub fn cv_fillPoly1(
        img: cv_InputOutputArray,
        pts: cv_InputArrayOfArrays,
        color: *const cv_Scalar,
        lineType: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
        offset: cv_Point,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv9polylinesERKNS_17_InputOutputArrayEPKPKNS_6Point_IiEEPKiibRKNS_7Scalar_IdEEiii"]
    pub fn cv_polylines(
        img: cv_InputOutputArray,
        pts: *const *const cv_Point,
        npts: *const ::std::os::raw::c_int,
        ncontours: ::std::os::raw::c_int,
        isClosed: bool,
        color: *const cv_Scalar,
        thickness: ::std::os::raw::c_int,
        lineType: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Draws several polygonal curves.\n\n@param img Image.\n@param pts Array of polygonal curves.\n@param isClosed Flag indicating whether the drawn polylines are closed or not. If they are closed,\nthe function draws a line from the last vertex of each curve to its first vertex.\n@param color Polyline color.\n@param thickness Thickness of the polyline edges.\n@param lineType Type of the line segments. See #LineTypes\n@param shift Number of fractional bits in the vertex coordinates.\n\nThe function cv::polylines draws one or more polygonal curves."]
    #[link_name = "\u{1}_ZN2cv9polylinesERKNS_17_InputOutputArrayERKNS_11_InputArrayEbRKNS_7Scalar_IdEEiii"]
    pub fn cv_polylines1(
        img: cv_InputOutputArray,
        pts: cv_InputArrayOfArrays,
        isClosed: bool,
        color: *const cv_Scalar,
        thickness: ::std::os::raw::c_int,
        lineType: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Draws contours outlines or filled contours.\n\nThe function draws contour outlines in the image if \\f$\\texttt{thickness} \\ge 0\\f$ or fills the area\nbounded by the contours if \\f$\\texttt{thickness}<0\\f$ . The example below shows how to retrieve\nconnected components from the binary image and label them: :\n@include snippets/imgproc_drawContours.cpp\n\n@param image Destination image.\n@param contours All the input contours. Each contour is stored as a point vector.\n@param contourIdx Parameter indicating a contour to draw. If it is negative, all the contours are drawn.\n@param color Color of the contours.\n@param thickness Thickness of lines the contours are drawn with. If it is negative (for example,\nthickness=#FILLED ), the contour interiors are drawn.\n@param lineType Line connectivity. See #LineTypes\n@param hierarchy Optional information about hierarchy. It is only needed if you want to draw only\nsome of the contours (see maxLevel ).\n@param maxLevel Maximal level for drawn contours. If it is 0, only the specified contour is drawn.\nIf it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function\ndraws the contours, all the nested contours, all the nested-to-nested contours, and so on. This\nparameter is only taken into account when there is hierarchy available.\n@param offset Optional contour shift parameter. Shift all the drawn contours by the specified\n\\f$\\texttt{offset}=(dx,dy)\\f$ .\n@note When thickness=#FILLED, the function is designed to handle connected components with holes correctly\neven when no hierarchy date is provided. This is done by analyzing all the outlines together\nusing even-odd rule. This may give incorrect results if you have a joint collection of separately retrieved\ncontours. In order to solve this problem, you need to call #drawContours separately for each sub-group\nof contours, or iterate over the collection using contourIdx parameter."]
    #[link_name = "\u{1}_ZN2cv12drawContoursERKNS_17_InputOutputArrayERKNS_11_InputArrayEiRKNS_7Scalar_IdEEiiS5_iNS_6Point_IiEE"]
    pub fn cv_drawContours(
        image: cv_InputOutputArray,
        contours: cv_InputArrayOfArrays,
        contourIdx: ::std::os::raw::c_int,
        color: *const cv_Scalar,
        thickness: ::std::os::raw::c_int,
        lineType: ::std::os::raw::c_int,
        hierarchy: cv_InputArray,
        maxLevel: ::std::os::raw::c_int,
        offset: cv_Point,
    );
}
unsafe extern "C" {
    #[doc = " @brief Clips the line against the image rectangle.\n\nThe function cv::clipLine calculates a part of the line segment that is entirely within the specified\nrectangle. it returns false if the line segment is completely outside the rectangle. Otherwise,\nit returns true .\n@param imgSize Image size. The image rectangle is Rect(0, 0, imgSize.width, imgSize.height) .\n@param pt1 First line point.\n@param pt2 Second line point."]
    #[link_name = "\u{1}_ZN2cv8clipLineENS_5Size_IiEERNS_6Point_IiEES4_"]
    pub fn cv_clipLine(imgSize: cv_Size, pt1: *mut cv_Point, pt2: *mut cv_Point) -> bool;
}
unsafe extern "C" {
    #[doc = " @overload\n@param imgSize Image size. The image rectangle is Rect(0, 0, imgSize.width, imgSize.height) .\n@param pt1 First line point.\n@param pt2 Second line point."]
    #[link_name = "\u{1}_ZN2cv8clipLineENS_5Size_IlEERNS_6Point_IlEES4_"]
    pub fn cv_clipLine1(imgSize: cv_Size2l, pt1: *mut cv_Point2l, pt2: *mut cv_Point2l) -> bool;
}
unsafe extern "C" {
    #[doc = " @overload\n@param imgRect Image rectangle.\n@param pt1 First line point.\n@param pt2 Second line point."]
    #[link_name = "\u{1}_ZN2cv8clipLineENS_5Rect_IiEERNS_6Point_IiEES4_"]
    pub fn cv_clipLine2(imgRect: cv_Rect, pt1: *mut cv_Point, pt2: *mut cv_Point) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Approximates an elliptic arc with a polyline.\n\nThe function ellipse2Poly computes the vertices of a polyline that approximates the specified\nelliptic arc. It is used by #ellipse. If `arcStart` is greater than `arcEnd`, they are swapped.\n\n@param center Center of the arc.\n@param axes Half of the size of the ellipse main axes. See #ellipse for details.\n@param angle Rotation angle of the ellipse in degrees. See #ellipse for details.\n@param arcStart Starting angle of the elliptic arc in degrees.\n@param arcEnd Ending angle of the elliptic arc in degrees.\n@param delta Angle between the subsequent polyline vertices. It defines the approximation\naccuracy.\n@param pts Output vector of polyline vertices."]
    #[link_name = "\u{1}_ZN2cv12ellipse2PolyENS_6Point_IiEENS_5Size_IiEEiiiiRSt6vectorIS1_SaIS1_EE"]
    pub fn cv_ellipse2Poly(
        center: cv_Point,
        axes: cv_Size,
        angle: ::std::os::raw::c_int,
        arcStart: ::std::os::raw::c_int,
        arcEnd: ::std::os::raw::c_int,
        delta: ::std::os::raw::c_int,
        pts: *mut std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param center Center of the arc.\n@param axes Half of the size of the ellipse main axes. See #ellipse for details.\n@param angle Rotation angle of the ellipse in degrees. See #ellipse for details.\n@param arcStart Starting angle of the elliptic arc in degrees.\n@param arcEnd Ending angle of the elliptic arc in degrees.\n@param delta Angle between the subsequent polyline vertices. It defines the approximation accuracy.\n@param pts Output vector of polyline vertices."]
    #[link_name = "\u{1}_ZN2cv12ellipse2PolyENS_6Point_IdEENS_5Size_IdEEiiiiRSt6vectorIS1_SaIS1_EE"]
    pub fn cv_ellipse2Poly1(
        center: cv_Point2d,
        axes: cv_Size2d,
        angle: ::std::os::raw::c_int,
        arcStart: ::std::os::raw::c_int,
        arcEnd: ::std::os::raw::c_int,
        delta: ::std::os::raw::c_int,
        pts: *mut std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @brief Draws a text string.\n\nThe function cv::putText renders the specified text string in the image. Symbols that cannot be rendered\nusing the specified font are replaced by question marks. See #getTextSize for a text rendering code\nexample.\n\n@param img Image.\n@param text Text string to be drawn.\n@param org Bottom-left corner of the text string in the image.\n@param fontFace Font type, see #HersheyFonts.\n@param fontScale Font scale factor that is multiplied by the font-specific base size.\n@param color Text color.\n@param thickness Thickness of the lines used to draw a text.\n@param lineType Line type. See #LineTypes\n@param bottomLeftOrigin When true, the image data origin is at the bottom-left corner. Otherwise,\nit is at the top-left corner."]
    #[link_name = "\u{1}_ZN2cv7putTextERKNS_17_InputOutputArrayERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS_6Point_IiEEidNS_7Scalar_IdEEiib"]
    pub fn cv_putText(
        img: cv_InputOutputArray,
        text: *const cv_String,
        org: cv_Point,
        fontFace: ::std::os::raw::c_int,
        fontScale: f64,
        color: cv_Scalar,
        thickness: ::std::os::raw::c_int,
        lineType: ::std::os::raw::c_int,
        bottomLeftOrigin: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief Calculates the width and height of a text string.\n\nThe function cv::getTextSize calculates and returns the size of a box that contains the specified text.\nThat is, the following code renders some text, the tight box surrounding it, and the baseline: :\n@code\nString text = \"Funny text inside the box\";\nint fontFace = FONT_HERSHEY_SCRIPT_SIMPLEX;\ndouble fontScale = 2;\nint thickness = 3;\n\nMat img(600, 800, CV_8UC3, Scalar::all(0));\n\nint baseline=0;\nSize textSize = getTextSize(text, fontFace,\nfontScale, thickness, &baseline);\nbaseline += thickness;\n\n// center the text\nPoint textOrg((img.cols - textSize.width)/2,\n(img.rows + textSize.height)/2);\n\n// draw the box\nrectangle(img, textOrg + Point(0, baseline),\ntextOrg + Point(textSize.width, -textSize.height),\nScalar(0,0,255));\n// ... and the baseline first\nline(img, textOrg + Point(0, thickness),\ntextOrg + Point(textSize.width, thickness),\nScalar(0, 0, 255));\n\n// then put the text itself\nputText(img, text, textOrg, fontFace, fontScale,\nScalar::all(255), thickness, 8);\n@endcode\n\n@param text Input text string.\n@param fontFace Font to use, see #HersheyFonts.\n@param fontScale Font scale factor that is multiplied by the font-specific base size.\n@param thickness Thickness of lines used to render the text. See #putText for details.\n@param[out] baseLine y-coordinate of the baseline relative to the bottom-most text\npoint.\n@return The size of a box that contains the specified text.\n\n@see putText"]
    #[link_name = "\u{1}_ZN2cv11getTextSizeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEidiPi"]
    pub fn cv_getTextSize(
        text: *const cv_String,
        fontFace: ::std::os::raw::c_int,
        fontScale: f64,
        thickness: ::std::os::raw::c_int,
        baseLine: *mut ::std::os::raw::c_int,
    ) -> cv_Size;
}
unsafe extern "C" {
    #[doc = " @brief Calculates the font-specific size to use to achieve a given height in pixels.\n\n@param fontFace Font to use, see cv::HersheyFonts.\n@param pixelHeight Pixel height to compute the fontScale for\n@param thickness Thickness of lines used to render the text.See putText for details.\n@return The fontSize to use for cv::putText\n\n@see cv::putText"]
    #[link_name = "\u{1}_ZN2cv22getFontScaleFromHeightEiii"]
    pub fn cv_getFontScaleFromHeight(
        fontFace: ::std::os::raw::c_int,
        pixelHeight: ::std::os::raw::c_int,
        thickness: ::std::os::raw::c_int,
    ) -> f64;
}
#[doc = " @brief Line iterator\n\nThe class is used to iterate over all the pixels on the raster line\nsegment connecting two specified points.\n\nThe class LineIterator is used to get each pixel of a raster line. It\ncan be treated as versatile implementation of the Bresenham algorithm\nwhere you can stop at each pixel and do some extra processing, for\nexample, grab pixel values along the line or draw a line with an effect\n(for example, with XOR operation).\n\nThe number of pixels along the line is stored in LineIterator::count.\nThe method LineIterator::pos returns the current position in the image:\n\n@code{.cpp}\n// grabs pixels along the line (pt1, pt2)\n// from 8-bit 3-channel image to the buffer\nLineIterator it(img, pt1, pt2, 8);\nLineIterator it2 = it;\nvector<Vec3b> buf(it.count);\n\nfor(int i = 0; i < it.count; i++, ++it)\nbuf[i] = *(const Vec3b*)*it;\n\n// alternative way of iterating through the line\nfor(int i = 0; i < it2.count; i++, ++it2)\n{\nVec3b val = img.at<Vec3b>(it2.pos());\nCV_Assert(buf[i] == val);\n}\n@endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_LineIterator {
    pub ptr: *mut uchar,
    pub ptr0: *const uchar,
    pub step: ::std::os::raw::c_int,
    pub elemSize: ::std::os::raw::c_int,
    pub err: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
    pub minusDelta: ::std::os::raw::c_int,
    pub plusDelta: ::std::os::raw::c_int,
    pub minusStep: ::std::os::raw::c_int,
    pub plusStep: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_LineIterator"][::std::mem::size_of::<cv_LineIterator>() - 48usize];
    ["Alignment of cv_LineIterator"][::std::mem::align_of::<cv_LineIterator>() - 8usize];
    ["Offset of field: cv_LineIterator::ptr"]
        [::std::mem::offset_of!(cv_LineIterator, ptr) - 0usize];
    ["Offset of field: cv_LineIterator::ptr0"]
        [::std::mem::offset_of!(cv_LineIterator, ptr0) - 8usize];
    ["Offset of field: cv_LineIterator::step"]
        [::std::mem::offset_of!(cv_LineIterator, step) - 16usize];
    ["Offset of field: cv_LineIterator::elemSize"]
        [::std::mem::offset_of!(cv_LineIterator, elemSize) - 20usize];
    ["Offset of field: cv_LineIterator::err"]
        [::std::mem::offset_of!(cv_LineIterator, err) - 24usize];
    ["Offset of field: cv_LineIterator::count"]
        [::std::mem::offset_of!(cv_LineIterator, count) - 28usize];
    ["Offset of field: cv_LineIterator::minusDelta"]
        [::std::mem::offset_of!(cv_LineIterator, minusDelta) - 32usize];
    ["Offset of field: cv_LineIterator::plusDelta"]
        [::std::mem::offset_of!(cv_LineIterator, plusDelta) - 36usize];
    ["Offset of field: cv_LineIterator::minusStep"]
        [::std::mem::offset_of!(cv_LineIterator, minusStep) - 40usize];
    ["Offset of field: cv_LineIterator::plusStep"]
        [::std::mem::offset_of!(cv_LineIterator, plusStep) - 44usize];
};
unsafe extern "C" {
    #[doc = " @brief initializes the iterator\n\ncreates iterators for the line connecting pt1 and pt2\nthe line will be clipped on the image boundaries\nthe line is 8-connected or 4-connected\nIf leftToRight=true, then the iteration is always done\nfrom the left-most point to the right most,\nnot to depend on the ordering of pt1 and pt2 parameters"]
    #[link_name = "\u{1}_ZN2cv12LineIteratorC1ERKNS_3MatENS_6Point_IiEES5_ib"]
    pub fn cv_LineIterator_LineIterator(
        this: *mut cv_LineIterator,
        img: *const cv_Mat,
        pt1: cv_Point,
        pt2: cv_Point,
        connectivity: ::std::os::raw::c_int,
        leftToRight: bool,
    );
}
impl cv_LineIterator {
    #[inline]
    pub unsafe fn new(
        img: *const cv_Mat,
        pt1: cv_Point,
        pt2: cv_Point,
        connectivity: ::std::os::raw::c_int,
        leftToRight: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_LineIterator_LineIterator(
            __bindgen_tmp.as_mut_ptr(),
            img,
            pt1,
            pt2,
            connectivity,
            leftToRight,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = "!< same as VAR_ORDERED"]
pub const cv_ml_VariableTypes_VAR_NUMERICAL: cv_ml_VariableTypes = 0;
#[doc = "!< ordered variables"]
pub const cv_ml_VariableTypes_VAR_ORDERED: cv_ml_VariableTypes = 0;
#[doc = "!< categorical variables"]
pub const cv_ml_VariableTypes_VAR_CATEGORICAL: cv_ml_VariableTypes = 1;
#[doc = " @brief Variable types"]
pub type cv_ml_VariableTypes = ::std::os::raw::c_uint;
pub const cv_ml_ErrorTypes_TEST_ERROR: cv_ml_ErrorTypes = 0;
pub const cv_ml_ErrorTypes_TRAIN_ERROR: cv_ml_ErrorTypes = 1;
#[doc = " @brief %Error types"]
pub type cv_ml_ErrorTypes = ::std::os::raw::c_uint;
#[doc = "!< each training sample is a row of samples"]
pub const cv_ml_SampleTypes_ROW_SAMPLE: cv_ml_SampleTypes = 0;
#[doc = "!< each training sample occupies a column of samples"]
pub const cv_ml_SampleTypes_COL_SAMPLE: cv_ml_SampleTypes = 1;
#[doc = " @brief Sample types"]
pub type cv_ml_SampleTypes = ::std::os::raw::c_uint;
#[doc = " @brief The structure represents the logarithmic grid range of statmodel parameters.\n\nIt is used for optimizing statmodel accuracy by varying model parameters, the accuracy estimate\nbeing computed by cross-validation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_ml_ParamGrid {
    #[doc = "!< Minimum value of the statmodel parameter. Default value is 0."]
    pub minVal: f64,
    #[doc = "!< Maximum value of the statmodel parameter. Default value is 0."]
    pub maxVal: f64,
    #[doc = " @brief Logarithmic step for iterating the statmodel parameter.\n\nThe grid determines the following iteration sequence of the statmodel parameter values:\n\\f[(minVal, minVal*step, minVal*{step}^2, \\dots,  minVal*{logStep}^n),\\f]\nwhere \\f$n\\f$ is the maximal index satisfying\n\\f[\\texttt{minVal} * \\texttt{logStep} ^n <  \\texttt{maxVal}\\f]\nThe grid is logarithmic, so logStep must always be greater than 1. Default value is 1."]
    pub logStep: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ml_ParamGrid"][::std::mem::size_of::<cv_ml_ParamGrid>() - 24usize];
    ["Alignment of cv_ml_ParamGrid"][::std::mem::align_of::<cv_ml_ParamGrid>() - 8usize];
    ["Offset of field: cv_ml_ParamGrid::minVal"]
        [::std::mem::offset_of!(cv_ml_ParamGrid, minVal) - 0usize];
    ["Offset of field: cv_ml_ParamGrid::maxVal"]
        [::std::mem::offset_of!(cv_ml_ParamGrid, maxVal) - 8usize];
    ["Offset of field: cv_ml_ParamGrid::logStep"]
        [::std::mem::offset_of!(cv_ml_ParamGrid, logStep) - 16usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates a ParamGrid Ptr that can be given to the %SVM::trainAuto method\n\n@param minVal minimum value of the parameter grid\n@param maxVal maximum value of the parameter grid\n@param logstep Logarithmic step for iterating the statmodel parameter"]
    #[link_name = "\u{1}_ZN2cv2ml9ParamGrid6createEddd"]
    pub fn cv_ml_ParamGrid_create(minVal: f64, maxVal: f64, logstep: f64) -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Default constructor"]
    #[link_name = "\u{1}_ZN2cv2ml9ParamGridC1Ev"]
    pub fn cv_ml_ParamGrid_ParamGrid(this: *mut cv_ml_ParamGrid);
}
unsafe extern "C" {
    #[doc = " @brief Constructor with parameters"]
    #[link_name = "\u{1}_ZN2cv2ml9ParamGridC1Eddd"]
    pub fn cv_ml_ParamGrid_ParamGrid1(
        this: *mut cv_ml_ParamGrid,
        _minVal: f64,
        _maxVal: f64,
        _logStep: f64,
    );
}
impl cv_ml_ParamGrid {
    #[inline]
    pub unsafe fn create(minVal: f64, maxVal: f64, logstep: f64) -> cv_Ptr {
        cv_ml_ParamGrid_create(minVal, maxVal, logstep)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_ml_ParamGrid_ParamGrid(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(_minVal: f64, _maxVal: f64, _logStep: f64) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_ml_ParamGrid_ParamGrid1(__bindgen_tmp.as_mut_ptr(), _minVal, _maxVal, _logStep);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct cv_ml_TrainData__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief Class encapsulating training data.\n\nPlease note that the class only specifies the interface of training data, but not implementation.\nAll the statistical model classes in _ml_ module accepts Ptr\\<TrainData\\> as parameter. In other\nwords, you can create your own class derived from TrainData and pass smart pointer to the instance\nof this class into StatModel::train.\n\n@sa @ref ml_intro_data"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_ml_TrainData {
    pub vtable_: *const cv_ml_TrainData__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ml_TrainData"][::std::mem::size_of::<cv_ml_TrainData>() - 8usize];
    ["Alignment of cv_ml_TrainData"][::std::mem::align_of::<cv_ml_TrainData>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Extract from 1D vector elements specified by passed indexes.\n@param vec input vector (supported types: CV_32S, CV_32F, CV_64F)\n@param idx 1D index vector"]
    #[link_name = "\u{1}_ZN2cv2ml9TrainData12getSubVectorERKNS_3MatES4_"]
    pub fn cv_ml_TrainData_getSubVector(vec: *const cv_Mat, idx: *const cv_Mat) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Extract from matrix rows/cols specified by passed indexes.\n@param matrix input matrix (supported types: CV_32S, CV_32F, CV_64F)\n@param idx 1D index vector\n@param layout specifies to extract rows (cv::ml::ROW_SAMPLES) or to extract columns (cv::ml::COL_SAMPLES)"]
    #[link_name = "\u{1}_ZN2cv2ml9TrainData12getSubMatrixERKNS_3MatES4_i"]
    pub fn cv_ml_TrainData_getSubMatrix(
        matrix: *const cv_Mat,
        idx: *const cv_Mat,
        layout: ::std::os::raw::c_int,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Reads the dataset from a .csv file and returns the ready-to-use training data.\n\n@param filename The input file name\n@param headerLineCount The number of lines in the beginning to skip; besides the header, the\nfunction also skips empty lines and lines staring with `#`\n@param responseStartIdx Index of the first output variable. If -1, the function considers the\nlast variable as the response\n@param responseEndIdx Index of the last output variable + 1. If -1, then there is single\nresponse variable at responseStartIdx.\n@param varTypeSpec The optional text string that specifies the variables' types. It has the\nformat `ord[n1-n2,n3,n4-n5,...]cat[n6,n7-n8,...]`. That is, variables from `n1 to n2`\n(inclusive range), `n3`, `n4 to n5` ... are considered ordered and `n6`, `n7 to n8` ... are\nconsidered as categorical. The range `[n1..n2] + [n3] + [n4..n5] + ... + [n6] + [n7..n8]`\nshould cover all the variables. If varTypeSpec is not specified, then algorithm uses the\nfollowing rules:\n- all input variables are considered ordered by default. If some column contains has non-\nnumerical values, e.g. 'apple', 'pear', 'apple', 'apple', 'mango', the corresponding\nvariable is considered categorical.\n- if there are several output variables, they are all considered as ordered. Error is\nreported when non-numerical values are used.\n- if there is a single output variable, then if its values are non-numerical or are all\nintegers, then it's considered categorical. Otherwise, it's considered ordered.\n@param delimiter The character used to separate values in each line.\n@param missch The character used to specify missing measurements. It should not be a digit.\nAlthough it's a non-numerical value, it surely does not affect the decision of whether the\nvariable ordered or categorical.\n@note If the dataset only contains input variables and no responses, use responseStartIdx = -2\nand responseEndIdx = 0. The output variables vector will just contain zeros."]
    #[link_name = "\u{1}_ZN2cv2ml9TrainData11loadFromCSVERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiiiS9_cc"]
    pub fn cv_ml_TrainData_loadFromCSV(
        filename: *const cv_String,
        headerLineCount: ::std::os::raw::c_int,
        responseStartIdx: ::std::os::raw::c_int,
        responseEndIdx: ::std::os::raw::c_int,
        varTypeSpec: *const cv_String,
        delimiter: ::std::os::raw::c_char,
        missch: ::std::os::raw::c_char,
    ) -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Creates training data from in-memory arrays.\n\n@param samples matrix of samples. It should have CV_32F type.\n@param layout see ml::SampleTypes.\n@param responses matrix of responses. If the responses are scalar, they should be stored as a\nsingle row or as a single column. The matrix should have type CV_32F or CV_32S (in the\nformer case the responses are considered as ordered by default; in the latter case - as\ncategorical)\n@param varIdx vector specifying which variables to use for training. It can be an integer vector\n(CV_32S) containing 0-based variable indices or byte vector (CV_8U) containing a mask of\nactive variables.\n@param sampleIdx vector specifying which samples to use for training. It can be an integer\nvector (CV_32S) containing 0-based sample indices or byte vector (CV_8U) containing a mask\nof training samples.\n@param sampleWeights optional vector with weights for each sample. It should have CV_32F type.\n@param varType optional vector of type CV_8U and size `<number_of_variables_in_samples> +\n<number_of_variables_in_responses>`, containing types of each input and output variable. See\nml::VariableTypes."]
    #[link_name = "\u{1}_ZN2cv2ml9TrainData6createERKNS_11_InputArrayEiS4_S4_S4_S4_S4_"]
    pub fn cv_ml_TrainData_create(
        samples: cv_InputArray,
        layout: ::std::os::raw::c_int,
        responses: cv_InputArray,
        varIdx: cv_InputArray,
        sampleIdx: cv_InputArray,
        sampleWeights: cv_InputArray,
        varType: cv_InputArray,
    ) -> cv_Ptr;
}
impl cv_ml_TrainData {
    #[inline]
    pub unsafe fn getSubVector(vec: *const cv_Mat, idx: *const cv_Mat) -> cv_Mat {
        cv_ml_TrainData_getSubVector(vec, idx)
    }
    #[inline]
    pub unsafe fn getSubMatrix(
        matrix: *const cv_Mat,
        idx: *const cv_Mat,
        layout: ::std::os::raw::c_int,
    ) -> cv_Mat {
        cv_ml_TrainData_getSubMatrix(matrix, idx, layout)
    }
    #[inline]
    pub unsafe fn loadFromCSV(
        filename: *const cv_String,
        headerLineCount: ::std::os::raw::c_int,
        responseStartIdx: ::std::os::raw::c_int,
        responseEndIdx: ::std::os::raw::c_int,
        varTypeSpec: *const cv_String,
        delimiter: ::std::os::raw::c_char,
        missch: ::std::os::raw::c_char,
    ) -> cv_Ptr {
        cv_ml_TrainData_loadFromCSV(
            filename,
            headerLineCount,
            responseStartIdx,
            responseEndIdx,
            varTypeSpec,
            delimiter,
            missch,
        )
    }
    #[inline]
    pub unsafe fn create(
        samples: cv_InputArray,
        layout: ::std::os::raw::c_int,
        responses: cv_InputArray,
        varIdx: cv_InputArray,
        sampleIdx: cv_InputArray,
        sampleWeights: cv_InputArray,
        varType: cv_InputArray,
    ) -> cv_Ptr {
        cv_ml_TrainData_create(
            samples,
            layout,
            responses,
            varIdx,
            sampleIdx,
            sampleWeights,
            varType,
        )
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv2ml9TrainDataD1Ev"]
    pub fn cv_ml_TrainData_TrainData_destructor(this: *mut cv_ml_TrainData);
}
#[doc = " @brief Base class for statistical models in OpenCV ML."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_ml_StatModel {
    pub _base: cv_Algorithm,
}
pub const cv_ml_StatModel_Flags_UPDATE_MODEL: cv_ml_StatModel_Flags = 1;
#[doc = "!< makes the method return the raw results (the sum), not the class label"]
pub const cv_ml_StatModel_Flags_RAW_OUTPUT: cv_ml_StatModel_Flags = 1;
pub const cv_ml_StatModel_Flags_COMPRESSED_INPUT: cv_ml_StatModel_Flags = 2;
pub const cv_ml_StatModel_Flags_PREPROCESSED_INPUT: cv_ml_StatModel_Flags = 4;
#[doc = " Predict options"]
pub type cv_ml_StatModel_Flags = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ml_StatModel"][::std::mem::size_of::<cv_ml_StatModel>() - 8usize];
    ["Alignment of cv_ml_StatModel"][::std::mem::align_of::<cv_ml_StatModel>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv2ml9StatModel5emptyEv"]
    pub fn cv_ml_StatModel_empty(this: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Trains the statistical model\n\n@param trainData training data that can be loaded from file using TrainData::loadFromCSV or\ncreated with TrainData::create.\n@param flags optional flags, depending on the model. Some of the models can be updated with the\nnew training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP)."]
    #[link_name = "\u{1}_ZN2cv2ml9StatModel5trainERKNS_3PtrINS0_9TrainDataEEEi"]
    pub fn cv_ml_StatModel_train(
        this: *mut ::std::os::raw::c_void,
        trainData: *const cv_Ptr,
        flags: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Trains the statistical model\n\n@param samples training samples\n@param layout See ml::SampleTypes.\n@param responses vector of responses associated with the training samples."]
    #[link_name = "\u{1}_ZN2cv2ml9StatModel5trainERKNS_11_InputArrayEiS4_"]
    pub fn cv_ml_StatModel_train1(
        this: *mut ::std::os::raw::c_void,
        samples: cv_InputArray,
        layout: ::std::os::raw::c_int,
        responses: cv_InputArray,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Computes error on the training or test dataset\n\n@param data the training data\n@param test if true, the error is computed over the test subset of the data, otherwise it's\ncomputed over the training subset of the data. Please note that if you loaded a completely\ndifferent dataset to evaluate already trained classifier, you will probably want not to set\nthe test subset at all with TrainData::setTrainTestSplitRatio and specify test=false, so\nthat the error is computed for the whole new set. Yes, this sounds a bit confusing.\n@param resp the optional output responses.\n\nThe method uses StatModel::predict to compute the error. For regression models the error is\ncomputed as RMS, for classifiers - as a percent of missclassified samples (0%-100%)."]
    #[link_name = "\u{1}_ZNK2cv2ml9StatModel9calcErrorERKNS_3PtrINS0_9TrainDataEEEbRKNS_12_OutputArrayE"]
    pub fn cv_ml_StatModel_calcError(
        this: *mut ::std::os::raw::c_void,
        data: *const cv_Ptr,
        test: bool,
        resp: cv_OutputArray,
    ) -> f32;
}
#[doc = " @brief Bayes classifier for normally distributed data.\n\n@sa @ref ml_intro_bayes"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_ml_NormalBayesClassifier {
    pub _base: cv_ml_StatModel,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ml_NormalBayesClassifier"]
        [::std::mem::size_of::<cv_ml_NormalBayesClassifier>() - 8usize];
    ["Alignment of cv_ml_NormalBayesClassifier"]
        [::std::mem::align_of::<cv_ml_NormalBayesClassifier>() - 8usize];
};
unsafe extern "C" {
    #[doc = " Creates empty model\nUse StatModel::train to train the model after creation."]
    #[link_name = "\u{1}_ZN2cv2ml21NormalBayesClassifier6createEv"]
    pub fn cv_ml_NormalBayesClassifier_create() -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Loads and creates a serialized NormalBayesClassifier from a file\n\n Use NormalBayesClassifier::save to serialize and store an NormalBayesClassifier to disk.\n Load the NormalBayesClassifier from this file again, by calling this function with the path to the file.\n Optionally specify the node for the file containing the classifier\n\n @param filepath path to serialized NormalBayesClassifier\n @param nodeName name of node containing the classifier"]
    #[link_name = "\u{1}_ZN2cv2ml21NormalBayesClassifier4loadERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_"]
    pub fn cv_ml_NormalBayesClassifier_load(
        filepath: *const cv_String,
        nodeName: *const cv_String,
    ) -> cv_Ptr;
}
impl cv_ml_NormalBayesClassifier {
    #[inline]
    pub unsafe fn create() -> cv_Ptr {
        cv_ml_NormalBayesClassifier_create()
    }
    #[inline]
    pub unsafe fn load(filepath: *const cv_String, nodeName: *const cv_String) -> cv_Ptr {
        cv_ml_NormalBayesClassifier_load(filepath, nodeName)
    }
}
#[doc = " @brief The class implements K-Nearest Neighbors model\n\n@sa @ref ml_intro_knn"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_ml_KNearest {
    pub _base: cv_ml_StatModel,
}
pub const cv_ml_KNearest_Types_BRUTE_FORCE: cv_ml_KNearest_Types = 1;
pub const cv_ml_KNearest_Types_KDTREE: cv_ml_KNearest_Types = 2;
#[doc = " @brief Implementations of KNearest algorithm"]
pub type cv_ml_KNearest_Types = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ml_KNearest"][::std::mem::size_of::<cv_ml_KNearest>() - 8usize];
    ["Alignment of cv_ml_KNearest"][::std::mem::align_of::<cv_ml_KNearest>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates the empty model\n\nThe static method creates empty %KNearest classifier. It should be then trained using StatModel::train method."]
    #[link_name = "\u{1}_ZN2cv2ml8KNearest6createEv"]
    pub fn cv_ml_KNearest_create() -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Loads and creates a serialized knearest from a file\n\n Use KNearest::save to serialize and store an KNearest to disk.\n Load the KNearest from this file again, by calling this function with the path to the file.\n\n @param filepath path to serialized KNearest"]
    #[link_name = "\u{1}_ZN2cv2ml8KNearest4loadERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_ml_KNearest_load(filepath: *const cv_String) -> cv_Ptr;
}
impl cv_ml_KNearest {
    #[inline]
    pub unsafe fn create() -> cv_Ptr {
        cv_ml_KNearest_create()
    }
    #[inline]
    pub unsafe fn load(filepath: *const cv_String) -> cv_Ptr {
        cv_ml_KNearest_load(filepath)
    }
}
#[doc = " @brief Support Vector Machines.\n\n@sa @ref ml_intro_svm"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_ml_SVM {
    pub _base: cv_ml_StatModel,
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_ml_SVM_Kernel {
    pub _base: cv_Algorithm,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ml_SVM_Kernel"][::std::mem::size_of::<cv_ml_SVM_Kernel>() - 8usize];
    ["Alignment of cv_ml_SVM_Kernel"][::std::mem::align_of::<cv_ml_SVM_Kernel>() - 8usize];
};
#[doc = " C-Support Vector Classification. n-class classification (n \\f$\\geq\\f$ 2), allows\nimperfect separation of classes with penalty multiplier C for outliers."]
pub const cv_ml_SVM_Types_C_SVC: cv_ml_SVM_Types = 100;
#[doc = " \\f$\\nu\\f$-Support Vector Classification. n-class classification with possible\nimperfect separation. Parameter \\f$\\nu\\f$ (in the range 0..1, the larger the value, the smoother\nthe decision boundary) is used instead of C."]
pub const cv_ml_SVM_Types_NU_SVC: cv_ml_SVM_Types = 101;
#[doc = " Distribution Estimation (One-class %SVM). All the training data are from\nthe same class, %SVM builds a boundary that separates the class from the rest of the feature\nspace."]
pub const cv_ml_SVM_Types_ONE_CLASS: cv_ml_SVM_Types = 102;
#[doc = " \\f$\\epsilon\\f$-Support Vector Regression. The distance between feature vectors\nfrom the training set and the fitting hyper-plane must be less than p. For outliers the\npenalty multiplier C is used."]
pub const cv_ml_SVM_Types_EPS_SVR: cv_ml_SVM_Types = 103;
#[doc = " \\f$\\nu\\f$-Support Vector Regression. \\f$\\nu\\f$ is used instead of p.\nSee @cite LibSVM for details."]
pub const cv_ml_SVM_Types_NU_SVR: cv_ml_SVM_Types = 104;
#[doc = "! %SVM type"]
pub type cv_ml_SVM_Types = ::std::os::raw::c_uint;
#[doc = " Returned by SVM::getKernelType in case when custom kernel has been set"]
pub const cv_ml_SVM_KernelTypes_CUSTOM: cv_ml_SVM_KernelTypes = -1;
#[doc = " Linear kernel. No mapping is done, linear discrimination (or regression) is\ndone in the original feature space. It is the fastest option. \\f$K(x_i, x_j) = x_i^T x_j\\f$."]
pub const cv_ml_SVM_KernelTypes_LINEAR: cv_ml_SVM_KernelTypes = 0;
#[doc = " Polynomial kernel:\n\\f$K(x_i, x_j) = (\\gamma x_i^T x_j + coef0)^{degree}, \\gamma > 0\\f$."]
pub const cv_ml_SVM_KernelTypes_POLY: cv_ml_SVM_KernelTypes = 1;
#[doc = " Radial basis function (RBF), a good choice in most cases.\n\\f$K(x_i, x_j) = e^{-\\gamma ||x_i - x_j||^2}, \\gamma > 0\\f$."]
pub const cv_ml_SVM_KernelTypes_RBF: cv_ml_SVM_KernelTypes = 2;
#[doc = " Sigmoid kernel: \\f$K(x_i, x_j) = \\tanh(\\gamma x_i^T x_j + coef0)\\f$."]
pub const cv_ml_SVM_KernelTypes_SIGMOID: cv_ml_SVM_KernelTypes = 3;
#[doc = " Exponential Chi2 kernel, similar to the RBF kernel:\n\\f$K(x_i, x_j) = e^{-\\gamma \\chi^2(x_i,x_j)}, \\chi^2(x_i,x_j) = (x_i-x_j)^2/(x_i+x_j), \\gamma > 0\\f$."]
pub const cv_ml_SVM_KernelTypes_CHI2: cv_ml_SVM_KernelTypes = 4;
#[doc = " Histogram intersection kernel. A fast kernel. \\f$K(x_i, x_j) = min(x_i,x_j)\\f$."]
pub const cv_ml_SVM_KernelTypes_INTER: cv_ml_SVM_KernelTypes = 5;
#[doc = " @brief %SVM kernel type\n\nA comparison of different kernels on the following 2D test case with four classes. Four\nSVM::C_SVC SVMs have been trained (one against rest) with auto_train. Evaluation on three\ndifferent kernels (SVM::CHI2, SVM::INTER, SVM::RBF). The color depicts the class with max score.\nBright means max-score \\> 0, dark means max-score \\< 0.\n[image](pics/SVM_Comparison.png)"]
pub type cv_ml_SVM_KernelTypes = ::std::os::raw::c_int;
pub const cv_ml_SVM_ParamTypes_C: cv_ml_SVM_ParamTypes = 0;
pub const cv_ml_SVM_ParamTypes_GAMMA: cv_ml_SVM_ParamTypes = 1;
pub const cv_ml_SVM_ParamTypes_P: cv_ml_SVM_ParamTypes = 2;
pub const cv_ml_SVM_ParamTypes_NU: cv_ml_SVM_ParamTypes = 3;
pub const cv_ml_SVM_ParamTypes_COEF: cv_ml_SVM_ParamTypes = 4;
pub const cv_ml_SVM_ParamTypes_DEGREE: cv_ml_SVM_ParamTypes = 5;
#[doc = "! %SVM params type"]
pub type cv_ml_SVM_ParamTypes = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ml_SVM"][::std::mem::size_of::<cv_ml_SVM>() - 8usize];
    ["Alignment of cv_ml_SVM"][::std::mem::align_of::<cv_ml_SVM>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Generates a grid for %SVM parameters.\n\n@param param_id %SVM parameters IDs that must be one of the SVM::ParamTypes. The grid is\ngenerated for the parameter with this ID.\n\nThe function generates a grid for the specified parameter of the %SVM algorithm. The grid may be\npassed to the function SVM::trainAuto."]
    #[link_name = "\u{1}_ZN2cv2ml3SVM14getDefaultGridEi"]
    pub fn cv_ml_SVM_getDefaultGrid(param_id: ::std::os::raw::c_int) -> cv_ml_ParamGrid;
}
unsafe extern "C" {
    #[doc = " @brief Generates a grid for %SVM parameters.\n\n@param param_id %SVM parameters IDs that must be one of the SVM::ParamTypes. The grid is\ngenerated for the parameter with this ID.\n\nThe function generates a grid pointer for the specified parameter of the %SVM algorithm.\nThe grid may be passed to the function SVM::trainAuto."]
    #[link_name = "\u{1}_ZN2cv2ml3SVM17getDefaultGridPtrEi"]
    pub fn cv_ml_SVM_getDefaultGridPtr(param_id: ::std::os::raw::c_int) -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " Creates empty model.\nUse StatModel::train to train the model. Since %SVM has several parameters, you may want to\nfind the best parameters for your problem, it can be done with SVM::trainAuto."]
    #[link_name = "\u{1}_ZN2cv2ml3SVM6createEv"]
    pub fn cv_ml_SVM_create() -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Loads and creates a serialized svm from a file\n\n Use SVM::save to serialize and store an SVM to disk.\n Load the SVM from this file again, by calling this function with the path to the file.\n\n @param filepath path to serialized svm"]
    #[link_name = "\u{1}_ZN2cv2ml3SVM4loadERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_ml_SVM_load(filepath: *const cv_String) -> cv_Ptr;
}
impl cv_ml_SVM {
    #[inline]
    pub unsafe fn getDefaultGrid(param_id: ::std::os::raw::c_int) -> cv_ml_ParamGrid {
        cv_ml_SVM_getDefaultGrid(param_id)
    }
    #[inline]
    pub unsafe fn getDefaultGridPtr(param_id: ::std::os::raw::c_int) -> cv_Ptr {
        cv_ml_SVM_getDefaultGridPtr(param_id)
    }
    #[inline]
    pub unsafe fn create() -> cv_Ptr {
        cv_ml_SVM_create()
    }
    #[inline]
    pub unsafe fn load(filepath: *const cv_String) -> cv_Ptr {
        cv_ml_SVM_load(filepath)
    }
}
#[doc = " @brief The class implements the Expectation Maximization algorithm.\n\n@sa @ref ml_intro_em"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_ml_EM {
    pub _base: cv_ml_StatModel,
}
#[doc = " A scaled identity matrix \\f$\\mu_k * I\\f$. There is the only\nparameter \\f$\\mu_k\\f$ to be estimated for each matrix. The option may be used in special cases,\nwhen the constraint is relevant, or as a first step in the optimization (for example in case\nwhen the data is preprocessed with PCA). The results of such preliminary estimation may be\npassed again to the optimization procedure, this time with\ncovMatType=EM::COV_MAT_DIAGONAL."]
pub const cv_ml_EM_Types_COV_MAT_SPHERICAL: cv_ml_EM_Types = 0;
#[doc = " A diagonal matrix with positive diagonal elements. The number of\nfree parameters is d for each matrix. This is most commonly used option yielding good\nestimation results."]
pub const cv_ml_EM_Types_COV_MAT_DIAGONAL: cv_ml_EM_Types = 1;
#[doc = " A symmetric positively defined matrix. The number of free\nparameters in each matrix is about \\f$d^2/2\\f$. It is not recommended to use this option, unless\nthere is pretty accurate initial estimation of the parameters and/or a huge number of\ntraining samples."]
pub const cv_ml_EM_Types_COV_MAT_GENERIC: cv_ml_EM_Types = 2;
#[doc = " A symmetric positively defined matrix. The number of free\nparameters in each matrix is about \\f$d^2/2\\f$. It is not recommended to use this option, unless\nthere is pretty accurate initial estimation of the parameters and/or a huge number of\ntraining samples."]
pub const cv_ml_EM_Types_COV_MAT_DEFAULT: cv_ml_EM_Types = 1;
#[doc = "! Type of covariation matrices"]
pub type cv_ml_EM_Types = ::std::os::raw::c_uint;
pub const cv_ml_EM_DEFAULT_NCLUSTERS: cv_ml_EM__bindgen_ty_1 = 5;
pub const cv_ml_EM_DEFAULT_MAX_ITERS: cv_ml_EM__bindgen_ty_1 = 100;
#[doc = "! Default parameters"]
pub type cv_ml_EM__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const cv_ml_EM_START_E_STEP: cv_ml_EM__bindgen_ty_2 = 1;
pub const cv_ml_EM_START_M_STEP: cv_ml_EM__bindgen_ty_2 = 2;
pub const cv_ml_EM_START_AUTO_STEP: cv_ml_EM__bindgen_ty_2 = 0;
#[doc = "! The initial step"]
pub type cv_ml_EM__bindgen_ty_2 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ml_EM"][::std::mem::size_of::<cv_ml_EM>() - 8usize];
    ["Alignment of cv_ml_EM"][::std::mem::align_of::<cv_ml_EM>() - 8usize];
};
unsafe extern "C" {
    #[doc = " Creates empty %EM model.\nThe model should be trained then using StatModel::train(traindata, flags) method. Alternatively, you\ncan use one of the EM::train\\* methods or load it from file using Algorithm::load\\<EM\\>(filename)."]
    #[link_name = "\u{1}_ZN2cv2ml2EM6createEv"]
    pub fn cv_ml_EM_create() -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Loads and creates a serialized EM from a file\n\n Use EM::save to serialize and store an EM to disk.\n Load the EM from this file again, by calling this function with the path to the file.\n Optionally specify the node for the file containing the classifier\n\n @param filepath path to serialized EM\n @param nodeName name of node containing the classifier"]
    #[link_name = "\u{1}_ZN2cv2ml2EM4loadERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_"]
    pub fn cv_ml_EM_load(filepath: *const cv_String, nodeName: *const cv_String) -> cv_Ptr;
}
impl cv_ml_EM {
    #[inline]
    pub unsafe fn create() -> cv_Ptr {
        cv_ml_EM_create()
    }
    #[inline]
    pub unsafe fn load(filepath: *const cv_String, nodeName: *const cv_String) -> cv_Ptr {
        cv_ml_EM_load(filepath, nodeName)
    }
}
#[doc = " @brief The class represents a single decision tree or a collection of decision trees.\n\nThe current public interface of the class allows user to train only a single decision tree, however\nthe class is capable of storing multiple decision trees and using them for prediction (by summing\nresponses or using a voting schemes), and the derived from DTrees classes (such as RTrees and Boost)\nuse this capability to implement decision tree ensembles.\n\n@sa @ref ml_intro_trees"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_ml_DTrees {
    pub _base: cv_ml_StatModel,
}
pub const cv_ml_DTrees_Flags_PREDICT_AUTO: cv_ml_DTrees_Flags = 0;
pub const cv_ml_DTrees_Flags_PREDICT_SUM: cv_ml_DTrees_Flags = 256;
pub const cv_ml_DTrees_Flags_PREDICT_MAX_VOTE: cv_ml_DTrees_Flags = 512;
pub const cv_ml_DTrees_Flags_PREDICT_MASK: cv_ml_DTrees_Flags = 768;
#[doc = " Predict options"]
pub type cv_ml_DTrees_Flags = ::std::os::raw::c_uint;
#[doc = " @brief The class represents a decision tree node."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_ml_DTrees_Node {
    #[doc = "!< Value at the node: a class label in case of classification or estimated\n!< function value in case of regression."]
    pub value: f64,
    #[doc = "!< Class index normalized to 0..class_count-1 range and assigned to the\n!< node. It is used internally in classification trees and tree ensembles."]
    pub classIdx: ::std::os::raw::c_int,
    #[doc = "!< Index of the parent node"]
    pub parent: ::std::os::raw::c_int,
    #[doc = "!< Index of the left child node"]
    pub left: ::std::os::raw::c_int,
    #[doc = "!< Index of right child node"]
    pub right: ::std::os::raw::c_int,
    #[doc = "!< Default direction where to go (-1: left or +1: right). It helps in the\n!< case of missing values."]
    pub defaultDir: ::std::os::raw::c_int,
    #[doc = "!< Index of the first split"]
    pub split: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ml_DTrees_Node"][::std::mem::size_of::<cv_ml_DTrees_Node>() - 32usize];
    ["Alignment of cv_ml_DTrees_Node"][::std::mem::align_of::<cv_ml_DTrees_Node>() - 8usize];
    ["Offset of field: cv_ml_DTrees_Node::value"]
        [::std::mem::offset_of!(cv_ml_DTrees_Node, value) - 0usize];
    ["Offset of field: cv_ml_DTrees_Node::classIdx"]
        [::std::mem::offset_of!(cv_ml_DTrees_Node, classIdx) - 8usize];
    ["Offset of field: cv_ml_DTrees_Node::parent"]
        [::std::mem::offset_of!(cv_ml_DTrees_Node, parent) - 12usize];
    ["Offset of field: cv_ml_DTrees_Node::left"]
        [::std::mem::offset_of!(cv_ml_DTrees_Node, left) - 16usize];
    ["Offset of field: cv_ml_DTrees_Node::right"]
        [::std::mem::offset_of!(cv_ml_DTrees_Node, right) - 20usize];
    ["Offset of field: cv_ml_DTrees_Node::defaultDir"]
        [::std::mem::offset_of!(cv_ml_DTrees_Node, defaultDir) - 24usize];
    ["Offset of field: cv_ml_DTrees_Node::split"]
        [::std::mem::offset_of!(cv_ml_DTrees_Node, split) - 28usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv2ml6DTrees4NodeC1Ev"]
    pub fn cv_ml_DTrees_Node_Node(this: *mut cv_ml_DTrees_Node);
}
impl cv_ml_DTrees_Node {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_ml_DTrees_Node_Node(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief The class represents split in a decision tree."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_ml_DTrees_Split {
    #[doc = "!< Index of variable on which the split is created."]
    pub varIdx: ::std::os::raw::c_int,
    #[doc = "!< If true, then the inverse split rule is used (i.e. left and right\n!< branches are exchanged in the rule expressions below)."]
    pub inversed: bool,
    #[doc = "!< The split quality, a positive number. It is used to choose the best split."]
    pub quality: f32,
    #[doc = "!< Index of the next split in the list of splits for the node"]
    pub next: ::std::os::raw::c_int,
    #[doc = "< The threshold value in case of split on an ordered variable.\nThe rule is:\n@code{.none}\nif var_value < c\nthen next_node <- left\nelse next_node <- right\n@endcode"]
    pub c: f32,
    #[doc = "< Offset of the bitset used by the split on a categorical variable.\nThe rule is:\n@code{.none}\nif bitset[var_value] == 1\nthen next_node <- left\nelse next_node <- right\n@endcode"]
    pub subsetOfs: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ml_DTrees_Split"][::std::mem::size_of::<cv_ml_DTrees_Split>() - 24usize];
    ["Alignment of cv_ml_DTrees_Split"][::std::mem::align_of::<cv_ml_DTrees_Split>() - 4usize];
    ["Offset of field: cv_ml_DTrees_Split::varIdx"]
        [::std::mem::offset_of!(cv_ml_DTrees_Split, varIdx) - 0usize];
    ["Offset of field: cv_ml_DTrees_Split::inversed"]
        [::std::mem::offset_of!(cv_ml_DTrees_Split, inversed) - 4usize];
    ["Offset of field: cv_ml_DTrees_Split::quality"]
        [::std::mem::offset_of!(cv_ml_DTrees_Split, quality) - 8usize];
    ["Offset of field: cv_ml_DTrees_Split::next"]
        [::std::mem::offset_of!(cv_ml_DTrees_Split, next) - 12usize];
    ["Offset of field: cv_ml_DTrees_Split::c"]
        [::std::mem::offset_of!(cv_ml_DTrees_Split, c) - 16usize];
    ["Offset of field: cv_ml_DTrees_Split::subsetOfs"]
        [::std::mem::offset_of!(cv_ml_DTrees_Split, subsetOfs) - 20usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv2ml6DTrees5SplitC1Ev"]
    pub fn cv_ml_DTrees_Split_Split(this: *mut cv_ml_DTrees_Split);
}
impl cv_ml_DTrees_Split {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_ml_DTrees_Split_Split(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ml_DTrees"][::std::mem::size_of::<cv_ml_DTrees>() - 8usize];
    ["Alignment of cv_ml_DTrees"][::std::mem::align_of::<cv_ml_DTrees>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates the empty model\n\nThe static method creates empty decision tree with the specified parameters. It should be then\ntrained using train method (see StatModel::train). Alternatively, you can load the model from\nfile using Algorithm::load\\<DTrees\\>(filename)."]
    #[link_name = "\u{1}_ZN2cv2ml6DTrees6createEv"]
    pub fn cv_ml_DTrees_create() -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Loads and creates a serialized DTrees from a file\n\n Use DTree::save to serialize and store an DTree to disk.\n Load the DTree from this file again, by calling this function with the path to the file.\n Optionally specify the node for the file containing the classifier\n\n @param filepath path to serialized DTree\n @param nodeName name of node containing the classifier"]
    #[link_name = "\u{1}_ZN2cv2ml6DTrees4loadERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_"]
    pub fn cv_ml_DTrees_load(filepath: *const cv_String, nodeName: *const cv_String) -> cv_Ptr;
}
impl cv_ml_DTrees {
    #[inline]
    pub unsafe fn create() -> cv_Ptr {
        cv_ml_DTrees_create()
    }
    #[inline]
    pub unsafe fn load(filepath: *const cv_String, nodeName: *const cv_String) -> cv_Ptr {
        cv_ml_DTrees_load(filepath, nodeName)
    }
}
#[doc = " @brief The class implements the random forest predictor.\n\n@sa @ref ml_intro_rtrees"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_ml_RTrees {
    pub _base: cv_ml_DTrees,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ml_RTrees"][::std::mem::size_of::<cv_ml_RTrees>() - 8usize];
    ["Alignment of cv_ml_RTrees"][::std::mem::align_of::<cv_ml_RTrees>() - 8usize];
};
unsafe extern "C" {
    #[doc = " Creates the empty model.\nUse StatModel::train to train the model, StatModel::train to create and train the model,\nAlgorithm::load to load the pre-trained model."]
    #[link_name = "\u{1}_ZN2cv2ml6RTrees6createEv"]
    pub fn cv_ml_RTrees_create() -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Loads and creates a serialized RTree from a file\n\n Use RTree::save to serialize and store an RTree to disk.\n Load the RTree from this file again, by calling this function with the path to the file.\n Optionally specify the node for the file containing the classifier\n\n @param filepath path to serialized RTree\n @param nodeName name of node containing the classifier"]
    #[link_name = "\u{1}_ZN2cv2ml6RTrees4loadERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_"]
    pub fn cv_ml_RTrees_load(filepath: *const cv_String, nodeName: *const cv_String) -> cv_Ptr;
}
impl cv_ml_RTrees {
    #[inline]
    pub unsafe fn create() -> cv_Ptr {
        cv_ml_RTrees_create()
    }
    #[inline]
    pub unsafe fn load(filepath: *const cv_String, nodeName: *const cv_String) -> cv_Ptr {
        cv_ml_RTrees_load(filepath, nodeName)
    }
}
#[doc = " @brief Boosted tree classifier derived from DTrees\n\n@sa @ref ml_intro_boost"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_ml_Boost {
    pub _base: cv_ml_DTrees,
}
#[doc = "!< Discrete AdaBoost."]
pub const cv_ml_Boost_Types_DISCRETE: cv_ml_Boost_Types = 0;
#[doc = "!< Real AdaBoost. It is a technique that utilizes confidence-rated predictions\n!< and works well with categorical data."]
pub const cv_ml_Boost_Types_REAL: cv_ml_Boost_Types = 1;
#[doc = "!< LogitBoost. It can produce good regression fits."]
pub const cv_ml_Boost_Types_LOGIT: cv_ml_Boost_Types = 2;
#[doc = "!< Gentle AdaBoost. It puts less weight on outlier data points and for that\n!<reason is often good with regression data."]
pub const cv_ml_Boost_Types_GENTLE: cv_ml_Boost_Types = 3;
#[doc = " Boosting type.\nGentle AdaBoost and Real AdaBoost are often the preferable choices."]
pub type cv_ml_Boost_Types = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ml_Boost"][::std::mem::size_of::<cv_ml_Boost>() - 8usize];
    ["Alignment of cv_ml_Boost"][::std::mem::align_of::<cv_ml_Boost>() - 8usize];
};
unsafe extern "C" {
    #[doc = " Creates the empty model.\nUse StatModel::train to train the model, Algorithm::load\\<Boost\\>(filename) to load the pre-trained model."]
    #[link_name = "\u{1}_ZN2cv2ml5Boost6createEv"]
    pub fn cv_ml_Boost_create() -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Loads and creates a serialized Boost from a file\n\n Use Boost::save to serialize and store an RTree to disk.\n Load the Boost from this file again, by calling this function with the path to the file.\n Optionally specify the node for the file containing the classifier\n\n @param filepath path to serialized Boost\n @param nodeName name of node containing the classifier"]
    #[link_name = "\u{1}_ZN2cv2ml5Boost4loadERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_"]
    pub fn cv_ml_Boost_load(filepath: *const cv_String, nodeName: *const cv_String) -> cv_Ptr;
}
impl cv_ml_Boost {
    #[inline]
    pub unsafe fn create() -> cv_Ptr {
        cv_ml_Boost_create()
    }
    #[inline]
    pub unsafe fn load(filepath: *const cv_String, nodeName: *const cv_String) -> cv_Ptr {
        cv_ml_Boost_load(filepath, nodeName)
    }
}
#[doc = " @brief Artificial Neural Networks - Multi-Layer Perceptrons.\n\nUnlike many other models in ML that are constructed and trained at once, in the MLP model these\nsteps are separated. First, a network with the specified topology is created using the non-default\nconstructor or the method ANN_MLP::create. All the weights are set to zeros. Then, the network is\ntrained using a set of input and output vectors. The training procedure can be repeated more than\nonce, that is, the weights can be adjusted based on the new training data.\n\nAdditional flags for StatModel::train are available: ANN_MLP::TrainFlags.\n\n@sa @ref ml_intro_ann"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_ml_ANN_MLP {
    pub _base: cv_ml_StatModel,
}
#[doc = "!< The back-propagation algorithm."]
pub const cv_ml_ANN_MLP_TrainingMethods_BACKPROP: cv_ml_ANN_MLP_TrainingMethods = 0;
#[doc = "!< The RPROP algorithm. See @cite RPROP93 for details."]
pub const cv_ml_ANN_MLP_TrainingMethods_RPROP: cv_ml_ANN_MLP_TrainingMethods = 1;
#[doc = "!< The simulated annealing algorithm. See @cite Kirkpatrick83 for details."]
pub const cv_ml_ANN_MLP_TrainingMethods_ANNEAL: cv_ml_ANN_MLP_TrainingMethods = 2;
#[doc = " Available training methods"]
pub type cv_ml_ANN_MLP_TrainingMethods = ::std::os::raw::c_uint;
#[doc = " Identity function: \\f$f(x)=x\\f$"]
pub const cv_ml_ANN_MLP_ActivationFunctions_IDENTITY: cv_ml_ANN_MLP_ActivationFunctions = 0;
#[doc = " Symmetrical sigmoid: \\f$f(x)=\\beta*(1-e^{-\\alpha x})/(1+e^{-\\alpha x})\\f$\n@note\nIf you are using the default sigmoid activation function with the default parameter values\nfparam1=0 and fparam2=0 then the function used is y = 1.7159\\*tanh(2/3 \\* x), so the output\nwill range from [-1.7159, 1.7159], instead of [0,1]."]
pub const cv_ml_ANN_MLP_ActivationFunctions_SIGMOID_SYM: cv_ml_ANN_MLP_ActivationFunctions = 1;
#[doc = " Gaussian function: \\f$f(x)=\\beta e^{-\\alpha x*x}\\f$"]
pub const cv_ml_ANN_MLP_ActivationFunctions_GAUSSIAN: cv_ml_ANN_MLP_ActivationFunctions = 2;
#[doc = " ReLU function: \\f$f(x)=max(0,x)\\f$"]
pub const cv_ml_ANN_MLP_ActivationFunctions_RELU: cv_ml_ANN_MLP_ActivationFunctions = 3;
#[doc = " Leaky ReLU function: for x>0 \\f$f(x)=x \\f$ and x<=0 \\f$f(x)=\\alpha x \\f$"]
pub const cv_ml_ANN_MLP_ActivationFunctions_LEAKYRELU: cv_ml_ANN_MLP_ActivationFunctions = 4;
#[doc = " possible activation functions"]
pub type cv_ml_ANN_MLP_ActivationFunctions = ::std::os::raw::c_uint;
#[doc = " Update the network weights, rather than compute them from scratch. In the latter case\nthe weights are initialized using the Nguyen-Widrow algorithm."]
pub const cv_ml_ANN_MLP_TrainFlags_UPDATE_WEIGHTS: cv_ml_ANN_MLP_TrainFlags = 1;
#[doc = " Do not normalize the input vectors. If this flag is not set, the training algorithm\nnormalizes each input feature independently, shifting its mean value to 0 and making the\nstandard deviation equal to 1. If the network is assumed to be updated frequently, the new\ntraining data could be much different from original one. In this case, you should take care\nof proper normalization."]
pub const cv_ml_ANN_MLP_TrainFlags_NO_INPUT_SCALE: cv_ml_ANN_MLP_TrainFlags = 2;
#[doc = " Do not normalize the output vectors. If the flag is not set, the training algorithm\nnormalizes each output feature independently, by transforming it to the certain range\ndepending on the used activation function."]
pub const cv_ml_ANN_MLP_TrainFlags_NO_OUTPUT_SCALE: cv_ml_ANN_MLP_TrainFlags = 4;
#[doc = " Train options"]
pub type cv_ml_ANN_MLP_TrainFlags = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ml_ANN_MLP"][::std::mem::size_of::<cv_ml_ANN_MLP>() - 8usize];
    ["Alignment of cv_ml_ANN_MLP"][::std::mem::align_of::<cv_ml_ANN_MLP>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates empty model\n\nUse StatModel::train to train the model, Algorithm::load\\<ANN_MLP\\>(filename) to load the pre-trained model.\nNote that the train method has optional flags: ANN_MLP::TrainFlags."]
    #[link_name = "\u{1}_ZN2cv2ml7ANN_MLP6createEv"]
    pub fn cv_ml_ANN_MLP_create() -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Loads and creates a serialized ANN from a file\n\n Use ANN::save to serialize and store an ANN to disk.\n Load the ANN from this file again, by calling this function with the path to the file.\n\n @param filepath path to serialized ANN"]
    #[link_name = "\u{1}_ZN2cv2ml7ANN_MLP4loadERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_ml_ANN_MLP_load(filepath: *const cv_String) -> cv_Ptr;
}
impl cv_ml_ANN_MLP {
    #[inline]
    pub unsafe fn create() -> cv_Ptr {
        cv_ml_ANN_MLP_create()
    }
    #[inline]
    pub unsafe fn load(filepath: *const cv_String) -> cv_Ptr {
        cv_ml_ANN_MLP_load(filepath)
    }
}
#[doc = " @brief Artificial Neural Networks - Multi-Layer Perceptrons.\n\nUnlike many other models in ML that are constructed and trained at once, in the MLP model these\nsteps are separated. First, a network with the specified topology is created using the non-default\nconstructor or the method ANN_MLP::create. All the weights are set to zeros. Then, the network is\ntrained using a set of input and output vectors. The training procedure can be repeated more than\nonce, that is, the weights can be adjusted based on the new training data.\n\nAdditional flags for StatModel::train are available: ANN_MLP::TrainFlags.\n\n@sa @ref ml_intro_ann"]
pub type cv_ml_ANN_MLP_ANNEAL = cv_ml_ANN_MLP;
#[doc = " @brief Implements Logistic Regression classifier.\n\n@sa @ref ml_intro_lr"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_ml_LogisticRegression {
    pub _base: cv_ml_StatModel,
}
#[doc = "!< Regularization disabled"]
pub const cv_ml_LogisticRegression_RegKinds_REG_DISABLE: cv_ml_LogisticRegression_RegKinds = -1;
#[doc = "!< %L1 norm"]
pub const cv_ml_LogisticRegression_RegKinds_REG_L1: cv_ml_LogisticRegression_RegKinds = 0;
#[doc = "!< %L2 norm"]
pub const cv_ml_LogisticRegression_RegKinds_REG_L2: cv_ml_LogisticRegression_RegKinds = 1;
#[doc = "! Regularization kinds"]
pub type cv_ml_LogisticRegression_RegKinds = ::std::os::raw::c_int;
pub const cv_ml_LogisticRegression_Methods_BATCH: cv_ml_LogisticRegression_Methods = 0;
#[doc = "!< Set MiniBatchSize to a positive integer when using this method."]
pub const cv_ml_LogisticRegression_Methods_MINI_BATCH: cv_ml_LogisticRegression_Methods = 1;
#[doc = "! Training methods"]
pub type cv_ml_LogisticRegression_Methods = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ml_LogisticRegression"]
        [::std::mem::size_of::<cv_ml_LogisticRegression>() - 8usize];
    ["Alignment of cv_ml_LogisticRegression"]
        [::std::mem::align_of::<cv_ml_LogisticRegression>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates empty model.\n\nCreates Logistic Regression model with parameters given."]
    #[link_name = "\u{1}_ZN2cv2ml18LogisticRegression6createEv"]
    pub fn cv_ml_LogisticRegression_create() -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Loads and creates a serialized LogisticRegression from a file\n\n Use LogisticRegression::save to serialize and store an LogisticRegression to disk.\n Load the LogisticRegression from this file again, by calling this function with the path to the file.\n Optionally specify the node for the file containing the classifier\n\n @param filepath path to serialized LogisticRegression\n @param nodeName name of node containing the classifier"]
    #[link_name = "\u{1}_ZN2cv2ml18LogisticRegression4loadERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_"]
    pub fn cv_ml_LogisticRegression_load(
        filepath: *const cv_String,
        nodeName: *const cv_String,
    ) -> cv_Ptr;
}
impl cv_ml_LogisticRegression {
    #[inline]
    pub unsafe fn create() -> cv_Ptr {
        cv_ml_LogisticRegression_create()
    }
    #[inline]
    pub unsafe fn load(filepath: *const cv_String, nodeName: *const cv_String) -> cv_Ptr {
        cv_ml_LogisticRegression_load(filepath, nodeName)
    }
}
#[doc = "@brief Stochastic Gradient Descent SVM classifier\n\nSVMSGD provides a fast and easy-to-use implementation of the SVM classifier using the Stochastic Gradient Descent approach,\nas presented in @cite bottou2010large.\n\nThe classifier has following parameters:\n- model type,\n- margin type,\n- margin regularization (\\f$\\lambda\\f$),\n- initial step size (\\f$\\gamma_0\\f$),\n- step decreasing power (\\f$c\\f$),\n- and termination criteria.\n\nThe model type may have one of the following values: \\ref SGD and \\ref ASGD.\n\n- \\ref SGD is the classic version of SVMSGD classifier: every next step is calculated by the formula\n\\f[w_{t+1} = w_t - \\gamma(t) \\frac{dQ_i}{dw} |_{w = w_t}\\f]\nwhere\n- \\f$w_t\\f$ is the weights vector for decision function at step \\f$t\\f$,\n- \\f$\\gamma(t)\\f$ is the step size of model parameters at the iteration \\f$t\\f$, it is decreased on each step by the formula\n\\f$\\gamma(t) = \\gamma_0  (1 + \\lambda  \\gamma_0 t) ^ {-c}\\f$\n- \\f$Q_i\\f$ is the target functional from SVM task for sample with number \\f$i\\f$, this sample is chosen stochastically on each step of the algorithm.\n\n- \\ref ASGD is Average Stochastic Gradient Descent SVM Classifier. ASGD classifier averages weights vector on each step of algorithm by the formula\n\\f$\\widehat{w}_{t+1} = \\frac{t}{1+t}\\widehat{w}_{t} + \\frac{1}{1+t}w_{t+1}\\f$\n\nThe recommended model type is ASGD (following @cite bottou2010large).\n\nThe margin type may have one of the following values: \\ref SOFT_MARGIN or \\ref HARD_MARGIN.\n\n- You should use \\ref HARD_MARGIN type, if you have linearly separable sets.\n- You should use \\ref SOFT_MARGIN type, if you have non-linearly separable sets or sets with outliers.\n- In the general case (if you know nothing about linear separability of your sets), use SOFT_MARGIN.\n\nThe other parameters may be described as follows:\n- Margin regularization parameter is responsible for weights decreasing at each step and for the strength of restrictions on outliers\n(the less the parameter, the less probability that an outlier will be ignored).\nRecommended value for SGD model is 0.0001, for ASGD model is 0.00001.\n\n- Initial step size parameter is the initial value for the step size \\f$\\gamma(t)\\f$.\nYou will have to find the best initial step for your problem.\n\n- Step decreasing power is the power parameter for \\f$\\gamma(t)\\f$ decreasing by the formula, mentioned above.\nRecommended value for SGD model is 1, for ASGD model is 0.75.\n\n- Termination criteria can be TermCriteria::COUNT, TermCriteria::EPS or TermCriteria::COUNT + TermCriteria::EPS.\nYou will have to find the best termination criteria for your problem.\n\nNote that the parameters margin regularization, initial step size, and step decreasing power should be positive.\n\nTo use SVMSGD algorithm do as follows:\n\n- first, create the SVMSGD object. The algorithm will set optimal parameters by default, but you can set your own parameters via functions setSvmsgdType(),\nsetMarginType(), setMarginRegularization(), setInitialStepSize(), and setStepDecreasingPower().\n\n- then the SVM model can be trained using the train features and the correspondent labels by the method train().\n\n- after that, the label of a new feature vector can be predicted using the method predict().\n\n@code\n// Create empty object\ncv::Ptr<SVMSGD> svmsgd = SVMSGD::create();\n\n// Train the Stochastic Gradient Descent SVM\nsvmsgd->train(trainData);\n\n// Predict labels for the new samples\nsvmsgd->predict(samples, responses);\n@endcode"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_ml_SVMSGD {
    pub _base: cv_ml_StatModel,
}
#[doc = "!< Stochastic Gradient Descent"]
pub const cv_ml_SVMSGD_SvmsgdType_SGD: cv_ml_SVMSGD_SvmsgdType = 0;
#[doc = "!< Average Stochastic Gradient Descent"]
pub const cv_ml_SVMSGD_SvmsgdType_ASGD: cv_ml_SVMSGD_SvmsgdType = 1;
#[doc = " SVMSGD type.\nASGD is often the preferable choice."]
pub type cv_ml_SVMSGD_SvmsgdType = ::std::os::raw::c_uint;
#[doc = "!< General case, suits to the case of non-linearly separable sets, allows outliers."]
pub const cv_ml_SVMSGD_MarginType_SOFT_MARGIN: cv_ml_SVMSGD_MarginType = 0;
#[doc = "!< More accurate for the case of linearly separable sets."]
pub const cv_ml_SVMSGD_MarginType_HARD_MARGIN: cv_ml_SVMSGD_MarginType = 1;
#[doc = " Margin type."]
pub type cv_ml_SVMSGD_MarginType = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ml_SVMSGD"][::std::mem::size_of::<cv_ml_SVMSGD>() - 8usize];
    ["Alignment of cv_ml_SVMSGD"][::std::mem::align_of::<cv_ml_SVMSGD>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates empty model.\n Use StatModel::train to train the model. Since %SVMSGD has several parameters, you may want to\n find the best parameters for your problem or use setOptimalParameters() to set some default parameters."]
    #[link_name = "\u{1}_ZN2cv2ml6SVMSGD6createEv"]
    pub fn cv_ml_SVMSGD_create() -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Loads and creates a serialized SVMSGD from a file\n\n Use SVMSGD::save to serialize and store an SVMSGD to disk.\n Load the SVMSGD from this file again, by calling this function with the path to the file.\n Optionally specify the node for the file containing the classifier\n\n @param filepath path to serialized SVMSGD\n @param nodeName name of node containing the classifier"]
    #[link_name = "\u{1}_ZN2cv2ml6SVMSGD4loadERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_"]
    pub fn cv_ml_SVMSGD_load(filepath: *const cv_String, nodeName: *const cv_String) -> cv_Ptr;
}
impl cv_ml_SVMSGD {
    #[inline]
    pub unsafe fn create() -> cv_Ptr {
        cv_ml_SVMSGD_create()
    }
    #[inline]
    pub unsafe fn load(filepath: *const cv_String, nodeName: *const cv_String) -> cv_Ptr {
        cv_ml_SVMSGD_load(filepath, nodeName)
    }
}
unsafe extern "C" {
    #[doc = " @brief Generates _sample_ from multivariate normal distribution\n\n@param mean an average row vector\n@param cov symmetric covariation matrix\n@param nsamples returned samples count\n@param samples returned samples array"]
    #[link_name = "\u{1}_ZN2cv2ml12randMVNormalERKNS_11_InputArrayES3_iRKNS_12_OutputArrayE"]
    pub fn cv_ml_randMVNormal(
        mean: cv_InputArray,
        cov: cv_InputArray,
        nsamples: ::std::os::raw::c_int,
        samples: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Creates test set"]
    #[link_name = "\u{1}_ZN2cv2ml30createConcentricSpheresTestSetEiiiRKNS_12_OutputArrayES3_"]
    pub fn cv_ml_createConcentricSpheresTestSet(
        nsamples: ::std::os::raw::c_int,
        nfeatures: ::std::os::raw::c_int,
        nclasses: ::std::os::raw::c_int,
        samples: cv_OutputArray,
        responses: cv_OutputArray,
    );
}
#[doc = "! class for grouping object candidates, detected by Cascade Classifier, HOG etc.\n! instance of the class is to be passed to cv::partition (see cxoperations.hpp)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_SimilarRects {
    pub eps: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_SimilarRects"][::std::mem::size_of::<cv_SimilarRects>() - 8usize];
    ["Alignment of cv_SimilarRects"][::std::mem::align_of::<cv_SimilarRects>() - 8usize];
    ["Offset of field: cv_SimilarRects::eps"]
        [::std::mem::offset_of!(cv_SimilarRects, eps) - 0usize];
};
unsafe extern "C" {
    #[doc = " @brief Groups the object candidate rectangles.\n\n@param rectList Input/output vector of rectangles. Output vector includes retained and grouped\nrectangles. (The Python list is not modified in place.)\n@param groupThreshold Minimum possible number of rectangles minus 1. The threshold is used in a\ngroup of rectangles to retain it.\n@param eps Relative difference between sides of the rectangles to merge them into a group.\n\nThe function is a wrapper for the generic function partition . It clusters all the input rectangles\nusing the rectangle equivalence criteria that combines rectangles with similar sizes and similar\nlocations. The similarity is defined by eps. When eps=0 , no clustering is done at all. If\n\\f$\\texttt{eps}\\rightarrow +\\inf\\f$ , all the rectangles are put in one cluster. Then, the small\nclusters containing less than or equal to groupThreshold rectangles are rejected. In each other\ncluster, the average rectangle is computed and put into the output rectangle list."]
    #[link_name = "\u{1}_ZN2cv15groupRectanglesERSt6vectorINS_5Rect_IiEESaIS2_EEid"]
    pub fn cv_groupRectangles(
        rectList: *mut std_vector,
        groupThreshold: ::std::os::raw::c_int,
        eps: f64,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv15groupRectanglesERSt6vectorINS_5Rect_IiEESaIS2_EERS0_IiSaIiEEid"]
    pub fn cv_groupRectangles1(
        rectList: *mut std_vector,
        weights: *mut std_vector,
        groupThreshold: ::std::os::raw::c_int,
        eps: f64,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv15groupRectanglesERSt6vectorINS_5Rect_IiEESaIS2_EEidPS0_IiSaIiEEPS0_IdSaIdEE"]
    pub fn cv_groupRectangles2(
        rectList: *mut std_vector,
        groupThreshold: ::std::os::raw::c_int,
        eps: f64,
        weights: *mut std_vector,
        levelWeights: *mut std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv15groupRectanglesERSt6vectorINS_5Rect_IiEESaIS2_EERS0_IiSaIiEERS0_IdSaIdEEid"]
    pub fn cv_groupRectangles3(
        rectList: *mut std_vector,
        rejectLevels: *mut std_vector,
        levelWeights: *mut std_vector,
        groupThreshold: ::std::os::raw::c_int,
        eps: f64,
    );
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv25groupRectangles_meanshiftERSt6vectorINS_5Rect_IiEESaIS2_EERS0_IdSaIdEES8_dNS_5Size_IiEE"]
    pub fn cv_groupRectangles_meanshift(
        rectList: *mut std_vector,
        foundWeights: *mut std_vector,
        foundScales: *mut std_vector,
        detectThreshold: f64,
        winDetSize: cv_Size,
    );
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_DefaultDeleter_open0_CvHaarClassifierCascade_close0"]
        [::std::mem::size_of::<cv_DefaultDeleter>() - 1usize];
    ["Align of template specialization: cv_DefaultDeleter_open0_CvHaarClassifierCascade_close0"]
        [::std::mem::align_of::<cv_DefaultDeleter>() - 1usize];
};
pub const CASCADE_DO_CANNY_PRUNING: cv__bindgen_ty_25 = 1;
pub const CASCADE_SCALE_IMAGE: cv__bindgen_ty_25 = 2;
pub const CASCADE_FIND_BIGGEST_OBJECT: cv__bindgen_ty_25 = 4;
pub const CASCADE_DO_ROUGH_SEARCH: cv__bindgen_ty_25 = 8;
pub type cv__bindgen_ty_25 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct cv_BaseCascadeClassifier {
    pub _base: cv_Algorithm,
}
#[repr(C)]
pub struct cv_BaseCascadeClassifier_MaskGenerator__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct cv_BaseCascadeClassifier_MaskGenerator {
    pub vtable_: *const cv_BaseCascadeClassifier_MaskGenerator__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_BaseCascadeClassifier_MaskGenerator"]
        [::std::mem::size_of::<cv_BaseCascadeClassifier_MaskGenerator>() - 8usize];
    ["Alignment of cv_BaseCascadeClassifier_MaskGenerator"]
        [::std::mem::align_of::<cv_BaseCascadeClassifier_MaskGenerator>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_BaseCascadeClassifier"]
        [::std::mem::size_of::<cv_BaseCascadeClassifier>() - 8usize];
    ["Alignment of cv_BaseCascadeClassifier"]
        [::std::mem::align_of::<cv_BaseCascadeClassifier>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv21BaseCascadeClassifierD1Ev"]
    pub fn cv_BaseCascadeClassifier_BaseCascadeClassifier_destructor(
        this: *mut cv_BaseCascadeClassifier,
    );
}
#[doc = " @example samples/cpp/facedetect.cpp\nThis program demonstrates usage of the Cascade classifier class\n\\image html Cascade_Classifier_Tutorial_Result_Haar.jpg \"Sample screenshot\" width=321 height=254\n/\n/** @brief Cascade classifier class for object detection."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_CascadeClassifier {
    pub cc: cv_Ptr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_CascadeClassifier"][::std::mem::size_of::<cv_CascadeClassifier>() - 16usize];
    ["Alignment of cv_CascadeClassifier"][::std::mem::align_of::<cv_CascadeClassifier>() - 8usize];
    ["Offset of field: cv_CascadeClassifier::cc"]
        [::std::mem::offset_of!(cv_CascadeClassifier, cc) - 0usize];
};
unsafe extern "C" {
    #[doc = " @brief Checks whether the classifier has been loaded."]
    #[link_name = "\u{1}_ZNK2cv17CascadeClassifier5emptyEv"]
    pub fn cv_CascadeClassifier_empty(this: *const cv_CascadeClassifier) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Loads a classifier from a file.\n\n@param filename Name of the file from which the classifier is loaded. The file may contain an old\nHAAR classifier trained by the haartraining application or a new cascade classifier trained by the\ntraincascade application."]
    #[link_name = "\u{1}_ZN2cv17CascadeClassifier4loadERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_CascadeClassifier_load(
        this: *mut cv_CascadeClassifier,
        filename: *const cv_String,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Reads a classifier from a FileStorage node.\n\n@note The file may contain a new cascade classifier (trained traincascade application) only."]
    #[link_name = "\u{1}_ZN2cv17CascadeClassifier4readERKNS_8FileNodeE"]
    pub fn cv_CascadeClassifier_read(
        this: *mut cv_CascadeClassifier,
        node: *const cv_FileNode,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Detects objects of different sizes in the input image. The detected objects are returned as a list\nof rectangles.\n\n@param image Matrix of the type CV_8U containing an image where objects are detected.\n@param objects Vector of rectangles where each rectangle contains the detected object, the\nrectangles may be partially outside the original image.\n@param scaleFactor Parameter specifying how much the image size is reduced at each image scale.\n@param minNeighbors Parameter specifying how many neighbors each candidate rectangle should have\nto retain it.\n@param flags Parameter with the same meaning for an old cascade as in the function\ncvHaarDetectObjects. It is not used for a new cascade.\n@param minSize Minimum possible object size. Objects smaller than that are ignored.\n@param maxSize Maximum possible object size. Objects larger than that are ignored. If `maxSize == minSize` model is evaluated on single scale.\n\nThe function is parallelized with the TBB library.\n\n@note\n-   (Python) A face detection example using cascade classifiers can be found at\nopencv_source_code/samples/python/facedetect.py"]
    #[link_name = "\u{1}_ZN2cv17CascadeClassifier16detectMultiScaleERKNS_11_InputArrayERSt6vectorINS_5Rect_IiEESaIS6_EEdiiNS_5Size_IiEESB_"]
    pub fn cv_CascadeClassifier_detectMultiScale(
        this: *mut cv_CascadeClassifier,
        image: cv_InputArray,
        objects: *mut std_vector,
        scaleFactor: f64,
        minNeighbors: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        minSize: cv_Size,
        maxSize: cv_Size,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param image Matrix of the type CV_8U containing an image where objects are detected.\n@param objects Vector of rectangles where each rectangle contains the detected object, the\nrectangles may be partially outside the original image.\n@param numDetections Vector of detection numbers for the corresponding objects. An object's number\nof detections is the number of neighboring positively classified rectangles that were joined\ntogether to form the object.\n@param scaleFactor Parameter specifying how much the image size is reduced at each image scale.\n@param minNeighbors Parameter specifying how many neighbors each candidate rectangle should have\nto retain it.\n@param flags Parameter with the same meaning for an old cascade as in the function\ncvHaarDetectObjects. It is not used for a new cascade.\n@param minSize Minimum possible object size. Objects smaller than that are ignored.\n@param maxSize Maximum possible object size. Objects larger than that are ignored. If `maxSize == minSize` model is evaluated on single scale."]
    #[link_name = "\u{1}_ZN2cv17CascadeClassifier16detectMultiScaleERKNS_11_InputArrayERSt6vectorINS_5Rect_IiEESaIS6_EERS4_IiSaIiEEdiiNS_5Size_IiEESE_"]
    pub fn cv_CascadeClassifier_detectMultiScale1(
        this: *mut cv_CascadeClassifier,
        image: cv_InputArray,
        objects: *mut std_vector,
        numDetections: *mut std_vector,
        scaleFactor: f64,
        minNeighbors: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        minSize: cv_Size,
        maxSize: cv_Size,
    );
}
unsafe extern "C" {
    #[doc = " @overload\nThis function allows you to retrieve the final stage decision certainty of classification.\nFor this, one needs to set `outputRejectLevels` on true and provide the `rejectLevels` and `levelWeights` parameter.\nFor each resulting detection, `levelWeights` will then contain the certainty of classification at the final stage.\nThis value can then be used to separate strong from weaker classifications.\n\nA code sample on how to use it efficiently can be found below:\n@code\nMat img;\nvector<double> weights;\nvector<int> levels;\nvector<Rect> detections;\nCascadeClassifier model(\"/path/to/your/model.xml\");\nmodel.detectMultiScale(img, detections, levels, weights, 1.1, 3, 0, Size(), Size(), true);\ncerr << \"Detection \" << detections[0] << \" with weight \" << weights[0] << endl;\n@endcode"]
    #[link_name = "\u{1}_ZN2cv17CascadeClassifier16detectMultiScaleERKNS_11_InputArrayERSt6vectorINS_5Rect_IiEESaIS6_EERS4_IiSaIiEERS4_IdSaIdEEdiiNS_5Size_IiEESH_b"]
    pub fn cv_CascadeClassifier_detectMultiScale2(
        this: *mut cv_CascadeClassifier,
        image: cv_InputArray,
        objects: *mut std_vector,
        rejectLevels: *mut std_vector,
        levelWeights: *mut std_vector,
        scaleFactor: f64,
        minNeighbors: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        minSize: cv_Size,
        maxSize: cv_Size,
        outputRejectLevels: bool,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv17CascadeClassifier18isOldFormatCascadeEv"]
    pub fn cv_CascadeClassifier_isOldFormatCascade(this: *const cv_CascadeClassifier) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv17CascadeClassifier21getOriginalWindowSizeEv"]
    pub fn cv_CascadeClassifier_getOriginalWindowSize(this: *const cv_CascadeClassifier)
    -> cv_Size;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv17CascadeClassifier14getFeatureTypeEv"]
    pub fn cv_CascadeClassifier_getFeatureType(
        this: *const cv_CascadeClassifier,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17CascadeClassifier13getOldCascadeEv"]
    pub fn cv_CascadeClassifier_getOldCascade(
        this: *mut cv_CascadeClassifier,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17CascadeClassifier7convertERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
    pub fn cv_CascadeClassifier_convert(
        oldcascade: *const cv_String,
        newcascade: *const cv_String,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17CascadeClassifier16setMaskGeneratorERKNS_3PtrINS_21BaseCascadeClassifier13MaskGeneratorEEE"]
    pub fn cv_CascadeClassifier_setMaskGenerator(
        this: *mut cv_CascadeClassifier,
        maskGenerator: *const cv_Ptr,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17CascadeClassifier16getMaskGeneratorEv"]
    pub fn cv_CascadeClassifier_getMaskGenerator(this: *mut cv_CascadeClassifier) -> cv_Ptr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17CascadeClassifierC1Ev"]
    pub fn cv_CascadeClassifier_CascadeClassifier(this: *mut cv_CascadeClassifier);
}
unsafe extern "C" {
    #[doc = " @brief Loads a classifier from a file.\n\n@param filename Name of the file from which the classifier is loaded."]
    #[link_name = "\u{1}_ZN2cv17CascadeClassifierC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_CascadeClassifier_CascadeClassifier1(
        this: *mut cv_CascadeClassifier,
        filename: *const cv_String,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv17CascadeClassifierD1Ev"]
    pub fn cv_CascadeClassifier_CascadeClassifier_destructor(this: *mut cv_CascadeClassifier);
}
impl cv_CascadeClassifier {
    #[inline]
    pub unsafe fn empty(&self) -> bool {
        cv_CascadeClassifier_empty(self)
    }
    #[inline]
    pub unsafe fn load(&mut self, filename: *const cv_String) -> bool {
        cv_CascadeClassifier_load(self, filename)
    }
    #[inline]
    pub unsafe fn read(&mut self, node: *const cv_FileNode) -> bool {
        cv_CascadeClassifier_read(self, node)
    }
    #[inline]
    pub unsafe fn detectMultiScale(
        &mut self,
        image: cv_InputArray,
        objects: *mut std_vector,
        scaleFactor: f64,
        minNeighbors: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        minSize: cv_Size,
        maxSize: cv_Size,
    ) {
        cv_CascadeClassifier_detectMultiScale(
            self,
            image,
            objects,
            scaleFactor,
            minNeighbors,
            flags,
            minSize,
            maxSize,
        )
    }
    #[inline]
    pub unsafe fn detectMultiScale1(
        &mut self,
        image: cv_InputArray,
        objects: *mut std_vector,
        numDetections: *mut std_vector,
        scaleFactor: f64,
        minNeighbors: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        minSize: cv_Size,
        maxSize: cv_Size,
    ) {
        cv_CascadeClassifier_detectMultiScale1(
            self,
            image,
            objects,
            numDetections,
            scaleFactor,
            minNeighbors,
            flags,
            minSize,
            maxSize,
        )
    }
    #[inline]
    pub unsafe fn detectMultiScale2(
        &mut self,
        image: cv_InputArray,
        objects: *mut std_vector,
        rejectLevels: *mut std_vector,
        levelWeights: *mut std_vector,
        scaleFactor: f64,
        minNeighbors: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        minSize: cv_Size,
        maxSize: cv_Size,
        outputRejectLevels: bool,
    ) {
        cv_CascadeClassifier_detectMultiScale2(
            self,
            image,
            objects,
            rejectLevels,
            levelWeights,
            scaleFactor,
            minNeighbors,
            flags,
            minSize,
            maxSize,
            outputRejectLevels,
        )
    }
    #[inline]
    pub unsafe fn isOldFormatCascade(&self) -> bool {
        cv_CascadeClassifier_isOldFormatCascade(self)
    }
    #[inline]
    pub unsafe fn getOriginalWindowSize(&self) -> cv_Size {
        cv_CascadeClassifier_getOriginalWindowSize(self)
    }
    #[inline]
    pub unsafe fn getFeatureType(&self) -> ::std::os::raw::c_int {
        cv_CascadeClassifier_getFeatureType(self)
    }
    #[inline]
    pub unsafe fn getOldCascade(&mut self) -> *mut ::std::os::raw::c_void {
        cv_CascadeClassifier_getOldCascade(self)
    }
    #[inline]
    pub unsafe fn convert(oldcascade: *const cv_String, newcascade: *const cv_String) -> bool {
        cv_CascadeClassifier_convert(oldcascade, newcascade)
    }
    #[inline]
    pub unsafe fn setMaskGenerator(&mut self, maskGenerator: *const cv_Ptr) {
        cv_CascadeClassifier_setMaskGenerator(self, maskGenerator)
    }
    #[inline]
    pub unsafe fn getMaskGenerator(&mut self) -> cv_Ptr {
        cv_CascadeClassifier_getMaskGenerator(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_CascadeClassifier_CascadeClassifier(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(filename: *const cv_String) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_CascadeClassifier_CascadeClassifier1(__bindgen_tmp.as_mut_ptr(), filename);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cv_CascadeClassifier_CascadeClassifier_destructor(self)
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv32createFaceDetectionMaskGeneratorEv"]
    pub fn cv_createFaceDetectionMaskGenerator() -> cv_Ptr;
}
#[doc = "! struct for detection region of interest (ROI)"]
#[repr(C)]
pub struct cv_DetectionROI {
    #[doc = "! scale(size) of the bounding box"]
    pub scale: f64,
    #[doc = "! set of requested locations to be evaluated"]
    pub locations: std_vector,
    #[doc = "! vector that will contain confidence values for each location"]
    pub confidences: std_vector,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_DetectionROI"][::std::mem::size_of::<cv_DetectionROI>() - 56usize];
    ["Alignment of cv_DetectionROI"][::std::mem::align_of::<cv_DetectionROI>() - 8usize];
    ["Offset of field: cv_DetectionROI::scale"]
        [::std::mem::offset_of!(cv_DetectionROI, scale) - 0usize];
    ["Offset of field: cv_DetectionROI::locations"]
        [::std::mem::offset_of!(cv_DetectionROI, locations) - 8usize];
    ["Offset of field: cv_DetectionROI::confidences"]
        [::std::mem::offset_of!(cv_DetectionROI, confidences) - 32usize];
};
#[repr(C)]
pub struct cv_HOGDescriptor__bindgen_vtable(::std::os::raw::c_void);
#[doc = "@brief Implementation of HOG (Histogram of Oriented Gradients) descriptor and object detector.\n\nthe HOG descriptor algorithm introduced by Navneet Dalal and Bill Triggs @cite Dalal2005 .\n\nuseful links:\n\nhttps://hal.inria.fr/inria-00548512/document/\n\nhttps://en.wikipedia.org/wiki/Histogram_of_oriented_gradients\n\nhttps://software.intel.com/en-us/ipp-dev-reference-histogram-of-oriented-gradients-hog-descriptor\n\nhttp://www.learnopencv.com/histogram-of-oriented-gradients\n\nhttp://www.learnopencv.com/handwritten-digits-classification-an-opencv-c-python-tutorial\n"]
#[repr(C)]
pub struct cv_HOGDescriptor {
    pub vtable_: *const cv_HOGDescriptor__bindgen_vtable,
    #[doc = "! Detection window size. Align to block size and block stride. Default value is Size(64,128)."]
    pub winSize: cv_Size,
    #[doc = "! Block size in pixels. Align to cell size. Default value is Size(16,16)."]
    pub blockSize: cv_Size,
    #[doc = "! Block stride. It must be a multiple of cell size. Default value is Size(8,8)."]
    pub blockStride: cv_Size,
    #[doc = "! Cell size. Default value is Size(8,8)."]
    pub cellSize: cv_Size,
    #[doc = "! Number of bins used in the calculation of histogram of gradients. Default value is 9."]
    pub nbins: ::std::os::raw::c_int,
    #[doc = "! not documented"]
    pub derivAperture: ::std::os::raw::c_int,
    #[doc = "! Gaussian smoothing window parameter."]
    pub winSigma: f64,
    #[doc = "! histogramNormType"]
    pub histogramNormType: cv_HOGDescriptor_HistogramNormType,
    #[doc = "! L2-Hys normalization method shrinkage."]
    pub L2HysThreshold: f64,
    #[doc = "! Flag to specify whether the gamma correction preprocessing is required or not."]
    pub gammaCorrection: bool,
    #[doc = "! coefficients for the linear SVM classifier."]
    pub svmDetector: std_vector,
    #[doc = "! coefficients for the linear SVM classifier used when OpenCL is enabled"]
    pub oclSvmDetector: cv_UMat,
    #[doc = "! not documented"]
    pub free_coef: f32,
    #[doc = "! Maximum number of detection window increases. Default value is 64"]
    pub nlevels: ::std::os::raw::c_int,
    #[doc = "! Indicates signed gradient will be used or not"]
    pub signedGradient: bool,
}
#[doc = "!< Default histogramNormType"]
pub const cv_HOGDescriptor_HistogramNormType_L2Hys: cv_HOGDescriptor_HistogramNormType = 0;
pub type cv_HOGDescriptor_HistogramNormType = ::std::os::raw::c_uint;
#[doc = "!< Default nlevels value."]
pub const cv_HOGDescriptor_DEFAULT_NLEVELS: cv_HOGDescriptor__bindgen_ty_1 = 64;
pub type cv_HOGDescriptor__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const cv_HOGDescriptor_DescriptorStorageFormat_DESCR_FORMAT_COL_BY_COL:
    cv_HOGDescriptor_DescriptorStorageFormat = 0;
pub const cv_HOGDescriptor_DescriptorStorageFormat_DESCR_FORMAT_ROW_BY_ROW:
    cv_HOGDescriptor_DescriptorStorageFormat = 1;
pub type cv_HOGDescriptor_DescriptorStorageFormat = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_HOGDescriptor"][::std::mem::size_of::<cv_HOGDescriptor>() - 200usize];
    ["Alignment of cv_HOGDescriptor"][::std::mem::align_of::<cv_HOGDescriptor>() - 8usize];
    ["Offset of field: cv_HOGDescriptor::winSize"]
        [::std::mem::offset_of!(cv_HOGDescriptor, winSize) - 8usize];
    ["Offset of field: cv_HOGDescriptor::blockSize"]
        [::std::mem::offset_of!(cv_HOGDescriptor, blockSize) - 16usize];
    ["Offset of field: cv_HOGDescriptor::blockStride"]
        [::std::mem::offset_of!(cv_HOGDescriptor, blockStride) - 24usize];
    ["Offset of field: cv_HOGDescriptor::cellSize"]
        [::std::mem::offset_of!(cv_HOGDescriptor, cellSize) - 32usize];
    ["Offset of field: cv_HOGDescriptor::nbins"]
        [::std::mem::offset_of!(cv_HOGDescriptor, nbins) - 40usize];
    ["Offset of field: cv_HOGDescriptor::derivAperture"]
        [::std::mem::offset_of!(cv_HOGDescriptor, derivAperture) - 44usize];
    ["Offset of field: cv_HOGDescriptor::winSigma"]
        [::std::mem::offset_of!(cv_HOGDescriptor, winSigma) - 48usize];
    ["Offset of field: cv_HOGDescriptor::histogramNormType"]
        [::std::mem::offset_of!(cv_HOGDescriptor, histogramNormType) - 56usize];
    ["Offset of field: cv_HOGDescriptor::L2HysThreshold"]
        [::std::mem::offset_of!(cv_HOGDescriptor, L2HysThreshold) - 64usize];
    ["Offset of field: cv_HOGDescriptor::gammaCorrection"]
        [::std::mem::offset_of!(cv_HOGDescriptor, gammaCorrection) - 72usize];
    ["Offset of field: cv_HOGDescriptor::svmDetector"]
        [::std::mem::offset_of!(cv_HOGDescriptor, svmDetector) - 80usize];
    ["Offset of field: cv_HOGDescriptor::oclSvmDetector"]
        [::std::mem::offset_of!(cv_HOGDescriptor, oclSvmDetector) - 104usize];
    ["Offset of field: cv_HOGDescriptor::free_coef"]
        [::std::mem::offset_of!(cv_HOGDescriptor, free_coef) - 184usize];
    ["Offset of field: cv_HOGDescriptor::nlevels"]
        [::std::mem::offset_of!(cv_HOGDescriptor, nlevels) - 188usize];
    ["Offset of field: cv_HOGDescriptor::signedGradient"]
        [::std::mem::offset_of!(cv_HOGDescriptor, signedGradient) - 192usize];
};
unsafe extern "C" {
    #[doc = "@brief Returns the number of coefficients required for the classification."]
    #[link_name = "\u{1}_ZNK2cv13HOGDescriptor17getDescriptorSizeEv"]
    pub fn cv_HOGDescriptor_getDescriptorSize(this: *const cv_HOGDescriptor) -> usize;
}
unsafe extern "C" {
    #[doc = " @brief Checks if detector size equal to descriptor size."]
    #[link_name = "\u{1}_ZNK2cv13HOGDescriptor17checkDetectorSizeEv"]
    pub fn cv_HOGDescriptor_checkDetectorSize(this: *const cv_HOGDescriptor) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Returns winSigma value"]
    #[link_name = "\u{1}_ZNK2cv13HOGDescriptor11getWinSigmaEv"]
    pub fn cv_HOGDescriptor_getWinSigma(this: *const cv_HOGDescriptor) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Returns coefficients of the classifier trained for people detection (for 64x128 windows)."]
    #[link_name = "\u{1}_ZN2cv13HOGDescriptor24getDefaultPeopleDetectorEv"]
    pub fn cv_HOGDescriptor_getDefaultPeopleDetector() -> std_vector;
}
unsafe extern "C" {
    #[doc = "@example samples/tapi/hog.cpp\n/\n/** @brief Returns coefficients of the classifier trained for people detection (for 48x96 windows)."]
    #[link_name = "\u{1}_ZN2cv13HOGDescriptor24getDaimlerPeopleDetectorEv"]
    pub fn cv_HOGDescriptor_getDaimlerPeopleDetector() -> std_vector;
}
unsafe extern "C" {
    #[doc = " @brief Groups the object candidate rectangles.\n@param rectList  Input/output vector of rectangles. Output vector includes retained and grouped rectangles. (The Python list is not modified in place.)\n@param weights Input/output vector of weights of rectangles. Output vector includes weights of retained and grouped rectangles. (The Python list is not modified in place.)\n@param groupThreshold Minimum possible number of rectangles minus 1. The threshold is used in a group of rectangles to retain it.\n@param eps Relative difference between sides of the rectangles to merge them into a group."]
    #[link_name = "\u{1}_ZNK2cv13HOGDescriptor15groupRectanglesERSt6vectorINS_5Rect_IiEESaIS3_EERS1_IdSaIdEEid"]
    pub fn cv_HOGDescriptor_groupRectangles(
        this: *const cv_HOGDescriptor,
        rectList: *mut std_vector,
        weights: *mut std_vector,
        groupThreshold: ::std::os::raw::c_int,
        eps: f64,
    );
}
impl cv_HOGDescriptor {
    #[inline]
    pub unsafe fn getDescriptorSize(&self) -> usize {
        cv_HOGDescriptor_getDescriptorSize(self)
    }
    #[inline]
    pub unsafe fn checkDetectorSize(&self) -> bool {
        cv_HOGDescriptor_checkDetectorSize(self)
    }
    #[inline]
    pub unsafe fn getWinSigma(&self) -> f64 {
        cv_HOGDescriptor_getWinSigma(self)
    }
    #[inline]
    pub unsafe fn getDefaultPeopleDetector() -> std_vector {
        cv_HOGDescriptor_getDefaultPeopleDetector()
    }
    #[inline]
    pub unsafe fn getDaimlerPeopleDetector() -> std_vector {
        cv_HOGDescriptor_getDaimlerPeopleDetector()
    }
    #[inline]
    pub unsafe fn groupRectangles(
        &self,
        rectList: *mut std_vector,
        weights: *mut std_vector,
        groupThreshold: ::std::os::raw::c_int,
        eps: f64,
    ) {
        cv_HOGDescriptor_groupRectangles(self, rectList, weights, groupThreshold, eps)
    }
}
unsafe extern "C" {
    #[doc = "@example samples/cpp/peopledetect.cpp\n/\n/**@brief Sets coefficients for the linear SVM classifier.\n@param svmdetector coefficients for the linear SVM classifier."]
    #[link_name = "\u{1}_ZN2cv13HOGDescriptor14setSVMDetectorERKNS_11_InputArrayE"]
    pub fn cv_HOGDescriptor_setSVMDetector(
        this: *mut ::std::os::raw::c_void,
        svmdetector: cv_InputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Reads HOGDescriptor parameters from a cv::FileNode.\n@param fn File node"]
    #[link_name = "\u{1}_ZN2cv13HOGDescriptor4readERNS_8FileNodeE"]
    pub fn cv_HOGDescriptor_read(this: *mut ::std::os::raw::c_void, fn_: *mut cv_FileNode) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Stores HOGDescriptor parameters in a cv::FileStorage.\n@param fs File storage\n@param objname Object name"]
    #[link_name = "\u{1}_ZNK2cv13HOGDescriptor5writeERNS_11FileStorageERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_HOGDescriptor_write(
        this: *mut ::std::os::raw::c_void,
        fs: *mut cv_FileStorage,
        objname: *const cv_String,
    );
}
unsafe extern "C" {
    #[doc = " @brief loads HOGDescriptor parameters and coefficients for the linear SVM classifier from a file.\n@param filename Path of the file to read.\n@param objname The optional name of the node to read (if empty, the first top-level node will be used)."]
    #[link_name = "\u{1}_ZN2cv13HOGDescriptor4loadERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
    pub fn cv_HOGDescriptor_load(
        this: *mut ::std::os::raw::c_void,
        filename: *const cv_String,
        objname: *const cv_String,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief saves HOGDescriptor parameters and coefficients for the linear SVM classifier to a file\n@param filename File name\n@param objname Object name"]
    #[link_name = "\u{1}_ZNK2cv13HOGDescriptor4saveERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
    pub fn cv_HOGDescriptor_save(
        this: *mut ::std::os::raw::c_void,
        filename: *const cv_String,
        objname: *const cv_String,
    );
}
unsafe extern "C" {
    #[doc = " @brief clones the HOGDescriptor\n@param c cloned HOGDescriptor"]
    #[link_name = "\u{1}_ZNK2cv13HOGDescriptor6copyToERS0_"]
    pub fn cv_HOGDescriptor_copyTo(this: *mut ::std::os::raw::c_void, c: *mut cv_HOGDescriptor);
}
unsafe extern "C" {
    #[doc = "@example samples/cpp/train_HOG.cpp\n/\n/** @brief Computes HOG descriptors of given image.\n@param img Matrix of the type CV_8U containing an image where HOG features will be calculated.\n@param descriptors Matrix of the type CV_32F\n@param winStride Window stride. It must be a multiple of block stride.\n@param padding Padding\n@param locations Vector of Point"]
    #[link_name = "\u{1}_ZNK2cv13HOGDescriptor7computeERKNS_11_InputArrayERSt6vectorIfSaIfEENS_5Size_IiEES9_RKS4_INS_6Point_IiEESaISB_EE"]
    pub fn cv_HOGDescriptor_compute(
        this: *mut ::std::os::raw::c_void,
        img: cv_InputArray,
        descriptors: *mut std_vector,
        winStride: cv_Size,
        padding: cv_Size,
        locations: *const std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @brief Performs object detection without a multi-scale window.\n@param img Matrix of the type CV_8U or CV_8UC3 containing an image where objects are detected.\n@param foundLocations Vector of point where each point contains left-top corner point of detected object boundaries.\n@param weights Vector that will contain confidence values for each detected object.\n@param hitThreshold Threshold for the distance between features and SVM classifying plane.\nUsually it is 0 and should be specified in the detector coefficients (as the last free coefficient).\nBut if the free coefficient is omitted (which is allowed), you can specify it manually here.\n@param winStride Window stride. It must be a multiple of block stride.\n@param padding Padding\n@param searchLocations Vector of Point includes set of requested locations to be evaluated."]
    #[link_name = "\u{1}_ZNK2cv13HOGDescriptor6detectERKNS_11_InputArrayERSt6vectorINS_6Point_IiEESaIS6_EERS4_IdSaIdEEdNS_5Size_IiEESE_RKS8_"]
    pub fn cv_HOGDescriptor_detect(
        this: *mut ::std::os::raw::c_void,
        img: cv_InputArray,
        foundLocations: *mut std_vector,
        weights: *mut std_vector,
        hitThreshold: f64,
        winStride: cv_Size,
        padding: cv_Size,
        searchLocations: *const std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @brief Performs object detection without a multi-scale window.\n@param img Matrix of the type CV_8U or CV_8UC3 containing an image where objects are detected.\n@param foundLocations Vector of point where each point contains left-top corner point of detected object boundaries.\n@param hitThreshold Threshold for the distance between features and SVM classifying plane.\nUsually it is 0 and should be specified in the detector coefficients (as the last free coefficient).\nBut if the free coefficient is omitted (which is allowed), you can specify it manually here.\n@param winStride Window stride. It must be a multiple of block stride.\n@param padding Padding\n@param searchLocations Vector of Point includes locations to search."]
    #[link_name = "\u{1}_ZNK2cv13HOGDescriptor6detectERKNS_11_InputArrayERSt6vectorINS_6Point_IiEESaIS6_EEdNS_5Size_IiEESB_RKS8_"]
    pub fn cv_HOGDescriptor_detect1(
        this: *mut ::std::os::raw::c_void,
        img: cv_InputArray,
        foundLocations: *mut std_vector,
        hitThreshold: f64,
        winStride: cv_Size,
        padding: cv_Size,
        searchLocations: *const std_vector,
    );
}
unsafe extern "C" {
    #[doc = " @brief Detects objects of different sizes in the input image. The detected objects are returned as a list\nof rectangles.\n@param img Matrix of the type CV_8U or CV_8UC3 containing an image where objects are detected.\n@param foundLocations Vector of rectangles where each rectangle contains the detected object.\n@param foundWeights Vector that will contain confidence values for each detected object.\n@param hitThreshold Threshold for the distance between features and SVM classifying plane.\nUsually it is 0 and should be specified in the detector coefficients (as the last free coefficient).\nBut if the free coefficient is omitted (which is allowed), you can specify it manually here.\n@param winStride Window stride. It must be a multiple of block stride.\n@param padding Padding\n@param scale Coefficient of the detection window increase.\n@param finalThreshold Final threshold\n@param useMeanshiftGrouping indicates grouping algorithm"]
    #[link_name = "\u{1}_ZNK2cv13HOGDescriptor16detectMultiScaleERKNS_11_InputArrayERSt6vectorINS_5Rect_IiEESaIS6_EERS4_IdSaIdEEdNS_5Size_IiEESE_ddb"]
    pub fn cv_HOGDescriptor_detectMultiScale(
        this: *mut ::std::os::raw::c_void,
        img: cv_InputArray,
        foundLocations: *mut std_vector,
        foundWeights: *mut std_vector,
        hitThreshold: f64,
        winStride: cv_Size,
        padding: cv_Size,
        scale: f64,
        finalThreshold: f64,
        useMeanshiftGrouping: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief Detects objects of different sizes in the input image. The detected objects are returned as a list\nof rectangles.\n@param img Matrix of the type CV_8U or CV_8UC3 containing an image where objects are detected.\n@param foundLocations Vector of rectangles where each rectangle contains the detected object.\n@param hitThreshold Threshold for the distance between features and SVM classifying plane.\nUsually it is 0 and should be specified in the detector coefficients (as the last free coefficient).\nBut if the free coefficient is omitted (which is allowed), you can specify it manually here.\n@param winStride Window stride. It must be a multiple of block stride.\n@param padding Padding\n@param scale Coefficient of the detection window increase.\n@param finalThreshold Final threshold\n@param useMeanshiftGrouping indicates grouping algorithm"]
    #[link_name = "\u{1}_ZNK2cv13HOGDescriptor16detectMultiScaleERKNS_11_InputArrayERSt6vectorINS_5Rect_IiEESaIS6_EEdNS_5Size_IiEESB_ddb"]
    pub fn cv_HOGDescriptor_detectMultiScale1(
        this: *mut ::std::os::raw::c_void,
        img: cv_InputArray,
        foundLocations: *mut std_vector,
        hitThreshold: f64,
        winStride: cv_Size,
        padding: cv_Size,
        scale: f64,
        finalThreshold: f64,
        useMeanshiftGrouping: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief  Computes gradients and quantized gradient orientations.\n@param img Matrix contains the image to be computed\n@param grad Matrix of type CV_32FC2 contains computed gradients\n@param angleOfs Matrix of type CV_8UC2 contains quantized gradient orientations\n@param paddingTL Padding from top-left\n@param paddingBR Padding from bottom-right"]
    #[link_name = "\u{1}_ZNK2cv13HOGDescriptor15computeGradientERKNS_11_InputArrayERKNS_17_InputOutputArrayES6_NS_5Size_IiEES8_"]
    pub fn cv_HOGDescriptor_computeGradient(
        this: *mut ::std::os::raw::c_void,
        img: cv_InputArray,
        grad: cv_InputOutputArray,
        angleOfs: cv_InputOutputArray,
        paddingTL: cv_Size,
        paddingBR: cv_Size,
    );
}
unsafe extern "C" {
    #[doc = " @brief evaluate specified ROI and return confidence value for each location\n@param img Matrix of the type CV_8U or CV_8UC3 containing an image where objects are detected.\n@param locations Vector of Point\n@param foundLocations Vector of Point where each Point is detected object's top-left point.\n@param confidences confidences\n@param hitThreshold Threshold for the distance between features and SVM classifying plane. Usually\nit is 0 and should be specified in the detector coefficients (as the last free coefficient). But if\nthe free coefficient is omitted (which is allowed), you can specify it manually here\n@param winStride winStride\n@param padding padding"]
    #[link_name = "\u{1}_ZNK2cv13HOGDescriptor9detectROIERKNS_11_InputArrayERKSt6vectorINS_6Point_IiEESaIS6_EERS8_RS4_IdSaIdEEdNS_5Size_IiEESG_"]
    pub fn cv_HOGDescriptor_detectROI(
        this: *mut ::std::os::raw::c_void,
        img: cv_InputArray,
        locations: *const std_vector,
        foundLocations: *mut std_vector,
        confidences: *mut std_vector,
        hitThreshold: f64,
        winStride: cv_Size,
        padding: cv_Size,
    );
}
unsafe extern "C" {
    #[doc = " @brief evaluate specified ROI and return confidence value for each location in multiple scales\n@param img Matrix of the type CV_8U or CV_8UC3 containing an image where objects are detected.\n@param foundLocations Vector of rectangles where each rectangle contains the detected object.\n@param locations Vector of DetectionROI\n@param hitThreshold Threshold for the distance between features and SVM classifying plane. Usually it is 0 and should be specified\nin the detector coefficients (as the last free coefficient). But if the free coefficient is omitted (which is allowed), you can specify it manually here.\n@param groupThreshold Minimum possible number of rectangles minus 1. The threshold is used in a group of rectangles to retain it."]
    #[link_name = "\u{1}_ZNK2cv13HOGDescriptor19detectMultiScaleROIERKNS_11_InputArrayERSt6vectorINS_5Rect_IiEESaIS6_EERS4_INS_12DetectionROIESaISA_EEdi"]
    pub fn cv_HOGDescriptor_detectMultiScaleROI(
        this: *mut ::std::os::raw::c_void,
        img: cv_InputArray,
        foundLocations: *mut std_vector,
        locations: *mut std_vector,
        hitThreshold: f64,
        groupThreshold: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_QRCodeDetector {
    pub p: cv_Ptr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_QRCodeDetector_Impl {
    _unused: [u8; 0],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_QRCodeDetector"][::std::mem::size_of::<cv_QRCodeDetector>() - 16usize];
    ["Alignment of cv_QRCodeDetector"][::std::mem::align_of::<cv_QRCodeDetector>() - 8usize];
    ["Offset of field: cv_QRCodeDetector::p"]
        [::std::mem::offset_of!(cv_QRCodeDetector, p) - 0usize];
};
unsafe extern "C" {
    #[doc = " @brief sets the epsilon used during the horizontal scan of QR code stop marker detection.\n@param epsX Epsilon neighborhood, which allows you to determine the horizontal pattern\nof the scheme 1:1:3:1:1 according to QR code standard."]
    #[link_name = "\u{1}_ZN2cv14QRCodeDetector7setEpsXEd"]
    pub fn cv_QRCodeDetector_setEpsX(this: *mut cv_QRCodeDetector, epsX: f64);
}
unsafe extern "C" {
    #[doc = " @brief sets the epsilon used during the vertical scan of QR code stop marker detection.\n@param epsY Epsilon neighborhood, which allows you to determine the vertical pattern\nof the scheme 1:1:3:1:1 according to QR code standard."]
    #[link_name = "\u{1}_ZN2cv14QRCodeDetector7setEpsYEd"]
    pub fn cv_QRCodeDetector_setEpsY(this: *mut cv_QRCodeDetector, epsY: f64);
}
unsafe extern "C" {
    #[doc = " @brief Detects QR code in image and returns the quadrangle containing the code.\n@param img grayscale or color (BGR) image containing (or not) QR code.\n@param points Output vector of vertices of the minimum-area quadrangle containing the code."]
    #[link_name = "\u{1}_ZNK2cv14QRCodeDetector6detectERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_QRCodeDetector_detect(
        this: *const cv_QRCodeDetector,
        img: cv_InputArray,
        points: cv_OutputArray,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Decodes QR code in image once it's found by the detect() method.\nReturns UTF8-encoded output string or empty string if the code cannot be decoded.\n\n@param img grayscale or color (BGR) image containing QR code.\n@param points Quadrangle vertices found by detect() method (or some other algorithm).\n@param straight_qrcode The optional output image containing rectified and binarized QR code"]
    #[link_name = "\u{1}_ZN2cv14QRCodeDetector6decodeB5cxx11ERKNS_11_InputArrayES3_RKNS_12_OutputArrayE"]
    pub fn cv_QRCodeDetector_decode(
        this: *mut cv_QRCodeDetector,
        img: cv_InputArray,
        points: cv_InputArray,
        straight_qrcode: cv_OutputArray,
    ) -> std_string;
}
unsafe extern "C" {
    #[doc = " @brief Both detects and decodes QR code\n\n@param img grayscale or color (BGR) image containing QR code.\n@param points opiotnal output array of vertices of the found QR code quadrangle. Will be empty if not found.\n@param straight_qrcode The optional output image containing rectified and binarized QR code"]
    #[link_name = "\u{1}_ZN2cv14QRCodeDetector15detectAndDecodeB5cxx11ERKNS_11_InputArrayERKNS_12_OutputArrayES6_"]
    pub fn cv_QRCodeDetector_detectAndDecode(
        this: *mut cv_QRCodeDetector,
        img: cv_InputArray,
        points: cv_OutputArray,
        straight_qrcode: cv_OutputArray,
    ) -> std_string;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv14QRCodeDetectorC1Ev"]
    pub fn cv_QRCodeDetector_QRCodeDetector(this: *mut cv_QRCodeDetector);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv14QRCodeDetectorD1Ev"]
    pub fn cv_QRCodeDetector_QRCodeDetector_destructor(this: *mut cv_QRCodeDetector);
}
impl cv_QRCodeDetector {
    #[inline]
    pub unsafe fn setEpsX(&mut self, epsX: f64) {
        cv_QRCodeDetector_setEpsX(self, epsX)
    }
    #[inline]
    pub unsafe fn setEpsY(&mut self, epsY: f64) {
        cv_QRCodeDetector_setEpsY(self, epsY)
    }
    #[inline]
    pub unsafe fn detect(&self, img: cv_InputArray, points: cv_OutputArray) -> bool {
        cv_QRCodeDetector_detect(self, img, points)
    }
    #[inline]
    pub unsafe fn decode(
        &mut self,
        img: cv_InputArray,
        points: cv_InputArray,
        straight_qrcode: cv_OutputArray,
    ) -> std_string {
        cv_QRCodeDetector_decode(self, img, points, straight_qrcode)
    }
    #[inline]
    pub unsafe fn detectAndDecode(
        &mut self,
        img: cv_InputArray,
        points: cv_OutputArray,
        straight_qrcode: cv_OutputArray,
    ) -> std_string {
        cv_QRCodeDetector_detectAndDecode(self, img, points, straight_qrcode)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_QRCodeDetector_QRCodeDetector(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cv_QRCodeDetector_QRCodeDetector_destructor(self)
    }
}
#[repr(C)]
pub struct cv_DetectionBasedTracker__bindgen_vtable(::std::os::raw::c_void);
#[doc = "! @addtogroup objdetect\n! @{"]
#[repr(C)]
pub struct cv_DetectionBasedTracker {
    pub vtable_: *const cv_DetectionBasedTracker__bindgen_vtable,
    pub separateDetectionWork: cv_Ptr,
    pub parameters: cv_DetectionBasedTracker_Parameters,
    pub innerParameters: cv_DetectionBasedTracker_InnerParameters,
    pub numTrackedSteps: ::std::os::raw::c_int,
    pub trackedObjects: std_vector,
    pub weightsPositionsSmoothing: std_vector,
    pub weightsSizesSmoothing: std_vector,
    pub cascadeForTracking: cv_Ptr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_DetectionBasedTracker_Parameters {
    pub maxTrackLifetime: ::std::os::raw::c_int,
    pub minDetectionPeriod: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_DetectionBasedTracker_Parameters"]
        [::std::mem::size_of::<cv_DetectionBasedTracker_Parameters>() - 8usize];
    ["Alignment of cv_DetectionBasedTracker_Parameters"]
        [::std::mem::align_of::<cv_DetectionBasedTracker_Parameters>() - 4usize];
    ["Offset of field: cv_DetectionBasedTracker_Parameters::maxTrackLifetime"]
        [::std::mem::offset_of!(cv_DetectionBasedTracker_Parameters, maxTrackLifetime) - 0usize];
    ["Offset of field: cv_DetectionBasedTracker_Parameters::minDetectionPeriod"]
        [::std::mem::offset_of!(cv_DetectionBasedTracker_Parameters, minDetectionPeriod) - 4usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv21DetectionBasedTracker10ParametersC1Ev"]
    pub fn cv_DetectionBasedTracker_Parameters_Parameters(
        this: *mut cv_DetectionBasedTracker_Parameters,
    );
}
impl cv_DetectionBasedTracker_Parameters {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_DetectionBasedTracker_Parameters_Parameters(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct cv_DetectionBasedTracker_IDetector__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct cv_DetectionBasedTracker_IDetector {
    pub vtable_: *const cv_DetectionBasedTracker_IDetector__bindgen_vtable,
    pub minObjSize: cv_Size,
    pub maxObjSize: cv_Size,
    pub minNeighbours: ::std::os::raw::c_int,
    pub scaleFactor: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_DetectionBasedTracker_IDetector"]
        [::std::mem::size_of::<cv_DetectionBasedTracker_IDetector>() - 32usize];
    ["Alignment of cv_DetectionBasedTracker_IDetector"]
        [::std::mem::align_of::<cv_DetectionBasedTracker_IDetector>() - 8usize];
    ["Offset of field: cv_DetectionBasedTracker_IDetector::minObjSize"]
        [::std::mem::offset_of!(cv_DetectionBasedTracker_IDetector, minObjSize) - 8usize];
    ["Offset of field: cv_DetectionBasedTracker_IDetector::maxObjSize"]
        [::std::mem::offset_of!(cv_DetectionBasedTracker_IDetector, maxObjSize) - 16usize];
    ["Offset of field: cv_DetectionBasedTracker_IDetector::minNeighbours"]
        [::std::mem::offset_of!(cv_DetectionBasedTracker_IDetector, minNeighbours) - 24usize];
    ["Offset of field: cv_DetectionBasedTracker_IDetector::scaleFactor"]
        [::std::mem::offset_of!(cv_DetectionBasedTracker_IDetector, scaleFactor) - 28usize];
};
pub type cv_DetectionBasedTracker_Object = std_pair<cv_Rect, ::std::os::raw::c_int>;
pub const cv_DetectionBasedTracker_ObjectStatus_DETECTED_NOT_SHOWN_YET:
    cv_DetectionBasedTracker_ObjectStatus = 0;
pub const cv_DetectionBasedTracker_ObjectStatus_DETECTED: cv_DetectionBasedTracker_ObjectStatus = 1;
pub const cv_DetectionBasedTracker_ObjectStatus_DETECTED_TEMPORARY_LOST:
    cv_DetectionBasedTracker_ObjectStatus = 2;
pub const cv_DetectionBasedTracker_ObjectStatus_WRONG_OBJECT:
    cv_DetectionBasedTracker_ObjectStatus = 3;
pub type cv_DetectionBasedTracker_ObjectStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_DetectionBasedTracker_ExtObject {
    pub id: ::std::os::raw::c_int,
    pub location: cv_Rect,
    pub status: cv_DetectionBasedTracker_ObjectStatus,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_DetectionBasedTracker_ExtObject"]
        [::std::mem::size_of::<cv_DetectionBasedTracker_ExtObject>() - 24usize];
    ["Alignment of cv_DetectionBasedTracker_ExtObject"]
        [::std::mem::align_of::<cv_DetectionBasedTracker_ExtObject>() - 4usize];
    ["Offset of field: cv_DetectionBasedTracker_ExtObject::id"]
        [::std::mem::offset_of!(cv_DetectionBasedTracker_ExtObject, id) - 0usize];
    ["Offset of field: cv_DetectionBasedTracker_ExtObject::location"]
        [::std::mem::offset_of!(cv_DetectionBasedTracker_ExtObject, location) - 4usize];
    ["Offset of field: cv_DetectionBasedTracker_ExtObject::status"]
        [::std::mem::offset_of!(cv_DetectionBasedTracker_ExtObject, status) - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_DetectionBasedTracker_SeparateDetectionWork {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_DetectionBasedTracker_InnerParameters {
    pub numLastPositionsToTrack: ::std::os::raw::c_int,
    pub numStepsToWaitBeforeFirstShow: ::std::os::raw::c_int,
    pub numStepsToTrackWithoutDetectingIfObjectHasNotBeenShown: ::std::os::raw::c_int,
    pub numStepsToShowWithoutDetecting: ::std::os::raw::c_int,
    pub coeffTrackingWindowSize: f32,
    pub coeffObjectSizeToTrack: f32,
    pub coeffObjectSpeedUsingInPrediction: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_DetectionBasedTracker_InnerParameters"]
        [::std::mem::size_of::<cv_DetectionBasedTracker_InnerParameters>() - 28usize];
    ["Alignment of cv_DetectionBasedTracker_InnerParameters"]
        [::std::mem::align_of::<cv_DetectionBasedTracker_InnerParameters>() - 4usize];
    ["Offset of field: cv_DetectionBasedTracker_InnerParameters::numLastPositionsToTrack"][::std::mem::offset_of!(
        cv_DetectionBasedTracker_InnerParameters,
        numLastPositionsToTrack
    )
        - 0usize];
    ["Offset of field: cv_DetectionBasedTracker_InnerParameters::numStepsToWaitBeforeFirstShow"][::std::mem::offset_of!(
        cv_DetectionBasedTracker_InnerParameters,
        numStepsToWaitBeforeFirstShow
    )
        - 4usize];
    [
        "Offset of field: cv_DetectionBasedTracker_InnerParameters::numStepsToTrackWithoutDetectingIfObjectHasNotBeenShown",
    ][::std::mem::offset_of!(
        cv_DetectionBasedTracker_InnerParameters,
        numStepsToTrackWithoutDetectingIfObjectHasNotBeenShown
    ) - 8usize];
    ["Offset of field: cv_DetectionBasedTracker_InnerParameters::numStepsToShowWithoutDetecting"][::std::mem::offset_of!(
        cv_DetectionBasedTracker_InnerParameters,
        numStepsToShowWithoutDetecting
    )
        - 12usize];
    ["Offset of field: cv_DetectionBasedTracker_InnerParameters::coeffTrackingWindowSize"][::std::mem::offset_of!(
        cv_DetectionBasedTracker_InnerParameters,
        coeffTrackingWindowSize
    )
        - 16usize];
    ["Offset of field: cv_DetectionBasedTracker_InnerParameters::coeffObjectSizeToTrack"][::std::mem::offset_of!(
        cv_DetectionBasedTracker_InnerParameters,
        coeffObjectSizeToTrack
    )
        - 20usize];
    [
        "Offset of field: cv_DetectionBasedTracker_InnerParameters::coeffObjectSpeedUsingInPrediction",
    ][::std::mem::offset_of!(
        cv_DetectionBasedTracker_InnerParameters,
        coeffObjectSpeedUsingInPrediction
    ) - 24usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv21DetectionBasedTracker15InnerParametersC1Ev"]
    pub fn cv_DetectionBasedTracker_InnerParameters_InnerParameters(
        this: *mut cv_DetectionBasedTracker_InnerParameters,
    );
}
impl cv_DetectionBasedTracker_InnerParameters {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_DetectionBasedTracker_InnerParameters_InnerParameters(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct cv_DetectionBasedTracker_TrackedObject {
    pub lastPositions: cv_DetectionBasedTracker_TrackedObject_PositionsVector,
    pub numDetectedFrames: ::std::os::raw::c_int,
    pub numFramesNotDetected: ::std::os::raw::c_int,
    pub id: ::std::os::raw::c_int,
}
pub type cv_DetectionBasedTracker_TrackedObject_PositionsVector = std_vector;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_DetectionBasedTracker_TrackedObject"]
        [::std::mem::size_of::<cv_DetectionBasedTracker_TrackedObject>() - 40usize];
    ["Alignment of cv_DetectionBasedTracker_TrackedObject"]
        [::std::mem::align_of::<cv_DetectionBasedTracker_TrackedObject>() - 8usize];
    ["Offset of field: cv_DetectionBasedTracker_TrackedObject::lastPositions"]
        [::std::mem::offset_of!(cv_DetectionBasedTracker_TrackedObject, lastPositions) - 0usize];
    ["Offset of field: cv_DetectionBasedTracker_TrackedObject::numDetectedFrames"][::std::mem::offset_of!(
        cv_DetectionBasedTracker_TrackedObject,
        numDetectedFrames
    ) - 24usize];
    ["Offset of field: cv_DetectionBasedTracker_TrackedObject::numFramesNotDetected"][::std::mem::offset_of!(
        cv_DetectionBasedTracker_TrackedObject,
        numFramesNotDetected
    ) - 28usize];
    ["Offset of field: cv_DetectionBasedTracker_TrackedObject::id"]
        [::std::mem::offset_of!(cv_DetectionBasedTracker_TrackedObject, id) - 32usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_DetectionBasedTracker"]
        [::std::mem::size_of::<cv_DetectionBasedTracker>() - 152usize];
    ["Alignment of cv_DetectionBasedTracker"]
        [::std::mem::align_of::<cv_DetectionBasedTracker>() - 8usize];
    ["Offset of field: cv_DetectionBasedTracker::separateDetectionWork"]
        [::std::mem::offset_of!(cv_DetectionBasedTracker, separateDetectionWork) - 8usize];
    ["Offset of field: cv_DetectionBasedTracker::parameters"]
        [::std::mem::offset_of!(cv_DetectionBasedTracker, parameters) - 24usize];
    ["Offset of field: cv_DetectionBasedTracker::innerParameters"]
        [::std::mem::offset_of!(cv_DetectionBasedTracker, innerParameters) - 32usize];
    ["Offset of field: cv_DetectionBasedTracker::numTrackedSteps"]
        [::std::mem::offset_of!(cv_DetectionBasedTracker, numTrackedSteps) - 60usize];
    ["Offset of field: cv_DetectionBasedTracker::trackedObjects"]
        [::std::mem::offset_of!(cv_DetectionBasedTracker, trackedObjects) - 64usize];
    ["Offset of field: cv_DetectionBasedTracker::weightsPositionsSmoothing"]
        [::std::mem::offset_of!(cv_DetectionBasedTracker, weightsPositionsSmoothing) - 88usize];
    ["Offset of field: cv_DetectionBasedTracker::weightsSizesSmoothing"]
        [::std::mem::offset_of!(cv_DetectionBasedTracker, weightsSizesSmoothing) - 112usize];
    ["Offset of field: cv_DetectionBasedTracker::cascadeForTracking"]
        [::std::mem::offset_of!(cv_DetectionBasedTracker, cascadeForTracking) - 136usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv21DetectionBasedTracker13setParametersERKNS0_10ParametersE"]
    pub fn cv_DetectionBasedTracker_setParameters(
        this: *mut cv_DetectionBasedTracker,
        params: *const cv_DetectionBasedTracker_Parameters,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv21DetectionBasedTracker13getParametersEv"]
    pub fn cv_DetectionBasedTracker_getParameters(
        this: *const cv_DetectionBasedTracker,
    ) -> *const cv_DetectionBasedTracker_Parameters;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv21DetectionBasedTracker20updateTrackedObjectsERKSt6vectorINS_5Rect_IiEESaIS3_EE"]
    pub fn cv_DetectionBasedTracker_updateTrackedObjects(
        this: *mut cv_DetectionBasedTracker,
        detectedObjects: *const std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv21DetectionBasedTracker31calcTrackedObjectPositionToShowEi"]
    pub fn cv_DetectionBasedTracker_calcTrackedObjectPositionToShow(
        this: *const cv_DetectionBasedTracker,
        i: ::std::os::raw::c_int,
    ) -> cv_Rect;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv21DetectionBasedTracker31calcTrackedObjectPositionToShowEiRNS0_12ObjectStatusE"]
    pub fn cv_DetectionBasedTracker_calcTrackedObjectPositionToShow1(
        this: *const cv_DetectionBasedTracker,
        i: ::std::os::raw::c_int,
        status: *mut cv_DetectionBasedTracker_ObjectStatus,
    ) -> cv_Rect;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv21DetectionBasedTracker14detectInRegionERKNS_3MatERKNS_5Rect_IiEERSt6vectorIS5_SaIS5_EE"]
    pub fn cv_DetectionBasedTracker_detectInRegion(
        this: *mut cv_DetectionBasedTracker,
        img: *const cv_Mat,
        r: *const cv_Rect,
        detectedObjectsInRegions: *mut std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv21DetectionBasedTrackerC1ENS_3PtrINS0_9IDetectorEEES3_RKNS0_10ParametersE"]
    pub fn cv_DetectionBasedTracker_DetectionBasedTracker(
        this: *mut cv_DetectionBasedTracker,
        mainDetector: cv_Ptr,
        trackingDetector: cv_Ptr,
        params: *const cv_DetectionBasedTracker_Parameters,
    );
}
impl cv_DetectionBasedTracker {
    #[inline]
    pub unsafe fn setParameters(
        &mut self,
        params: *const cv_DetectionBasedTracker_Parameters,
    ) -> bool {
        cv_DetectionBasedTracker_setParameters(self, params)
    }
    #[inline]
    pub unsafe fn getParameters(&self) -> *const cv_DetectionBasedTracker_Parameters {
        cv_DetectionBasedTracker_getParameters(self)
    }
    #[inline]
    pub unsafe fn updateTrackedObjects(&mut self, detectedObjects: *const std_vector) {
        cv_DetectionBasedTracker_updateTrackedObjects(self, detectedObjects)
    }
    #[inline]
    pub unsafe fn calcTrackedObjectPositionToShow(&self, i: ::std::os::raw::c_int) -> cv_Rect {
        cv_DetectionBasedTracker_calcTrackedObjectPositionToShow(self, i)
    }
    #[inline]
    pub unsafe fn calcTrackedObjectPositionToShow1(
        &self,
        i: ::std::os::raw::c_int,
        status: *mut cv_DetectionBasedTracker_ObjectStatus,
    ) -> cv_Rect {
        cv_DetectionBasedTracker_calcTrackedObjectPositionToShow1(self, i, status)
    }
    #[inline]
    pub unsafe fn detectInRegion(
        &mut self,
        img: *const cv_Mat,
        r: *const cv_Rect,
        detectedObjectsInRegions: *mut std_vector,
    ) {
        cv_DetectionBasedTracker_detectInRegion(self, img, r, detectedObjectsInRegions)
    }
    #[inline]
    pub unsafe fn new(
        mainDetector: cv_Ptr,
        trackingDetector: cv_Ptr,
        params: *const cv_DetectionBasedTracker_Parameters,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_DetectionBasedTracker_DetectionBasedTracker(
            __bindgen_tmp.as_mut_ptr(),
            mainDetector,
            trackingDetector,
            params,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv21DetectionBasedTrackerD1Ev"]
    pub fn cv_DetectionBasedTracker_DetectionBasedTracker_destructor(
        this: *mut cv_DetectionBasedTracker,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv21DetectionBasedTracker3runEv"]
    pub fn cv_DetectionBasedTracker_run(this: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv21DetectionBasedTracker4stopEv"]
    pub fn cv_DetectionBasedTracker_stop(this: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv21DetectionBasedTracker13resetTrackingEv"]
    pub fn cv_DetectionBasedTracker_resetTracking(this: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv21DetectionBasedTracker7processERKNS_3MatE"]
    pub fn cv_DetectionBasedTracker_process(
        this: *mut ::std::os::raw::c_void,
        imageGray: *const cv_Mat,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv21DetectionBasedTracker10getObjectsERSt6vectorINS_5Rect_IiEESaIS3_EE"]
    pub fn cv_DetectionBasedTracker_getObjects(
        this: *mut ::std::os::raw::c_void,
        result: *mut std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv21DetectionBasedTracker10getObjectsERSt6vectorISt4pairINS_5Rect_IiEEiESaIS5_EE"]
    pub fn cv_DetectionBasedTracker_getObjects1(
        this: *mut ::std::os::raw::c_void,
        result: *mut std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK2cv21DetectionBasedTracker10getObjectsERSt6vectorINS0_9ExtObjectESaIS2_EE"]
    pub fn cv_DetectionBasedTracker_getObjects2(
        this: *mut ::std::os::raw::c_void,
        result: *mut std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv21DetectionBasedTracker9addObjectERKNS_5Rect_IiEE"]
    pub fn cv_DetectionBasedTracker_addObject(
        this: *mut ::std::os::raw::c_void,
        location: *const cv_Rect,
    ) -> ::std::os::raw::c_int;
}
#[doc = "!< Use Navier-Stokes based method"]
pub const INPAINT_NS: cv__bindgen_ty_26 = 0;
#[doc = "!< Use the algorithm proposed by Alexandru Telea @cite Telea04"]
pub const INPAINT_TELEA: cv__bindgen_ty_26 = 1;
#[doc = "! @addtogroup photo_inpaint\n! @{\n! the inpainting algorithm"]
pub type cv__bindgen_ty_26 = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Restores the selected region in an image using the region neighborhood.\n\n@param src Input 8-bit, 16-bit unsigned or 32-bit float 1-channel or 8-bit 3-channel image.\n@param inpaintMask Inpainting mask, 8-bit 1-channel image. Non-zero pixels indicate the area that\nneeds to be inpainted.\n@param dst Output image with the same size and type as src .\n@param inpaintRadius Radius of a circular neighborhood of each point inpainted that is considered\nby the algorithm.\n@param flags Inpainting method that could be cv::INPAINT_NS or cv::INPAINT_TELEA\n\nThe function reconstructs the selected image area from the pixel near the area boundary. The\nfunction may be used to remove dust and scratches from a scanned photo, or to remove undesirable\nobjects from still images or video. See <http://en.wikipedia.org/wiki/Inpainting> for more details.\n\n@note\n-   An example using the inpainting technique can be found at\nopencv_source_code/samples/cpp/inpaint.cpp\n-   (Python) An example using the inpainting technique can be found at\nopencv_source_code/samples/python/inpaint.py"]
    #[link_name = "\u{1}_ZN2cv7inpaintERKNS_11_InputArrayES2_RKNS_12_OutputArrayEdi"]
    pub fn cv_inpaint(
        src: cv_InputArray,
        inpaintMask: cv_InputArray,
        dst: cv_OutputArray,
        inpaintRadius: f64,
        flags: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Perform image denoising using Non-local Means Denoising algorithm\n<http://www.ipol.im/pub/algo/bcm_non_local_means_denoising/> with several computational\noptimizations. Noise expected to be a gaussian white noise\n\n@param src Input 8-bit 1-channel, 2-channel, 3-channel or 4-channel image.\n@param dst Output image with the same size and type as src .\n@param templateWindowSize Size in pixels of the template patch that is used to compute weights.\nShould be odd. Recommended value 7 pixels\n@param searchWindowSize Size in pixels of the window that is used to compute weighted average for\ngiven pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater\ndenoising time. Recommended value 21 pixels\n@param h Parameter regulating filter strength. Big h value perfectly removes noise but also\nremoves image details, smaller h value preserves details but also preserves some noise\n\nThis function expected to be applied to grayscale images. For colored images look at\nfastNlMeansDenoisingColored. Advanced usage of this functions can be manual denoising of colored\nimage in different colorspaces. Such approach is used in fastNlMeansDenoisingColored by converting\nimage to CIELAB colorspace and then separately denoise L and AB components with different h\nparameter."]
    #[link_name = "\u{1}_ZN2cv20fastNlMeansDenoisingERKNS_11_InputArrayERKNS_12_OutputArrayEfii"]
    pub fn cv_fastNlMeansDenoising(
        src: cv_InputArray,
        dst: cv_OutputArray,
        h: f32,
        templateWindowSize: ::std::os::raw::c_int,
        searchWindowSize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Perform image denoising using Non-local Means Denoising algorithm\n<http://www.ipol.im/pub/algo/bcm_non_local_means_denoising/> with several computational\noptimizations. Noise expected to be a gaussian white noise\n\n@param src Input 8-bit or 16-bit (only with NORM_L1) 1-channel,\n2-channel, 3-channel or 4-channel image.\n@param dst Output image with the same size and type as src .\n@param templateWindowSize Size in pixels of the template patch that is used to compute weights.\nShould be odd. Recommended value 7 pixels\n@param searchWindowSize Size in pixels of the window that is used to compute weighted average for\ngiven pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater\ndenoising time. Recommended value 21 pixels\n@param h Array of parameters regulating filter strength, either one\nparameter applied to all channels or one per channel in dst. Big h value\nperfectly removes noise but also removes image details, smaller h\nvalue preserves details but also preserves some noise\n@param normType Type of norm used for weight calculation. Can be either NORM_L2 or NORM_L1\n\nThis function expected to be applied to grayscale images. For colored images look at\nfastNlMeansDenoisingColored. Advanced usage of this functions can be manual denoising of colored\nimage in different colorspaces. Such approach is used in fastNlMeansDenoisingColored by converting\nimage to CIELAB colorspace and then separately denoise L and AB components with different h\nparameter."]
    #[link_name = "\u{1}_ZN2cv20fastNlMeansDenoisingERKNS_11_InputArrayERKNS_12_OutputArrayERKSt6vectorIfSaIfEEiii"]
    pub fn cv_fastNlMeansDenoising1(
        src: cv_InputArray,
        dst: cv_OutputArray,
        h: *const std_vector,
        templateWindowSize: ::std::os::raw::c_int,
        searchWindowSize: ::std::os::raw::c_int,
        normType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Modification of fastNlMeansDenoising function for colored images\n\n@param src Input 8-bit 3-channel image.\n@param dst Output image with the same size and type as src .\n@param templateWindowSize Size in pixels of the template patch that is used to compute weights.\nShould be odd. Recommended value 7 pixels\n@param searchWindowSize Size in pixels of the window that is used to compute weighted average for\ngiven pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater\ndenoising time. Recommended value 21 pixels\n@param h Parameter regulating filter strength for luminance component. Bigger h value perfectly\nremoves noise but also removes image details, smaller h value preserves details but also preserves\nsome noise\n@param hColor The same as h but for color components. For most images value equals 10\nwill be enough to remove colored noise and do not distort colors\n\nThe function converts image to CIELAB colorspace and then separately denoise L and AB components\nwith given h parameters using fastNlMeansDenoising function."]
    #[link_name = "\u{1}_ZN2cv27fastNlMeansDenoisingColoredERKNS_11_InputArrayERKNS_12_OutputArrayEffii"]
    pub fn cv_fastNlMeansDenoisingColored(
        src: cv_InputArray,
        dst: cv_OutputArray,
        h: f32,
        hColor: f32,
        templateWindowSize: ::std::os::raw::c_int,
        searchWindowSize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Modification of fastNlMeansDenoising function for images sequence where consecutive images have been\ncaptured in small period of time. For example video. This version of the function is for grayscale\nimages or for manual manipulation with colorspaces. For more details see\n<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.131.6394>\n\n@param srcImgs Input 8-bit 1-channel, 2-channel, 3-channel or\n4-channel images sequence. All images should have the same type and\nsize.\n@param imgToDenoiseIndex Target image to denoise index in srcImgs sequence\n@param temporalWindowSize Number of surrounding images to use for target image denoising. Should\nbe odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to\nimgToDenoiseIndex - temporalWindowSize / 2 from srcImgs will be used to denoise\nsrcImgs[imgToDenoiseIndex] image.\n@param dst Output image with the same size and type as srcImgs images.\n@param templateWindowSize Size in pixels of the template patch that is used to compute weights.\nShould be odd. Recommended value 7 pixels\n@param searchWindowSize Size in pixels of the window that is used to compute weighted average for\ngiven pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater\ndenoising time. Recommended value 21 pixels\n@param h Parameter regulating filter strength. Bigger h value\nperfectly removes noise but also removes image details, smaller h\nvalue preserves details but also preserves some noise"]
    #[link_name = "\u{1}_ZN2cv25fastNlMeansDenoisingMultiERKNS_11_InputArrayERKNS_12_OutputArrayEiifii"]
    pub fn cv_fastNlMeansDenoisingMulti(
        srcImgs: cv_InputArrayOfArrays,
        dst: cv_OutputArray,
        imgToDenoiseIndex: ::std::os::raw::c_int,
        temporalWindowSize: ::std::os::raw::c_int,
        h: f32,
        templateWindowSize: ::std::os::raw::c_int,
        searchWindowSize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Modification of fastNlMeansDenoising function for images sequence where consecutive images have been\ncaptured in small period of time. For example video. This version of the function is for grayscale\nimages or for manual manipulation with colorspaces. For more details see\n<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.131.6394>\n\n@param srcImgs Input 8-bit or 16-bit (only with NORM_L1) 1-channel,\n2-channel, 3-channel or 4-channel images sequence. All images should\nhave the same type and size.\n@param imgToDenoiseIndex Target image to denoise index in srcImgs sequence\n@param temporalWindowSize Number of surrounding images to use for target image denoising. Should\nbe odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to\nimgToDenoiseIndex - temporalWindowSize / 2 from srcImgs will be used to denoise\nsrcImgs[imgToDenoiseIndex] image.\n@param dst Output image with the same size and type as srcImgs images.\n@param templateWindowSize Size in pixels of the template patch that is used to compute weights.\nShould be odd. Recommended value 7 pixels\n@param searchWindowSize Size in pixels of the window that is used to compute weighted average for\ngiven pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater\ndenoising time. Recommended value 21 pixels\n@param h Array of parameters regulating filter strength, either one\nparameter applied to all channels or one per channel in dst. Big h value\nperfectly removes noise but also removes image details, smaller h\nvalue preserves details but also preserves some noise\n@param normType Type of norm used for weight calculation. Can be either NORM_L2 or NORM_L1"]
    #[link_name = "\u{1}_ZN2cv25fastNlMeansDenoisingMultiERKNS_11_InputArrayERKNS_12_OutputArrayEiiRKSt6vectorIfSaIfEEiii"]
    pub fn cv_fastNlMeansDenoisingMulti1(
        srcImgs: cv_InputArrayOfArrays,
        dst: cv_OutputArray,
        imgToDenoiseIndex: ::std::os::raw::c_int,
        temporalWindowSize: ::std::os::raw::c_int,
        h: *const std_vector,
        templateWindowSize: ::std::os::raw::c_int,
        searchWindowSize: ::std::os::raw::c_int,
        normType: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Modification of fastNlMeansDenoisingMulti function for colored images sequences\n\n@param srcImgs Input 8-bit 3-channel images sequence. All images should have the same type and\nsize.\n@param imgToDenoiseIndex Target image to denoise index in srcImgs sequence\n@param temporalWindowSize Number of surrounding images to use for target image denoising. Should\nbe odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to\nimgToDenoiseIndex - temporalWindowSize / 2 from srcImgs will be used to denoise\nsrcImgs[imgToDenoiseIndex] image.\n@param dst Output image with the same size and type as srcImgs images.\n@param templateWindowSize Size in pixels of the template patch that is used to compute weights.\nShould be odd. Recommended value 7 pixels\n@param searchWindowSize Size in pixels of the window that is used to compute weighted average for\ngiven pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater\ndenoising time. Recommended value 21 pixels\n@param h Parameter regulating filter strength for luminance component. Bigger h value perfectly\nremoves noise but also removes image details, smaller h value preserves details but also preserves\nsome noise.\n@param hColor The same as h but for color components.\n\nThe function converts images to CIELAB colorspace and then separately denoise L and AB components\nwith given h parameters using fastNlMeansDenoisingMulti function."]
    #[link_name = "\u{1}_ZN2cv32fastNlMeansDenoisingColoredMultiERKNS_11_InputArrayERKNS_12_OutputArrayEiiffii"]
    pub fn cv_fastNlMeansDenoisingColoredMulti(
        srcImgs: cv_InputArrayOfArrays,
        dst: cv_OutputArray,
        imgToDenoiseIndex: ::std::os::raw::c_int,
        temporalWindowSize: ::std::os::raw::c_int,
        h: f32,
        hColor: f32,
        templateWindowSize: ::std::os::raw::c_int,
        searchWindowSize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Primal-dual algorithm is an algorithm for solving special types of variational problems (that is,\nfinding a function to minimize some functional). As the image denoising, in particular, may be seen\nas the variational problem, primal-dual algorithm then can be used to perform denoising and this is\nexactly what is implemented.\n\nIt should be noted, that this implementation was taken from the July 2013 blog entry\n@cite MA13 , which also contained (slightly more general) ready-to-use source code on Python.\nSubsequently, that code was rewritten on C++ with the usage of openCV by Vadim Pisarevsky at the end\nof July 2013 and finally it was slightly adapted by later authors.\n\nAlthough the thorough discussion and justification of the algorithm involved may be found in\n@cite ChambolleEtAl, it might make sense to skim over it here, following @cite MA13 . To begin\nwith, we consider the 1-byte gray-level images as the functions from the rectangular domain of\npixels (it may be seen as set\n\\f$\\left\\{(x,y)\\in\\mathbb{N}\\times\\mathbb{N}\\mid 1\\leq x\\leq n,\\;1\\leq y\\leq m\\right\\}\\f$ for some\n\\f$m,\\;n\\in\\mathbb{N}\\f$) into \\f$\\{0,1,\\dots,255\\}\\f$. We shall denote the noised images as \\f$f_i\\f$ and with\nthis view, given some image \\f$x\\f$ of the same size, we may measure how bad it is by the formula\n\n\\f[\\left\\|\\left\\|\\nabla x\\right\\|\\right\\| + \\lambda\\sum_i\\left\\|\\left\\|x-f_i\\right\\|\\right\\|\\f]\n\n\\f$\\|\\|\\cdot\\|\\|\\f$ here denotes \\f$L_2\\f$-norm and as you see, the first addend states that we want our\nimage to be smooth (ideally, having zero gradient, thus being constant) and the second states that\nwe want our result to be close to the observations we've got. If we treat \\f$x\\f$ as a function, this is\nexactly the functional what we seek to minimize and here the Primal-Dual algorithm comes into play.\n\n@param observations This array should contain one or more noised versions of the image that is to\nbe restored.\n@param result Here the denoised image will be stored. There is no need to do pre-allocation of\nstorage space, as it will be automatically allocated, if necessary.\n@param lambda Corresponds to \\f$\\lambda\\f$ in the formulas above. As it is enlarged, the smooth\n(blurred) images are treated more favorably than detailed (but maybe more noised) ones. Roughly\nspeaking, as it becomes smaller, the result will be more blur but more sever outliers will be\nremoved.\n@param niters Number of iterations that the algorithm will run. Of course, as more iterations as\nbetter, but it is hard to quantitatively refine this statement, so just use the default and\nincrease it if the results are poor."]
    #[link_name = "\u{1}_ZN2cv12denoise_TVL1ERKSt6vectorINS_3MatESaIS1_EERS1_di"]
    pub fn cv_denoise_TVL1(
        observations: *const std_vector,
        result: *mut cv_Mat,
        lambda: f64,
        niters: ::std::os::raw::c_int,
    );
}
pub const LDR_SIZE: cv__bindgen_ty_27 = 256;
#[doc = "! @addtogroup photo_hdr\n! @{"]
pub type cv__bindgen_ty_27 = ::std::os::raw::c_uint;
#[doc = " @brief Base class for tonemapping algorithms - tools that are used to map HDR image to 8-bit range."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_Tonemap {
    pub _base: cv_Algorithm,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_Tonemap"][::std::mem::size_of::<cv_Tonemap>() - 8usize];
    ["Alignment of cv_Tonemap"][::std::mem::align_of::<cv_Tonemap>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates simple linear mapper with gamma correction\n\n@param gamma positive value for gamma correction. Gamma value of 1.0 implies no correction, gamma\nequal to 2.2f is suitable for most displays.\nGenerally gamma \\> 1 brightens the image and gamma \\< 1 darkens it."]
    #[link_name = "\u{1}_ZN2cv13createTonemapEf"]
    pub fn cv_createTonemap(gamma: f32) -> cv_Ptr;
}
#[doc = " @brief Adaptive logarithmic mapping is a fast global tonemapping algorithm that scales the image in\nlogarithmic domain.\n\nSince it's a global operator the same function is applied to all the pixels, it is controlled by the\nbias parameter.\n\nOptional saturation enhancement is possible as described in @cite FL02 .\n\nFor more information see @cite DM03 ."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_TonemapDrago {
    pub _base: cv_Tonemap,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_TonemapDrago"][::std::mem::size_of::<cv_TonemapDrago>() - 8usize];
    ["Alignment of cv_TonemapDrago"][::std::mem::align_of::<cv_TonemapDrago>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates TonemapDrago object\n\n@param gamma gamma value for gamma correction. See createTonemap\n@param saturation positive saturation enhancement value. 1.0 preserves saturation, values greater\nthan 1 increase saturation and values less than 1 decrease it.\n@param bias value for bias function in [0, 1] range. Values from 0.7 to 0.9 usually give best\nresults, default value is 0.85."]
    #[link_name = "\u{1}_ZN2cv18createTonemapDragoEfff"]
    pub fn cv_createTonemapDrago(gamma: f32, saturation: f32, bias: f32) -> cv_Ptr;
}
#[doc = " @brief This is a global tonemapping operator that models human visual system.\n\nMapping function is controlled by adaptation parameter, that is computed using light adaptation and\ncolor adaptation.\n\nFor more information see @cite RD05 ."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_TonemapReinhard {
    pub _base: cv_Tonemap,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_TonemapReinhard"][::std::mem::size_of::<cv_TonemapReinhard>() - 8usize];
    ["Alignment of cv_TonemapReinhard"][::std::mem::align_of::<cv_TonemapReinhard>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates TonemapReinhard object\n\n@param gamma gamma value for gamma correction. See createTonemap\n@param intensity result intensity in [-8, 8] range. Greater intensity produces brighter results.\n@param light_adapt light adaptation in [0, 1] range. If 1 adaptation is based only on pixel\nvalue, if 0 it's global, otherwise it's a weighted mean of this two cases.\n@param color_adapt chromatic adaptation in [0, 1] range. If 1 channels are treated independently,\nif 0 adaptation level is the same for each channel."]
    #[link_name = "\u{1}_ZN2cv21createTonemapReinhardEffff"]
    pub fn cv_createTonemapReinhard(
        gamma: f32,
        intensity: f32,
        light_adapt: f32,
        color_adapt: f32,
    ) -> cv_Ptr;
}
#[doc = " @brief This algorithm transforms image to contrast using gradients on all levels of gaussian pyramid,\ntransforms contrast values to HVS response and scales the response. After this the image is\nreconstructed from new contrast values.\n\nFor more information see @cite MM06 ."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_TonemapMantiuk {
    pub _base: cv_Tonemap,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_TonemapMantiuk"][::std::mem::size_of::<cv_TonemapMantiuk>() - 8usize];
    ["Alignment of cv_TonemapMantiuk"][::std::mem::align_of::<cv_TonemapMantiuk>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates TonemapMantiuk object\n\n@param gamma gamma value for gamma correction. See createTonemap\n@param scale contrast scale factor. HVS response is multiplied by this parameter, thus compressing\ndynamic range. Values from 0.6 to 0.9 produce best results.\n@param saturation saturation enhancement value. See createTonemapDrago"]
    #[link_name = "\u{1}_ZN2cv20createTonemapMantiukEfff"]
    pub fn cv_createTonemapMantiuk(gamma: f32, scale: f32, saturation: f32) -> cv_Ptr;
}
#[doc = " @brief The base class for algorithms that align images of the same scene with different exposures"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_AlignExposures {
    pub _base: cv_Algorithm,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_AlignExposures"][::std::mem::size_of::<cv_AlignExposures>() - 8usize];
    ["Alignment of cv_AlignExposures"][::std::mem::align_of::<cv_AlignExposures>() - 8usize];
};
#[doc = " @brief This algorithm converts images to median threshold bitmaps (1 for pixels brighter than median\nluminance and 0 otherwise) and than aligns the resulting bitmaps using bit operations.\n\nIt is invariant to exposure, so exposure values and camera response are not necessary.\n\nIn this implementation new image regions are filled with zeros.\n\nFor more information see @cite GW03 ."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_AlignMTB {
    pub _base: cv_AlignExposures,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_AlignMTB"][::std::mem::size_of::<cv_AlignMTB>() - 8usize];
    ["Alignment of cv_AlignMTB"][::std::mem::align_of::<cv_AlignMTB>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates AlignMTB object\n\n@param max_bits logarithm to the base 2 of maximal shift in each dimension. Values of 5 and 6 are\nusually good enough (31 and 63 pixels shift respectively).\n@param exclude_range range for exclusion bitmap that is constructed to suppress noise around the\nmedian value.\n@param cut if true cuts images, otherwise fills the new regions with zeros."]
    #[link_name = "\u{1}_ZN2cv14createAlignMTBEiib"]
    pub fn cv_createAlignMTB(
        max_bits: ::std::os::raw::c_int,
        exclude_range: ::std::os::raw::c_int,
        cut: bool,
    ) -> cv_Ptr;
}
#[doc = " @brief The base class for camera response calibration algorithms."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_CalibrateCRF {
    pub _base: cv_Algorithm,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_CalibrateCRF"][::std::mem::size_of::<cv_CalibrateCRF>() - 8usize];
    ["Alignment of cv_CalibrateCRF"][::std::mem::align_of::<cv_CalibrateCRF>() - 8usize];
};
#[doc = " @brief Inverse camera response function is extracted for each brightness value by minimizing an objective\nfunction as linear system. Objective function is constructed using pixel values on the same position\nin all images, extra term is added to make the result smoother.\n\nFor more information see @cite DM97 ."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_CalibrateDebevec {
    pub _base: cv_CalibrateCRF,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_CalibrateDebevec"][::std::mem::size_of::<cv_CalibrateDebevec>() - 8usize];
    ["Alignment of cv_CalibrateDebevec"][::std::mem::align_of::<cv_CalibrateDebevec>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates CalibrateDebevec object\n\n@param samples number of pixel locations to use\n@param lambda smoothness term weight. Greater values produce smoother results, but can alter the\nresponse.\n@param random if true sample pixel locations are chosen at random, otherwise they form a\nrectangular grid."]
    #[link_name = "\u{1}_ZN2cv22createCalibrateDebevecEifb"]
    pub fn cv_createCalibrateDebevec(
        samples: ::std::os::raw::c_int,
        lambda: f32,
        random: bool,
    ) -> cv_Ptr;
}
#[doc = " @brief Inverse camera response function is extracted for each brightness value by minimizing an objective\nfunction as linear system. This algorithm uses all image pixels.\n\nFor more information see @cite RB99 ."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_CalibrateRobertson {
    pub _base: cv_CalibrateCRF,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_CalibrateRobertson"][::std::mem::size_of::<cv_CalibrateRobertson>() - 8usize];
    ["Alignment of cv_CalibrateRobertson"]
        [::std::mem::align_of::<cv_CalibrateRobertson>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates CalibrateRobertson object\n\n@param max_iter maximal number of Gauss-Seidel solver iterations.\n@param threshold target difference between results of two successive steps of the minimization."]
    #[link_name = "\u{1}_ZN2cv24createCalibrateRobertsonEif"]
    pub fn cv_createCalibrateRobertson(max_iter: ::std::os::raw::c_int, threshold: f32) -> cv_Ptr;
}
#[doc = " @brief The base class algorithms that can merge exposure sequence to a single image."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_MergeExposures {
    pub _base: cv_Algorithm,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_MergeExposures"][::std::mem::size_of::<cv_MergeExposures>() - 8usize];
    ["Alignment of cv_MergeExposures"][::std::mem::align_of::<cv_MergeExposures>() - 8usize];
};
#[doc = " @brief The resulting HDR image is calculated as weighted average of the exposures considering exposure\nvalues and camera response.\n\nFor more information see @cite DM97 ."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_MergeDebevec {
    pub _base: cv_MergeExposures,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_MergeDebevec"][::std::mem::size_of::<cv_MergeDebevec>() - 8usize];
    ["Alignment of cv_MergeDebevec"][::std::mem::align_of::<cv_MergeDebevec>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates MergeDebevec object"]
    #[link_name = "\u{1}_ZN2cv18createMergeDebevecEv"]
    pub fn cv_createMergeDebevec() -> cv_Ptr;
}
#[doc = " @brief Pixels are weighted using contrast, saturation and well-exposedness measures, than images are\ncombined using laplacian pyramids.\n\nThe resulting image weight is constructed as weighted average of contrast, saturation and\nwell-exposedness measures.\n\nThe resulting image doesn't require tonemapping and can be converted to 8-bit image by multiplying\nby 255, but it's recommended to apply gamma correction and/or linear tonemapping.\n\nFor more information see @cite MK07 ."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_MergeMertens {
    pub _base: cv_MergeExposures,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_MergeMertens"][::std::mem::size_of::<cv_MergeMertens>() - 8usize];
    ["Alignment of cv_MergeMertens"][::std::mem::align_of::<cv_MergeMertens>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates MergeMertens object\n\n@param contrast_weight contrast measure weight. See MergeMertens.\n@param saturation_weight saturation measure weight\n@param exposure_weight well-exposedness measure weight"]
    #[link_name = "\u{1}_ZN2cv18createMergeMertensEfff"]
    pub fn cv_createMergeMertens(
        contrast_weight: f32,
        saturation_weight: f32,
        exposure_weight: f32,
    ) -> cv_Ptr;
}
#[doc = " @brief The resulting HDR image is calculated as weighted average of the exposures considering exposure\nvalues and camera response.\n\nFor more information see @cite RB99 ."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_MergeRobertson {
    pub _base: cv_MergeExposures,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_MergeRobertson"][::std::mem::size_of::<cv_MergeRobertson>() - 8usize];
    ["Alignment of cv_MergeRobertson"][::std::mem::align_of::<cv_MergeRobertson>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates MergeRobertson object"]
    #[link_name = "\u{1}_ZN2cv20createMergeRobertsonEv"]
    pub fn cv_createMergeRobertson() -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief Transforms a color image to a grayscale image. It is a basic tool in digital printing, stylized\nblack-and-white photograph rendering, and in many single channel image processing applications\n@cite CL12 .\n\n@param src Input 8-bit 3-channel image.\n@param grayscale Output 8-bit 1-channel image.\n@param color_boost Output 8-bit 3-channel image.\n\nThis function is to be applied on color images."]
    #[link_name = "\u{1}_ZN2cv7decolorERKNS_11_InputArrayERKNS_12_OutputArrayES5_"]
    pub fn cv_decolor(src: cv_InputArray, grayscale: cv_OutputArray, color_boost: cv_OutputArray);
}
#[doc = " The power of the method is fully expressed when inserting objects with complex outlines into a new background"]
pub const NORMAL_CLONE: cv__bindgen_ty_28 = 1;
#[doc = " The classic method, color-based selection and alpha masking might be time consuming and often leaves an undesirable\nhalo. Seamless cloning, even averaged with the original image, is not effective. Mixed seamless cloning based on a loose selection proves effective."]
pub const MIXED_CLONE: cv__bindgen_ty_28 = 2;
#[doc = " Monochrome transfer allows the user to easily replace certain features of one object by alternative features."]
pub const MONOCHROME_TRANSFER: cv__bindgen_ty_28 = 3;
#[doc = "! seamlessClone algorithm flags"]
pub type cv__bindgen_ty_28 = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @example samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp\nAn example using seamlessClone function\n/\n/** @brief Image editing tasks concern either global changes (color/intensity corrections, filters,\ndeformations) or local changes concerned to a selection. Here we are interested in achieving local\nchanges, ones that are restricted to a region manually selected (ROI), in a seamless and effortless\nmanner. The extent of the changes ranges from slight distortions to complete replacement by novel\ncontent @cite PM03 .\n\n@param src Input 8-bit 3-channel image.\n@param dst Input 8-bit 3-channel image.\n@param mask Input 8-bit 1 or 3-channel image.\n@param p Point in dst image where object is placed.\n@param blend Output image with the same size and type as dst.\n@param flags Cloning method that could be cv::NORMAL_CLONE, cv::MIXED_CLONE or cv::MONOCHROME_TRANSFER"]
    #[link_name = "\u{1}_ZN2cv13seamlessCloneERKNS_11_InputArrayES2_S2_NS_6Point_IiEERKNS_12_OutputArrayEi"]
    pub fn cv_seamlessClone(
        src: cv_InputArray,
        dst: cv_InputArray,
        mask: cv_InputArray,
        p: cv_Point,
        blend: cv_OutputArray,
        flags: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Given an original color image, two differently colored versions of this image can be mixed\nseamlessly.\n\n@param src Input 8-bit 3-channel image.\n@param mask Input 8-bit 1 or 3-channel image.\n@param dst Output image with the same size and type as src .\n@param red_mul R-channel multiply factor.\n@param green_mul G-channel multiply factor.\n@param blue_mul B-channel multiply factor.\n\nMultiplication factor is between .5 to 2.5."]
    #[link_name = "\u{1}_ZN2cv11colorChangeERKNS_11_InputArrayES2_RKNS_12_OutputArrayEfff"]
    pub fn cv_colorChange(
        src: cv_InputArray,
        mask: cv_InputArray,
        dst: cv_OutputArray,
        red_mul: f32,
        green_mul: f32,
        blue_mul: f32,
    );
}
unsafe extern "C" {
    #[doc = " @brief Applying an appropriate non-linear transformation to the gradient field inside the selection and\nthen integrating back with a Poisson solver, modifies locally the apparent illumination of an image.\n\n@param src Input 8-bit 3-channel image.\n@param mask Input 8-bit 1 or 3-channel image.\n@param dst Output image with the same size and type as src.\n@param alpha Value ranges between 0-2.\n@param beta Value ranges between 0-2.\n\nThis is useful to highlight under-exposed foreground objects or to reduce specular reflections."]
    #[link_name = "\u{1}_ZN2cv18illuminationChangeERKNS_11_InputArrayES2_RKNS_12_OutputArrayEff"]
    pub fn cv_illuminationChange(
        src: cv_InputArray,
        mask: cv_InputArray,
        dst: cv_OutputArray,
        alpha: f32,
        beta: f32,
    );
}
unsafe extern "C" {
    #[doc = " @brief By retaining only the gradients at edge locations, before integrating with the Poisson solver, one\nwashes out the texture of the selected region, giving its contents a flat aspect. Here Canny Edge %Detector is used.\n\n@param src Input 8-bit 3-channel image.\n@param mask Input 8-bit 1 or 3-channel image.\n@param dst Output image with the same size and type as src.\n@param low_threshold %Range from 0 to 100.\n@param high_threshold Value \\> 100.\n@param kernel_size The size of the Sobel kernel to be used.\n\n@note\nThe algorithm assumes that the color of the source image is close to that of the destination. This\nassumption means that when the colors don't match, the source image color gets tinted toward the\ncolor of the destination image."]
    #[link_name = "\u{1}_ZN2cv17textureFlatteningERKNS_11_InputArrayES2_RKNS_12_OutputArrayEffi"]
    pub fn cv_textureFlattening(
        src: cv_InputArray,
        mask: cv_InputArray,
        dst: cv_OutputArray,
        low_threshold: f32,
        high_threshold: f32,
        kernel_size: ::std::os::raw::c_int,
    );
}
#[doc = "!< Recursive Filtering"]
pub const RECURS_FILTER: cv__bindgen_ty_29 = 1;
#[doc = "!< Normalized Convolution Filtering"]
pub const NORMCONV_FILTER: cv__bindgen_ty_29 = 2;
#[doc = "! Edge preserving filters"]
pub type cv__bindgen_ty_29 = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Filtering is the fundamental operation in image and video processing. Edge-preserving smoothing\nfilters are used in many different applications @cite EM11 .\n\n@param src Input 8-bit 3-channel image.\n@param dst Output 8-bit 3-channel image.\n@param flags Edge preserving filters: cv::RECURS_FILTER or cv::NORMCONV_FILTER\n@param sigma_s %Range between 0 to 200.\n@param sigma_r %Range between 0 to 1."]
    #[link_name = "\u{1}_ZN2cv20edgePreservingFilterERKNS_11_InputArrayERKNS_12_OutputArrayEiff"]
    pub fn cv_edgePreservingFilter(
        src: cv_InputArray,
        dst: cv_OutputArray,
        flags: ::std::os::raw::c_int,
        sigma_s: f32,
        sigma_r: f32,
    );
}
unsafe extern "C" {
    #[doc = " @brief This filter enhances the details of a particular image.\n\n@param src Input 8-bit 3-channel image.\n@param dst Output image with the same size and type as src.\n@param sigma_s %Range between 0 to 200.\n@param sigma_r %Range between 0 to 1."]
    #[link_name = "\u{1}_ZN2cv13detailEnhanceERKNS_11_InputArrayERKNS_12_OutputArrayEff"]
    pub fn cv_detailEnhance(src: cv_InputArray, dst: cv_OutputArray, sigma_s: f32, sigma_r: f32);
}
unsafe extern "C" {
    #[doc = " @example samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp\nAn example using non-photorealistic line drawing functions\n/\n/** @brief Pencil-like non-photorealistic line drawing\n\n@param src Input 8-bit 3-channel image.\n@param dst1 Output 8-bit 1-channel image.\n@param dst2 Output image with the same size and type as src.\n@param sigma_s %Range between 0 to 200.\n@param sigma_r %Range between 0 to 1.\n@param shade_factor %Range between 0 to 0.1."]
    #[link_name = "\u{1}_ZN2cv12pencilSketchERKNS_11_InputArrayERKNS_12_OutputArrayES5_fff"]
    pub fn cv_pencilSketch(
        src: cv_InputArray,
        dst1: cv_OutputArray,
        dst2: cv_OutputArray,
        sigma_s: f32,
        sigma_r: f32,
        shade_factor: f32,
    );
}
unsafe extern "C" {
    #[doc = " @brief Stylization aims to produce digital imagery with a wide variety of effects not focused on\nphotorealism. Edge-aware filters are ideal for stylization, as they can abstract regions of low\ncontrast while preserving, or enhancing, high-contrast features.\n\n@param src Input 8-bit 3-channel image.\n@param dst Output image with the same size and type as src.\n@param sigma_s %Range between 0 to 200.\n@param sigma_r %Range between 0 to 1."]
    #[link_name = "\u{1}_ZN2cv11stylizationERKNS_11_InputArrayERKNS_12_OutputArrayEff"]
    pub fn cv_stylization(src: cv_InputArray, dst: cv_OutputArray, sigma_s: f32, sigma_r: f32);
}
unsafe extern "C" {
    #[doc = " @brief Computes the \"minimal work\" distance between two weighted point configurations base on the papers\n\"EMD-L1: An efficient and Robust Algorithm for comparing histogram-based descriptors\", by Haibin\nLing and Kazunori Okuda; and \"The Earth Mover's Distance is the Mallows Distance: Some Insights from\nStatistics\", by Elizaveta Levina and Peter Bickel.\n\n@param signature1 First signature, a single column floating-point matrix. Each row is the value of\nthe histogram in each bin.\n@param signature2 Second signature of the same format and size as signature1."]
    #[link_name = "\u{1}_ZN2cv5EMDL1ERKNS_11_InputArrayES2_"]
    pub fn cv_EMDL1(signature1: cv_InputArray, signature2: cv_InputArray) -> f32;
}
#[doc = " @brief Abstract base class for shape transformation algorithms."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_ShapeTransformer {
    pub _base: cv_Algorithm,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ShapeTransformer"][::std::mem::size_of::<cv_ShapeTransformer>() - 8usize];
    ["Alignment of cv_ShapeTransformer"][::std::mem::align_of::<cv_ShapeTransformer>() - 8usize];
};
#[doc = " @brief Definition of the transformation\n\noccupied in the paper \"Principal Warps: Thin-Plate Splines and Decomposition of Deformations\", by\nF.L. Bookstein (PAMI 1989). :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_ThinPlateSplineShapeTransformer {
    pub _base: cv_ShapeTransformer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ThinPlateSplineShapeTransformer"]
        [::std::mem::size_of::<cv_ThinPlateSplineShapeTransformer>() - 8usize];
    ["Alignment of cv_ThinPlateSplineShapeTransformer"]
        [::std::mem::align_of::<cv_ThinPlateSplineShapeTransformer>() - 8usize];
};
unsafe extern "C" {
    #[doc = " Complete constructor"]
    #[link_name = "\u{1}_ZN2cv37createThinPlateSplineShapeTransformerEd"]
    pub fn cv_createThinPlateSplineShapeTransformer(regularizationParameter: f64) -> cv_Ptr;
}
#[doc = " @brief Wrapper class for the OpenCV Affine Transformation algorithm. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_AffineTransformer {
    pub _base: cv_ShapeTransformer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_AffineTransformer"][::std::mem::size_of::<cv_AffineTransformer>() - 8usize];
    ["Alignment of cv_AffineTransformer"][::std::mem::align_of::<cv_AffineTransformer>() - 8usize];
};
unsafe extern "C" {
    #[doc = " Complete constructor"]
    #[link_name = "\u{1}_ZN2cv23createAffineTransformerEb"]
    pub fn cv_createAffineTransformer(fullAffine: bool) -> cv_Ptr;
}
#[doc = " @brief Abstract base class for histogram cost algorithms."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_HistogramCostExtractor {
    pub _base: cv_Algorithm,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_HistogramCostExtractor"]
        [::std::mem::size_of::<cv_HistogramCostExtractor>() - 8usize];
    ["Alignment of cv_HistogramCostExtractor"]
        [::std::mem::align_of::<cv_HistogramCostExtractor>() - 8usize];
};
#[doc = " @brief A norm based cost extraction. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_NormHistogramCostExtractor {
    pub _base: cv_HistogramCostExtractor,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_NormHistogramCostExtractor"]
        [::std::mem::size_of::<cv_NormHistogramCostExtractor>() - 8usize];
    ["Alignment of cv_NormHistogramCostExtractor"]
        [::std::mem::align_of::<cv_NormHistogramCostExtractor>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv32createNormHistogramCostExtractorEiif"]
    pub fn cv_createNormHistogramCostExtractor(
        flag: ::std::os::raw::c_int,
        nDummies: ::std::os::raw::c_int,
        defaultCost: f32,
    ) -> cv_Ptr;
}
#[doc = " @brief An EMD based cost extraction. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_EMDHistogramCostExtractor {
    pub _base: cv_HistogramCostExtractor,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_EMDHistogramCostExtractor"]
        [::std::mem::size_of::<cv_EMDHistogramCostExtractor>() - 8usize];
    ["Alignment of cv_EMDHistogramCostExtractor"]
        [::std::mem::align_of::<cv_EMDHistogramCostExtractor>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv31createEMDHistogramCostExtractorEiif"]
    pub fn cv_createEMDHistogramCostExtractor(
        flag: ::std::os::raw::c_int,
        nDummies: ::std::os::raw::c_int,
        defaultCost: f32,
    ) -> cv_Ptr;
}
#[doc = " @brief An Chi based cost extraction. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_ChiHistogramCostExtractor {
    pub _base: cv_HistogramCostExtractor,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ChiHistogramCostExtractor"]
        [::std::mem::size_of::<cv_ChiHistogramCostExtractor>() - 8usize];
    ["Alignment of cv_ChiHistogramCostExtractor"]
        [::std::mem::align_of::<cv_ChiHistogramCostExtractor>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv31createChiHistogramCostExtractorEif"]
    pub fn cv_createChiHistogramCostExtractor(
        nDummies: ::std::os::raw::c_int,
        defaultCost: f32,
    ) -> cv_Ptr;
}
#[doc = " @brief An EMD-L1 based cost extraction. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_EMDL1HistogramCostExtractor {
    pub _base: cv_HistogramCostExtractor,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_EMDL1HistogramCostExtractor"]
        [::std::mem::size_of::<cv_EMDL1HistogramCostExtractor>() - 8usize];
    ["Alignment of cv_EMDL1HistogramCostExtractor"]
        [::std::mem::align_of::<cv_EMDL1HistogramCostExtractor>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv33createEMDL1HistogramCostExtractorEif"]
    pub fn cv_createEMDL1HistogramCostExtractor(
        nDummies: ::std::os::raw::c_int,
        defaultCost: f32,
    ) -> cv_Ptr;
}
#[doc = " @example modules/shape/samples/shape_example.cpp\nAn example using shape distance algorithm\n/\n/** @brief Abstract base class for shape distance algorithms."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_ShapeDistanceExtractor {
    pub _base: cv_Algorithm,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ShapeDistanceExtractor"]
        [::std::mem::size_of::<cv_ShapeDistanceExtractor>() - 8usize];
    ["Alignment of cv_ShapeDistanceExtractor"]
        [::std::mem::align_of::<cv_ShapeDistanceExtractor>() - 8usize];
};
#[doc = "/\n/***********************************************************************************/\n/***********************************************************************************/\n/** @brief Implementation of the Shape Context descriptor and matching algorithm\n\nproposed by Belongie et al. in \"Shape Matching and Object Recognition Using Shape Contexts\" (PAMI\n2002). This implementation is packaged in a generic scheme, in order to allow you the\nimplementation of the common variations of the original pipeline."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_ShapeContextDistanceExtractor {
    pub _base: cv_ShapeDistanceExtractor,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_ShapeContextDistanceExtractor"]
        [::std::mem::size_of::<cv_ShapeContextDistanceExtractor>() - 8usize];
    ["Alignment of cv_ShapeContextDistanceExtractor"]
        [::std::mem::align_of::<cv_ShapeContextDistanceExtractor>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv35createShapeContextDistanceExtractorEiiffiRKNS_3PtrINS_22HistogramCostExtractorEEERKNS0_INS_16ShapeTransformerEEE"]
    pub fn cv_createShapeContextDistanceExtractor(
        nAngularBins: ::std::os::raw::c_int,
        nRadialBins: ::std::os::raw::c_int,
        innerRadius: f32,
        outerRadius: f32,
        iterations: ::std::os::raw::c_int,
        comparer: *const cv_Ptr,
        transformer: *const cv_Ptr,
    ) -> cv_Ptr;
}
#[doc = "/\n/***********************************************************************************/\n/***********************************************************************************/\n/** @brief A simple Hausdorff distance measure between shapes defined by contours\n\naccording to the paper \"Comparing Images using the Hausdorff distance.\" by D.P. Huttenlocher, G.A.\nKlanderman, and W.J. Rucklidge. (PAMI 1993). :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_HausdorffDistanceExtractor {
    pub _base: cv_ShapeDistanceExtractor,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_HausdorffDistanceExtractor"]
        [::std::mem::size_of::<cv_HausdorffDistanceExtractor>() - 8usize];
    ["Alignment of cv_HausdorffDistanceExtractor"]
        [::std::mem::align_of::<cv_HausdorffDistanceExtractor>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv32createHausdorffDistanceExtractorEif"]
    pub fn cv_createHausdorffDistanceExtractor(
        distanceFlag: ::std::os::raw::c_int,
        rankProp: f32,
    ) -> cv_Ptr;
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_PyRotationWarper {
    pub rw: cv_Ptr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_PyRotationWarper"][::std::mem::size_of::<cv_PyRotationWarper>() - 16usize];
    ["Alignment of cv_PyRotationWarper"][::std::mem::align_of::<cv_PyRotationWarper>() - 8usize];
    ["Offset of field: cv_PyRotationWarper::rw"]
        [::std::mem::offset_of!(cv_PyRotationWarper, rw) - 0usize];
};
unsafe extern "C" {
    #[doc = " @brief Projects the image point.\n\n@param pt Source point\n@param K Camera intrinsic parameters\n@param R Camera rotation matrix\n@return Projected point"]
    #[link_name = "\u{1}_ZN2cv16PyRotationWarper9warpPointERKNS_6Point_IfEERKNS_11_InputArrayES7_"]
    pub fn cv_PyRotationWarper_warpPoint(
        this: *mut cv_PyRotationWarper,
        pt: *const cv_Point2f,
        K: cv_InputArray,
        R: cv_InputArray,
    ) -> cv_Point2f;
}
unsafe extern "C" {
    #[doc = " @brief Builds the projection maps according to the given camera data.\n\n@param src_size Source image size\n@param K Camera intrinsic parameters\n@param R Camera rotation matrix\n@param xmap Projection map for the x axis\n@param ymap Projection map for the y axis\n@return Projected image minimum bounding box"]
    #[link_name = "\u{1}_ZN2cv16PyRotationWarper9buildMapsENS_5Size_IiEERKNS_11_InputArrayES5_RKNS_12_OutputArrayES8_"]
    pub fn cv_PyRotationWarper_buildMaps(
        this: *mut cv_PyRotationWarper,
        src_size: cv_Size,
        K: cv_InputArray,
        R: cv_InputArray,
        xmap: cv_OutputArray,
        ymap: cv_OutputArray,
    ) -> cv_Rect;
}
unsafe extern "C" {
    #[doc = " @brief Projects the image.\n\n@param src Source image\n@param K Camera intrinsic parameters\n@param R Camera rotation matrix\n@param interp_mode Interpolation mode\n@param border_mode Border extrapolation mode\n@param dst Projected image\n@return Project image top-left corner"]
    #[link_name = "\u{1}_ZN2cv16PyRotationWarper4warpERKNS_11_InputArrayES3_S3_iiRKNS_12_OutputArrayE"]
    pub fn cv_PyRotationWarper_warp(
        this: *mut cv_PyRotationWarper,
        src: cv_InputArray,
        K: cv_InputArray,
        R: cv_InputArray,
        interp_mode: ::std::os::raw::c_int,
        border_mode: ::std::os::raw::c_int,
        dst: cv_OutputArray,
    ) -> cv_Point;
}
unsafe extern "C" {
    #[doc = " @brief Projects the image backward.\n\n@param src Projected image\n@param K Camera intrinsic parameters\n@param R Camera rotation matrix\n@param interp_mode Interpolation mode\n@param border_mode Border extrapolation mode\n@param dst_size Backward-projected image size\n@param dst Backward-projected image"]
    #[link_name = "\u{1}_ZN2cv16PyRotationWarper12warpBackwardERKNS_11_InputArrayES3_S3_iiNS_5Size_IiEERKNS_12_OutputArrayE"]
    pub fn cv_PyRotationWarper_warpBackward(
        this: *mut cv_PyRotationWarper,
        src: cv_InputArray,
        K: cv_InputArray,
        R: cv_InputArray,
        interp_mode: ::std::os::raw::c_int,
        border_mode: ::std::os::raw::c_int,
        dst_size: cv_Size,
        dst: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = "@param src_size Source image bounding box\n@param K Camera intrinsic parameters\n@param R Camera rotation matrix\n@return Projected image minimum bounding box"]
    #[link_name = "\u{1}_ZN2cv16PyRotationWarper7warpRoiENS_5Size_IiEERKNS_11_InputArrayES5_"]
    pub fn cv_PyRotationWarper_warpRoi(
        this: *mut cv_PyRotationWarper,
        src_size: cv_Size,
        K: cv_InputArray,
        R: cv_InputArray,
    ) -> cv_Rect;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv16PyRotationWarperC1ENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEf"]
    pub fn cv_PyRotationWarper_PyRotationWarper(
        this: *mut cv_PyRotationWarper,
        type_: cv_String,
        scale: f32,
    );
}
impl cv_PyRotationWarper {
    #[inline]
    pub unsafe fn warpPoint(
        &mut self,
        pt: *const cv_Point2f,
        K: cv_InputArray,
        R: cv_InputArray,
    ) -> cv_Point2f {
        cv_PyRotationWarper_warpPoint(self, pt, K, R)
    }
    #[inline]
    pub unsafe fn buildMaps(
        &mut self,
        src_size: cv_Size,
        K: cv_InputArray,
        R: cv_InputArray,
        xmap: cv_OutputArray,
        ymap: cv_OutputArray,
    ) -> cv_Rect {
        cv_PyRotationWarper_buildMaps(self, src_size, K, R, xmap, ymap)
    }
    #[inline]
    pub unsafe fn warp(
        &mut self,
        src: cv_InputArray,
        K: cv_InputArray,
        R: cv_InputArray,
        interp_mode: ::std::os::raw::c_int,
        border_mode: ::std::os::raw::c_int,
        dst: cv_OutputArray,
    ) -> cv_Point {
        cv_PyRotationWarper_warp(self, src, K, R, interp_mode, border_mode, dst)
    }
    #[inline]
    pub unsafe fn warpBackward(
        &mut self,
        src: cv_InputArray,
        K: cv_InputArray,
        R: cv_InputArray,
        interp_mode: ::std::os::raw::c_int,
        border_mode: ::std::os::raw::c_int,
        dst_size: cv_Size,
        dst: cv_OutputArray,
    ) {
        cv_PyRotationWarper_warpBackward(self, src, K, R, interp_mode, border_mode, dst_size, dst)
    }
    #[inline]
    pub unsafe fn warpRoi(
        &mut self,
        src_size: cv_Size,
        K: cv_InputArray,
        R: cv_InputArray,
    ) -> cv_Rect {
        cv_PyRotationWarper_warpRoi(self, src_size, K, R)
    }
    #[inline]
    pub unsafe fn new(type_: cv_String, scale: f32) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_PyRotationWarper_PyRotationWarper(__bindgen_tmp.as_mut_ptr(), type_, scale);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct cv_WarperCreator__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief Image warper factories base class."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_WarperCreator {
    pub vtable_: *const cv_WarperCreator__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_WarperCreator"][::std::mem::size_of::<cv_WarperCreator>() - 8usize];
    ["Alignment of cv_WarperCreator"][::std::mem::align_of::<cv_WarperCreator>() - 8usize];
};
#[doc = " @brief Plane warper factory class.\n@sa detail::PlaneWarper"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_PlaneWarper {
    pub _base: cv_WarperCreator,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_PlaneWarper"][::std::mem::size_of::<cv_PlaneWarper>() - 8usize];
    ["Alignment of cv_PlaneWarper"][::std::mem::align_of::<cv_PlaneWarper>() - 8usize];
};
#[doc = " @brief Affine warper factory class.\n@sa detail::AffineWarper"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_AffineWarper {
    pub _base: cv_WarperCreator,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_AffineWarper"][::std::mem::size_of::<cv_AffineWarper>() - 8usize];
    ["Alignment of cv_AffineWarper"][::std::mem::align_of::<cv_AffineWarper>() - 8usize];
};
#[doc = " @brief Cylindrical warper factory class.\n@sa detail::CylindricalWarper"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_CylindricalWarper {
    pub _base: cv_WarperCreator,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_CylindricalWarper"][::std::mem::size_of::<cv_CylindricalWarper>() - 8usize];
    ["Alignment of cv_CylindricalWarper"][::std::mem::align_of::<cv_CylindricalWarper>() - 8usize];
};
#[doc = " @brief Spherical warper factory class"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_SphericalWarper {
    pub _base: cv_WarperCreator,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_SphericalWarper"][::std::mem::size_of::<cv_SphericalWarper>() - 8usize];
    ["Alignment of cv_SphericalWarper"][::std::mem::align_of::<cv_SphericalWarper>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_FisheyeWarper {
    pub _base: cv_WarperCreator,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_FisheyeWarper"][::std::mem::size_of::<cv_FisheyeWarper>() - 8usize];
    ["Alignment of cv_FisheyeWarper"][::std::mem::align_of::<cv_FisheyeWarper>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_StereographicWarper {
    pub _base: cv_WarperCreator,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_StereographicWarper"][::std::mem::size_of::<cv_StereographicWarper>() - 8usize];
    ["Alignment of cv_StereographicWarper"]
        [::std::mem::align_of::<cv_StereographicWarper>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_CompressedRectilinearWarper {
    pub _base: cv_WarperCreator,
    pub a: f32,
    pub b: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_CompressedRectilinearWarper"]
        [::std::mem::size_of::<cv_CompressedRectilinearWarper>() - 16usize];
    ["Alignment of cv_CompressedRectilinearWarper"]
        [::std::mem::align_of::<cv_CompressedRectilinearWarper>() - 8usize];
    ["Offset of field: cv_CompressedRectilinearWarper::a"]
        [::std::mem::offset_of!(cv_CompressedRectilinearWarper, a) - 8usize];
    ["Offset of field: cv_CompressedRectilinearWarper::b"]
        [::std::mem::offset_of!(cv_CompressedRectilinearWarper, b) - 12usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_CompressedRectilinearPortraitWarper {
    pub _base: cv_WarperCreator,
    pub a: f32,
    pub b: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_CompressedRectilinearPortraitWarper"]
        [::std::mem::size_of::<cv_CompressedRectilinearPortraitWarper>() - 16usize];
    ["Alignment of cv_CompressedRectilinearPortraitWarper"]
        [::std::mem::align_of::<cv_CompressedRectilinearPortraitWarper>() - 8usize];
    ["Offset of field: cv_CompressedRectilinearPortraitWarper::a"]
        [::std::mem::offset_of!(cv_CompressedRectilinearPortraitWarper, a) - 8usize];
    ["Offset of field: cv_CompressedRectilinearPortraitWarper::b"]
        [::std::mem::offset_of!(cv_CompressedRectilinearPortraitWarper, b) - 12usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_PaniniWarper {
    pub _base: cv_WarperCreator,
    pub a: f32,
    pub b: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_PaniniWarper"][::std::mem::size_of::<cv_PaniniWarper>() - 16usize];
    ["Alignment of cv_PaniniWarper"][::std::mem::align_of::<cv_PaniniWarper>() - 8usize];
    ["Offset of field: cv_PaniniWarper::a"][::std::mem::offset_of!(cv_PaniniWarper, a) - 8usize];
    ["Offset of field: cv_PaniniWarper::b"][::std::mem::offset_of!(cv_PaniniWarper, b) - 12usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_PaniniPortraitWarper {
    pub _base: cv_WarperCreator,
    pub a: f32,
    pub b: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_PaniniPortraitWarper"][::std::mem::size_of::<cv_PaniniPortraitWarper>() - 16usize];
    ["Alignment of cv_PaniniPortraitWarper"]
        [::std::mem::align_of::<cv_PaniniPortraitWarper>() - 8usize];
    ["Offset of field: cv_PaniniPortraitWarper::a"]
        [::std::mem::offset_of!(cv_PaniniPortraitWarper, a) - 8usize];
    ["Offset of field: cv_PaniniPortraitWarper::b"]
        [::std::mem::offset_of!(cv_PaniniPortraitWarper, b) - 12usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_MercatorWarper {
    pub _base: cv_WarperCreator,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_MercatorWarper"][::std::mem::size_of::<cv_MercatorWarper>() - 8usize];
    ["Alignment of cv_MercatorWarper"][::std::mem::align_of::<cv_MercatorWarper>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_TransverseMercatorWarper {
    pub _base: cv_WarperCreator,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_TransverseMercatorWarper"]
        [::std::mem::size_of::<cv_TransverseMercatorWarper>() - 8usize];
    ["Alignment of cv_TransverseMercatorWarper"]
        [::std::mem::align_of::<cv_TransverseMercatorWarper>() - 8usize];
};
#[doc = " @brief High level image stitcher.\n\nIt's possible to use this class without being aware of the entire stitching pipeline. However, to\nbe able to achieve higher stitching stability and quality of the final images at least being\nfamiliar with the theory is recommended.\n\n@note\n-   A basic example on image stitching can be found at\nopencv_source_code/samples/cpp/stitching.cpp\n-   A basic example on image stitching in Python can be found at\nopencv_source_code/samples/python/stitching.py\n-   A detailed example on image stitching can be found at\nopencv_source_code/samples/cpp/stitching_detailed.cpp"]
#[repr(C)]
pub struct cv_Stitcher {
    pub registr_resol_: f64,
    pub seam_est_resol_: f64,
    pub compose_resol_: f64,
    pub conf_thresh_: f64,
    pub interp_flags_: cv_InterpolationFlags,
    pub features_finder_: cv_Ptr,
    pub features_matcher_: cv_Ptr,
    pub matching_mask_: cv_UMat,
    pub bundle_adjuster_: cv_Ptr,
    pub estimator_: cv_Ptr,
    pub do_wave_correct_: bool,
    pub wave_correct_kind_: cv_detail_WaveCorrectKind,
    pub warper_: cv_Ptr,
    pub exposure_comp_: cv_Ptr,
    pub seam_finder_: cv_Ptr,
    pub blender_: cv_Ptr,
    pub imgs_: std_vector,
    pub masks_: std_vector,
    pub full_img_sizes_: std_vector,
    pub features_: std_vector,
    pub pairwise_matches_: std_vector,
    pub seam_est_imgs_: std_vector,
    pub indices_: std_vector,
    pub cameras_: std_vector,
    pub result_mask_: cv_UMat,
    pub work_scale_: f64,
    pub seam_scale_: f64,
    pub seam_work_aspect_: f64,
    pub warped_image_scale_: f64,
}
pub const cv_Stitcher_Status_OK: cv_Stitcher_Status = 0;
pub const cv_Stitcher_Status_ERR_NEED_MORE_IMGS: cv_Stitcher_Status = 1;
pub const cv_Stitcher_Status_ERR_HOMOGRAPHY_EST_FAIL: cv_Stitcher_Status = 2;
pub const cv_Stitcher_Status_ERR_CAMERA_PARAMS_ADJUST_FAIL: cv_Stitcher_Status = 3;
pub type cv_Stitcher_Status = ::std::os::raw::c_uint;
#[doc = " Mode for creating photo panoramas. Expects images under perspective\ntransformation and projects resulting pano to sphere.\n\n@sa detail::BestOf2NearestMatcher SphericalWarper"]
pub const cv_Stitcher_Mode_PANORAMA: cv_Stitcher_Mode = 0;
#[doc = " Mode for composing scans. Expects images under affine transformation does\nnot compensate exposure by default.\n\n@sa detail::AffineBestOf2NearestMatcher AffineWarper"]
pub const cv_Stitcher_Mode_SCANS: cv_Stitcher_Mode = 1;
pub type cv_Stitcher_Mode = ::std::os::raw::c_uint;
pub const cv_Stitcher_ORIG_RESOL: f64 = -1.0;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_Stitcher"][::std::mem::size_of::<cv_Stitcher>() - 560usize];
    ["Alignment of cv_Stitcher"][::std::mem::align_of::<cv_Stitcher>() - 8usize];
    ["Offset of field: cv_Stitcher::registr_resol_"]
        [::std::mem::offset_of!(cv_Stitcher, registr_resol_) - 0usize];
    ["Offset of field: cv_Stitcher::seam_est_resol_"]
        [::std::mem::offset_of!(cv_Stitcher, seam_est_resol_) - 8usize];
    ["Offset of field: cv_Stitcher::compose_resol_"]
        [::std::mem::offset_of!(cv_Stitcher, compose_resol_) - 16usize];
    ["Offset of field: cv_Stitcher::conf_thresh_"]
        [::std::mem::offset_of!(cv_Stitcher, conf_thresh_) - 24usize];
    ["Offset of field: cv_Stitcher::interp_flags_"]
        [::std::mem::offset_of!(cv_Stitcher, interp_flags_) - 32usize];
    ["Offset of field: cv_Stitcher::features_finder_"]
        [::std::mem::offset_of!(cv_Stitcher, features_finder_) - 40usize];
    ["Offset of field: cv_Stitcher::features_matcher_"]
        [::std::mem::offset_of!(cv_Stitcher, features_matcher_) - 56usize];
    ["Offset of field: cv_Stitcher::matching_mask_"]
        [::std::mem::offset_of!(cv_Stitcher, matching_mask_) - 72usize];
    ["Offset of field: cv_Stitcher::bundle_adjuster_"]
        [::std::mem::offset_of!(cv_Stitcher, bundle_adjuster_) - 152usize];
    ["Offset of field: cv_Stitcher::estimator_"]
        [::std::mem::offset_of!(cv_Stitcher, estimator_) - 168usize];
    ["Offset of field: cv_Stitcher::do_wave_correct_"]
        [::std::mem::offset_of!(cv_Stitcher, do_wave_correct_) - 184usize];
    ["Offset of field: cv_Stitcher::wave_correct_kind_"]
        [::std::mem::offset_of!(cv_Stitcher, wave_correct_kind_) - 188usize];
    ["Offset of field: cv_Stitcher::warper_"]
        [::std::mem::offset_of!(cv_Stitcher, warper_) - 192usize];
    ["Offset of field: cv_Stitcher::exposure_comp_"]
        [::std::mem::offset_of!(cv_Stitcher, exposure_comp_) - 208usize];
    ["Offset of field: cv_Stitcher::seam_finder_"]
        [::std::mem::offset_of!(cv_Stitcher, seam_finder_) - 224usize];
    ["Offset of field: cv_Stitcher::blender_"]
        [::std::mem::offset_of!(cv_Stitcher, blender_) - 240usize];
    ["Offset of field: cv_Stitcher::imgs_"][::std::mem::offset_of!(cv_Stitcher, imgs_) - 256usize];
    ["Offset of field: cv_Stitcher::masks_"]
        [::std::mem::offset_of!(cv_Stitcher, masks_) - 280usize];
    ["Offset of field: cv_Stitcher::full_img_sizes_"]
        [::std::mem::offset_of!(cv_Stitcher, full_img_sizes_) - 304usize];
    ["Offset of field: cv_Stitcher::features_"]
        [::std::mem::offset_of!(cv_Stitcher, features_) - 328usize];
    ["Offset of field: cv_Stitcher::pairwise_matches_"]
        [::std::mem::offset_of!(cv_Stitcher, pairwise_matches_) - 352usize];
    ["Offset of field: cv_Stitcher::seam_est_imgs_"]
        [::std::mem::offset_of!(cv_Stitcher, seam_est_imgs_) - 376usize];
    ["Offset of field: cv_Stitcher::indices_"]
        [::std::mem::offset_of!(cv_Stitcher, indices_) - 400usize];
    ["Offset of field: cv_Stitcher::cameras_"]
        [::std::mem::offset_of!(cv_Stitcher, cameras_) - 424usize];
    ["Offset of field: cv_Stitcher::result_mask_"]
        [::std::mem::offset_of!(cv_Stitcher, result_mask_) - 448usize];
    ["Offset of field: cv_Stitcher::work_scale_"]
        [::std::mem::offset_of!(cv_Stitcher, work_scale_) - 528usize];
    ["Offset of field: cv_Stitcher::seam_scale_"]
        [::std::mem::offset_of!(cv_Stitcher, seam_scale_) - 536usize];
    ["Offset of field: cv_Stitcher::seam_work_aspect_"]
        [::std::mem::offset_of!(cv_Stitcher, seam_work_aspect_) - 544usize];
    ["Offset of field: cv_Stitcher::warped_image_scale_"]
        [::std::mem::offset_of!(cv_Stitcher, warped_image_scale_) - 552usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates a Stitcher configured in one of the stitching modes.\n\n@param mode Scenario for stitcher operation. This is usually determined by source of images\nto stitch and their transformation. Default parameters will be chosen for operation in given\nscenario.\n@return Stitcher class instance."]
    #[link_name = "\u{1}_ZN2cv8Stitcher6createENS0_4ModeE"]
    pub fn cv_Stitcher_create(mode: cv_Stitcher_Mode) -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @brief These functions try to match the given images and to estimate rotations of each camera.\n\n@note Use the functions only if you're aware of the stitching pipeline, otherwise use\nStitcher::stitch.\n\n@param images Input images.\n@param masks Masks for each input image specifying where to look for keypoints (optional).\n@return Status code."]
    #[link_name = "\u{1}_ZN2cv8Stitcher17estimateTransformERKNS_11_InputArrayES3_"]
    pub fn cv_Stitcher_estimateTransform(
        this: *mut cv_Stitcher,
        images: cv_InputArrayOfArrays,
        masks: cv_InputArrayOfArrays,
    ) -> cv_Stitcher_Status;
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv8Stitcher15composePanoramaERKNS_12_OutputArrayE"]
    pub fn cv_Stitcher_composePanorama(
        this: *mut cv_Stitcher,
        pano: cv_OutputArray,
    ) -> cv_Stitcher_Status;
}
unsafe extern "C" {
    #[doc = " @brief These functions try to compose the given images (or images stored internally from the other function\ncalls) into the final pano under the assumption that the image transformations were estimated\nbefore.\n\n@note Use the functions only if you're aware of the stitching pipeline, otherwise use\nStitcher::stitch.\n\n@param images Input images.\n@param pano Final pano.\n@return Status code."]
    #[link_name = "\u{1}_ZN2cv8Stitcher15composePanoramaERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_Stitcher_composePanorama1(
        this: *mut cv_Stitcher,
        images: cv_InputArrayOfArrays,
        pano: cv_OutputArray,
    ) -> cv_Stitcher_Status;
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv8Stitcher6stitchERKNS_11_InputArrayERKNS_12_OutputArrayE"]
    pub fn cv_Stitcher_stitch(
        this: *mut cv_Stitcher,
        images: cv_InputArrayOfArrays,
        pano: cv_OutputArray,
    ) -> cv_Stitcher_Status;
}
unsafe extern "C" {
    #[doc = " @brief These functions try to stitch the given images.\n\n@param images Input images.\n@param masks Masks for each input image specifying where to look for keypoints (optional).\n@param pano Final pano.\n@return Status code."]
    #[link_name = "\u{1}_ZN2cv8Stitcher6stitchERKNS_11_InputArrayES3_RKNS_12_OutputArrayE"]
    pub fn cv_Stitcher_stitch1(
        this: *mut cv_Stitcher,
        images: cv_InputArrayOfArrays,
        masks: cv_InputArrayOfArrays,
        pano: cv_OutputArray,
    ) -> cv_Stitcher_Status;
}
impl cv_Stitcher {
    #[inline]
    pub unsafe fn create(mode: cv_Stitcher_Mode) -> cv_Ptr {
        cv_Stitcher_create(mode)
    }
    #[inline]
    pub unsafe fn estimateTransform(
        &mut self,
        images: cv_InputArrayOfArrays,
        masks: cv_InputArrayOfArrays,
    ) -> cv_Stitcher_Status {
        cv_Stitcher_estimateTransform(self, images, masks)
    }
    #[inline]
    pub unsafe fn composePanorama(&mut self, pano: cv_OutputArray) -> cv_Stitcher_Status {
        cv_Stitcher_composePanorama(self, pano)
    }
    #[inline]
    pub unsafe fn composePanorama1(
        &mut self,
        images: cv_InputArrayOfArrays,
        pano: cv_OutputArray,
    ) -> cv_Stitcher_Status {
        cv_Stitcher_composePanorama1(self, images, pano)
    }
    #[inline]
    pub unsafe fn stitch(
        &mut self,
        images: cv_InputArrayOfArrays,
        pano: cv_OutputArray,
    ) -> cv_Stitcher_Status {
        cv_Stitcher_stitch(self, images, pano)
    }
    #[inline]
    pub unsafe fn stitch1(
        &mut self,
        images: cv_InputArrayOfArrays,
        masks: cv_InputArrayOfArrays,
        pano: cv_OutputArray,
    ) -> cv_Stitcher_Status {
        cv_Stitcher_stitch1(self, images, masks, pano)
    }
}
unsafe extern "C" {
    #[doc = " @deprecated use Stitcher::create"]
    #[link_name = "\u{1}_ZN2cv14createStitcherEb"]
    pub fn cv_createStitcher(try_use_gpu: bool) -> cv_Ptr;
}
unsafe extern "C" {
    #[doc = " @deprecated use Stitcher::create"]
    #[link_name = "\u{1}_ZN2cv19createStitcherScansEb"]
    pub fn cv_createStitcherScans(try_use_gpu: bool) -> cv_Ptr;
}
#[doc = "! @addtogroup superres\n! @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_superres_DenseOpticalFlowExt {
    pub _base: cv_Algorithm,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_superres_DenseOpticalFlowExt"]
        [::std::mem::size_of::<cv_superres_DenseOpticalFlowExt>() - 8usize];
    ["Alignment of cv_superres_DenseOpticalFlowExt"]
        [::std::mem::align_of::<cv_superres_DenseOpticalFlowExt>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_superres_FarnebackOpticalFlow {
    pub __bindgen_padding_0: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_superres_FarnebackOpticalFlow"]
        [::std::mem::size_of::<cv_superres_FarnebackOpticalFlow>() - 8usize];
    ["Alignment of cv_superres_FarnebackOpticalFlow"]
        [::std::mem::align_of::<cv_superres_FarnebackOpticalFlow>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8superres23createOptFlow_FarnebackEv"]
    pub fn cv_superres_createOptFlow_Farneback() -> cv_Ptr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8superres28createOptFlow_Farneback_CUDAEv"]
    pub fn cv_superres_createOptFlow_Farneback_CUDA() -> cv_Ptr;
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_superres_DualTVL1OpticalFlow {
    pub __bindgen_padding_0: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_superres_DualTVL1OpticalFlow"]
        [::std::mem::size_of::<cv_superres_DualTVL1OpticalFlow>() - 8usize];
    ["Alignment of cv_superres_DualTVL1OpticalFlow"]
        [::std::mem::align_of::<cv_superres_DualTVL1OpticalFlow>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8superres22createOptFlow_DualTVL1Ev"]
    pub fn cv_superres_createOptFlow_DualTVL1() -> cv_Ptr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8superres27createOptFlow_DualTVL1_CUDAEv"]
    pub fn cv_superres_createOptFlow_DualTVL1_CUDA() -> cv_Ptr;
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_superres_BroxOpticalFlow {
    pub __bindgen_padding_0: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_superres_BroxOpticalFlow"]
        [::std::mem::size_of::<cv_superres_BroxOpticalFlow>() - 8usize];
    ["Alignment of cv_superres_BroxOpticalFlow"]
        [::std::mem::align_of::<cv_superres_BroxOpticalFlow>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8superres23createOptFlow_Brox_CUDAEv"]
    pub fn cv_superres_createOptFlow_Brox_CUDA() -> cv_Ptr;
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_superres_PyrLKOpticalFlow {
    pub __bindgen_padding_0: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_superres_PyrLKOpticalFlow"]
        [::std::mem::size_of::<cv_superres_PyrLKOpticalFlow>() - 8usize];
    ["Alignment of cv_superres_PyrLKOpticalFlow"]
        [::std::mem::align_of::<cv_superres_PyrLKOpticalFlow>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8superres24createOptFlow_PyrLK_CUDAEv"]
    pub fn cv_superres_createOptFlow_PyrLK_CUDA() -> cv_Ptr;
}
#[repr(C)]
pub struct cv_superres_FrameSource__bindgen_vtable(::std::os::raw::c_void);
#[doc = "! @addtogroup superres\n! @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_superres_FrameSource {
    pub vtable_: *const cv_superres_FrameSource__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_superres_FrameSource"][::std::mem::size_of::<cv_superres_FrameSource>() - 8usize];
    ["Alignment of cv_superres_FrameSource"]
        [::std::mem::align_of::<cv_superres_FrameSource>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8superres11FrameSourceD1Ev"]
    pub fn cv_superres_FrameSource_FrameSource_destructor(this: *mut cv_superres_FrameSource);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8superres23createFrameSource_EmptyEv"]
    pub fn cv_superres_createFrameSource_Empty() -> cv_Ptr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8superres23createFrameSource_VideoERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_superres_createFrameSource_Video(fileName: *const cv_String) -> cv_Ptr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8superres28createFrameSource_Video_CUDAERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_superres_createFrameSource_Video_CUDA(fileName: *const cv_String) -> cv_Ptr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8superres24createFrameSource_CameraEi"]
    pub fn cv_superres_createFrameSource_Camera(deviceId: ::std::os::raw::c_int) -> cv_Ptr;
}
#[doc = " @brief Base class for Super Resolution algorithms.\n\nThe class is only used to define the common interface for the whole family of Super Resolution\nalgorithms."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_superres_SuperResolution {
    pub _base: cv_Algorithm,
    pub _base_1: cv_superres_FrameSource,
    pub isUmat_: bool,
    pub frameSource_: cv_Ptr,
    pub firstCall_: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_superres_SuperResolution"]
        [::std::mem::size_of::<cv_superres_SuperResolution>() - 48usize];
    ["Alignment of cv_superres_SuperResolution"]
        [::std::mem::align_of::<cv_superres_SuperResolution>() - 8usize];
    ["Offset of field: cv_superres_SuperResolution::isUmat_"]
        [::std::mem::offset_of!(cv_superres_SuperResolution, isUmat_) - 16usize];
    ["Offset of field: cv_superres_SuperResolution::frameSource_"]
        [::std::mem::offset_of!(cv_superres_SuperResolution, frameSource_) - 24usize];
    ["Offset of field: cv_superres_SuperResolution::firstCall_"]
        [::std::mem::offset_of!(cv_superres_SuperResolution, firstCall_) - 40usize];
};
unsafe extern "C" {
    #[doc = " @brief Set input frame source for Super Resolution algorithm.\n\n@param frameSource Input frame source"]
    #[link_name = "\u{1}_ZN2cv8superres15SuperResolution8setInputERKNS_3PtrINS0_11FrameSourceEEE"]
    pub fn cv_superres_SuperResolution_setInput(
        this: *mut cv_superres_SuperResolution,
        frameSource: *const cv_Ptr,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8superres15SuperResolutionC2Ev"]
    pub fn cv_superres_SuperResolution_SuperResolution(this: *mut cv_superres_SuperResolution);
}
impl cv_superres_SuperResolution {
    #[inline]
    pub unsafe fn setInput(&mut self, frameSource: *const cv_Ptr) {
        cv_superres_SuperResolution_setInput(self, frameSource)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_superres_SuperResolution_SuperResolution(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[doc = " @brief Process next frame from input and return output result.\n\n@param frame Output result"]
    #[link_name = "\u{1}_ZThn8_N2cv8superres15SuperResolution9nextFrameERKNS_12_OutputArrayE"]
    pub fn cv_superres_SuperResolution_nextFrame(
        this: *mut ::std::os::raw::c_void,
        frame: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZThn8_N2cv8superres15SuperResolution5resetEv"]
    pub fn cv_superres_SuperResolution_reset(this: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " @brief Clear all inner buffers."]
    #[link_name = "\u{1}_ZN2cv8superres15SuperResolution14collectGarbageEv"]
    pub fn cv_superres_SuperResolution_collectGarbage(this: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " @brief Create Bilateral TV-L1 Super Resolution.\n\nThis class implements Super Resolution algorithm described in the papers @cite Farsiu03 and\n@cite Mitzel09 .\n\nHere are important members of the class that control the algorithm, which you can set after\nconstructing the class instance:\n\n-   **int scale** Scale factor.\n-   **int iterations** Iteration count.\n-   **double tau** Asymptotic value of steepest descent method.\n-   **double lambda** Weight parameter to balance data term and smoothness term.\n-   **double alpha** Parameter of spacial distribution in Bilateral-TV.\n-   **int btvKernelSize** Kernel size of Bilateral-TV filter.\n-   **int blurKernelSize** Gaussian blur kernel size.\n-   **double blurSigma** Gaussian blur sigma.\n-   **int temporalAreaRadius** Radius of the temporal search area.\n-   **Ptr\\<DenseOpticalFlowExt\\> opticalFlow** Dense optical flow algorithm."]
    #[link_name = "\u{1}_ZN2cv8superres27createSuperResolution_BTVL1Ev"]
    pub fn cv_superres_createSuperResolution_BTVL1() -> cv_Ptr;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv8superres32createSuperResolution_BTVL1_CUDAEv"]
    pub fn cv_superres_createSuperResolution_BTVL1_CUDA() -> cv_Ptr;
}
pub const OPTFLOW_USE_INITIAL_FLOW: cv__bindgen_ty_30 = 4;
pub const OPTFLOW_LK_GET_MIN_EIGENVALS: cv__bindgen_ty_30 = 8;
pub const OPTFLOW_FARNEBACK_GAUSSIAN: cv__bindgen_ty_30 = 256;
#[doc = "! @addtogroup video_track\n! @{"]
pub type cv__bindgen_ty_30 = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Finds an object center, size, and orientation.\n\n@param probImage Back projection of the object histogram. See calcBackProject.\n@param window Initial search window.\n@param criteria Stop criteria for the underlying meanShift.\nreturns\n(in old interfaces) Number of iterations CAMSHIFT took to converge\nThe function implements the CAMSHIFT object tracking algorithm @cite Bradski98 . First, it finds an\nobject center using meanShift and then adjusts the window size and finds the optimal rotation. The\nfunction returns the rotated rectangle structure that includes the object position, size, and\norientation. The next position of the search window can be obtained with RotatedRect::boundingRect()\n\nSee the OpenCV sample camshiftdemo.c that tracks colored objects.\n\n@note\n-   (Python) A sample explaining the camshift tracking algorithm can be found at\nopencv_source_code/samples/python/camshift.py"]
    #[link_name = "\u{1}_ZN2cv8CamShiftERKNS_11_InputArrayERNS_5Rect_IiEENS_12TermCriteriaE"]
    pub fn cv_CamShift(
        probImage: cv_InputArray,
        window: *mut cv_Rect,
        criteria: cv_TermCriteria,
    ) -> cv_RotatedRect;
}
unsafe extern "C" {
    #[doc = " @brief Finds an object on a back projection image.\n\n@param probImage Back projection of the object histogram. See calcBackProject for details.\n@param window Initial search window.\n@param criteria Stop criteria for the iterative search algorithm.\nreturns\n:   Number of iterations CAMSHIFT took to converge.\nThe function implements the iterative object search algorithm. It takes the input back projection of\nan object and the initial position. The mass center in window of the back projection image is\ncomputed and the search window center shifts to the mass center. The procedure is repeated until the\nspecified number of iterations criteria.maxCount is done or until the window center shifts by less\nthan criteria.epsilon. The algorithm is used inside CamShift and, unlike CamShift , the search\nwindow size or orientation do not change during the search. You can simply pass the output of\ncalcBackProject to this function. But better results can be obtained if you pre-filter the back\nprojection and remove the noise. For example, you can do this by retrieving connected components\nwith findContours , throwing away contours with small area ( contourArea ), and rendering the\nremaining contours with drawContours.\n"]
    #[link_name = "\u{1}_ZN2cv9meanShiftERKNS_11_InputArrayERNS_5Rect_IiEENS_12TermCriteriaE"]
    pub fn cv_meanShift(
        probImage: cv_InputArray,
        window: *mut cv_Rect,
        criteria: cv_TermCriteria,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.\n\n@param img 8-bit input image.\n@param pyramid output pyramid.\n@param winSize window size of optical flow algorithm. Must be not less than winSize argument of\ncalcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels.\n@param maxLevel 0-based maximal pyramid level number.\n@param withDerivatives set to precompute gradients for the every pyramid level. If pyramid is\nconstructed without the gradients then calcOpticalFlowPyrLK will calculate them internally.\n@param pyrBorder the border mode for pyramid layers.\n@param derivBorder the border mode for gradients.\n@param tryReuseInputImage put ROI of input image into the pyramid if possible. You can pass false\nto force data copying.\n@return number of levels in constructed pyramid. Can be less than maxLevel."]
    #[link_name = "\u{1}_ZN2cv23buildOpticalFlowPyramidERKNS_11_InputArrayERKNS_12_OutputArrayENS_5Size_IiEEibiib"]
    pub fn cv_buildOpticalFlowPyramid(
        img: cv_InputArray,
        pyramid: cv_OutputArrayOfArrays,
        winSize: cv_Size,
        maxLevel: ::std::os::raw::c_int,
        withDerivatives: bool,
        pyrBorder: ::std::os::raw::c_int,
        derivBorder: ::std::os::raw::c_int,
        tryReuseInputImage: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with\npyramids.\n\n@param prevImg first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid.\n@param nextImg second input image or pyramid of the same size and the same type as prevImg.\n@param prevPts vector of 2D points for which the flow needs to be found; point coordinates must be\nsingle-precision floating-point numbers.\n@param nextPts output vector of 2D points (with single-precision floating-point coordinates)\ncontaining the calculated new positions of input features in the second image; when\nOPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input.\n@param status output status vector (of unsigned chars); each element of the vector is set to 1 if\nthe flow for the corresponding features has been found, otherwise, it is set to 0.\n@param err output vector of errors; each element of the vector is set to an error for the\ncorresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't\nfound then the error is not defined (use the status parameter to find such cases).\n@param winSize size of the search window at each pyramid level.\n@param maxLevel 0-based maximal pyramid level number; if set to 0, pyramids are not used (single\nlevel), if set to 1, two levels are used, and so on; if pyramids are passed to input then\nalgorithm will use as many levels as pyramids have but no more than maxLevel.\n@param criteria parameter, specifying the termination criteria of the iterative search algorithm\n(after the specified maximum number of iterations criteria.maxCount or when the search window\nmoves by less than criteria.epsilon.\n@param flags operation flags:\n-   **OPTFLOW_USE_INITIAL_FLOW** uses initial estimations, stored in nextPts; if the flag is\nnot set, then prevPts is copied to nextPts and is considered the initial estimate.\n-   **OPTFLOW_LK_GET_MIN_EIGENVALS** use minimum eigen values as an error measure (see\nminEigThreshold description); if the flag is not set, then L1 distance between patches\naround the original and a moved point, divided by number of pixels in a window, is used as a\nerror measure.\n@param minEigThreshold the algorithm calculates the minimum eigen value of a 2x2 normal matrix of\noptical flow equations (this matrix is called a spatial gradient matrix in @cite Bouguet00), divided\nby number of pixels in a window; if this value is less than minEigThreshold, then a corresponding\nfeature is filtered out and its flow is not processed, so it allows to remove bad points and get a\nperformance boost.\n\nThe function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See\n@cite Bouguet00 . The function is parallelized with the TBB library.\n\n@note\n\n-   An example using the Lucas-Kanade optical flow algorithm can be found at\nopencv_source_code/samples/cpp/lkdemo.cpp\n-   (Python) An example using the Lucas-Kanade optical flow algorithm can be found at\nopencv_source_code/samples/python/lk_track.py\n-   (Python) An example using the Lucas-Kanade tracker for homography matching can be found at\nopencv_source_code/samples/python/lk_homography.py"]
    #[link_name = "\u{1}_ZN2cv20calcOpticalFlowPyrLKERKNS_11_InputArrayES2_S2_RKNS_17_InputOutputArrayERKNS_12_OutputArrayES8_NS_5Size_IiEEiNS_12TermCriteriaEid"]
    pub fn cv_calcOpticalFlowPyrLK(
        prevImg: cv_InputArray,
        nextImg: cv_InputArray,
        prevPts: cv_InputArray,
        nextPts: cv_InputOutputArray,
        status: cv_OutputArray,
        err: cv_OutputArray,
        winSize: cv_Size,
        maxLevel: ::std::os::raw::c_int,
        criteria: cv_TermCriteria,
        flags: ::std::os::raw::c_int,
        minEigThreshold: f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Computes a dense optical flow using the Gunnar Farneback's algorithm.\n\n@param prev first 8-bit single-channel input image.\n@param next second input image of the same size and the same type as prev.\n@param flow computed flow image that has the same size as prev and type CV_32FC2.\n@param pyr_scale parameter, specifying the image scale (\\<1) to build pyramids for each image;\npyr_scale=0.5 means a classical pyramid, where each next layer is twice smaller than the previous\none.\n@param levels number of pyramid layers including the initial image; levels=1 means that no extra\nlayers are created and only the original images are used.\n@param winsize averaging window size; larger values increase the algorithm robustness to image\nnoise and give more chances for fast motion detection, but yield more blurred motion field.\n@param iterations number of iterations the algorithm does at each pyramid level.\n@param poly_n size of the pixel neighborhood used to find polynomial expansion in each pixel;\nlarger values mean that the image will be approximated with smoother surfaces, yielding more\nrobust algorithm and more blurred motion field, typically poly_n =5 or 7.\n@param poly_sigma standard deviation of the Gaussian that is used to smooth derivatives used as a\nbasis for the polynomial expansion; for poly_n=5, you can set poly_sigma=1.1, for poly_n=7, a\ngood value would be poly_sigma=1.5.\n@param flags operation flags that can be a combination of the following:\n-   **OPTFLOW_USE_INITIAL_FLOW** uses the input flow as an initial flow approximation.\n-   **OPTFLOW_FARNEBACK_GAUSSIAN** uses the Gaussian \\f$\\texttt{winsize}\\times\\texttt{winsize}\\f$\nfilter instead of a box filter of the same size for optical flow estimation; usually, this\noption gives z more accurate flow than with a box filter, at the cost of lower speed;\nnormally, winsize for a Gaussian window should be set to a larger value to achieve the same\nlevel of robustness.\n\nThe function finds an optical flow for each prev pixel using the @cite Farneback2003 algorithm so that\n\n\\f[\\texttt{prev} (y,x)  \\sim \\texttt{next} ( y + \\texttt{flow} (y,x)[1],  x + \\texttt{flow} (y,x)[0])\\f]\n\n@note\n\n-   An example using the optical flow algorithm described by Gunnar Farneback can be found at\nopencv_source_code/samples/cpp/fback.cpp\n-   (Python) An example using the optical flow algorithm described by Gunnar Farneback can be\nfound at opencv_source_code/samples/python/opt_flow.py"]
    #[link_name = "\u{1}_ZN2cv24calcOpticalFlowFarnebackERKNS_11_InputArrayES2_RKNS_17_InputOutputArrayEdiiiidi"]
    pub fn cv_calcOpticalFlowFarneback(
        prev: cv_InputArray,
        next: cv_InputArray,
        flow: cv_InputOutputArray,
        pyr_scale: f64,
        levels: ::std::os::raw::c_int,
        winsize: ::std::os::raw::c_int,
        iterations: ::std::os::raw::c_int,
        poly_n: ::std::os::raw::c_int,
        poly_sigma: f64,
        flags: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Computes an optimal affine transformation between two 2D point sets.\n\n@param src First input 2D point set stored in std::vector or Mat, or an image stored in Mat.\n@param dst Second input 2D point set of the same size and the same type as A, or another image.\n@param fullAffine If true, the function finds an optimal affine transformation with no additional\nrestrictions (6 degrees of freedom). Otherwise, the class of transformations to choose from is\nlimited to combinations of translation, rotation, and uniform scaling (4 degrees of freedom).\n\nThe function finds an optimal affine transform *[A|b]* (a 2 x 3 floating-point matrix) that\napproximates best the affine transformation between:\n\n   Two point sets\n   Two raster images. In this case, the function first finds some features in the src image and\nfinds the corresponding features in dst image. After that, the problem is reduced to the first\ncase.\nIn case of point sets, the problem is formulated as follows: you need to find a 2x2 matrix *A* and\n2x1 vector *b* so that:\n\n\\f[[A^*|b^*] = arg  \\min _{[A|b]}  \\sum _i  \\| \\texttt{dst}[i] - A { \\texttt{src}[i]}^T - b  \\| ^2\\f]\nwhere src[i] and dst[i] are the i-th points in src and dst, respectively\n\\f$[A|b]\\f$ can be either arbitrary (when fullAffine=true ) or have a form of\n\\f[\\begin{bmatrix} a_{11} & a_{12} & b_1  \\\\ -a_{12} & a_{11} & b_2  \\end{bmatrix}\\f]\nwhen fullAffine=false.\n\n@deprecated Use cv::estimateAffine2D, cv::estimateAffinePartial2D instead. If you are using this function\nwith images, extract points using cv::calcOpticalFlowPyrLK and then use the estimation functions.\n\n@sa\nestimateAffine2D, estimateAffinePartial2D, getAffineTransform, getPerspectiveTransform, findHomography"]
    #[link_name = "\u{1}_ZN2cv22estimateRigidTransformERKNS_11_InputArrayES2_b"]
    pub fn cv_estimateRigidTransform(
        src: cv_InputArray,
        dst: cv_InputArray,
        fullAffine: bool,
    ) -> cv_Mat;
}
pub const MOTION_TRANSLATION: cv__bindgen_ty_31 = 0;
pub const MOTION_EUCLIDEAN: cv__bindgen_ty_31 = 1;
pub const MOTION_AFFINE: cv__bindgen_ty_31 = 2;
pub const MOTION_HOMOGRAPHY: cv__bindgen_ty_31 = 3;
pub type cv__bindgen_ty_31 = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Computes the Enhanced Correlation Coefficient value between two images @cite EP08 .\n\n@param templateImage single-channel template image; CV_8U or CV_32F array.\n@param inputImage single-channel input image to be warped to provide an image similar to\ntemplateImage, same type as templateImage.\n@param inputMask An optional mask to indicate valid values of inputImage.\n\n@sa\nfindTransformECC"]
    #[link_name = "\u{1}_ZN2cv10computeECCERKNS_11_InputArrayES2_S2_"]
    pub fn cv_computeECC(
        templateImage: cv_InputArray,
        inputImage: cv_InputArray,
        inputMask: cv_InputArray,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Finds the geometric transform (warp) between two images in terms of the ECC criterion @cite EP08 .\n\n@param templateImage single-channel template image; CV_8U or CV_32F array.\n@param inputImage single-channel input image which should be warped with the final warpMatrix in\norder to provide an image similar to templateImage, same type as templateImage.\n@param warpMatrix floating-point \\f$2\\times 3\\f$ or \\f$3\\times 3\\f$ mapping matrix (warp).\n@param motionType parameter, specifying the type of motion:\n-   **MOTION_TRANSLATION** sets a translational motion model; warpMatrix is \\f$2\\times 3\\f$ with\nthe first \\f$2\\times 2\\f$ part being the unity matrix and the rest two parameters being\nestimated.\n-   **MOTION_EUCLIDEAN** sets a Euclidean (rigid) transformation as motion model; three\nparameters are estimated; warpMatrix is \\f$2\\times 3\\f$.\n-   **MOTION_AFFINE** sets an affine motion model (DEFAULT); six parameters are estimated;\nwarpMatrix is \\f$2\\times 3\\f$.\n-   **MOTION_HOMOGRAPHY** sets a homography as a motion model; eight parameters are\nestimated;\\`warpMatrix\\` is \\f$3\\times 3\\f$.\n@param criteria parameter, specifying the termination criteria of the ECC algorithm;\ncriteria.epsilon defines the threshold of the increment in the correlation coefficient between two\niterations (a negative criteria.epsilon makes criteria.maxcount the only termination criterion).\nDefault values are shown in the declaration above.\n@param inputMask An optional mask to indicate valid values of inputImage.\n@param gaussFiltSize An optional value indicating size of gaussian blur filter; (DEFAULT: 5)\n\nThe function estimates the optimum transformation (warpMatrix) with respect to ECC criterion\n(@cite EP08), that is\n\n\\f[\\texttt{warpMatrix} = \\texttt{warpMatrix} = \\arg\\max_{W} \\texttt{ECC}(\\texttt{templateImage}(x,y),\\texttt{inputImage}(x',y'))\\f]\n\nwhere\n\n\\f[\\begin{bmatrix} x' \\\\ y' \\end{bmatrix} = W \\cdot \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}\\f]\n\n(the equation holds with homogeneous coordinates for homography). It returns the final enhanced\ncorrelation coefficient, that is the correlation coefficient between the template image and the\nfinal warped input image. When a \\f$3\\times 3\\f$ matrix is given with motionType =0, 1 or 2, the third\nrow is ignored.\n\nUnlike findHomography and estimateRigidTransform, the function findTransformECC implements an\narea-based alignment that builds on intensity similarities. In essence, the function updates the\ninitial transformation that roughly aligns the images. If this information is missing, the identity\nwarp (unity matrix) is used as an initialization. Note that if images undergo strong\ndisplacements/rotations, an initial transformation that roughly aligns the images is necessary\n(e.g., a simple euclidean/similarity transform that allows for the images showing the same image\ncontent approximately). Use inverse warping in the second image to take an image close to the first\none, i.e. use the flag WARP_INVERSE_MAP with warpAffine or warpPerspective. See also the OpenCV\nsample image_alignment.cpp that demonstrates the use of the function. Note that the function throws\nan exception if algorithm does not converges.\n\n@sa\ncomputeECC, estimateAffine2D, estimateAffinePartial2D, findHomography"]
    #[link_name = "\u{1}_ZN2cv16findTransformECCERKNS_11_InputArrayES2_RKNS_17_InputOutputArrayEiNS_12TermCriteriaES2_i"]
    pub fn cv_findTransformECC(
        templateImage: cv_InputArray,
        inputImage: cv_InputArray,
        warpMatrix: cv_InputOutputArray,
        motionType: ::std::os::raw::c_int,
        criteria: cv_TermCriteria,
        inputMask: cv_InputArray,
        gaussFiltSize: ::std::os::raw::c_int,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " @overload"]
    #[link_name = "\u{1}_ZN2cv16findTransformECCERKNS_11_InputArrayES2_RKNS_17_InputOutputArrayEiNS_12TermCriteriaES2_"]
    pub fn cv_findTransformECC1(
        templateImage: cv_InputArray,
        inputImage: cv_InputArray,
        warpMatrix: cv_InputOutputArray,
        motionType: ::std::os::raw::c_int,
        criteria: cv_TermCriteria,
        inputMask: cv_InputArray,
    ) -> f64;
}
#[doc = " @brief Kalman filter class.\n\nThe class implements a standard Kalman filter <http://en.wikipedia.org/wiki/Kalman_filter>,\n@cite Welch95 . However, you can modify transitionMatrix, controlMatrix, and measurementMatrix to get\nan extended Kalman filter functionality.\n@note In C API when CvKalman\\* kalmanFilter structure is not needed anymore, it should be released\nwith cvReleaseKalman(&kalmanFilter)"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_KalmanFilter {
    #[doc = "!< predicted state (x'(k)): x(k)=A*x(k-1)+B*u(k)"]
    pub statePre: cv_Mat,
    #[doc = "!< corrected state (x(k)): x(k)=x'(k)+K(k)*(z(k)-H*x'(k))"]
    pub statePost: cv_Mat,
    #[doc = "!< state transition matrix (A)"]
    pub transitionMatrix: cv_Mat,
    #[doc = "!< control matrix (B) (not used if there is no control)"]
    pub controlMatrix: cv_Mat,
    #[doc = "!< measurement matrix (H)"]
    pub measurementMatrix: cv_Mat,
    #[doc = "!< process noise covariance matrix (Q)"]
    pub processNoiseCov: cv_Mat,
    #[doc = "!< measurement noise covariance matrix (R)"]
    pub measurementNoiseCov: cv_Mat,
    #[doc = "!< priori error estimate covariance matrix (P'(k)): P'(k)=A*P(k-1)*At + Q)*/"]
    pub errorCovPre: cv_Mat,
    #[doc = "!< Kalman gain matrix (K(k)): K(k)=P'(k)*Ht*inv(H*P'(k)*Ht+R)"]
    pub gain: cv_Mat,
    #[doc = "!< posteriori error estimate covariance matrix (P(k)): P(k)=(I-K(k)*H)*P'(k)"]
    pub errorCovPost: cv_Mat,
    pub temp1: cv_Mat,
    pub temp2: cv_Mat,
    pub temp3: cv_Mat,
    pub temp4: cv_Mat,
    pub temp5: cv_Mat,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_KalmanFilter"][::std::mem::size_of::<cv_KalmanFilter>() - 1440usize];
    ["Alignment of cv_KalmanFilter"][::std::mem::align_of::<cv_KalmanFilter>() - 8usize];
    ["Offset of field: cv_KalmanFilter::statePre"]
        [::std::mem::offset_of!(cv_KalmanFilter, statePre) - 0usize];
    ["Offset of field: cv_KalmanFilter::statePost"]
        [::std::mem::offset_of!(cv_KalmanFilter, statePost) - 96usize];
    ["Offset of field: cv_KalmanFilter::transitionMatrix"]
        [::std::mem::offset_of!(cv_KalmanFilter, transitionMatrix) - 192usize];
    ["Offset of field: cv_KalmanFilter::controlMatrix"]
        [::std::mem::offset_of!(cv_KalmanFilter, controlMatrix) - 288usize];
    ["Offset of field: cv_KalmanFilter::measurementMatrix"]
        [::std::mem::offset_of!(cv_KalmanFilter, measurementMatrix) - 384usize];
    ["Offset of field: cv_KalmanFilter::processNoiseCov"]
        [::std::mem::offset_of!(cv_KalmanFilter, processNoiseCov) - 480usize];
    ["Offset of field: cv_KalmanFilter::measurementNoiseCov"]
        [::std::mem::offset_of!(cv_KalmanFilter, measurementNoiseCov) - 576usize];
    ["Offset of field: cv_KalmanFilter::errorCovPre"]
        [::std::mem::offset_of!(cv_KalmanFilter, errorCovPre) - 672usize];
    ["Offset of field: cv_KalmanFilter::gain"]
        [::std::mem::offset_of!(cv_KalmanFilter, gain) - 768usize];
    ["Offset of field: cv_KalmanFilter::errorCovPost"]
        [::std::mem::offset_of!(cv_KalmanFilter, errorCovPost) - 864usize];
    ["Offset of field: cv_KalmanFilter::temp1"]
        [::std::mem::offset_of!(cv_KalmanFilter, temp1) - 960usize];
    ["Offset of field: cv_KalmanFilter::temp2"]
        [::std::mem::offset_of!(cv_KalmanFilter, temp2) - 1056usize];
    ["Offset of field: cv_KalmanFilter::temp3"]
        [::std::mem::offset_of!(cv_KalmanFilter, temp3) - 1152usize];
    ["Offset of field: cv_KalmanFilter::temp4"]
        [::std::mem::offset_of!(cv_KalmanFilter, temp4) - 1248usize];
    ["Offset of field: cv_KalmanFilter::temp5"]
        [::std::mem::offset_of!(cv_KalmanFilter, temp5) - 1344usize];
};
unsafe extern "C" {
    #[doc = " @brief Re-initializes Kalman filter. The previous content is destroyed.\n\n@param dynamParams Dimensionality of the state.\n@param measureParams Dimensionality of the measurement.\n@param controlParams Dimensionality of the control vector.\n@param type Type of the created matrices that should be CV_32F or CV_64F."]
    #[link_name = "\u{1}_ZN2cv12KalmanFilter4initEiiii"]
    pub fn cv_KalmanFilter_init(
        this: *mut cv_KalmanFilter,
        dynamParams: ::std::os::raw::c_int,
        measureParams: ::std::os::raw::c_int,
        controlParams: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Computes a predicted state.\n\n@param control The optional input control"]
    #[link_name = "\u{1}_ZN2cv12KalmanFilter7predictERKNS_3MatE"]
    pub fn cv_KalmanFilter_predict(
        this: *mut cv_KalmanFilter,
        control: *const cv_Mat,
    ) -> *const cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Updates the predicted state from the measurement.\n\n@param measurement The measured system parameters"]
    #[link_name = "\u{1}_ZN2cv12KalmanFilter7correctERKNS_3MatE"]
    pub fn cv_KalmanFilter_correct(
        this: *mut cv_KalmanFilter,
        measurement: *const cv_Mat,
    ) -> *const cv_Mat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv12KalmanFilterC1Ev"]
    pub fn cv_KalmanFilter_KalmanFilter(this: *mut cv_KalmanFilter);
}
unsafe extern "C" {
    #[doc = " @overload\n@param dynamParams Dimensionality of the state.\n@param measureParams Dimensionality of the measurement.\n@param controlParams Dimensionality of the control vector.\n@param type Type of the created matrices that should be CV_32F or CV_64F."]
    #[link_name = "\u{1}_ZN2cv12KalmanFilterC1Eiiii"]
    pub fn cv_KalmanFilter_KalmanFilter1(
        this: *mut cv_KalmanFilter,
        dynamParams: ::std::os::raw::c_int,
        measureParams: ::std::os::raw::c_int,
        controlParams: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    );
}
impl cv_KalmanFilter {
    #[inline]
    pub unsafe fn init(
        &mut self,
        dynamParams: ::std::os::raw::c_int,
        measureParams: ::std::os::raw::c_int,
        controlParams: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) {
        cv_KalmanFilter_init(self, dynamParams, measureParams, controlParams, type_)
    }
    #[inline]
    pub unsafe fn predict(&mut self, control: *const cv_Mat) -> *const cv_Mat {
        cv_KalmanFilter_predict(self, control)
    }
    #[inline]
    pub unsafe fn correct(&mut self, measurement: *const cv_Mat) -> *const cv_Mat {
        cv_KalmanFilter_correct(self, measurement)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_KalmanFilter_KalmanFilter(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        dynamParams: ::std::os::raw::c_int,
        measureParams: ::std::os::raw::c_int,
        controlParams: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_KalmanFilter_KalmanFilter1(
            __bindgen_tmp.as_mut_ptr(),
            dynamParams,
            measureParams,
            controlParams,
            type_,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[doc = " @brief Read a .flo file\n\n@param path Path to the file to be loaded\n\nThe function readOpticalFlow loads a flow field from a file and returns it as a single matrix.\nResulting Mat has a type CV_32FC2 - floating-point, 2-channel. First channel corresponds to the\nflow in the horizontal direction (u), second - vertical (v)."]
    #[link_name = "\u{1}_ZN2cv15readOpticalFlowERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_readOpticalFlow(path: *const cv_String) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Write a .flo to disk\n\n@param path Path to the file to be written\n@param flow Flow field to be stored\n\nThe function stores a flow field in a file, returns true on success, false otherwise.\nThe flow field must be a 2-channel, floating-point matrix (CV_32FC2). First channel corresponds\nto the flow in the horizontal direction (u), second - vertical (v)."]
    #[link_name = "\u{1}_ZN2cv16writeOpticalFlowERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_11_InputArrayE"]
    pub fn cv_writeOpticalFlow(path: *const cv_String, flow: cv_InputArray) -> bool;
}
#[doc = "Base class for dense optical flow algorithms"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_DenseOpticalFlow {
    pub _base: cv_Algorithm,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_DenseOpticalFlow"][::std::mem::size_of::<cv_DenseOpticalFlow>() - 8usize];
    ["Alignment of cv_DenseOpticalFlow"][::std::mem::align_of::<cv_DenseOpticalFlow>() - 8usize];
};
#[doc = " @brief Base interface for sparse optical flow algorithms."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_SparseOpticalFlow {
    pub _base: cv_Algorithm,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_SparseOpticalFlow"][::std::mem::size_of::<cv_SparseOpticalFlow>() - 8usize];
    ["Alignment of cv_SparseOpticalFlow"][::std::mem::align_of::<cv_SparseOpticalFlow>() - 8usize];
};
#[doc = " @brief Class computing a dense optical flow using the Gunnar Farneback's algorithm."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_FarnebackOpticalFlow {
    pub _base: cv_DenseOpticalFlow,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_FarnebackOpticalFlow"][::std::mem::size_of::<cv_FarnebackOpticalFlow>() - 8usize];
    ["Alignment of cv_FarnebackOpticalFlow"]
        [::std::mem::align_of::<cv_FarnebackOpticalFlow>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv20FarnebackOpticalFlow6createEidbiiidi"]
    pub fn cv_FarnebackOpticalFlow_create(
        numLevels: ::std::os::raw::c_int,
        pyrScale: f64,
        fastPyramids: bool,
        winSize: ::std::os::raw::c_int,
        numIters: ::std::os::raw::c_int,
        polyN: ::std::os::raw::c_int,
        polySigma: f64,
        flags: ::std::os::raw::c_int,
    ) -> cv_Ptr;
}
impl cv_FarnebackOpticalFlow {
    #[inline]
    pub unsafe fn create(
        numLevels: ::std::os::raw::c_int,
        pyrScale: f64,
        fastPyramids: bool,
        winSize: ::std::os::raw::c_int,
        numIters: ::std::os::raw::c_int,
        polyN: ::std::os::raw::c_int,
        polySigma: f64,
        flags: ::std::os::raw::c_int,
    ) -> cv_Ptr {
        cv_FarnebackOpticalFlow_create(
            numLevels,
            pyrScale,
            fastPyramids,
            winSize,
            numIters,
            polyN,
            polySigma,
            flags,
        )
    }
}
#[doc = " @brief Variational optical flow refinement\n\nThis class implements variational refinement of the input flow field, i.e.\nit uses input flow to initialize the minimization of the following functional:\n\\f$E(U) = \\int_{\\Omega} \\delta \\Psi(E_I) + \\gamma \\Psi(E_G) + \\alpha \\Psi(E_S) \\f$,\nwhere \\f$E_I,E_G,E_S\\f$ are color constancy, gradient constancy and smoothness terms\nrespectively. \\f$\\Psi(s^2)=\\sqrt{s^2+\\epsilon^2}\\f$ is a robust penalizer to limit the\ninfluence of outliers. A complete formulation and a description of the minimization\nprocedure can be found in @cite Brox2004"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_VariationalRefinement {
    pub _base: cv_DenseOpticalFlow,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_VariationalRefinement"]
        [::std::mem::size_of::<cv_VariationalRefinement>() - 8usize];
    ["Alignment of cv_VariationalRefinement"]
        [::std::mem::align_of::<cv_VariationalRefinement>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates an instance of VariationalRefinement"]
    #[link_name = "\u{1}_ZN2cv21VariationalRefinement6createEv"]
    pub fn cv_VariationalRefinement_create() -> cv_Ptr;
}
impl cv_VariationalRefinement {
    #[inline]
    pub unsafe fn create() -> cv_Ptr {
        cv_VariationalRefinement_create()
    }
}
#[doc = " @brief DIS optical flow algorithm.\n\nThis class implements the Dense Inverse Search (DIS) optical flow algorithm. More\ndetails about the algorithm can be found at @cite Kroeger2016 . Includes three presets with preselected\nparameters to provide reasonable trade-off between speed and quality. However, even the slowest preset is\nstill relatively fast, use DeepFlow if you need better quality and don't care about speed.\n\nThis implementation includes several additional features compared to the algorithm described in the paper,\nincluding spatial propagation of flow vectors (@ref getUseSpatialPropagation), as well as an option to\nutilize an initial flow approximation passed to @ref calc (which is, essentially, temporal propagation,\nif the previous frame's flow field is passed)."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_DISOpticalFlow {
    pub _base: cv_DenseOpticalFlow,
}
pub const cv_DISOpticalFlow_PRESET_ULTRAFAST: cv_DISOpticalFlow__bindgen_ty_1 = 0;
pub const cv_DISOpticalFlow_PRESET_FAST: cv_DISOpticalFlow__bindgen_ty_1 = 1;
pub const cv_DISOpticalFlow_PRESET_MEDIUM: cv_DISOpticalFlow__bindgen_ty_1 = 2;
pub type cv_DISOpticalFlow__bindgen_ty_1 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_DISOpticalFlow"][::std::mem::size_of::<cv_DISOpticalFlow>() - 8usize];
    ["Alignment of cv_DISOpticalFlow"][::std::mem::align_of::<cv_DISOpticalFlow>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates an instance of DISOpticalFlow\n\n@param preset one of PRESET_ULTRAFAST, PRESET_FAST and PRESET_MEDIUM"]
    #[link_name = "\u{1}_ZN2cv14DISOpticalFlow6createEi"]
    pub fn cv_DISOpticalFlow_create(preset: ::std::os::raw::c_int) -> cv_Ptr;
}
impl cv_DISOpticalFlow {
    #[inline]
    pub unsafe fn create(preset: ::std::os::raw::c_int) -> cv_Ptr {
        cv_DISOpticalFlow_create(preset)
    }
}
#[doc = " @brief Class used for calculating a sparse optical flow.\n\nThe class can calculate an optical flow for a sparse feature set using the\niterative Lucas-Kanade method with pyramids.\n\n@sa calcOpticalFlowPyrLK"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_SparsePyrLKOpticalFlow {
    pub _base: cv_SparseOpticalFlow,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_SparsePyrLKOpticalFlow"]
        [::std::mem::size_of::<cv_SparsePyrLKOpticalFlow>() - 8usize];
    ["Alignment of cv_SparsePyrLKOpticalFlow"]
        [::std::mem::align_of::<cv_SparsePyrLKOpticalFlow>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv22SparsePyrLKOpticalFlow6createENS_5Size_IiEEiNS_12TermCriteriaEid"]
    pub fn cv_SparsePyrLKOpticalFlow_create(
        winSize: cv_Size,
        maxLevel: ::std::os::raw::c_int,
        crit: cv_TermCriteria,
        flags: ::std::os::raw::c_int,
        minEigThreshold: f64,
    ) -> cv_Ptr;
}
impl cv_SparsePyrLKOpticalFlow {
    #[inline]
    pub unsafe fn create(
        winSize: cv_Size,
        maxLevel: ::std::os::raw::c_int,
        crit: cv_TermCriteria,
        flags: ::std::os::raw::c_int,
        minEigThreshold: f64,
    ) -> cv_Ptr {
        cv_SparsePyrLKOpticalFlow_create(winSize, maxLevel, crit, flags, minEigThreshold)
    }
}
#[doc = " @brief Base class for background/foreground segmentation. :\n\nThe class is only used to define the common interface for the whole family of background/foreground\nsegmentation algorithms."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_BackgroundSubtractor {
    pub _base: cv_Algorithm,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_BackgroundSubtractor"][::std::mem::size_of::<cv_BackgroundSubtractor>() - 8usize];
    ["Alignment of cv_BackgroundSubtractor"]
        [::std::mem::align_of::<cv_BackgroundSubtractor>() - 8usize];
};
#[doc = " @brief Gaussian Mixture-based Background/Foreground Segmentation Algorithm.\n\nThe class implements the Gaussian mixture model background subtraction described in @cite Zivkovic2004\nand @cite Zivkovic2006 ."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_BackgroundSubtractorMOG2 {
    pub _base: cv_BackgroundSubtractor,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_BackgroundSubtractorMOG2"]
        [::std::mem::size_of::<cv_BackgroundSubtractorMOG2>() - 8usize];
    ["Alignment of cv_BackgroundSubtractorMOG2"]
        [::std::mem::align_of::<cv_BackgroundSubtractorMOG2>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates MOG2 Background Subtractor\n\n@param history Length of the history.\n@param varThreshold Threshold on the squared Mahalanobis distance between the pixel and the model\nto decide whether a pixel is well described by the background model. This parameter does not\naffect the background update.\n@param detectShadows If true, the algorithm will detect shadows and mark them. It decreases the\nspeed a bit, so if you do not need this feature, set the parameter to false."]
    #[link_name = "\u{1}_ZN2cv30createBackgroundSubtractorMOG2Eidb"]
    pub fn cv_createBackgroundSubtractorMOG2(
        history: ::std::os::raw::c_int,
        varThreshold: f64,
        detectShadows: bool,
    ) -> cv_Ptr;
}
#[doc = " @brief K-nearest neighbours - based Background/Foreground Segmentation Algorithm.\n\nThe class implements the K-nearest neighbours background subtraction described in @cite Zivkovic2006 .\nVery efficient if number of foreground pixels is low."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_BackgroundSubtractorKNN {
    pub _base: cv_BackgroundSubtractor,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_BackgroundSubtractorKNN"]
        [::std::mem::size_of::<cv_BackgroundSubtractorKNN>() - 8usize];
    ["Alignment of cv_BackgroundSubtractorKNN"]
        [::std::mem::align_of::<cv_BackgroundSubtractorKNN>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates KNN Background Subtractor\n\n@param history Length of the history.\n@param dist2Threshold Threshold on the squared distance between the pixel and the sample to decide\nwhether a pixel is close to that sample. This parameter does not affect the background update.\n@param detectShadows If true, the algorithm will detect shadows and mark them. It decreases the\nspeed a bit, so if you do not need this feature, set the parameter to false."]
    #[link_name = "\u{1}_ZN2cv29createBackgroundSubtractorKNNEidb"]
    pub fn cv_createBackgroundSubtractorKNN(
        history: ::std::os::raw::c_int,
        dist2Threshold: f64,
        detectShadows: bool,
    ) -> cv_Ptr;
}
#[repr(C)]
pub struct cv_videostab_ISparseOptFlowEstimator__bindgen_vtable(::std::os::raw::c_void);
#[doc = "! @addtogroup videostab\n! @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_ISparseOptFlowEstimator {
    pub vtable_: *const cv_videostab_ISparseOptFlowEstimator__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_ISparseOptFlowEstimator"]
        [::std::mem::size_of::<cv_videostab_ISparseOptFlowEstimator>() - 8usize];
    ["Alignment of cv_videostab_ISparseOptFlowEstimator"]
        [::std::mem::align_of::<cv_videostab_ISparseOptFlowEstimator>() - 8usize];
};
#[repr(C)]
pub struct cv_videostab_IDenseOptFlowEstimator__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_IDenseOptFlowEstimator {
    pub vtable_: *const cv_videostab_IDenseOptFlowEstimator__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_IDenseOptFlowEstimator"]
        [::std::mem::size_of::<cv_videostab_IDenseOptFlowEstimator>() - 8usize];
    ["Alignment of cv_videostab_IDenseOptFlowEstimator"]
        [::std::mem::align_of::<cv_videostab_IDenseOptFlowEstimator>() - 8usize];
};
#[repr(C)]
pub struct cv_videostab_PyrLkOptFlowEstimatorBase__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_PyrLkOptFlowEstimatorBase {
    pub vtable_: *const cv_videostab_PyrLkOptFlowEstimatorBase__bindgen_vtable,
    pub winSize_: cv_Size,
    pub maxLevel_: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_PyrLkOptFlowEstimatorBase"]
        [::std::mem::size_of::<cv_videostab_PyrLkOptFlowEstimatorBase>() - 24usize];
    ["Alignment of cv_videostab_PyrLkOptFlowEstimatorBase"]
        [::std::mem::align_of::<cv_videostab_PyrLkOptFlowEstimatorBase>() - 8usize];
    ["Offset of field: cv_videostab_PyrLkOptFlowEstimatorBase::winSize_"]
        [::std::mem::offset_of!(cv_videostab_PyrLkOptFlowEstimatorBase, winSize_) - 8usize];
    ["Offset of field: cv_videostab_PyrLkOptFlowEstimatorBase::maxLevel_"]
        [::std::mem::offset_of!(cv_videostab_PyrLkOptFlowEstimatorBase, maxLevel_) - 16usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_SparsePyrLkOptFlowEstimator {
    pub _base: cv_videostab_PyrLkOptFlowEstimatorBase,
    pub _base_1: cv_videostab_ISparseOptFlowEstimator,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_SparsePyrLkOptFlowEstimator"]
        [::std::mem::size_of::<cv_videostab_SparsePyrLkOptFlowEstimator>() - 32usize];
    ["Alignment of cv_videostab_SparsePyrLkOptFlowEstimator"]
        [::std::mem::align_of::<cv_videostab_SparsePyrLkOptFlowEstimator>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZThn24_N2cv9videostab27SparsePyrLkOptFlowEstimator3runERKNS_11_InputArrayES4_S4_RKNS_17_InputOutputArrayERKNS_12_OutputArrayESA_"]
    pub fn cv_videostab_SparsePyrLkOptFlowEstimator_run(
        this: *mut ::std::os::raw::c_void,
        frame0: cv_InputArray,
        frame1: cv_InputArray,
        points0: cv_InputArray,
        points1: cv_InputOutputArray,
        status: cv_OutputArray,
        errors: cv_OutputArray,
    );
}
pub const cv_videostab_MotionModel_MM_TRANSLATION: cv_videostab_MotionModel = 0;
pub const cv_videostab_MotionModel_MM_TRANSLATION_AND_SCALE: cv_videostab_MotionModel = 1;
pub const cv_videostab_MotionModel_MM_ROTATION: cv_videostab_MotionModel = 2;
pub const cv_videostab_MotionModel_MM_RIGID: cv_videostab_MotionModel = 3;
pub const cv_videostab_MotionModel_MM_SIMILARITY: cv_videostab_MotionModel = 4;
pub const cv_videostab_MotionModel_MM_AFFINE: cv_videostab_MotionModel = 5;
pub const cv_videostab_MotionModel_MM_HOMOGRAPHY: cv_videostab_MotionModel = 6;
pub const cv_videostab_MotionModel_MM_UNKNOWN: cv_videostab_MotionModel = 7;
#[doc = " @brief Describes motion model between two point clouds."]
pub type cv_videostab_MotionModel = ::std::os::raw::c_uint;
#[doc = " @brief Describes RANSAC method parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_videostab_RansacParams {
    #[doc = "!< subset size"]
    pub size: ::std::os::raw::c_int,
    #[doc = "!< max error to classify as inlier"]
    pub thresh: f32,
    #[doc = "!< max outliers ratio"]
    pub eps: f32,
    #[doc = "!< probability of success"]
    pub prob: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_RansacParams"]
        [::std::mem::size_of::<cv_videostab_RansacParams>() - 16usize];
    ["Alignment of cv_videostab_RansacParams"]
        [::std::mem::align_of::<cv_videostab_RansacParams>() - 4usize];
    ["Offset of field: cv_videostab_RansacParams::size"]
        [::std::mem::offset_of!(cv_videostab_RansacParams, size) - 0usize];
    ["Offset of field: cv_videostab_RansacParams::thresh"]
        [::std::mem::offset_of!(cv_videostab_RansacParams, thresh) - 4usize];
    ["Offset of field: cv_videostab_RansacParams::eps"]
        [::std::mem::offset_of!(cv_videostab_RansacParams, eps) - 8usize];
    ["Offset of field: cv_videostab_RansacParams::prob"]
        [::std::mem::offset_of!(cv_videostab_RansacParams, prob) - 12usize];
};
#[repr(C)]
pub struct cv_videostab_IOutlierRejector__bindgen_vtable(::std::os::raw::c_void);
#[doc = "! @addtogroup videostab\n! @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_IOutlierRejector {
    pub vtable_: *const cv_videostab_IOutlierRejector__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_IOutlierRejector"]
        [::std::mem::size_of::<cv_videostab_IOutlierRejector>() - 8usize];
    ["Alignment of cv_videostab_IOutlierRejector"]
        [::std::mem::align_of::<cv_videostab_IOutlierRejector>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_NullOutlierRejector {
    pub _base: cv_videostab_IOutlierRejector,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_NullOutlierRejector"]
        [::std::mem::size_of::<cv_videostab_NullOutlierRejector>() - 8usize];
    ["Alignment of cv_videostab_NullOutlierRejector"]
        [::std::mem::align_of::<cv_videostab_NullOutlierRejector>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab19NullOutlierRejector7processENS_5Size_IiEERKNS_11_InputArrayES6_RKNS_12_OutputArrayE"]
    pub fn cv_videostab_NullOutlierRejector_process(
        this: *mut ::std::os::raw::c_void,
        frameSize: cv_Size,
        points0: cv_InputArray,
        points1: cv_InputArray,
        mask: cv_OutputArray,
    );
}
#[repr(C)]
pub struct cv_videostab_TranslationBasedLocalOutlierRejector {
    pub _base: cv_videostab_IOutlierRejector,
    pub cellSize_: cv_Size,
    pub ransacParams_: cv_videostab_RansacParams,
    pub grid_: std_vector,
}
pub type cv_videostab_TranslationBasedLocalOutlierRejector_Cell = std_vector;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_TranslationBasedLocalOutlierRejector"]
        [::std::mem::size_of::<cv_videostab_TranslationBasedLocalOutlierRejector>() - 56usize];
    ["Alignment of cv_videostab_TranslationBasedLocalOutlierRejector"]
        [::std::mem::align_of::<cv_videostab_TranslationBasedLocalOutlierRejector>() - 8usize];
    ["Offset of field: cv_videostab_TranslationBasedLocalOutlierRejector::cellSize_"][::std::mem::offset_of!(
        cv_videostab_TranslationBasedLocalOutlierRejector,
        cellSize_
    ) - 8usize];
    ["Offset of field: cv_videostab_TranslationBasedLocalOutlierRejector::ransacParams_"][::std::mem::offset_of!(
        cv_videostab_TranslationBasedLocalOutlierRejector,
        ransacParams_
    )
        - 16usize];
    ["Offset of field: cv_videostab_TranslationBasedLocalOutlierRejector::grid_"][::std::mem::offset_of!(
        cv_videostab_TranslationBasedLocalOutlierRejector,
        grid_
    ) - 32usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab36TranslationBasedLocalOutlierRejectorC1Ev"]
    pub fn cv_videostab_TranslationBasedLocalOutlierRejector_TranslationBasedLocalOutlierRejector(
        this: *mut cv_videostab_TranslationBasedLocalOutlierRejector,
    );
}
impl cv_videostab_TranslationBasedLocalOutlierRejector {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_videostab_TranslationBasedLocalOutlierRejector_TranslationBasedLocalOutlierRejector(
            __bindgen_tmp.as_mut_ptr(),
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab36TranslationBasedLocalOutlierRejector7processENS_5Size_IiEERKNS_11_InputArrayES6_RKNS_12_OutputArrayE"]
    pub fn cv_videostab_TranslationBasedLocalOutlierRejector_process(
        this: *mut ::std::os::raw::c_void,
        frameSize: cv_Size,
        points0: cv_InputArray,
        points1: cv_InputArray,
        mask: cv_OutputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Estimates best global motion between two 2D point clouds in the least-squares sense.\n\n@note Works in-place and changes input point arrays.\n\n@param points0 Source set of 2D points (32F).\n@param points1 Destination set of 2D points (32F).\n@param model Motion model (up to MM_AFFINE).\n@param rmse Final root-mean-square error.\n@return 3x3 2D transformation matrix (32F)."]
    #[link_name = "\u{1}_ZN2cv9videostab32estimateGlobalMotionLeastSquaresERKNS_17_InputOutputArrayES3_iPf"]
    pub fn cv_videostab_estimateGlobalMotionLeastSquares(
        points0: cv_InputOutputArray,
        points1: cv_InputOutputArray,
        model: ::std::os::raw::c_int,
        rmse: *mut f32,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Estimates best global motion between two 2D point clouds robustly (using RANSAC method).\n\n@param points0 Source set of 2D points (32F).\n@param points1 Destination set of 2D points (32F).\n@param model Motion model. See cv::videostab::MotionModel.\n@param params RANSAC method parameters. See videostab::RansacParams.\n@param rmse Final root-mean-square error.\n@param ninliers Final number of inliers."]
    #[link_name = "\u{1}_ZN2cv9videostab26estimateGlobalMotionRansacERKNS_11_InputArrayES3_iRKNS0_12RansacParamsEPfPi"]
    pub fn cv_videostab_estimateGlobalMotionRansac(
        points0: cv_InputArray,
        points1: cv_InputArray,
        model: ::std::os::raw::c_int,
        params: *const cv_videostab_RansacParams,
        rmse: *mut f32,
        ninliers: *mut ::std::os::raw::c_int,
    ) -> cv_Mat;
}
#[repr(C)]
pub struct cv_videostab_MotionEstimatorBase__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief Base class for all global motion estimation methods."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_MotionEstimatorBase {
    pub vtable_: *const cv_videostab_MotionEstimatorBase__bindgen_vtable,
    pub motionModel_: cv_videostab_MotionModel,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_MotionEstimatorBase"]
        [::std::mem::size_of::<cv_videostab_MotionEstimatorBase>() - 16usize];
    ["Alignment of cv_videostab_MotionEstimatorBase"]
        [::std::mem::align_of::<cv_videostab_MotionEstimatorBase>() - 8usize];
    ["Offset of field: cv_videostab_MotionEstimatorBase::motionModel_"]
        [::std::mem::offset_of!(cv_videostab_MotionEstimatorBase, motionModel_) - 8usize];
};
#[doc = " @brief Describes a robust RANSAC-based global 2D motion estimation method which minimizes L2 error."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_MotionEstimatorRansacL2 {
    pub _base: cv_videostab_MotionEstimatorBase,
    pub ransacParams_: cv_videostab_RansacParams,
    pub minInlierRatio_: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_MotionEstimatorRansacL2"]
        [::std::mem::size_of::<cv_videostab_MotionEstimatorRansacL2>() - 32usize];
    ["Alignment of cv_videostab_MotionEstimatorRansacL2"]
        [::std::mem::align_of::<cv_videostab_MotionEstimatorRansacL2>() - 8usize];
    ["Offset of field: cv_videostab_MotionEstimatorRansacL2::ransacParams_"]
        [::std::mem::offset_of!(cv_videostab_MotionEstimatorRansacL2, ransacParams_) - 12usize];
    ["Offset of field: cv_videostab_MotionEstimatorRansacL2::minInlierRatio_"]
        [::std::mem::offset_of!(cv_videostab_MotionEstimatorRansacL2, minInlierRatio_) - 28usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab23MotionEstimatorRansacL2C1ENS0_11MotionModelE"]
    pub fn cv_videostab_MotionEstimatorRansacL2_MotionEstimatorRansacL2(
        this: *mut cv_videostab_MotionEstimatorRansacL2,
        model: cv_videostab_MotionModel,
    );
}
impl cv_videostab_MotionEstimatorRansacL2 {
    #[inline]
    pub unsafe fn new(model: cv_videostab_MotionModel) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_videostab_MotionEstimatorRansacL2_MotionEstimatorRansacL2(
            __bindgen_tmp.as_mut_ptr(),
            model,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab23MotionEstimatorRansacL28estimateERKNS_11_InputArrayES4_Pb"]
    pub fn cv_videostab_MotionEstimatorRansacL2_estimate(
        this: *mut ::std::os::raw::c_void,
        points0: cv_InputArray,
        points1: cv_InputArray,
        ok: *mut bool,
    ) -> cv_Mat;
}
#[doc = " @brief Describes a global 2D motion estimation method which minimizes L1 error.\n\n@note To be able to use this method you must build OpenCV with CLP library support. :"]
#[repr(C)]
pub struct cv_videostab_MotionEstimatorL1 {
    pub _base: cv_videostab_MotionEstimatorBase,
    pub obj_: std_vector,
    pub collb_: std_vector,
    pub colub_: std_vector,
    pub elems_: std_vector,
    pub rowlb_: std_vector,
    pub rowub_: std_vector,
    pub rows_: std_vector,
    pub cols_: std_vector,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_MotionEstimatorL1"]
        [::std::mem::size_of::<cv_videostab_MotionEstimatorL1>() - 208usize];
    ["Alignment of cv_videostab_MotionEstimatorL1"]
        [::std::mem::align_of::<cv_videostab_MotionEstimatorL1>() - 8usize];
    ["Offset of field: cv_videostab_MotionEstimatorL1::obj_"]
        [::std::mem::offset_of!(cv_videostab_MotionEstimatorL1, obj_) - 16usize];
    ["Offset of field: cv_videostab_MotionEstimatorL1::collb_"]
        [::std::mem::offset_of!(cv_videostab_MotionEstimatorL1, collb_) - 40usize];
    ["Offset of field: cv_videostab_MotionEstimatorL1::colub_"]
        [::std::mem::offset_of!(cv_videostab_MotionEstimatorL1, colub_) - 64usize];
    ["Offset of field: cv_videostab_MotionEstimatorL1::elems_"]
        [::std::mem::offset_of!(cv_videostab_MotionEstimatorL1, elems_) - 88usize];
    ["Offset of field: cv_videostab_MotionEstimatorL1::rowlb_"]
        [::std::mem::offset_of!(cv_videostab_MotionEstimatorL1, rowlb_) - 112usize];
    ["Offset of field: cv_videostab_MotionEstimatorL1::rowub_"]
        [::std::mem::offset_of!(cv_videostab_MotionEstimatorL1, rowub_) - 136usize];
    ["Offset of field: cv_videostab_MotionEstimatorL1::rows_"]
        [::std::mem::offset_of!(cv_videostab_MotionEstimatorL1, rows_) - 160usize];
    ["Offset of field: cv_videostab_MotionEstimatorL1::cols_"]
        [::std::mem::offset_of!(cv_videostab_MotionEstimatorL1, cols_) - 184usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab17MotionEstimatorL1C1ENS0_11MotionModelE"]
    pub fn cv_videostab_MotionEstimatorL1_MotionEstimatorL1(
        this: *mut cv_videostab_MotionEstimatorL1,
        model: cv_videostab_MotionModel,
    );
}
impl cv_videostab_MotionEstimatorL1 {
    #[inline]
    pub unsafe fn new(model: cv_videostab_MotionModel) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_videostab_MotionEstimatorL1_MotionEstimatorL1(__bindgen_tmp.as_mut_ptr(), model);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab17MotionEstimatorL18estimateERKNS_11_InputArrayES4_Pb"]
    pub fn cv_videostab_MotionEstimatorL1_estimate(
        this: *mut ::std::os::raw::c_void,
        points0: cv_InputArray,
        points1: cv_InputArray,
        ok: *mut bool,
    ) -> cv_Mat;
}
#[repr(C)]
pub struct cv_videostab_ImageMotionEstimatorBase__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief Base class for global 2D motion estimation methods which take frames as input."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_ImageMotionEstimatorBase {
    pub vtable_: *const cv_videostab_ImageMotionEstimatorBase__bindgen_vtable,
    pub motionModel_: cv_videostab_MotionModel,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_ImageMotionEstimatorBase"]
        [::std::mem::size_of::<cv_videostab_ImageMotionEstimatorBase>() - 16usize];
    ["Alignment of cv_videostab_ImageMotionEstimatorBase"]
        [::std::mem::align_of::<cv_videostab_ImageMotionEstimatorBase>() - 8usize];
    ["Offset of field: cv_videostab_ImageMotionEstimatorBase::motionModel_"]
        [::std::mem::offset_of!(cv_videostab_ImageMotionEstimatorBase, motionModel_) - 8usize];
};
#[repr(C)]
pub struct cv_videostab_FromFileMotionReader {
    pub _base: cv_videostab_ImageMotionEstimatorBase,
    pub file_: std_ifstream,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_FromFileMotionReader"]
        [::std::mem::size_of::<cv_videostab_FromFileMotionReader>() - 536usize];
    ["Alignment of cv_videostab_FromFileMotionReader"]
        [::std::mem::align_of::<cv_videostab_FromFileMotionReader>() - 8usize];
    ["Offset of field: cv_videostab_FromFileMotionReader::file_"]
        [::std::mem::offset_of!(cv_videostab_FromFileMotionReader, file_) - 16usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab20FromFileMotionReaderC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_videostab_FromFileMotionReader_FromFileMotionReader(
        this: *mut cv_videostab_FromFileMotionReader,
        path: *const cv_String,
    );
}
impl cv_videostab_FromFileMotionReader {
    #[inline]
    pub unsafe fn new(path: *const cv_String) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_videostab_FromFileMotionReader_FromFileMotionReader(__bindgen_tmp.as_mut_ptr(), path);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab20FromFileMotionReader8estimateERKNS_3MatES4_Pb"]
    pub fn cv_videostab_FromFileMotionReader_estimate(
        this: *mut ::std::os::raw::c_void,
        frame0: *const cv_Mat,
        frame1: *const cv_Mat,
        ok: *mut bool,
    ) -> cv_Mat;
}
#[repr(C)]
pub struct cv_videostab_ToFileMotionWriter {
    pub _base: cv_videostab_ImageMotionEstimatorBase,
    pub file_: std_ofstream,
    pub motionEstimator_: cv_Ptr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_ToFileMotionWriter"]
        [::std::mem::size_of::<cv_videostab_ToFileMotionWriter>() - 544usize];
    ["Alignment of cv_videostab_ToFileMotionWriter"]
        [::std::mem::align_of::<cv_videostab_ToFileMotionWriter>() - 8usize];
    ["Offset of field: cv_videostab_ToFileMotionWriter::file_"]
        [::std::mem::offset_of!(cv_videostab_ToFileMotionWriter, file_) - 16usize];
    ["Offset of field: cv_videostab_ToFileMotionWriter::motionEstimator_"]
        [::std::mem::offset_of!(cv_videostab_ToFileMotionWriter, motionEstimator_) - 528usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab18ToFileMotionWriterC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS_3PtrINS0_24ImageMotionEstimatorBaseEEE"]
    pub fn cv_videostab_ToFileMotionWriter_ToFileMotionWriter(
        this: *mut cv_videostab_ToFileMotionWriter,
        path: *const cv_String,
        estimator: cv_Ptr,
    );
}
impl cv_videostab_ToFileMotionWriter {
    #[inline]
    pub unsafe fn new(path: *const cv_String, estimator: cv_Ptr) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_videostab_ToFileMotionWriter_ToFileMotionWriter(
            __bindgen_tmp.as_mut_ptr(),
            path,
            estimator,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab18ToFileMotionWriter8estimateERKNS_3MatES4_Pb"]
    pub fn cv_videostab_ToFileMotionWriter_estimate(
        this: *mut ::std::os::raw::c_void,
        frame0: *const cv_Mat,
        frame1: *const cv_Mat,
        ok: *mut bool,
    ) -> cv_Mat;
}
#[doc = " @brief Describes a global 2D motion estimation method which uses keypoints detection and optical flow for\nmatching."]
#[repr(C)]
pub struct cv_videostab_KeypointBasedMotionEstimator {
    pub _base: cv_videostab_ImageMotionEstimatorBase,
    pub motionEstimator_: cv_Ptr,
    pub detector_: cv_Ptr,
    pub optFlowEstimator_: cv_Ptr,
    pub outlierRejector_: cv_Ptr,
    pub mask_: cv_Mat,
    pub status_: std_vector,
    pub keypointsPrev_: std_vector,
    pub pointsPrev_: std_vector,
    pub points_: std_vector,
    pub pointsPrevGood_: std_vector,
    pub pointsGood_: std_vector,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_KeypointBasedMotionEstimator"]
        [::std::mem::size_of::<cv_videostab_KeypointBasedMotionEstimator>() - 320usize];
    ["Alignment of cv_videostab_KeypointBasedMotionEstimator"]
        [::std::mem::align_of::<cv_videostab_KeypointBasedMotionEstimator>() - 8usize];
    ["Offset of field: cv_videostab_KeypointBasedMotionEstimator::motionEstimator_"][::std::mem::offset_of!(
        cv_videostab_KeypointBasedMotionEstimator,
        motionEstimator_
    ) - 16usize];
    ["Offset of field: cv_videostab_KeypointBasedMotionEstimator::detector_"]
        [::std::mem::offset_of!(cv_videostab_KeypointBasedMotionEstimator, detector_) - 32usize];
    ["Offset of field: cv_videostab_KeypointBasedMotionEstimator::optFlowEstimator_"][::std::mem::offset_of!(
        cv_videostab_KeypointBasedMotionEstimator,
        optFlowEstimator_
    ) - 48usize];
    ["Offset of field: cv_videostab_KeypointBasedMotionEstimator::outlierRejector_"][::std::mem::offset_of!(
        cv_videostab_KeypointBasedMotionEstimator,
        outlierRejector_
    ) - 64usize];
    ["Offset of field: cv_videostab_KeypointBasedMotionEstimator::mask_"]
        [::std::mem::offset_of!(cv_videostab_KeypointBasedMotionEstimator, mask_) - 80usize];
    ["Offset of field: cv_videostab_KeypointBasedMotionEstimator::status_"]
        [::std::mem::offset_of!(cv_videostab_KeypointBasedMotionEstimator, status_) - 176usize];
    ["Offset of field: cv_videostab_KeypointBasedMotionEstimator::keypointsPrev_"][::std::mem::offset_of!(
        cv_videostab_KeypointBasedMotionEstimator,
        keypointsPrev_
    ) - 200usize];
    ["Offset of field: cv_videostab_KeypointBasedMotionEstimator::pointsPrev_"]
        [::std::mem::offset_of!(cv_videostab_KeypointBasedMotionEstimator, pointsPrev_) - 224usize];
    ["Offset of field: cv_videostab_KeypointBasedMotionEstimator::points_"]
        [::std::mem::offset_of!(cv_videostab_KeypointBasedMotionEstimator, points_) - 248usize];
    ["Offset of field: cv_videostab_KeypointBasedMotionEstimator::pointsPrevGood_"][::std::mem::offset_of!(
        cv_videostab_KeypointBasedMotionEstimator,
        pointsPrevGood_
    ) - 272usize];
    ["Offset of field: cv_videostab_KeypointBasedMotionEstimator::pointsGood_"]
        [::std::mem::offset_of!(cv_videostab_KeypointBasedMotionEstimator, pointsGood_) - 296usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab28KeypointBasedMotionEstimator8estimateERKNS_11_InputArrayES4_Pb"]
    pub fn cv_videostab_KeypointBasedMotionEstimator_estimate1(
        this: *mut cv_videostab_KeypointBasedMotionEstimator,
        frame0: cv_InputArray,
        frame1: cv_InputArray,
        ok: *mut bool,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab28KeypointBasedMotionEstimatorC1ENS_3PtrINS0_19MotionEstimatorBaseEEE"]
    pub fn cv_videostab_KeypointBasedMotionEstimator_KeypointBasedMotionEstimator(
        this: *mut cv_videostab_KeypointBasedMotionEstimator,
        estimator: cv_Ptr,
    );
}
impl cv_videostab_KeypointBasedMotionEstimator {
    #[inline]
    pub unsafe fn estimate(
        &mut self,
        frame0: cv_InputArray,
        frame1: cv_InputArray,
        ok: *mut bool,
    ) -> cv_Mat {
        cv_videostab_KeypointBasedMotionEstimator_estimate1(self, frame0, frame1, ok)
    }
    #[inline]
    pub unsafe fn new(estimator: cv_Ptr) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_videostab_KeypointBasedMotionEstimator_KeypointBasedMotionEstimator(
            __bindgen_tmp.as_mut_ptr(),
            estimator,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab28KeypointBasedMotionEstimator8estimateERKNS_3MatES4_Pb"]
    pub fn cv_videostab_KeypointBasedMotionEstimator_estimate(
        this: *mut ::std::os::raw::c_void,
        frame0: *const cv_Mat,
        frame1: *const cv_Mat,
        ok: *mut bool,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Computes motion between two frames assuming that all the intermediate motions are known.\n\n@param from Source frame index.\n@param to Destination frame index.\n@param motions Pair-wise motions. motions[i] denotes motion from the frame i to the frame i+1\n@return Motion from the Source frame to the Destination frame."]
    #[link_name = "\u{1}_ZN2cv9videostab9getMotionEiiRKSt6vectorINS_3MatESaIS2_EE"]
    pub fn cv_videostab_getMotion(
        from: ::std::os::raw::c_int,
        to: ::std::os::raw::c_int,
        motions: *const std_vector,
    ) -> cv_Mat;
}
#[repr(C)]
pub struct cv_videostab_IMotionStabilizer__bindgen_vtable(::std::os::raw::c_void);
#[doc = "! @addtogroup videostab_motion\n! @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_IMotionStabilizer {
    pub vtable_: *const cv_videostab_IMotionStabilizer__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_IMotionStabilizer"]
        [::std::mem::size_of::<cv_videostab_IMotionStabilizer>() - 8usize];
    ["Alignment of cv_videostab_IMotionStabilizer"]
        [::std::mem::align_of::<cv_videostab_IMotionStabilizer>() - 8usize];
};
#[repr(C)]
pub struct cv_videostab_MotionStabilizationPipeline {
    pub _base: cv_videostab_IMotionStabilizer,
    pub stabilizers_: std_vector,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_MotionStabilizationPipeline"]
        [::std::mem::size_of::<cv_videostab_MotionStabilizationPipeline>() - 32usize];
    ["Alignment of cv_videostab_MotionStabilizationPipeline"]
        [::std::mem::align_of::<cv_videostab_MotionStabilizationPipeline>() - 8usize];
    ["Offset of field: cv_videostab_MotionStabilizationPipeline::stabilizers_"]
        [::std::mem::offset_of!(cv_videostab_MotionStabilizationPipeline, stabilizers_) - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab27MotionStabilizationPipeline9stabilizeEiRKSt6vectorINS_3MatESaIS3_EESt4pairIiiEPS3_"]
    pub fn cv_videostab_MotionStabilizationPipeline_stabilize(
        this: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
        motions: *const std_vector,
        range: std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>,
        stabilizationMotions: *mut cv_Mat,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_MotionFilterBase {
    pub _base: cv_videostab_IMotionStabilizer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_MotionFilterBase"]
        [::std::mem::size_of::<cv_videostab_MotionFilterBase>() - 8usize];
    ["Alignment of cv_videostab_MotionFilterBase"]
        [::std::mem::align_of::<cv_videostab_MotionFilterBase>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab16MotionFilterBase9stabilizeEiRKSt6vectorINS_3MatESaIS3_EESt4pairIiiEPS3_"]
    pub fn cv_videostab_MotionFilterBase_stabilize1(
        this: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
        motions: *const std_vector,
        range: std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>,
        stabilizationMotions: *mut cv_Mat,
    );
}
#[repr(C)]
pub struct cv_videostab_GaussianMotionFilter {
    pub _base: cv_videostab_MotionFilterBase,
    pub radius_: ::std::os::raw::c_int,
    pub stdev_: f32,
    pub weight_: std_vector,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_GaussianMotionFilter"]
        [::std::mem::size_of::<cv_videostab_GaussianMotionFilter>() - 40usize];
    ["Alignment of cv_videostab_GaussianMotionFilter"]
        [::std::mem::align_of::<cv_videostab_GaussianMotionFilter>() - 8usize];
    ["Offset of field: cv_videostab_GaussianMotionFilter::radius_"]
        [::std::mem::offset_of!(cv_videostab_GaussianMotionFilter, radius_) - 8usize];
    ["Offset of field: cv_videostab_GaussianMotionFilter::stdev_"]
        [::std::mem::offset_of!(cv_videostab_GaussianMotionFilter, stdev_) - 12usize];
    ["Offset of field: cv_videostab_GaussianMotionFilter::weight_"]
        [::std::mem::offset_of!(cv_videostab_GaussianMotionFilter, weight_) - 16usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab20GaussianMotionFilter9setParamsEif"]
    pub fn cv_videostab_GaussianMotionFilter_setParams(
        this: *mut cv_videostab_GaussianMotionFilter,
        radius: ::std::os::raw::c_int,
        stdev: f32,
    );
}
impl cv_videostab_GaussianMotionFilter {
    #[inline]
    pub unsafe fn setParams(&mut self, radius: ::std::os::raw::c_int, stdev: f32) {
        cv_videostab_GaussianMotionFilter_setParams(self, radius, stdev)
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab20GaussianMotionFilter9stabilizeEiRKSt6vectorINS_3MatESaIS3_EESt4pairIiiE"]
    pub fn cv_videostab_GaussianMotionFilter_stabilize(
        this: *mut ::std::os::raw::c_void,
        idx: ::std::os::raw::c_int,
        motions: *const std_vector,
        range: std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>,
    ) -> cv_Mat;
}
#[repr(C)]
pub struct cv_videostab_LpMotionStabilizer {
    pub _base: cv_videostab_IMotionStabilizer,
    pub model_: cv_videostab_MotionModel,
    pub frameSize_: cv_Size,
    pub trimRatio_: f32,
    pub w1_: f32,
    pub w2_: f32,
    pub w3_: f32,
    pub w4_: f32,
    pub obj_: std_vector,
    pub collb_: std_vector,
    pub colub_: std_vector,
    pub rows_: std_vector,
    pub cols_: std_vector,
    pub elems_: std_vector,
    pub rowlb_: std_vector,
    pub rowub_: std_vector,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_LpMotionStabilizer"]
        [::std::mem::size_of::<cv_videostab_LpMotionStabilizer>() - 232usize];
    ["Alignment of cv_videostab_LpMotionStabilizer"]
        [::std::mem::align_of::<cv_videostab_LpMotionStabilizer>() - 8usize];
    ["Offset of field: cv_videostab_LpMotionStabilizer::model_"]
        [::std::mem::offset_of!(cv_videostab_LpMotionStabilizer, model_) - 8usize];
    ["Offset of field: cv_videostab_LpMotionStabilizer::frameSize_"]
        [::std::mem::offset_of!(cv_videostab_LpMotionStabilizer, frameSize_) - 12usize];
    ["Offset of field: cv_videostab_LpMotionStabilizer::trimRatio_"]
        [::std::mem::offset_of!(cv_videostab_LpMotionStabilizer, trimRatio_) - 20usize];
    ["Offset of field: cv_videostab_LpMotionStabilizer::w1_"]
        [::std::mem::offset_of!(cv_videostab_LpMotionStabilizer, w1_) - 24usize];
    ["Offset of field: cv_videostab_LpMotionStabilizer::w2_"]
        [::std::mem::offset_of!(cv_videostab_LpMotionStabilizer, w2_) - 28usize];
    ["Offset of field: cv_videostab_LpMotionStabilizer::w3_"]
        [::std::mem::offset_of!(cv_videostab_LpMotionStabilizer, w3_) - 32usize];
    ["Offset of field: cv_videostab_LpMotionStabilizer::w4_"]
        [::std::mem::offset_of!(cv_videostab_LpMotionStabilizer, w4_) - 36usize];
    ["Offset of field: cv_videostab_LpMotionStabilizer::obj_"]
        [::std::mem::offset_of!(cv_videostab_LpMotionStabilizer, obj_) - 40usize];
    ["Offset of field: cv_videostab_LpMotionStabilizer::collb_"]
        [::std::mem::offset_of!(cv_videostab_LpMotionStabilizer, collb_) - 64usize];
    ["Offset of field: cv_videostab_LpMotionStabilizer::colub_"]
        [::std::mem::offset_of!(cv_videostab_LpMotionStabilizer, colub_) - 88usize];
    ["Offset of field: cv_videostab_LpMotionStabilizer::rows_"]
        [::std::mem::offset_of!(cv_videostab_LpMotionStabilizer, rows_) - 112usize];
    ["Offset of field: cv_videostab_LpMotionStabilizer::cols_"]
        [::std::mem::offset_of!(cv_videostab_LpMotionStabilizer, cols_) - 136usize];
    ["Offset of field: cv_videostab_LpMotionStabilizer::elems_"]
        [::std::mem::offset_of!(cv_videostab_LpMotionStabilizer, elems_) - 160usize];
    ["Offset of field: cv_videostab_LpMotionStabilizer::rowlb_"]
        [::std::mem::offset_of!(cv_videostab_LpMotionStabilizer, rowlb_) - 184usize];
    ["Offset of field: cv_videostab_LpMotionStabilizer::rowub_"]
        [::std::mem::offset_of!(cv_videostab_LpMotionStabilizer, rowub_) - 208usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab18LpMotionStabilizerC1ENS0_11MotionModelE"]
    pub fn cv_videostab_LpMotionStabilizer_LpMotionStabilizer(
        this: *mut cv_videostab_LpMotionStabilizer,
        model: cv_videostab_MotionModel,
    );
}
impl cv_videostab_LpMotionStabilizer {
    #[inline]
    pub unsafe fn new(model: cv_videostab_MotionModel) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_videostab_LpMotionStabilizer_LpMotionStabilizer(__bindgen_tmp.as_mut_ptr(), model);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab18LpMotionStabilizer9stabilizeEiRKSt6vectorINS_3MatESaIS3_EESt4pairIiiEPS3_"]
    pub fn cv_videostab_LpMotionStabilizer_stabilize(
        this: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
        motions: *const std_vector,
        range: std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>,
        stabilizationMotions: *mut cv_Mat,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab25ensureInclusionConstraintERKNS_3MatENS_5Size_IiEEf"]
    pub fn cv_videostab_ensureInclusionConstraint(
        M: *const cv_Mat,
        size: cv_Size,
        trimRatio: f32,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab24estimateOptimalTrimRatioERKNS_3MatENS_5Size_IiEE"]
    pub fn cv_videostab_estimateOptimalTrimRatio(M: *const cv_Mat, size: cv_Size) -> f32;
}
#[repr(C)]
pub struct cv_videostab_IFrameSource__bindgen_vtable(::std::os::raw::c_void);
#[doc = "! @addtogroup videostab\n! @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_IFrameSource {
    pub vtable_: *const cv_videostab_IFrameSource__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_IFrameSource"]
        [::std::mem::size_of::<cv_videostab_IFrameSource>() - 8usize];
    ["Alignment of cv_videostab_IFrameSource"]
        [::std::mem::align_of::<cv_videostab_IFrameSource>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_NullFrameSource {
    pub _base: cv_videostab_IFrameSource,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_NullFrameSource"]
        [::std::mem::size_of::<cv_videostab_NullFrameSource>() - 8usize];
    ["Alignment of cv_videostab_NullFrameSource"]
        [::std::mem::align_of::<cv_videostab_NullFrameSource>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_VideoFileSource {
    pub _base: cv_videostab_IFrameSource,
    pub impl_: cv_Ptr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_VideoFileSource"]
        [::std::mem::size_of::<cv_videostab_VideoFileSource>() - 24usize];
    ["Alignment of cv_videostab_VideoFileSource"]
        [::std::mem::align_of::<cv_videostab_VideoFileSource>() - 8usize];
    ["Offset of field: cv_videostab_VideoFileSource::impl_"]
        [::std::mem::offset_of!(cv_videostab_VideoFileSource, impl_) - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab15VideoFileSource5widthEv"]
    pub fn cv_videostab_VideoFileSource_width(
        this: *mut cv_videostab_VideoFileSource,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab15VideoFileSource6heightEv"]
    pub fn cv_videostab_VideoFileSource_height(
        this: *mut cv_videostab_VideoFileSource,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab15VideoFileSource5countEv"]
    pub fn cv_videostab_VideoFileSource_count(
        this: *mut cv_videostab_VideoFileSource,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab15VideoFileSource3fpsEv"]
    pub fn cv_videostab_VideoFileSource_fps(this: *mut cv_videostab_VideoFileSource) -> f64;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab15VideoFileSourceC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb"]
    pub fn cv_videostab_VideoFileSource_VideoFileSource(
        this: *mut cv_videostab_VideoFileSource,
        path: *const cv_String,
        volatileFrame: bool,
    );
}
impl cv_videostab_VideoFileSource {
    #[inline]
    pub unsafe fn width(&mut self) -> ::std::os::raw::c_int {
        cv_videostab_VideoFileSource_width(self)
    }
    #[inline]
    pub unsafe fn height(&mut self) -> ::std::os::raw::c_int {
        cv_videostab_VideoFileSource_height(self)
    }
    #[inline]
    pub unsafe fn count(&mut self) -> ::std::os::raw::c_int {
        cv_videostab_VideoFileSource_count(self)
    }
    #[inline]
    pub unsafe fn fps(&mut self) -> f64 {
        cv_videostab_VideoFileSource_fps(self)
    }
    #[inline]
    pub unsafe fn new(path: *const cv_String, volatileFrame: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_videostab_VideoFileSource_VideoFileSource(
            __bindgen_tmp.as_mut_ptr(),
            path,
            volatileFrame,
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab15VideoFileSource5resetEv"]
    pub fn cv_videostab_VideoFileSource_reset(this: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab15VideoFileSource9nextFrameEv"]
    pub fn cv_videostab_VideoFileSource_nextFrame(this: *mut ::std::os::raw::c_void) -> cv_Mat;
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_MaskFrameSource {
    pub _base: cv_videostab_IFrameSource,
    pub impl_: cv_Ptr,
    pub maskCallback_: __BindgenOpaqueArray<u64, 4usize>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_MaskFrameSource"]
        [::std::mem::size_of::<cv_videostab_MaskFrameSource>() - 56usize];
    ["Alignment of cv_videostab_MaskFrameSource"]
        [::std::mem::align_of::<cv_videostab_MaskFrameSource>() - 8usize];
    ["Offset of field: cv_videostab_MaskFrameSource::impl_"]
        [::std::mem::offset_of!(cv_videostab_MaskFrameSource, impl_) - 8usize];
    ["Offset of field: cv_videostab_MaskFrameSource::maskCallback_"]
        [::std::mem::offset_of!(cv_videostab_MaskFrameSource, maskCallback_) - 24usize];
};
#[repr(C)]
pub struct cv_videostab_ILog__bindgen_vtable(::std::os::raw::c_void);
#[doc = "! @addtogroup videostab\n! @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_ILog {
    pub vtable_: *const cv_videostab_ILog__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_ILog"][::std::mem::size_of::<cv_videostab_ILog>() - 8usize];
    ["Alignment of cv_videostab_ILog"][::std::mem::align_of::<cv_videostab_ILog>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_NullLog {
    pub _base: cv_videostab_ILog,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_NullLog"][::std::mem::size_of::<cv_videostab_NullLog>() - 8usize];
    ["Alignment of cv_videostab_NullLog"][::std::mem::align_of::<cv_videostab_NullLog>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_LogToStdout {
    pub _base: cv_videostab_ILog,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_LogToStdout"]
        [::std::mem::size_of::<cv_videostab_LogToStdout>() - 8usize];
    ["Alignment of cv_videostab_LogToStdout"]
        [::std::mem::align_of::<cv_videostab_LogToStdout>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab11LogToStdout5printEPKcz"]
    pub fn cv_videostab_LogToStdout_print(
        this: *mut ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
#[doc = " @brief Describes the Fast Marching Method implementation.\n\nSee http://iwi.eldoc.ub.rug.nl/FILES/root/2004/JGraphToolsTelea/2004JGraphToolsTelea.pdf"]
#[repr(C)]
pub struct cv_videostab_FastMarchingMethod {
    pub inf_: f32,
    pub flag_: cv_Mat_,
    pub dist_: cv_Mat_,
    pub index_: cv_Mat_,
    pub narrowBand_: std_vector,
    pub size_: ::std::os::raw::c_int,
}
pub const cv_videostab_FastMarchingMethod_INSIDE: cv_videostab_FastMarchingMethod__bindgen_ty_1 = 0;
pub const cv_videostab_FastMarchingMethod_BAND: cv_videostab_FastMarchingMethod__bindgen_ty_1 = 1;
pub const cv_videostab_FastMarchingMethod_KNOWN: cv_videostab_FastMarchingMethod__bindgen_ty_1 =
    255;
pub type cv_videostab_FastMarchingMethod__bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_videostab_FastMarchingMethod_DXY {
    pub dist: f32,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_FastMarchingMethod_DXY"]
        [::std::mem::size_of::<cv_videostab_FastMarchingMethod_DXY>() - 12usize];
    ["Alignment of cv_videostab_FastMarchingMethod_DXY"]
        [::std::mem::align_of::<cv_videostab_FastMarchingMethod_DXY>() - 4usize];
    ["Offset of field: cv_videostab_FastMarchingMethod_DXY::dist"]
        [::std::mem::offset_of!(cv_videostab_FastMarchingMethod_DXY, dist) - 0usize];
    ["Offset of field: cv_videostab_FastMarchingMethod_DXY::x"]
        [::std::mem::offset_of!(cv_videostab_FastMarchingMethod_DXY, x) - 4usize];
    ["Offset of field: cv_videostab_FastMarchingMethod_DXY::y"]
        [::std::mem::offset_of!(cv_videostab_FastMarchingMethod_DXY, y) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_FastMarchingMethod"]
        [::std::mem::size_of::<cv_videostab_FastMarchingMethod>() - 328usize];
    ["Alignment of cv_videostab_FastMarchingMethod"]
        [::std::mem::align_of::<cv_videostab_FastMarchingMethod>() - 8usize];
    ["Offset of field: cv_videostab_FastMarchingMethod::inf_"]
        [::std::mem::offset_of!(cv_videostab_FastMarchingMethod, inf_) - 0usize];
    ["Offset of field: cv_videostab_FastMarchingMethod::flag_"]
        [::std::mem::offset_of!(cv_videostab_FastMarchingMethod, flag_) - 8usize];
    ["Offset of field: cv_videostab_FastMarchingMethod::dist_"]
        [::std::mem::offset_of!(cv_videostab_FastMarchingMethod, dist_) - 104usize];
    ["Offset of field: cv_videostab_FastMarchingMethod::index_"]
        [::std::mem::offset_of!(cv_videostab_FastMarchingMethod, index_) - 200usize];
    ["Offset of field: cv_videostab_FastMarchingMethod::narrowBand_"]
        [::std::mem::offset_of!(cv_videostab_FastMarchingMethod, narrowBand_) - 296usize];
    ["Offset of field: cv_videostab_FastMarchingMethod::size_"]
        [::std::mem::offset_of!(cv_videostab_FastMarchingMethod, size_) - 320usize];
};
#[repr(C)]
pub struct cv_videostab_InpainterBase__bindgen_vtable(::std::os::raw::c_void);
#[doc = "! @addtogroup videostab\n! @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_InpainterBase {
    pub vtable_: *const cv_videostab_InpainterBase__bindgen_vtable,
    pub radius_: ::std::os::raw::c_int,
    pub motionModel_: cv_videostab_MotionModel,
    pub frames_: *const std_vector,
    pub motions_: *const std_vector,
    pub stabilizedFrames_: *const std_vector,
    pub stabilizationMotions_: *const std_vector,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_InpainterBase"]
        [::std::mem::size_of::<cv_videostab_InpainterBase>() - 48usize];
    ["Alignment of cv_videostab_InpainterBase"]
        [::std::mem::align_of::<cv_videostab_InpainterBase>() - 8usize];
    ["Offset of field: cv_videostab_InpainterBase::radius_"]
        [::std::mem::offset_of!(cv_videostab_InpainterBase, radius_) - 8usize];
    ["Offset of field: cv_videostab_InpainterBase::motionModel_"]
        [::std::mem::offset_of!(cv_videostab_InpainterBase, motionModel_) - 12usize];
    ["Offset of field: cv_videostab_InpainterBase::frames_"]
        [::std::mem::offset_of!(cv_videostab_InpainterBase, frames_) - 16usize];
    ["Offset of field: cv_videostab_InpainterBase::motions_"]
        [::std::mem::offset_of!(cv_videostab_InpainterBase, motions_) - 24usize];
    ["Offset of field: cv_videostab_InpainterBase::stabilizedFrames_"]
        [::std::mem::offset_of!(cv_videostab_InpainterBase, stabilizedFrames_) - 32usize];
    ["Offset of field: cv_videostab_InpainterBase::stabilizationMotions_"]
        [::std::mem::offset_of!(cv_videostab_InpainterBase, stabilizationMotions_) - 40usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_NullInpainter {
    pub _base: cv_videostab_InpainterBase,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_NullInpainter"]
        [::std::mem::size_of::<cv_videostab_NullInpainter>() - 48usize];
    ["Alignment of cv_videostab_NullInpainter"]
        [::std::mem::align_of::<cv_videostab_NullInpainter>() - 8usize];
};
#[repr(C)]
pub struct cv_videostab_InpaintingPipeline {
    pub _base: cv_videostab_InpainterBase,
    pub inpainters_: std_vector,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_InpaintingPipeline"]
        [::std::mem::size_of::<cv_videostab_InpaintingPipeline>() - 72usize];
    ["Alignment of cv_videostab_InpaintingPipeline"]
        [::std::mem::align_of::<cv_videostab_InpaintingPipeline>() - 8usize];
    ["Offset of field: cv_videostab_InpaintingPipeline::inpainters_"]
        [::std::mem::offset_of!(cv_videostab_InpaintingPipeline, inpainters_) - 48usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab18InpaintingPipeline9setRadiusEi"]
    pub fn cv_videostab_InpaintingPipeline_setRadius(
        this: *mut ::std::os::raw::c_void,
        val: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab18InpaintingPipeline14setMotionModelENS0_11MotionModelE"]
    pub fn cv_videostab_InpaintingPipeline_setMotionModel(
        this: *mut ::std::os::raw::c_void,
        val: cv_videostab_MotionModel,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab18InpaintingPipeline9setFramesERKSt6vectorINS_3MatESaIS3_EE"]
    pub fn cv_videostab_InpaintingPipeline_setFrames(
        this: *mut ::std::os::raw::c_void,
        val: *const std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab18InpaintingPipeline10setMotionsERKSt6vectorINS_3MatESaIS3_EE"]
    pub fn cv_videostab_InpaintingPipeline_setMotions(
        this: *mut ::std::os::raw::c_void,
        val: *const std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab18InpaintingPipeline19setStabilizedFramesERKSt6vectorINS_3MatESaIS3_EE"]
    pub fn cv_videostab_InpaintingPipeline_setStabilizedFrames(
        this: *mut ::std::os::raw::c_void,
        val: *const std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab18InpaintingPipeline23setStabilizationMotionsERKSt6vectorINS_3MatESaIS3_EE"]
    pub fn cv_videostab_InpaintingPipeline_setStabilizationMotions(
        this: *mut ::std::os::raw::c_void,
        val: *const std_vector,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab18InpaintingPipeline7inpaintEiRNS_3MatES3_"]
    pub fn cv_videostab_InpaintingPipeline_inpaint(
        this: *mut ::std::os::raw::c_void,
        idx: ::std::os::raw::c_int,
        frame: *mut cv_Mat,
        mask: *mut cv_Mat,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_ConsistentMosaicInpainter {
    pub _base: cv_videostab_InpainterBase,
    pub stdevThresh_: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_ConsistentMosaicInpainter"]
        [::std::mem::size_of::<cv_videostab_ConsistentMosaicInpainter>() - 56usize];
    ["Alignment of cv_videostab_ConsistentMosaicInpainter"]
        [::std::mem::align_of::<cv_videostab_ConsistentMosaicInpainter>() - 8usize];
    ["Offset of field: cv_videostab_ConsistentMosaicInpainter::stdevThresh_"]
        [::std::mem::offset_of!(cv_videostab_ConsistentMosaicInpainter, stdevThresh_) - 48usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab25ConsistentMosaicInpainterC1Ev"]
    pub fn cv_videostab_ConsistentMosaicInpainter_ConsistentMosaicInpainter(
        this: *mut cv_videostab_ConsistentMosaicInpainter,
    );
}
impl cv_videostab_ConsistentMosaicInpainter {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_videostab_ConsistentMosaicInpainter_ConsistentMosaicInpainter(
            __bindgen_tmp.as_mut_ptr(),
        );
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab25ConsistentMosaicInpainter7inpaintEiRNS_3MatES3_"]
    pub fn cv_videostab_ConsistentMosaicInpainter_inpaint(
        this: *mut ::std::os::raw::c_void,
        idx: ::std::os::raw::c_int,
        frame: *mut cv_Mat,
        mask: *mut cv_Mat,
    );
}
#[repr(C)]
pub struct cv_videostab_MotionInpainter {
    pub _base: cv_videostab_InpainterBase,
    pub fmm_: cv_videostab_FastMarchingMethod,
    pub optFlowEstimator_: cv_Ptr,
    pub flowErrorThreshold_: f32,
    pub distThresh_: f32,
    pub borderMode_: ::std::os::raw::c_int,
    pub frame1_: cv_Mat,
    pub transformedFrame1_: cv_Mat,
    pub grayFrame_: cv_Mat_,
    pub transformedGrayFrame1_: cv_Mat_,
    pub mask1_: cv_Mat_,
    pub transformedMask1_: cv_Mat_,
    pub flowX_: cv_Mat_,
    pub flowY_: cv_Mat_,
    pub flowErrors_: cv_Mat_,
    pub flowMask_: cv_Mat_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_MotionInpainter"]
        [::std::mem::size_of::<cv_videostab_MotionInpainter>() - 1368usize];
    ["Alignment of cv_videostab_MotionInpainter"]
        [::std::mem::align_of::<cv_videostab_MotionInpainter>() - 8usize];
    ["Offset of field: cv_videostab_MotionInpainter::fmm_"]
        [::std::mem::offset_of!(cv_videostab_MotionInpainter, fmm_) - 48usize];
    ["Offset of field: cv_videostab_MotionInpainter::optFlowEstimator_"]
        [::std::mem::offset_of!(cv_videostab_MotionInpainter, optFlowEstimator_) - 376usize];
    ["Offset of field: cv_videostab_MotionInpainter::flowErrorThreshold_"]
        [::std::mem::offset_of!(cv_videostab_MotionInpainter, flowErrorThreshold_) - 392usize];
    ["Offset of field: cv_videostab_MotionInpainter::distThresh_"]
        [::std::mem::offset_of!(cv_videostab_MotionInpainter, distThresh_) - 396usize];
    ["Offset of field: cv_videostab_MotionInpainter::borderMode_"]
        [::std::mem::offset_of!(cv_videostab_MotionInpainter, borderMode_) - 400usize];
    ["Offset of field: cv_videostab_MotionInpainter::frame1_"]
        [::std::mem::offset_of!(cv_videostab_MotionInpainter, frame1_) - 408usize];
    ["Offset of field: cv_videostab_MotionInpainter::transformedFrame1_"]
        [::std::mem::offset_of!(cv_videostab_MotionInpainter, transformedFrame1_) - 504usize];
    ["Offset of field: cv_videostab_MotionInpainter::grayFrame_"]
        [::std::mem::offset_of!(cv_videostab_MotionInpainter, grayFrame_) - 600usize];
    ["Offset of field: cv_videostab_MotionInpainter::transformedGrayFrame1_"]
        [::std::mem::offset_of!(cv_videostab_MotionInpainter, transformedGrayFrame1_) - 696usize];
    ["Offset of field: cv_videostab_MotionInpainter::mask1_"]
        [::std::mem::offset_of!(cv_videostab_MotionInpainter, mask1_) - 792usize];
    ["Offset of field: cv_videostab_MotionInpainter::transformedMask1_"]
        [::std::mem::offset_of!(cv_videostab_MotionInpainter, transformedMask1_) - 888usize];
    ["Offset of field: cv_videostab_MotionInpainter::flowX_"]
        [::std::mem::offset_of!(cv_videostab_MotionInpainter, flowX_) - 984usize];
    ["Offset of field: cv_videostab_MotionInpainter::flowY_"]
        [::std::mem::offset_of!(cv_videostab_MotionInpainter, flowY_) - 1080usize];
    ["Offset of field: cv_videostab_MotionInpainter::flowErrors_"]
        [::std::mem::offset_of!(cv_videostab_MotionInpainter, flowErrors_) - 1176usize];
    ["Offset of field: cv_videostab_MotionInpainter::flowMask_"]
        [::std::mem::offset_of!(cv_videostab_MotionInpainter, flowMask_) - 1272usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab15MotionInpainterC1Ev"]
    pub fn cv_videostab_MotionInpainter_MotionInpainter(this: *mut cv_videostab_MotionInpainter);
}
impl cv_videostab_MotionInpainter {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_videostab_MotionInpainter_MotionInpainter(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab15MotionInpainter7inpaintEiRNS_3MatES3_"]
    pub fn cv_videostab_MotionInpainter_inpaint(
        this: *mut ::std::os::raw::c_void,
        idx: ::std::os::raw::c_int,
        frame: *mut cv_Mat,
        mask: *mut cv_Mat,
    );
}
#[repr(C)]
pub struct cv_videostab_ColorAverageInpainter {
    pub _base: cv_videostab_InpainterBase,
    pub fmm_: cv_videostab_FastMarchingMethod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_ColorAverageInpainter"]
        [::std::mem::size_of::<cv_videostab_ColorAverageInpainter>() - 376usize];
    ["Alignment of cv_videostab_ColorAverageInpainter"]
        [::std::mem::align_of::<cv_videostab_ColorAverageInpainter>() - 8usize];
    ["Offset of field: cv_videostab_ColorAverageInpainter::fmm_"]
        [::std::mem::offset_of!(cv_videostab_ColorAverageInpainter, fmm_) - 48usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab21ColorAverageInpainter7inpaintEiRNS_3MatES3_"]
    pub fn cv_videostab_ColorAverageInpainter_inpaint(
        this: *mut ::std::os::raw::c_void,
        idx: ::std::os::raw::c_int,
        frame: *mut cv_Mat,
        mask: *mut cv_Mat,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_ColorInpainter {
    pub _base: cv_videostab_InpainterBase,
    pub method_: ::std::os::raw::c_int,
    pub radius_: f64,
    pub invMask_: cv_Mat,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_ColorInpainter"]
        [::std::mem::size_of::<cv_videostab_ColorInpainter>() - 160usize];
    ["Alignment of cv_videostab_ColorInpainter"]
        [::std::mem::align_of::<cv_videostab_ColorInpainter>() - 8usize];
    ["Offset of field: cv_videostab_ColorInpainter::method_"]
        [::std::mem::offset_of!(cv_videostab_ColorInpainter, method_) - 48usize];
    ["Offset of field: cv_videostab_ColorInpainter::radius_"]
        [::std::mem::offset_of!(cv_videostab_ColorInpainter, radius_) - 56usize];
    ["Offset of field: cv_videostab_ColorInpainter::invMask_"]
        [::std::mem::offset_of!(cv_videostab_ColorInpainter, invMask_) - 64usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab14ColorInpainter7inpaintEiRNS_3MatES3_"]
    pub fn cv_videostab_ColorInpainter_inpaint(
        this: *mut ::std::os::raw::c_void,
        idx: ::std::os::raw::c_int,
        frame: *mut cv_Mat,
        mask: *mut cv_Mat,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab12calcFlowMaskERKNS_3MatES3_S3_fS3_S3_RS1_"]
    pub fn cv_videostab_calcFlowMask(
        flowX: *const cv_Mat,
        flowY: *const cv_Mat,
        errors: *const cv_Mat,
        maxError: f32,
        mask0: *const cv_Mat,
        mask1: *const cv_Mat,
        flowMask: *mut cv_Mat,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab28completeFrameAccordingToFlowERKNS_3MatES3_S3_S3_S3_fRS1_S4_"]
    pub fn cv_videostab_completeFrameAccordingToFlow(
        flowMask: *const cv_Mat,
        flowX: *const cv_Mat,
        flowY: *const cv_Mat,
        frame1: *const cv_Mat,
        mask1: *const cv_Mat,
        distThresh: f32,
        frame0: *mut cv_Mat,
        mask0: *mut cv_Mat,
    );
}
unsafe extern "C" {
    #[doc = "! @addtogroup videostab\n! @{"]
    #[link_name = "\u{1}_ZN2cv9videostab14calcBlurrinessERKNS_3MatE"]
    pub fn cv_videostab_calcBlurriness(frame: *const cv_Mat) -> f32;
}
#[repr(C)]
pub struct cv_videostab_DeblurerBase__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_DeblurerBase {
    pub vtable_: *const cv_videostab_DeblurerBase__bindgen_vtable,
    pub radius_: ::std::os::raw::c_int,
    pub frames_: *const std_vector,
    pub motions_: *const std_vector,
    pub blurrinessRates_: *const std_vector,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_DeblurerBase"]
        [::std::mem::size_of::<cv_videostab_DeblurerBase>() - 40usize];
    ["Alignment of cv_videostab_DeblurerBase"]
        [::std::mem::align_of::<cv_videostab_DeblurerBase>() - 8usize];
    ["Offset of field: cv_videostab_DeblurerBase::radius_"]
        [::std::mem::offset_of!(cv_videostab_DeblurerBase, radius_) - 8usize];
    ["Offset of field: cv_videostab_DeblurerBase::frames_"]
        [::std::mem::offset_of!(cv_videostab_DeblurerBase, frames_) - 16usize];
    ["Offset of field: cv_videostab_DeblurerBase::motions_"]
        [::std::mem::offset_of!(cv_videostab_DeblurerBase, motions_) - 24usize];
    ["Offset of field: cv_videostab_DeblurerBase::blurrinessRates_"]
        [::std::mem::offset_of!(cv_videostab_DeblurerBase, blurrinessRates_) - 32usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_NullDeblurer {
    pub _base: cv_videostab_DeblurerBase,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_NullDeblurer"]
        [::std::mem::size_of::<cv_videostab_NullDeblurer>() - 40usize];
    ["Alignment of cv_videostab_NullDeblurer"]
        [::std::mem::align_of::<cv_videostab_NullDeblurer>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_WeightingDeblurer {
    pub _base: cv_videostab_DeblurerBase,
    pub sensitivity_: f32,
    pub bSum_: cv_Mat_,
    pub gSum_: cv_Mat_,
    pub rSum_: cv_Mat_,
    pub wSum_: cv_Mat_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_WeightingDeblurer"]
        [::std::mem::size_of::<cv_videostab_WeightingDeblurer>() - 432usize];
    ["Alignment of cv_videostab_WeightingDeblurer"]
        [::std::mem::align_of::<cv_videostab_WeightingDeblurer>() - 8usize];
    ["Offset of field: cv_videostab_WeightingDeblurer::sensitivity_"]
        [::std::mem::offset_of!(cv_videostab_WeightingDeblurer, sensitivity_) - 40usize];
    ["Offset of field: cv_videostab_WeightingDeblurer::bSum_"]
        [::std::mem::offset_of!(cv_videostab_WeightingDeblurer, bSum_) - 48usize];
    ["Offset of field: cv_videostab_WeightingDeblurer::gSum_"]
        [::std::mem::offset_of!(cv_videostab_WeightingDeblurer, gSum_) - 144usize];
    ["Offset of field: cv_videostab_WeightingDeblurer::rSum_"]
        [::std::mem::offset_of!(cv_videostab_WeightingDeblurer, rSum_) - 240usize];
    ["Offset of field: cv_videostab_WeightingDeblurer::wSum_"]
        [::std::mem::offset_of!(cv_videostab_WeightingDeblurer, wSum_) - 336usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab17WeightingDeblurerC1Ev"]
    pub fn cv_videostab_WeightingDeblurer_WeightingDeblurer(
        this: *mut cv_videostab_WeightingDeblurer,
    );
}
impl cv_videostab_WeightingDeblurer {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_videostab_WeightingDeblurer_WeightingDeblurer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab17WeightingDeblurer6deblurEiRNS_3MatE"]
    pub fn cv_videostab_WeightingDeblurer_deblur(
        this: *mut ::std::os::raw::c_void,
        idx: ::std::os::raw::c_int,
        frame: *mut cv_Mat,
    );
}
#[repr(C)]
pub struct cv_videostab_WobbleSuppressorBase__bindgen_vtable(::std::os::raw::c_void);
#[doc = "! @addtogroup videostab\n! @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_WobbleSuppressorBase {
    pub vtable_: *const cv_videostab_WobbleSuppressorBase__bindgen_vtable,
    pub motionEstimator_: cv_Ptr,
    pub frameCount_: ::std::os::raw::c_int,
    pub motions_: *const std_vector,
    pub motions2_: *const std_vector,
    pub stabilizationMotions_: *const std_vector,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_WobbleSuppressorBase"]
        [::std::mem::size_of::<cv_videostab_WobbleSuppressorBase>() - 56usize];
    ["Alignment of cv_videostab_WobbleSuppressorBase"]
        [::std::mem::align_of::<cv_videostab_WobbleSuppressorBase>() - 8usize];
    ["Offset of field: cv_videostab_WobbleSuppressorBase::motionEstimator_"]
        [::std::mem::offset_of!(cv_videostab_WobbleSuppressorBase, motionEstimator_) - 8usize];
    ["Offset of field: cv_videostab_WobbleSuppressorBase::frameCount_"]
        [::std::mem::offset_of!(cv_videostab_WobbleSuppressorBase, frameCount_) - 24usize];
    ["Offset of field: cv_videostab_WobbleSuppressorBase::motions_"]
        [::std::mem::offset_of!(cv_videostab_WobbleSuppressorBase, motions_) - 32usize];
    ["Offset of field: cv_videostab_WobbleSuppressorBase::motions2_"]
        [::std::mem::offset_of!(cv_videostab_WobbleSuppressorBase, motions2_) - 40usize];
    ["Offset of field: cv_videostab_WobbleSuppressorBase::stabilizationMotions_"][::std::mem::offset_of!(
        cv_videostab_WobbleSuppressorBase,
        stabilizationMotions_
    ) - 48usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab20WobbleSuppressorBaseC2Ev"]
    pub fn cv_videostab_WobbleSuppressorBase_WobbleSuppressorBase(
        this: *mut cv_videostab_WobbleSuppressorBase,
    );
}
impl cv_videostab_WobbleSuppressorBase {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_videostab_WobbleSuppressorBase_WobbleSuppressorBase(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_NullWobbleSuppressor {
    pub _base: cv_videostab_WobbleSuppressorBase,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_NullWobbleSuppressor"]
        [::std::mem::size_of::<cv_videostab_NullWobbleSuppressor>() - 56usize];
    ["Alignment of cv_videostab_NullWobbleSuppressor"]
        [::std::mem::align_of::<cv_videostab_NullWobbleSuppressor>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab20NullWobbleSuppressor8suppressEiRKNS_3MatERS2_"]
    pub fn cv_videostab_NullWobbleSuppressor_suppress(
        this: *mut ::std::os::raw::c_void,
        idx: ::std::os::raw::c_int,
        frame: *const cv_Mat,
        result: *mut cv_Mat,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_MoreAccurateMotionWobbleSuppressorBase {
    pub _base: cv_videostab_WobbleSuppressorBase,
    pub period_: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_MoreAccurateMotionWobbleSuppressorBase"]
        [::std::mem::size_of::<cv_videostab_MoreAccurateMotionWobbleSuppressorBase>() - 64usize];
    ["Alignment of cv_videostab_MoreAccurateMotionWobbleSuppressorBase"]
        [::std::mem::align_of::<cv_videostab_MoreAccurateMotionWobbleSuppressorBase>() - 8usize];
    ["Offset of field: cv_videostab_MoreAccurateMotionWobbleSuppressorBase::period_"][::std::mem::offset_of!(
        cv_videostab_MoreAccurateMotionWobbleSuppressorBase,
        period_
    ) - 56usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cv_videostab_MoreAccurateMotionWobbleSuppressor {
    pub _base: cv_videostab_MoreAccurateMotionWobbleSuppressorBase,
    pub mapx_: cv_Mat_,
    pub mapy_: cv_Mat_,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_MoreAccurateMotionWobbleSuppressor"]
        [::std::mem::size_of::<cv_videostab_MoreAccurateMotionWobbleSuppressor>() - 256usize];
    ["Alignment of cv_videostab_MoreAccurateMotionWobbleSuppressor"]
        [::std::mem::align_of::<cv_videostab_MoreAccurateMotionWobbleSuppressor>() - 8usize];
    ["Offset of field: cv_videostab_MoreAccurateMotionWobbleSuppressor::mapx_"]
        [::std::mem::offset_of!(cv_videostab_MoreAccurateMotionWobbleSuppressor, mapx_) - 64usize];
    ["Offset of field: cv_videostab_MoreAccurateMotionWobbleSuppressor::mapy_"]
        [::std::mem::offset_of!(cv_videostab_MoreAccurateMotionWobbleSuppressor, mapy_) - 160usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab34MoreAccurateMotionWobbleSuppressor8suppressEiRKNS_3MatERS2_"]
    pub fn cv_videostab_MoreAccurateMotionWobbleSuppressor_suppress(
        this: *mut ::std::os::raw::c_void,
        idx: ::std::os::raw::c_int,
        frame: *const cv_Mat,
        result: *mut cv_Mat,
    );
}
#[repr(C)]
pub struct cv_videostab_StabilizerBase__bindgen_vtable(::std::os::raw::c_void);
#[doc = "! @addtogroup videostab\n! @{"]
#[repr(C)]
pub struct cv_videostab_StabilizerBase {
    pub vtable_: *const cv_videostab_StabilizerBase__bindgen_vtable,
    pub log_: cv_Ptr,
    pub frameSource_: cv_Ptr,
    pub maskSource_: cv_Ptr,
    pub motionEstimator_: cv_Ptr,
    pub deblurer_: cv_Ptr,
    pub inpainter_: cv_Ptr,
    pub radius_: ::std::os::raw::c_int,
    pub trimRatio_: f32,
    pub doCorrectionForInclusion_: bool,
    pub borderMode_: ::std::os::raw::c_int,
    pub frameSize_: cv_Size,
    pub frameMask_: cv_Mat,
    pub curPos_: ::std::os::raw::c_int,
    pub curStabilizedPos_: ::std::os::raw::c_int,
    pub doDeblurring_: bool,
    pub preProcessedFrame_: cv_Mat,
    pub doInpainting_: bool,
    pub inpaintingMask_: cv_Mat,
    pub finalFrame_: cv_Mat,
    pub frames_: std_vector,
    pub motions_: std_vector,
    pub blurrinessRates_: std_vector,
    pub stabilizedFrames_: std_vector,
    pub stabilizedMasks_: std_vector,
    pub stabilizationMotions_: std_vector,
    pub processingStartTime_: clock_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_StabilizerBase"]
        [::std::mem::size_of::<cv_videostab_StabilizerBase>() - 688usize];
    ["Alignment of cv_videostab_StabilizerBase"]
        [::std::mem::align_of::<cv_videostab_StabilizerBase>() - 8usize];
    ["Offset of field: cv_videostab_StabilizerBase::log_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, log_) - 8usize];
    ["Offset of field: cv_videostab_StabilizerBase::frameSource_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, frameSource_) - 24usize];
    ["Offset of field: cv_videostab_StabilizerBase::maskSource_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, maskSource_) - 40usize];
    ["Offset of field: cv_videostab_StabilizerBase::motionEstimator_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, motionEstimator_) - 56usize];
    ["Offset of field: cv_videostab_StabilizerBase::deblurer_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, deblurer_) - 72usize];
    ["Offset of field: cv_videostab_StabilizerBase::inpainter_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, inpainter_) - 88usize];
    ["Offset of field: cv_videostab_StabilizerBase::radius_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, radius_) - 104usize];
    ["Offset of field: cv_videostab_StabilizerBase::trimRatio_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, trimRatio_) - 108usize];
    ["Offset of field: cv_videostab_StabilizerBase::doCorrectionForInclusion_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, doCorrectionForInclusion_) - 112usize];
    ["Offset of field: cv_videostab_StabilizerBase::borderMode_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, borderMode_) - 116usize];
    ["Offset of field: cv_videostab_StabilizerBase::frameSize_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, frameSize_) - 120usize];
    ["Offset of field: cv_videostab_StabilizerBase::frameMask_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, frameMask_) - 128usize];
    ["Offset of field: cv_videostab_StabilizerBase::curPos_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, curPos_) - 224usize];
    ["Offset of field: cv_videostab_StabilizerBase::curStabilizedPos_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, curStabilizedPos_) - 228usize];
    ["Offset of field: cv_videostab_StabilizerBase::doDeblurring_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, doDeblurring_) - 232usize];
    ["Offset of field: cv_videostab_StabilizerBase::preProcessedFrame_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, preProcessedFrame_) - 240usize];
    ["Offset of field: cv_videostab_StabilizerBase::doInpainting_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, doInpainting_) - 336usize];
    ["Offset of field: cv_videostab_StabilizerBase::inpaintingMask_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, inpaintingMask_) - 344usize];
    ["Offset of field: cv_videostab_StabilizerBase::finalFrame_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, finalFrame_) - 440usize];
    ["Offset of field: cv_videostab_StabilizerBase::frames_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, frames_) - 536usize];
    ["Offset of field: cv_videostab_StabilizerBase::motions_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, motions_) - 560usize];
    ["Offset of field: cv_videostab_StabilizerBase::blurrinessRates_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, blurrinessRates_) - 584usize];
    ["Offset of field: cv_videostab_StabilizerBase::stabilizedFrames_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, stabilizedFrames_) - 608usize];
    ["Offset of field: cv_videostab_StabilizerBase::stabilizedMasks_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, stabilizedMasks_) - 632usize];
    ["Offset of field: cv_videostab_StabilizerBase::stabilizationMotions_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, stabilizationMotions_) - 656usize];
    ["Offset of field: cv_videostab_StabilizerBase::processingStartTime_"]
        [::std::mem::offset_of!(cv_videostab_StabilizerBase, processingStartTime_) - 680usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab14StabilizerBase5resetEv"]
    pub fn cv_videostab_StabilizerBase_reset(this: *mut cv_videostab_StabilizerBase);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab14StabilizerBase19nextStabilizedFrameEv"]
    pub fn cv_videostab_StabilizerBase_nextStabilizedFrame(
        this: *mut cv_videostab_StabilizerBase,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab14StabilizerBase14doOneIterationEv"]
    pub fn cv_videostab_StabilizerBase_doOneIteration(
        this: *mut cv_videostab_StabilizerBase,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab14StabilizerBase14stabilizeFrameEv"]
    pub fn cv_videostab_StabilizerBase_stabilizeFrame(this: *mut cv_videostab_StabilizerBase);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab14StabilizerBase17logProcessingTimeEv"]
    pub fn cv_videostab_StabilizerBase_logProcessingTime(this: *mut cv_videostab_StabilizerBase);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab14StabilizerBaseC2Ev"]
    pub fn cv_videostab_StabilizerBase_StabilizerBase(this: *mut cv_videostab_StabilizerBase);
}
impl cv_videostab_StabilizerBase {
    #[inline]
    pub unsafe fn reset(&mut self) {
        cv_videostab_StabilizerBase_reset(self)
    }
    #[inline]
    pub unsafe fn nextStabilizedFrame(&mut self) -> cv_Mat {
        cv_videostab_StabilizerBase_nextStabilizedFrame(self)
    }
    #[inline]
    pub unsafe fn doOneIteration(&mut self) -> bool {
        cv_videostab_StabilizerBase_doOneIteration(self)
    }
    #[inline]
    pub unsafe fn stabilizeFrame(&mut self) {
        cv_videostab_StabilizerBase_stabilizeFrame(self)
    }
    #[inline]
    pub unsafe fn logProcessingTime(&mut self) {
        cv_videostab_StabilizerBase_logProcessingTime(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_videostab_StabilizerBase_StabilizerBase(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab14StabilizerBase5setUpERKNS_3MatE"]
    pub fn cv_videostab_StabilizerBase_setUp(
        this: *mut ::std::os::raw::c_void,
        firstFrame: *const cv_Mat,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab14StabilizerBase16postProcessFrameERKNS_3MatE"]
    pub fn cv_videostab_StabilizerBase_postProcessFrame(
        this: *mut ::std::os::raw::c_void,
        frame: *const cv_Mat,
    ) -> cv_Mat;
}
#[repr(C)]
pub struct cv_videostab_OnePassStabilizer {
    pub _base: cv_videostab_StabilizerBase,
    pub _base_1: cv_videostab_IFrameSource,
    pub motionFilter_: cv_Ptr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_OnePassStabilizer"]
        [::std::mem::size_of::<cv_videostab_OnePassStabilizer>() - 712usize];
    ["Alignment of cv_videostab_OnePassStabilizer"]
        [::std::mem::align_of::<cv_videostab_OnePassStabilizer>() - 8usize];
    ["Offset of field: cv_videostab_OnePassStabilizer::motionFilter_"]
        [::std::mem::offset_of!(cv_videostab_OnePassStabilizer, motionFilter_) - 696usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab17OnePassStabilizerC1Ev"]
    pub fn cv_videostab_OnePassStabilizer_OnePassStabilizer(
        this: *mut cv_videostab_OnePassStabilizer,
    );
}
impl cv_videostab_OnePassStabilizer {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_videostab_OnePassStabilizer_OnePassStabilizer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZThn688_N2cv9videostab17OnePassStabilizer5resetEv"]
    pub fn cv_videostab_OnePassStabilizer_reset(this: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab17OnePassStabilizer5setUpERKNS_3MatE"]
    pub fn cv_videostab_OnePassStabilizer_setUp(
        this: *mut ::std::os::raw::c_void,
        firstFrame: *const cv_Mat,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab17OnePassStabilizer14estimateMotionEv"]
    pub fn cv_videostab_OnePassStabilizer_estimateMotion(
        this: *mut ::std::os::raw::c_void,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab17OnePassStabilizer27estimateStabilizationMotionEv"]
    pub fn cv_videostab_OnePassStabilizer_estimateStabilizationMotion(
        this: *mut ::std::os::raw::c_void,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab17OnePassStabilizer16postProcessFrameERKNS_3MatE"]
    pub fn cv_videostab_OnePassStabilizer_postProcessFrame(
        this: *mut ::std::os::raw::c_void,
        frame: *const cv_Mat,
    ) -> cv_Mat;
}
#[repr(C)]
pub struct cv_videostab_TwoPassStabilizer {
    pub _base: cv_videostab_StabilizerBase,
    pub _base_1: cv_videostab_IFrameSource,
    pub motionStabilizer_: cv_Ptr,
    pub wobbleSuppressor_: cv_Ptr,
    pub mustEstTrimRatio_: bool,
    pub frameCount_: ::std::os::raw::c_int,
    pub isPrePassDone_: bool,
    pub doWobbleSuppression_: bool,
    pub motions2_: std_vector,
    pub suppressedFrame_: cv_Mat,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_videostab_TwoPassStabilizer"]
        [::std::mem::size_of::<cv_videostab_TwoPassStabilizer>() - 864usize];
    ["Alignment of cv_videostab_TwoPassStabilizer"]
        [::std::mem::align_of::<cv_videostab_TwoPassStabilizer>() - 8usize];
    ["Offset of field: cv_videostab_TwoPassStabilizer::motionStabilizer_"]
        [::std::mem::offset_of!(cv_videostab_TwoPassStabilizer, motionStabilizer_) - 696usize];
    ["Offset of field: cv_videostab_TwoPassStabilizer::wobbleSuppressor_"]
        [::std::mem::offset_of!(cv_videostab_TwoPassStabilizer, wobbleSuppressor_) - 712usize];
    ["Offset of field: cv_videostab_TwoPassStabilizer::mustEstTrimRatio_"]
        [::std::mem::offset_of!(cv_videostab_TwoPassStabilizer, mustEstTrimRatio_) - 728usize];
    ["Offset of field: cv_videostab_TwoPassStabilizer::frameCount_"]
        [::std::mem::offset_of!(cv_videostab_TwoPassStabilizer, frameCount_) - 732usize];
    ["Offset of field: cv_videostab_TwoPassStabilizer::isPrePassDone_"]
        [::std::mem::offset_of!(cv_videostab_TwoPassStabilizer, isPrePassDone_) - 736usize];
    ["Offset of field: cv_videostab_TwoPassStabilizer::doWobbleSuppression_"]
        [::std::mem::offset_of!(cv_videostab_TwoPassStabilizer, doWobbleSuppression_) - 737usize];
    ["Offset of field: cv_videostab_TwoPassStabilizer::motions2_"]
        [::std::mem::offset_of!(cv_videostab_TwoPassStabilizer, motions2_) - 744usize];
    ["Offset of field: cv_videostab_TwoPassStabilizer::suppressedFrame_"]
        [::std::mem::offset_of!(cv_videostab_TwoPassStabilizer, suppressedFrame_) - 768usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab17TwoPassStabilizer21runPrePassIfNecessaryEv"]
    pub fn cv_videostab_TwoPassStabilizer_runPrePassIfNecessary(
        this: *mut cv_videostab_TwoPassStabilizer,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab17TwoPassStabilizerC1Ev"]
    pub fn cv_videostab_TwoPassStabilizer_TwoPassStabilizer(
        this: *mut cv_videostab_TwoPassStabilizer,
    );
}
impl cv_videostab_TwoPassStabilizer {
    #[inline]
    pub unsafe fn runPrePassIfNecessary(&mut self) {
        cv_videostab_TwoPassStabilizer_runPrePassIfNecessary(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_videostab_TwoPassStabilizer_TwoPassStabilizer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZThn688_N2cv9videostab17TwoPassStabilizer5resetEv"]
    pub fn cv_videostab_TwoPassStabilizer_reset(this: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZThn688_N2cv9videostab17TwoPassStabilizer9nextFrameEv"]
    pub fn cv_videostab_TwoPassStabilizer_nextFrame(this: *mut ::std::os::raw::c_void) -> cv_Mat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab17TwoPassStabilizer5setUpERKNS_3MatE"]
    pub fn cv_videostab_TwoPassStabilizer_setUp(
        this: *mut ::std::os::raw::c_void,
        firstFrame: *const cv_Mat,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab17TwoPassStabilizer14estimateMotionEv"]
    pub fn cv_videostab_TwoPassStabilizer_estimateMotion(
        this: *mut ::std::os::raw::c_void,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab17TwoPassStabilizer27estimateStabilizationMotionEv"]
    pub fn cv_videostab_TwoPassStabilizer_estimateStabilizationMotion(
        this: *mut ::std::os::raw::c_void,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv9videostab17TwoPassStabilizer16postProcessFrameERKNS_3MatE"]
    pub fn cv_videostab_TwoPassStabilizer_postProcessFrame(
        this: *mut ::std::os::raw::c_void,
        frame: *const cv_Mat,
    ) -> cv_Mat;
}
#[doc = " @brief This class represents color in BGR order."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_viz_Color {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_Color"][::std::mem::size_of::<cv_viz_Color>() - 32usize];
    ["Alignment of cv_viz_Color"][::std::mem::align_of::<cv_viz_Color>() - 8usize];
};
#[doc = " @brief This class wraps mesh attributes, and it can load a mesh from a ply file. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_Mesh {
    #[doc = "!< point coordinates of type CV_32FC3 or CV_64FC3 with only 1 row"]
    pub cloud: cv_Mat,
    #[doc = "!< point color of type CV_8UC3 or CV_8UC4 with only 1 row"]
    pub colors: cv_Mat,
    #[doc = "!< point normals of type CV_32FC3, CV_32FC4, CV_64FC3 or CV_64FC4 with only 1 row"]
    pub normals: cv_Mat,
    #[doc = "!< CV_32SC1 with only 1 row"]
    pub polygons: cv_Mat,
    pub texture: cv_Mat,
    #[doc = "!< CV_32FC2 or CV_64FC2 with only 1 row"]
    pub tcoords: cv_Mat,
}
pub const cv_viz_Mesh_LOAD_AUTO: cv_viz_Mesh__bindgen_ty_1 = 0;
pub const cv_viz_Mesh_LOAD_PLY: cv_viz_Mesh__bindgen_ty_1 = 1;
pub const cv_viz_Mesh_LOAD_OBJ: cv_viz_Mesh__bindgen_ty_1 = 2;
pub type cv_viz_Mesh__bindgen_ty_1 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_Mesh"][::std::mem::size_of::<cv_viz_Mesh>() - 576usize];
    ["Alignment of cv_viz_Mesh"][::std::mem::align_of::<cv_viz_Mesh>() - 8usize];
    ["Offset of field: cv_viz_Mesh::cloud"][::std::mem::offset_of!(cv_viz_Mesh, cloud) - 0usize];
    ["Offset of field: cv_viz_Mesh::colors"][::std::mem::offset_of!(cv_viz_Mesh, colors) - 96usize];
    ["Offset of field: cv_viz_Mesh::normals"]
        [::std::mem::offset_of!(cv_viz_Mesh, normals) - 192usize];
    ["Offset of field: cv_viz_Mesh::polygons"]
        [::std::mem::offset_of!(cv_viz_Mesh, polygons) - 288usize];
    ["Offset of field: cv_viz_Mesh::texture"]
        [::std::mem::offset_of!(cv_viz_Mesh, texture) - 384usize];
    ["Offset of field: cv_viz_Mesh::tcoords"]
        [::std::mem::offset_of!(cv_viz_Mesh, tcoords) - 480usize];
};
unsafe extern "C" {
    #[doc = " @brief Loads a mesh from a ply or a obj file.\n\n@param file File name\n@param type File type (for now only PLY and OBJ are supported)\n\nFile type** can be one of the following:\n-   **LOAD_PLY**\n-   **LOAD_OBJ**"]
    #[link_name = "\u{1}_ZN2cv3viz4Mesh4loadERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
    pub fn cv_viz_Mesh_load(file: *const cv_String, type_: ::std::os::raw::c_int) -> cv_viz_Mesh;
}
impl cv_viz_Mesh {
    #[inline]
    pub unsafe fn load(file: *const cv_String, type_: ::std::os::raw::c_int) -> cv_viz_Mesh {
        cv_viz_Mesh_load(file, type_)
    }
}
#[doc = " @brief This class wraps intrinsic parameters of a camera.\n\nIt provides several constructors that can extract the intrinsic parameters from field of\nview, intrinsic matrix and projection matrix. :"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_viz_Camera {
    #[doc = " The near plane and the far plane.\n  - clip_[0]: the near plane; default value is 0.01\n  - clip_[1]: the far plane; default value is 1000.01"]
    pub clip_: cv_Vec2d,
    #[doc = " Field of view.\n  - fov_[0]: horizontal(x-axis) field of view in radians\n  - fov_[1]: vertical(y-axis) field of view in radians"]
    pub fov_: cv_Vec2d,
    #[doc = " Window size."]
    pub window_size_: cv_Size,
    #[doc = " Principal point.\n  - principal_point_[0]: cx\n  - principal_point_[1]: cy"]
    pub principal_point_: cv_Vec2d,
    #[doc = " Focal length.\n  - focal_[0]: fx\n  - focal_[1]: fy"]
    pub focal_: cv_Vec2d,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_Camera"][::std::mem::size_of::<cv_viz_Camera>() - 72usize];
    ["Alignment of cv_viz_Camera"][::std::mem::align_of::<cv_viz_Camera>() - 8usize];
    ["Offset of field: cv_viz_Camera::clip_"]
        [::std::mem::offset_of!(cv_viz_Camera, clip_) - 0usize];
    ["Offset of field: cv_viz_Camera::fov_"][::std::mem::offset_of!(cv_viz_Camera, fov_) - 16usize];
    ["Offset of field: cv_viz_Camera::window_size_"]
        [::std::mem::offset_of!(cv_viz_Camera, window_size_) - 32usize];
    ["Offset of field: cv_viz_Camera::principal_point_"]
        [::std::mem::offset_of!(cv_viz_Camera, principal_point_) - 40usize];
    ["Offset of field: cv_viz_Camera::focal_"]
        [::std::mem::offset_of!(cv_viz_Camera, focal_) - 56usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3viz6Camera13setWindowSizeERKNS_5Size_IiEE"]
    pub fn cv_viz_Camera_setWindowSize(this: *mut cv_viz_Camera, window_size: *const cv_Size);
}
unsafe extern "C" {
    #[doc = " @brief Computes projection matrix using intrinsic parameters of the camera.\n\n\n@param proj Output projection matrix with the following form\n\\f[\n\\begin{bmatrix}\n\\frac{2n}{r-l} &        0       & \\frac{r+l}{r-l}  & 0\\\\\n0        & \\frac{2n}{t-b} & \\frac{t+b}{t-b}  & 0\\\\\n0        &        0       & -\\frac{f+n}{f-n} & -\\frac{2fn}{f-n}\\\\\n0        &        0       & -1               & 0\\\\\n\\end{bmatrix}\n\\f]"]
    #[link_name = "\u{1}_ZNK2cv3viz6Camera23computeProjectionMatrixERNS_4MatxIdLi4ELi4EEE"]
    pub fn cv_viz_Camera_computeProjectionMatrix(this: *const cv_viz_Camera, proj: *mut cv_Matx44d);
}
unsafe extern "C" {
    #[doc = " @brief Creates a Kinect Camera with\n- fx = fy = 525\n- cx = 320\n- cy = 240\n\n@param window_size Size of the window. This together with intrinsic matrix of a Kinect Camera\ndetermines the field of view."]
    #[link_name = "\u{1}_ZN2cv3viz6Camera12KinectCameraERKNS_5Size_IiEE"]
    pub fn cv_viz_Camera_KinectCamera(window_size: *const cv_Size) -> cv_viz_Camera;
}
unsafe extern "C" {
    #[doc = " @brief Constructs a Camera.\n\n@param fx Horizontal focal length.\n@param fy Vertical focal length.\n@param cx x coordinate of the principal point.\n@param cy y coordinate of the principal point.\n@param window_size Size of the window. This together with focal length and principal\npoint determines the field of view."]
    #[link_name = "\u{1}_ZN2cv3viz6CameraC1EddddRKNS_5Size_IiEE"]
    pub fn cv_viz_Camera_Camera(
        this: *mut cv_viz_Camera,
        fx: f64,
        fy: f64,
        cx: f64,
        cy: f64,
        window_size: *const cv_Size,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param fov Field of view (horizontal, vertical)\n@param window_size Size of the window. Principal point is at the center of the window\nby default."]
    #[link_name = "\u{1}_ZN2cv3viz6CameraC1ERKNS_3VecIdLi2EEERKNS_5Size_IiEE"]
    pub fn cv_viz_Camera_Camera1(
        this: *mut cv_viz_Camera,
        fov: *const cv_Vec2d,
        window_size: *const cv_Size,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param K Intrinsic matrix of the camera with the following form\n\\f[\n\\begin{bmatrix}\nf_x &   0 & c_x\\\\\n0 & f_y & c_y\\\\\n0 &   0 &   1\\\\\n\\end{bmatrix}\n\\f]\n@param window_size Size of the window. This together with intrinsic matrix determines\nthe field of view."]
    #[link_name = "\u{1}_ZN2cv3viz6CameraC1ERKNS_4MatxIdLi3ELi3EEERKNS_5Size_IiEE"]
    pub fn cv_viz_Camera_Camera2(
        this: *mut cv_viz_Camera,
        K: *const cv_Matx33d,
        window_size: *const cv_Size,
    );
}
unsafe extern "C" {
    #[doc = " @overload\n@param proj Projection matrix of the camera with the following form\n\\f[\n\\begin{bmatrix}\n\\frac{2n}{r-l} &        0       & \\frac{r+l}{r-l}  & 0\\\\\n0        & \\frac{2n}{t-b} & \\frac{t+b}{t-b}  & 0\\\\\n0        &        0       & -\\frac{f+n}{f-n} & -\\frac{2fn}{f-n}\\\\\n0        &        0       & -1               & 0\\\\\n\\end{bmatrix}\n\\f]\n\n@param window_size Size of the window. This together with projection matrix determines\nthe field of view."]
    #[link_name = "\u{1}_ZN2cv3viz6CameraC1ERKNS_4MatxIdLi4ELi4EEERKNS_5Size_IiEE"]
    pub fn cv_viz_Camera_Camera3(
        this: *mut cv_viz_Camera,
        proj: *const cv_Matx44d,
        window_size: *const cv_Size,
    );
}
impl cv_viz_Camera {
    #[inline]
    pub unsafe fn setWindowSize(&mut self, window_size: *const cv_Size) {
        cv_viz_Camera_setWindowSize(self, window_size)
    }
    #[inline]
    pub unsafe fn computeProjectionMatrix(&self, proj: *mut cv_Matx44d) {
        cv_viz_Camera_computeProjectionMatrix(self, proj)
    }
    #[inline]
    pub unsafe fn KinectCamera(window_size: *const cv_Size) -> cv_viz_Camera {
        cv_viz_Camera_KinectCamera(window_size)
    }
    #[inline]
    pub unsafe fn new(fx: f64, fy: f64, cx: f64, cy: f64, window_size: *const cv_Size) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_Camera_Camera(__bindgen_tmp.as_mut_ptr(), fx, fy, cx, cy, window_size);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(fov: *const cv_Vec2d, window_size: *const cv_Size) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_Camera_Camera1(__bindgen_tmp.as_mut_ptr(), fov, window_size);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(K: *const cv_Matx33d, window_size: *const cv_Size) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_Camera_Camera2(__bindgen_tmp.as_mut_ptr(), K, window_size);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(proj: *const cv_Matx44d, window_size: *const cv_Size) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_Camera_Camera3(__bindgen_tmp.as_mut_ptr(), proj, window_size);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This class represents a keyboard event."]
#[repr(C)]
pub struct cv_viz_KeyboardEvent {
    pub action: cv_viz_KeyboardEvent_Action,
    pub symbol: cv_String,
    pub code: ::std::os::raw::c_uchar,
    pub modifiers: ::std::os::raw::c_int,
}
pub const cv_viz_KeyboardEvent_NONE: cv_viz_KeyboardEvent__bindgen_ty_1 = 0;
pub const cv_viz_KeyboardEvent_ALT: cv_viz_KeyboardEvent__bindgen_ty_1 = 1;
pub const cv_viz_KeyboardEvent_CTRL: cv_viz_KeyboardEvent__bindgen_ty_1 = 2;
pub const cv_viz_KeyboardEvent_SHIFT: cv_viz_KeyboardEvent__bindgen_ty_1 = 4;
pub type cv_viz_KeyboardEvent__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const cv_viz_KeyboardEvent_Action_KEY_UP: cv_viz_KeyboardEvent_Action = 0;
pub const cv_viz_KeyboardEvent_Action_KEY_DOWN: cv_viz_KeyboardEvent_Action = 1;
pub type cv_viz_KeyboardEvent_Action = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_KeyboardEvent"][::std::mem::size_of::<cv_viz_KeyboardEvent>() - 48usize];
    ["Alignment of cv_viz_KeyboardEvent"][::std::mem::align_of::<cv_viz_KeyboardEvent>() - 8usize];
    ["Offset of field: cv_viz_KeyboardEvent::action"]
        [::std::mem::offset_of!(cv_viz_KeyboardEvent, action) - 0usize];
    ["Offset of field: cv_viz_KeyboardEvent::symbol"]
        [::std::mem::offset_of!(cv_viz_KeyboardEvent, symbol) - 8usize];
    ["Offset of field: cv_viz_KeyboardEvent::code"]
        [::std::mem::offset_of!(cv_viz_KeyboardEvent, code) - 40usize];
    ["Offset of field: cv_viz_KeyboardEvent::modifiers"]
        [::std::mem::offset_of!(cv_viz_KeyboardEvent, modifiers) - 44usize];
};
unsafe extern "C" {
    #[doc = " @brief Constructs a KeyboardEvent.\n\n@param action Signals if key is pressed or released.\n@param symbol Name of the key.\n@param code Code of the key.\n@param modifiers Signals if alt, ctrl or shift are pressed or their combination."]
    #[link_name = "\u{1}_ZN2cv3viz13KeyboardEventC1ENS1_6ActionERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEhi"]
    pub fn cv_viz_KeyboardEvent_KeyboardEvent(
        this: *mut cv_viz_KeyboardEvent,
        action: cv_viz_KeyboardEvent_Action,
        symbol: *const cv_String,
        code: ::std::os::raw::c_uchar,
        modifiers: ::std::os::raw::c_int,
    );
}
impl cv_viz_KeyboardEvent {
    #[inline]
    pub unsafe fn new(
        action: cv_viz_KeyboardEvent_Action,
        symbol: *const cv_String,
        code: ::std::os::raw::c_uchar,
        modifiers: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_KeyboardEvent_KeyboardEvent(
            __bindgen_tmp.as_mut_ptr(),
            action,
            symbol,
            code,
            modifiers,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This class represents a mouse event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_viz_MouseEvent {
    pub type_: cv_viz_MouseEvent_Type,
    pub button: cv_viz_MouseEvent_MouseButton,
    pub pointer: cv_Point,
    pub modifiers: ::std::os::raw::c_int,
}
pub const cv_viz_MouseEvent_Type_MouseMove: cv_viz_MouseEvent_Type = 1;
pub const cv_viz_MouseEvent_Type_MouseButtonPress: cv_viz_MouseEvent_Type = 2;
pub const cv_viz_MouseEvent_Type_MouseButtonRelease: cv_viz_MouseEvent_Type = 3;
pub const cv_viz_MouseEvent_Type_MouseScrollDown: cv_viz_MouseEvent_Type = 4;
pub const cv_viz_MouseEvent_Type_MouseScrollUp: cv_viz_MouseEvent_Type = 5;
pub const cv_viz_MouseEvent_Type_MouseDblClick: cv_viz_MouseEvent_Type = 6;
pub type cv_viz_MouseEvent_Type = ::std::os::raw::c_uint;
pub const cv_viz_MouseEvent_MouseButton_NoButton: cv_viz_MouseEvent_MouseButton = 0;
pub const cv_viz_MouseEvent_MouseButton_LeftButton: cv_viz_MouseEvent_MouseButton = 1;
pub const cv_viz_MouseEvent_MouseButton_MiddleButton: cv_viz_MouseEvent_MouseButton = 2;
pub const cv_viz_MouseEvent_MouseButton_RightButton: cv_viz_MouseEvent_MouseButton = 3;
pub const cv_viz_MouseEvent_MouseButton_VScroll: cv_viz_MouseEvent_MouseButton = 4;
pub type cv_viz_MouseEvent_MouseButton = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_MouseEvent"][::std::mem::size_of::<cv_viz_MouseEvent>() - 20usize];
    ["Alignment of cv_viz_MouseEvent"][::std::mem::align_of::<cv_viz_MouseEvent>() - 4usize];
    ["Offset of field: cv_viz_MouseEvent::type_"]
        [::std::mem::offset_of!(cv_viz_MouseEvent, type_) - 0usize];
    ["Offset of field: cv_viz_MouseEvent::button"]
        [::std::mem::offset_of!(cv_viz_MouseEvent, button) - 4usize];
    ["Offset of field: cv_viz_MouseEvent::pointer"]
        [::std::mem::offset_of!(cv_viz_MouseEvent, pointer) - 8usize];
    ["Offset of field: cv_viz_MouseEvent::modifiers"]
        [::std::mem::offset_of!(cv_viz_MouseEvent, modifiers) - 16usize];
};
unsafe extern "C" {
    #[doc = " @brief Constructs a MouseEvent.\n\n@param type Type of the event. This can be **MouseMove**, **MouseButtonPress**,\nMouseButtonRelease**, **MouseScrollDown**, **MouseScrollUp**, **MouseDblClick**.\n@param button Mouse button. This can be **NoButton**, **LeftButton**, **MiddleButton**,\nRightButton**, **VScroll**.\n@param pointer Position of the event.\n@param modifiers Signals if alt, ctrl or shift are pressed or their combination."]
    #[link_name = "\u{1}_ZN2cv3viz10MouseEventC1ERKNS1_4TypeERKNS1_11MouseButtonERKNS_6Point_IiEEi"]
    pub fn cv_viz_MouseEvent_MouseEvent(
        this: *mut cv_viz_MouseEvent,
        type_: *const cv_viz_MouseEvent_Type,
        button: *const cv_viz_MouseEvent_MouseButton,
        pointer: *const cv_Point,
        modifiers: ::std::os::raw::c_int,
    );
}
impl cv_viz_MouseEvent {
    #[inline]
    pub unsafe fn new(
        type_: *const cv_viz_MouseEvent_Type,
        button: *const cv_viz_MouseEvent_MouseButton,
        pointer: *const cv_Point,
        modifiers: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_MouseEvent_MouseEvent(
            __bindgen_tmp.as_mut_ptr(),
            type_,
            button,
            pointer,
            modifiers,
        );
        __bindgen_tmp.assume_init()
    }
}
pub const cv_viz_RenderingProperties_POINT_SIZE: cv_viz_RenderingProperties = 0;
pub const cv_viz_RenderingProperties_OPACITY: cv_viz_RenderingProperties = 1;
pub const cv_viz_RenderingProperties_LINE_WIDTH: cv_viz_RenderingProperties = 2;
pub const cv_viz_RenderingProperties_FONT_SIZE: cv_viz_RenderingProperties = 3;
pub const cv_viz_RenderingProperties_REPRESENTATION: cv_viz_RenderingProperties = 4;
pub const cv_viz_RenderingProperties_IMMEDIATE_RENDERING: cv_viz_RenderingProperties = 5;
pub const cv_viz_RenderingProperties_SHADING: cv_viz_RenderingProperties = 6;
pub const cv_viz_RenderingProperties_AMBIENT: cv_viz_RenderingProperties = 7;
pub const cv_viz_RenderingProperties_LIGHTING: cv_viz_RenderingProperties = 8;
#[doc = "\n Widget rendering properties"]
pub type cv_viz_RenderingProperties = ::std::os::raw::c_uint;
pub const cv_viz_RepresentationValues_REPRESENTATION_POINTS: cv_viz_RepresentationValues = 0;
pub const cv_viz_RepresentationValues_REPRESENTATION_WIREFRAME: cv_viz_RepresentationValues = 1;
pub const cv_viz_RepresentationValues_REPRESENTATION_SURFACE: cv_viz_RepresentationValues = 2;
pub type cv_viz_RepresentationValues = ::std::os::raw::c_uint;
pub const cv_viz_ShadingValues_SHADING_FLAT: cv_viz_ShadingValues = 0;
pub const cv_viz_ShadingValues_SHADING_GOURAUD: cv_viz_ShadingValues = 1;
pub const cv_viz_ShadingValues_SHADING_PHONG: cv_viz_ShadingValues = 2;
pub type cv_viz_ShadingValues = ::std::os::raw::c_uint;
#[repr(C)]
pub struct cv_viz_Widget__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief Base class of all widgets. Widget is implicitly shared."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_Widget {
    pub vtable_: *const cv_viz_Widget__bindgen_vtable,
    pub impl_: *mut cv_viz_Widget_Impl,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_viz_Widget_Impl {
    _unused: [u8; 0],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_Widget"][::std::mem::size_of::<cv_viz_Widget>() - 16usize];
    ["Alignment of cv_viz_Widget"][::std::mem::align_of::<cv_viz_Widget>() - 8usize];
    ["Offset of field: cv_viz_Widget::impl_"]
        [::std::mem::offset_of!(cv_viz_Widget, impl_) - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates a widget from ply file.\n\n@param file_name Ply file name."]
    #[link_name = "\u{1}_ZN2cv3viz6Widget11fromPlyFileERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_viz_Widget_fromPlyFile(file_name: *const cv_String) -> cv_viz_Widget;
}
unsafe extern "C" {
    #[doc = " @brief Sets rendering property of the widget.\n\n@param property Property that will be modified.\n@param value The new value of the property.\n\nRendering property can be one of the following:\n-   **POINT_SIZE**\n-   **OPACITY**\n-   **LINE_WIDTH**\n-   **FONT_SIZE**\n\nREPRESENTATION: Expected values are\n-   **REPRESENTATION_POINTS**\n-   **REPRESENTATION_WIREFRAME**\n-   **REPRESENTATION_SURFACE**\n\nIMMEDIATE_RENDERING:\n-   Turn on immediate rendering by setting the value to 1.\n-   Turn off immediate rendering by setting the value to 0.\n\nSHADING: Expected values are\n-   **SHADING_FLAT**\n-   **SHADING_GOURAUD**\n-   **SHADING_PHONG**"]
    #[link_name = "\u{1}_ZN2cv3viz6Widget20setRenderingPropertyEid"]
    pub fn cv_viz_Widget_setRenderingProperty(
        this: *mut cv_viz_Widget,
        property: ::std::os::raw::c_int,
        value: f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Returns rendering property of the widget.\n\n@param property Property.\n\nRendering property can be one of the following:\n-   **POINT_SIZE**\n-   **OPACITY**\n-   **LINE_WIDTH**\n-   **FONT_SIZE**\n-   **AMBIENT**\n\nREPRESENTATION: Expected values are\n-   **REPRESENTATION_POINTS**\n-   **REPRESENTATION_WIREFRAME**\n-   **REPRESENTATION_SURFACE**\n\nIMMEDIATE_RENDERING**:\n-   Turn on immediate rendering by setting the value to 1.\n-   Turn off immediate rendering by setting the value to 0.\n\nSHADING: Expected values are\n-   **SHADING_FLAT**\n-   **SHADING_GOURAUD**\n-   **SHADING_PHONG**"]
    #[link_name = "\u{1}_ZNK2cv3viz6Widget20getRenderingPropertyEi"]
    pub fn cv_viz_Widget_getRenderingProperty(
        this: *const cv_viz_Widget,
        property: ::std::os::raw::c_int,
    ) -> f64;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3viz6WidgetC1Ev"]
    pub fn cv_viz_Widget_Widget(this: *mut cv_viz_Widget);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3viz6WidgetC1ERKS1_"]
    pub fn cv_viz_Widget_Widget1(this: *mut cv_viz_Widget, other: *const cv_viz_Widget);
}
impl cv_viz_Widget {
    #[inline]
    pub unsafe fn fromPlyFile(file_name: *const cv_String) -> cv_viz_Widget {
        cv_viz_Widget_fromPlyFile(file_name)
    }
    #[inline]
    pub unsafe fn setRenderingProperty(&mut self, property: ::std::os::raw::c_int, value: f64) {
        cv_viz_Widget_setRenderingProperty(self, property, value)
    }
    #[inline]
    pub unsafe fn getRenderingProperty(&self, property: ::std::os::raw::c_int) -> f64 {
        cv_viz_Widget_getRenderingProperty(self, property)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_Widget_Widget(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(other: *const cv_viz_Widget) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_Widget_Widget1(__bindgen_tmp.as_mut_ptr(), other);
        __bindgen_tmp.assume_init()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3viz6WidgetD1Ev"]
    pub fn cv_viz_Widget_Widget_destructor(this: *mut cv_viz_Widget);
}
#[doc = " @brief Base class of all 3D widgets."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_Widget3D {
    pub _base: cv_viz_Widget,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_Widget3D"][::std::mem::size_of::<cv_viz_Widget3D>() - 16usize];
    ["Alignment of cv_viz_Widget3D"][::std::mem::align_of::<cv_viz_Widget3D>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Sets pose of the widget.\n\n@param pose The new pose of the widget."]
    #[link_name = "\u{1}_ZN2cv3viz8Widget3D7setPoseERKNS_7Affine3IdEE"]
    pub fn cv_viz_Widget3D_setPose(this: *mut cv_viz_Widget3D, pose: *const cv_Affine3d);
}
unsafe extern "C" {
    #[doc = " @brief Updates pose of the widget by pre-multiplying its current pose.\n\n@param pose The pose that the current pose of the widget will be pre-multiplied by."]
    #[link_name = "\u{1}_ZN2cv3viz8Widget3D10updatePoseERKNS_7Affine3IdEE"]
    pub fn cv_viz_Widget3D_updatePose(this: *mut cv_viz_Widget3D, pose: *const cv_Affine3d);
}
unsafe extern "C" {
    #[doc = " @brief Returns the current pose of the widget."]
    #[link_name = "\u{1}_ZNK2cv3viz8Widget3D7getPoseEv"]
    pub fn cv_viz_Widget3D_getPose(this: *const cv_viz_Widget3D) -> cv_Affine3d;
}
unsafe extern "C" {
    #[doc = " @brief Transforms internal widget data (i.e. points, normals) using the given transform.\n\n@param transform Specified transformation to apply."]
    #[link_name = "\u{1}_ZN2cv3viz8Widget3D14applyTransformERKNS_7Affine3IdEE"]
    pub fn cv_viz_Widget3D_applyTransform(
        this: *mut cv_viz_Widget3D,
        transform: *const cv_Affine3d,
    );
}
unsafe extern "C" {
    #[doc = " @brief Sets the color of the widget.\n\n@param color color of type Color"]
    #[link_name = "\u{1}_ZN2cv3viz8Widget3D8setColorERKNS0_5ColorE"]
    pub fn cv_viz_Widget3D_setColor(this: *mut cv_viz_Widget3D, color: *const cv_viz_Color);
}
impl cv_viz_Widget3D {
    #[inline]
    pub unsafe fn setPose(&mut self, pose: *const cv_Affine3d) {
        cv_viz_Widget3D_setPose(self, pose)
    }
    #[inline]
    pub unsafe fn updatePose(&mut self, pose: *const cv_Affine3d) {
        cv_viz_Widget3D_updatePose(self, pose)
    }
    #[inline]
    pub unsafe fn getPose(&self) -> cv_Affine3d {
        cv_viz_Widget3D_getPose(self)
    }
    #[inline]
    pub unsafe fn applyTransform(&mut self, transform: *const cv_Affine3d) {
        cv_viz_Widget3D_applyTransform(self, transform)
    }
    #[inline]
    pub unsafe fn setColor(&mut self, color: *const cv_viz_Color) {
        cv_viz_Widget3D_setColor(self, color)
    }
}
#[doc = " @brief Base class of all 2D widgets."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_Widget2D {
    pub _base: cv_viz_Widget,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_Widget2D"][::std::mem::size_of::<cv_viz_Widget2D>() - 16usize];
    ["Alignment of cv_viz_Widget2D"][::std::mem::align_of::<cv_viz_Widget2D>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Sets the color of the widget.\n\n@param color color of type Color"]
    #[link_name = "\u{1}_ZN2cv3viz8Widget2D8setColorERKNS0_5ColorE"]
    pub fn cv_viz_Widget2D_setColor(this: *mut cv_viz_Widget2D, color: *const cv_viz_Color);
}
impl cv_viz_Widget2D {
    #[inline]
    pub unsafe fn setColor(&mut self, color: *const cv_viz_Color) {
        cv_viz_Widget2D_setColor(self, color)
    }
}
#[doc = " @brief This 3D Widget defines a finite line."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WLine {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WLine"][::std::mem::size_of::<cv_viz_WLine>() - 16usize];
    ["Alignment of cv_viz_WLine"][::std::mem::align_of::<cv_viz_WLine>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Constructs a WLine.\n\n@param pt1 Start point of the line.\n@param pt2 End point of the line.\n@param color Color of the line."]
    #[link_name = "\u{1}_ZN2cv3viz5WLineC1ERKNS_7Point3_IdEES5_RKNS0_5ColorE"]
    pub fn cv_viz_WLine_WLine(
        this: *mut cv_viz_WLine,
        pt1: *const cv_Point3d,
        pt2: *const cv_Point3d,
        color: *const cv_viz_Color,
    );
}
impl cv_viz_WLine {
    #[inline]
    pub unsafe fn new(
        pt1: *const cv_Point3d,
        pt2: *const cv_Point3d,
        color: *const cv_viz_Color,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WLine_WLine(__bindgen_tmp.as_mut_ptr(), pt1, pt2, color);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This 3D Widget defines a finite plane."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WPlane {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WPlane"][::std::mem::size_of::<cv_viz_WPlane>() - 16usize];
    ["Alignment of cv_viz_WPlane"][::std::mem::align_of::<cv_viz_WPlane>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Constructs a default plane with center point at origin and normal oriented along z-axis.\n\n@param size Size of the plane\n@param color Color of the plane."]
    #[link_name = "\u{1}_ZN2cv3viz6WPlaneC1ERKNS_5Size_IdEERKNS0_5ColorE"]
    pub fn cv_viz_WPlane_WPlane(
        this: *mut cv_viz_WPlane,
        size: *const cv_Size2d,
        color: *const cv_viz_Color,
    );
}
unsafe extern "C" {
    #[doc = " @brief Constructs a repositioned plane\n\n@param center Center of the plane\n@param normal Plane normal orientation\n@param new_yaxis Up-vector. New orientation of plane y-axis.\n@param size\n@param color Color of the plane."]
    #[link_name = "\u{1}_ZN2cv3viz6WPlaneC1ERKNS_7Point3_IdEERKNS_3VecIdLi3EEES9_RKNS_5Size_IdEERKNS0_5ColorE"]
    pub fn cv_viz_WPlane_WPlane1(
        this: *mut cv_viz_WPlane,
        center: *const cv_Point3d,
        normal: *const cv_Vec3d,
        new_yaxis: *const cv_Vec3d,
        size: *const cv_Size2d,
        color: *const cv_viz_Color,
    );
}
impl cv_viz_WPlane {
    #[inline]
    pub unsafe fn new(size: *const cv_Size2d, color: *const cv_viz_Color) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WPlane_WPlane(__bindgen_tmp.as_mut_ptr(), size, color);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        center: *const cv_Point3d,
        normal: *const cv_Vec3d,
        new_yaxis: *const cv_Vec3d,
        size: *const cv_Size2d,
        color: *const cv_viz_Color,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WPlane_WPlane1(
            __bindgen_tmp.as_mut_ptr(),
            center,
            normal,
            new_yaxis,
            size,
            color,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This 3D Widget defines a sphere. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WSphere {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WSphere"][::std::mem::size_of::<cv_viz_WSphere>() - 16usize];
    ["Alignment of cv_viz_WSphere"][::std::mem::align_of::<cv_viz_WSphere>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Constructs a WSphere.\n\n@param center Center of the sphere.\n@param radius Radius of the sphere.\n@param sphere_resolution Resolution of the sphere.\n@param color Color of the sphere."]
    #[link_name = "\u{1}_ZN2cv3viz7WSphereC1ERKNS_7Point3_IdEEdiRKNS0_5ColorE"]
    pub fn cv_viz_WSphere_WSphere(
        this: *mut cv_viz_WSphere,
        center: *const cv_Point3d,
        radius: f64,
        sphere_resolution: ::std::os::raw::c_int,
        color: *const cv_viz_Color,
    );
}
impl cv_viz_WSphere {
    #[inline]
    pub unsafe fn new(
        center: *const cv_Point3d,
        radius: f64,
        sphere_resolution: ::std::os::raw::c_int,
        color: *const cv_viz_Color,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WSphere_WSphere(
            __bindgen_tmp.as_mut_ptr(),
            center,
            radius,
            sphere_resolution,
            color,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This 3D Widget defines an arrow."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WArrow {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WArrow"][::std::mem::size_of::<cv_viz_WArrow>() - 16usize];
    ["Alignment of cv_viz_WArrow"][::std::mem::align_of::<cv_viz_WArrow>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Constructs an WArrow.\n\n@param pt1 Start point of the arrow.\n@param pt2 End point of the arrow.\n@param thickness Thickness of the arrow. Thickness of arrow head is also adjusted\naccordingly.\n@param color Color of the arrow.\n\nArrow head is located at the end point of the arrow."]
    #[link_name = "\u{1}_ZN2cv3viz6WArrowC1ERKNS_7Point3_IdEES5_dRKNS0_5ColorE"]
    pub fn cv_viz_WArrow_WArrow(
        this: *mut cv_viz_WArrow,
        pt1: *const cv_Point3d,
        pt2: *const cv_Point3d,
        thickness: f64,
        color: *const cv_viz_Color,
    );
}
impl cv_viz_WArrow {
    #[inline]
    pub unsafe fn new(
        pt1: *const cv_Point3d,
        pt2: *const cv_Point3d,
        thickness: f64,
        color: *const cv_viz_Color,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WArrow_WArrow(__bindgen_tmp.as_mut_ptr(), pt1, pt2, thickness, color);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This 3D Widget defines a circle."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WCircle {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WCircle"][::std::mem::size_of::<cv_viz_WCircle>() - 16usize];
    ["Alignment of cv_viz_WCircle"][::std::mem::align_of::<cv_viz_WCircle>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Constructs default planar circle centered at origin with plane normal along z-axis\n\n@param radius Radius of the circle.\n@param thickness Thickness of the circle.\n@param color Color of the circle."]
    #[link_name = "\u{1}_ZN2cv3viz7WCircleC1EddRKNS0_5ColorE"]
    pub fn cv_viz_WCircle_WCircle(
        this: *mut cv_viz_WCircle,
        radius: f64,
        thickness: f64,
        color: *const cv_viz_Color,
    );
}
unsafe extern "C" {
    #[doc = " @brief Constructs repositioned planar circle.\n\n@param radius Radius of the circle.\n@param center Center of the circle.\n@param normal Normal of the plane in which the circle lies.\n@param thickness Thickness of the circle.\n@param color Color of the circle."]
    #[link_name = "\u{1}_ZN2cv3viz7WCircleC1EdRKNS_7Point3_IdEERKNS_3VecIdLi3EEEdRKNS0_5ColorE"]
    pub fn cv_viz_WCircle_WCircle1(
        this: *mut cv_viz_WCircle,
        radius: f64,
        center: *const cv_Point3d,
        normal: *const cv_Vec3d,
        thickness: f64,
        color: *const cv_viz_Color,
    );
}
impl cv_viz_WCircle {
    #[inline]
    pub unsafe fn new(radius: f64, thickness: f64, color: *const cv_viz_Color) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WCircle_WCircle(__bindgen_tmp.as_mut_ptr(), radius, thickness, color);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        radius: f64,
        center: *const cv_Point3d,
        normal: *const cv_Vec3d,
        thickness: f64,
        color: *const cv_viz_Color,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WCircle_WCircle1(
            __bindgen_tmp.as_mut_ptr(),
            radius,
            center,
            normal,
            thickness,
            color,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This 3D Widget defines a cone. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WCone {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WCone"][::std::mem::size_of::<cv_viz_WCone>() - 16usize];
    ["Alignment of cv_viz_WCone"][::std::mem::align_of::<cv_viz_WCone>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Constructs default cone oriented along x-axis with center of its base located at origin\n\n@param length Length of the cone.\n@param radius Radius of the cone.\n@param resolution Resolution of the cone.\n@param color Color of the cone."]
    #[link_name = "\u{1}_ZN2cv3viz5WConeC1EddiRKNS0_5ColorE"]
    pub fn cv_viz_WCone_WCone(
        this: *mut cv_viz_WCone,
        length: f64,
        radius: f64,
        resolution: ::std::os::raw::c_int,
        color: *const cv_viz_Color,
    );
}
unsafe extern "C" {
    #[doc = " @brief Constructs repositioned planar cone.\n\n@param radius Radius of the cone.\n@param center Center of the cone base.\n@param tip Tip of the cone.\n@param resolution Resolution of the cone.\n@param color Color of the cone.\n"]
    #[link_name = "\u{1}_ZN2cv3viz5WConeC1EdRKNS_7Point3_IdEES5_iRKNS0_5ColorE"]
    pub fn cv_viz_WCone_WCone1(
        this: *mut cv_viz_WCone,
        radius: f64,
        center: *const cv_Point3d,
        tip: *const cv_Point3d,
        resolution: ::std::os::raw::c_int,
        color: *const cv_viz_Color,
    );
}
impl cv_viz_WCone {
    #[inline]
    pub unsafe fn new(
        length: f64,
        radius: f64,
        resolution: ::std::os::raw::c_int,
        color: *const cv_viz_Color,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WCone_WCone(
            __bindgen_tmp.as_mut_ptr(),
            length,
            radius,
            resolution,
            color,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        radius: f64,
        center: *const cv_Point3d,
        tip: *const cv_Point3d,
        resolution: ::std::os::raw::c_int,
        color: *const cv_viz_Color,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WCone_WCone1(
            __bindgen_tmp.as_mut_ptr(),
            radius,
            center,
            tip,
            resolution,
            color,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This 3D Widget defines a cylinder. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WCylinder {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WCylinder"][::std::mem::size_of::<cv_viz_WCylinder>() - 16usize];
    ["Alignment of cv_viz_WCylinder"][::std::mem::align_of::<cv_viz_WCylinder>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Constructs a WCylinder.\n\n@param axis_point1 A point1 on the axis of the cylinder.\n@param axis_point2 A point2 on the axis of the cylinder.\n@param radius Radius of the cylinder.\n@param numsides Resolution of the cylinder.\n@param color Color of the cylinder."]
    #[link_name = "\u{1}_ZN2cv3viz9WCylinderC1ERKNS_7Point3_IdEES5_diRKNS0_5ColorE"]
    pub fn cv_viz_WCylinder_WCylinder(
        this: *mut cv_viz_WCylinder,
        axis_point1: *const cv_Point3d,
        axis_point2: *const cv_Point3d,
        radius: f64,
        numsides: ::std::os::raw::c_int,
        color: *const cv_viz_Color,
    );
}
impl cv_viz_WCylinder {
    #[inline]
    pub unsafe fn new(
        axis_point1: *const cv_Point3d,
        axis_point2: *const cv_Point3d,
        radius: f64,
        numsides: ::std::os::raw::c_int,
        color: *const cv_viz_Color,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WCylinder_WCylinder(
            __bindgen_tmp.as_mut_ptr(),
            axis_point1,
            axis_point2,
            radius,
            numsides,
            color,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This 3D Widget defines a cube."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WCube {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WCube"][::std::mem::size_of::<cv_viz_WCube>() - 16usize];
    ["Alignment of cv_viz_WCube"][::std::mem::align_of::<cv_viz_WCube>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Constructs a WCube.\n\n@param min_point Specifies minimum point of the bounding box.\n@param max_point Specifies maximum point of the bounding box.\n@param wire_frame If true, cube is represented as wireframe.\n@param color Color of the cube.\n\n[Cube Widget](images/cube_widget.png)"]
    #[link_name = "\u{1}_ZN2cv3viz5WCubeC1ERKNS_7Point3_IdEES5_bRKNS0_5ColorE"]
    pub fn cv_viz_WCube_WCube(
        this: *mut cv_viz_WCube,
        min_point: *const cv_Point3d,
        max_point: *const cv_Point3d,
        wire_frame: bool,
        color: *const cv_viz_Color,
    );
}
impl cv_viz_WCube {
    #[inline]
    pub unsafe fn new(
        min_point: *const cv_Point3d,
        max_point: *const cv_Point3d,
        wire_frame: bool,
        color: *const cv_viz_Color,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WCube_WCube(
            __bindgen_tmp.as_mut_ptr(),
            min_point,
            max_point,
            wire_frame,
            color,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This 3D Widget defines a poly line. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WPolyLine {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WPolyLine"][::std::mem::size_of::<cv_viz_WPolyLine>() - 16usize];
    ["Alignment of cv_viz_WPolyLine"][::std::mem::align_of::<cv_viz_WPolyLine>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3viz9WPolyLineC1ERKNS_11_InputArrayES4_"]
    pub fn cv_viz_WPolyLine_WPolyLine(
        this: *mut cv_viz_WPolyLine,
        points: cv_InputArray,
        colors: cv_InputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Constructs a WPolyLine.\n\n@param points Point set.\n@param color Color of the poly line."]
    #[link_name = "\u{1}_ZN2cv3viz9WPolyLineC1ERKNS_11_InputArrayERKNS0_5ColorE"]
    pub fn cv_viz_WPolyLine_WPolyLine1(
        this: *mut cv_viz_WPolyLine,
        points: cv_InputArray,
        color: *const cv_viz_Color,
    );
}
impl cv_viz_WPolyLine {
    #[inline]
    pub unsafe fn new(points: cv_InputArray, colors: cv_InputArray) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WPolyLine_WPolyLine(__bindgen_tmp.as_mut_ptr(), points, colors);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(points: cv_InputArray, color: *const cv_viz_Color) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WPolyLine_WPolyLine1(__bindgen_tmp.as_mut_ptr(), points, color);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This 2D Widget represents text overlay."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WText {
    pub _base: cv_viz_Widget2D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WText"][::std::mem::size_of::<cv_viz_WText>() - 16usize];
    ["Alignment of cv_viz_WText"][::std::mem::align_of::<cv_viz_WText>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Sets the text content of the widget.\n\n@param text Text content of the widget."]
    #[link_name = "\u{1}_ZN2cv3viz5WText7setTextERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_viz_WText_setText(this: *mut cv_viz_WText, text: *const cv_String);
}
unsafe extern "C" {
    #[doc = " @brief Returns the current text content of the widget."]
    #[link_name = "\u{1}_ZNK2cv3viz5WText7getTextB5cxx11Ev"]
    pub fn cv_viz_WText_getText(this: *const cv_viz_WText) -> cv_String;
}
unsafe extern "C" {
    #[doc = " @brief Constructs a WText.\n\n@param text Text content of the widget.\n@param pos Position of the text.\n@param font_size Font size.\n@param color Color of the text."]
    #[link_name = "\u{1}_ZN2cv3viz5WTextC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_6Point_IiEEiRKNS0_5ColorE"]
    pub fn cv_viz_WText_WText(
        this: *mut cv_viz_WText,
        text: *const cv_String,
        pos: *const cv_Point,
        font_size: ::std::os::raw::c_int,
        color: *const cv_viz_Color,
    );
}
impl cv_viz_WText {
    #[inline]
    pub unsafe fn setText(&mut self, text: *const cv_String) {
        cv_viz_WText_setText(self, text)
    }
    #[inline]
    pub unsafe fn getText(&self) -> cv_String {
        cv_viz_WText_getText(self)
    }
    #[inline]
    pub unsafe fn new(
        text: *const cv_String,
        pos: *const cv_Point,
        font_size: ::std::os::raw::c_int,
        color: *const cv_viz_Color,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WText_WText(__bindgen_tmp.as_mut_ptr(), text, pos, font_size, color);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This 3D Widget represents 3D text. The text always faces the camera."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WText3D {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WText3D"][::std::mem::size_of::<cv_viz_WText3D>() - 16usize];
    ["Alignment of cv_viz_WText3D"][::std::mem::align_of::<cv_viz_WText3D>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Sets the text content of the widget.\n\n@param text Text content of the widget.\n"]
    #[link_name = "\u{1}_ZN2cv3viz7WText3D7setTextERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_viz_WText3D_setText(this: *mut cv_viz_WText3D, text: *const cv_String);
}
unsafe extern "C" {
    #[doc = " @brief Returns the current text content of the widget."]
    #[link_name = "\u{1}_ZNK2cv3viz7WText3D7getTextB5cxx11Ev"]
    pub fn cv_viz_WText3D_getText(this: *const cv_viz_WText3D) -> cv_String;
}
unsafe extern "C" {
    #[doc = " @brief Constructs a WText3D.\n\n@param text Text content of the widget.\n@param position Position of the text.\n@param text_scale Size of the text.\n@param face_camera If true, text always faces the camera.\n@param color Color of the text."]
    #[link_name = "\u{1}_ZN2cv3viz7WText3DC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_7Point3_IdEEdbRKNS0_5ColorE"]
    pub fn cv_viz_WText3D_WText3D(
        this: *mut cv_viz_WText3D,
        text: *const cv_String,
        position: *const cv_Point3d,
        text_scale: f64,
        face_camera: bool,
        color: *const cv_viz_Color,
    );
}
impl cv_viz_WText3D {
    #[inline]
    pub unsafe fn setText(&mut self, text: *const cv_String) {
        cv_viz_WText3D_setText(self, text)
    }
    #[inline]
    pub unsafe fn getText(&self) -> cv_String {
        cv_viz_WText3D_getText(self)
    }
    #[inline]
    pub unsafe fn new(
        text: *const cv_String,
        position: *const cv_Point3d,
        text_scale: f64,
        face_camera: bool,
        color: *const cv_viz_Color,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WText3D_WText3D(
            __bindgen_tmp.as_mut_ptr(),
            text,
            position,
            text_scale,
            face_camera,
            color,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This 2D Widget represents an image overlay. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WImageOverlay {
    pub _base: cv_viz_Widget2D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WImageOverlay"][::std::mem::size_of::<cv_viz_WImageOverlay>() - 16usize];
    ["Alignment of cv_viz_WImageOverlay"][::std::mem::align_of::<cv_viz_WImageOverlay>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Sets the image content of the widget.\n\n@param image BGR or Gray-Scale image."]
    #[link_name = "\u{1}_ZN2cv3viz13WImageOverlay8setImageERKNS_11_InputArrayE"]
    pub fn cv_viz_WImageOverlay_setImage(this: *mut cv_viz_WImageOverlay, image: cv_InputArray);
}
unsafe extern "C" {
    #[doc = " @brief Constructs an WImageOverlay.\n\n@param image BGR or Gray-Scale image.\n@param rect Image is scaled and positioned based on rect."]
    #[link_name = "\u{1}_ZN2cv3viz13WImageOverlayC1ERKNS_11_InputArrayERKNS_5Rect_IiEE"]
    pub fn cv_viz_WImageOverlay_WImageOverlay(
        this: *mut cv_viz_WImageOverlay,
        image: cv_InputArray,
        rect: *const cv_Rect,
    );
}
impl cv_viz_WImageOverlay {
    #[inline]
    pub unsafe fn setImage(&mut self, image: cv_InputArray) {
        cv_viz_WImageOverlay_setImage(self, image)
    }
    #[inline]
    pub unsafe fn new(image: cv_InputArray, rect: *const cv_Rect) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WImageOverlay_WImageOverlay(__bindgen_tmp.as_mut_ptr(), image, rect);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This 3D Widget represents an image in 3D space. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WImage3D {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WImage3D"][::std::mem::size_of::<cv_viz_WImage3D>() - 16usize];
    ["Alignment of cv_viz_WImage3D"][::std::mem::align_of::<cv_viz_WImage3D>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Sets the image content of the widget.\n\n@param image BGR or Gray-Scale image."]
    #[link_name = "\u{1}_ZN2cv3viz8WImage3D8setImageERKNS_11_InputArrayE"]
    pub fn cv_viz_WImage3D_setImage(this: *mut cv_viz_WImage3D, image: cv_InputArray);
}
unsafe extern "C" {
    #[doc = " @brief Sets the image size of the widget.\n\n@param size the new size of the image."]
    #[link_name = "\u{1}_ZN2cv3viz8WImage3D7setSizeERKNS_5Size_IiEE"]
    pub fn cv_viz_WImage3D_setSize(this: *mut cv_viz_WImage3D, size: *const cv_Size);
}
unsafe extern "C" {
    #[doc = " @brief Constructs an WImage3D.\n\n@param image BGR or Gray-Scale image.\n@param size Size of the image."]
    #[link_name = "\u{1}_ZN2cv3viz8WImage3DC1ERKNS_11_InputArrayERKNS_5Size_IdEE"]
    pub fn cv_viz_WImage3D_WImage3D(
        this: *mut cv_viz_WImage3D,
        image: cv_InputArray,
        size: *const cv_Size2d,
    );
}
unsafe extern "C" {
    #[doc = " @brief Constructs an WImage3D.\n\n@param image BGR or Gray-Scale image.\n@param size Size of the image.\n@param center Position of the image.\n@param normal Normal of the plane that represents the image.\n@param up_vector Determines orientation of the image."]
    #[link_name = "\u{1}_ZN2cv3viz8WImage3DC1ERKNS_11_InputArrayERKNS_5Size_IdEERKNS_3VecIdLi3EEESC_SC_"]
    pub fn cv_viz_WImage3D_WImage3D1(
        this: *mut cv_viz_WImage3D,
        image: cv_InputArray,
        size: *const cv_Size2d,
        center: *const cv_Vec3d,
        normal: *const cv_Vec3d,
        up_vector: *const cv_Vec3d,
    );
}
impl cv_viz_WImage3D {
    #[inline]
    pub unsafe fn setImage(&mut self, image: cv_InputArray) {
        cv_viz_WImage3D_setImage(self, image)
    }
    #[inline]
    pub unsafe fn setSize(&mut self, size: *const cv_Size) {
        cv_viz_WImage3D_setSize(self, size)
    }
    #[inline]
    pub unsafe fn new(image: cv_InputArray, size: *const cv_Size2d) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WImage3D_WImage3D(__bindgen_tmp.as_mut_ptr(), image, size);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        image: cv_InputArray,
        size: *const cv_Size2d,
        center: *const cv_Vec3d,
        normal: *const cv_Vec3d,
        up_vector: *const cv_Vec3d,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WImage3D_WImage3D1(
            __bindgen_tmp.as_mut_ptr(),
            image,
            size,
            center,
            normal,
            up_vector,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This 3D Widget represents a coordinate system. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WCoordinateSystem {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WCoordinateSystem"]
        [::std::mem::size_of::<cv_viz_WCoordinateSystem>() - 16usize];
    ["Alignment of cv_viz_WCoordinateSystem"]
        [::std::mem::align_of::<cv_viz_WCoordinateSystem>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Constructs a WCoordinateSystem.\n\n@param scale Determines the size of the axes."]
    #[link_name = "\u{1}_ZN2cv3viz17WCoordinateSystemC1Ed"]
    pub fn cv_viz_WCoordinateSystem_WCoordinateSystem(
        this: *mut cv_viz_WCoordinateSystem,
        scale: f64,
    );
}
impl cv_viz_WCoordinateSystem {
    #[inline]
    pub unsafe fn new(scale: f64) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WCoordinateSystem_WCoordinateSystem(__bindgen_tmp.as_mut_ptr(), scale);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This 3D Widget defines a grid. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WGrid {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WGrid"][::std::mem::size_of::<cv_viz_WGrid>() - 16usize];
    ["Alignment of cv_viz_WGrid"][::std::mem::align_of::<cv_viz_WGrid>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Constructs a WGrid.\n\n@param cells Number of cell columns and rows, respectively.\n@param cells_spacing Size of each cell, respectively.\n@param color Color of the grid."]
    #[link_name = "\u{1}_ZN2cv3viz5WGridC1ERKNS_3VecIiLi2EEERKNS2_IdLi2EEERKNS0_5ColorE"]
    pub fn cv_viz_WGrid_WGrid(
        this: *mut cv_viz_WGrid,
        cells: *const cv_Vec2i,
        cells_spacing: *const cv_Vec2d,
        color: *const cv_viz_Color,
    );
}
unsafe extern "C" {
    #[doc = "! Creates repositioned grid"]
    #[link_name = "\u{1}_ZN2cv3viz5WGridC1ERKNS_7Point3_IdEERKNS_3VecIdLi3EEES9_RKNS6_IiLi2EEERKNS6_IdLi2EEERKNS0_5ColorE"]
    pub fn cv_viz_WGrid_WGrid1(
        this: *mut cv_viz_WGrid,
        center: *const cv_Point3d,
        normal: *const cv_Vec3d,
        new_yaxis: *const cv_Vec3d,
        cells: *const cv_Vec2i,
        cells_spacing: *const cv_Vec2d,
        color: *const cv_viz_Color,
    );
}
impl cv_viz_WGrid {
    #[inline]
    pub unsafe fn new(
        cells: *const cv_Vec2i,
        cells_spacing: *const cv_Vec2d,
        color: *const cv_viz_Color,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WGrid_WGrid(__bindgen_tmp.as_mut_ptr(), cells, cells_spacing, color);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        center: *const cv_Point3d,
        normal: *const cv_Vec3d,
        new_yaxis: *const cv_Vec3d,
        cells: *const cv_Vec2i,
        cells_spacing: *const cv_Vec2d,
        color: *const cv_viz_Color,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WGrid_WGrid1(
            __bindgen_tmp.as_mut_ptr(),
            center,
            normal,
            new_yaxis,
            cells,
            cells_spacing,
            color,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This 3D Widget represents camera position in a scene by its axes or viewing frustum. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WCameraPosition {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WCameraPosition"][::std::mem::size_of::<cv_viz_WCameraPosition>() - 16usize];
    ["Alignment of cv_viz_WCameraPosition"]
        [::std::mem::align_of::<cv_viz_WCameraPosition>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Creates camera coordinate frame at the origin.\n\n[Camera coordinate frame](images/cpw1.png)"]
    #[link_name = "\u{1}_ZN2cv3viz15WCameraPositionC1Ed"]
    pub fn cv_viz_WCameraPosition_WCameraPosition(this: *mut cv_viz_WCameraPosition, scale: f64);
}
unsafe extern "C" {
    #[doc = " @brief Display the viewing frustum\n@param K Intrinsic matrix of the camera.\n@param scale Scale of the frustum.\n@param color Color of the frustum.\n\nCreates viewing frustum of the camera based on its intrinsic matrix K.\n\n[Camera viewing frustum](images/cpw2.png)"]
    #[link_name = "\u{1}_ZN2cv3viz15WCameraPositionC1ERKNS_4MatxIdLi3ELi3EEEdRKNS0_5ColorE"]
    pub fn cv_viz_WCameraPosition_WCameraPosition1(
        this: *mut cv_viz_WCameraPosition,
        K: *const cv_Matx33d,
        scale: f64,
        color: *const cv_viz_Color,
    );
}
unsafe extern "C" {
    #[doc = " @brief Display the viewing frustum\n@param fov Field of view of the camera (horizontal, vertical).\n@param scale Scale of the frustum.\n@param color Color of the frustum.\n\nCreates viewing frustum of the camera based on its field of view fov.\n\n[Camera viewing frustum](images/cpw2.png)"]
    #[link_name = "\u{1}_ZN2cv3viz15WCameraPositionC1ERKNS_3VecIdLi2EEEdRKNS0_5ColorE"]
    pub fn cv_viz_WCameraPosition_WCameraPosition2(
        this: *mut cv_viz_WCameraPosition,
        fov: *const cv_Vec2d,
        scale: f64,
        color: *const cv_viz_Color,
    );
}
unsafe extern "C" {
    #[doc = " @brief Display image on the far plane of the viewing frustum\n\n@param K Intrinsic matrix of the camera.\n@param image BGR or Gray-Scale image that is going to be displayed on the far plane of the frustum.\n@param scale Scale of the frustum and image.\n@param color Color of the frustum.\n\nCreates viewing frustum of the camera based on its intrinsic matrix K, and displays image on\nthe far end plane.\n\n[Camera viewing frustum with image](images/cpw3.png)"]
    #[link_name = "\u{1}_ZN2cv3viz15WCameraPositionC1ERKNS_4MatxIdLi3ELi3EEERKNS_11_InputArrayEdRKNS0_5ColorE"]
    pub fn cv_viz_WCameraPosition_WCameraPosition3(
        this: *mut cv_viz_WCameraPosition,
        K: *const cv_Matx33d,
        image: cv_InputArray,
        scale: f64,
        color: *const cv_viz_Color,
    );
}
unsafe extern "C" {
    #[doc = " @brief  Display image on the far plane of the viewing frustum\n\n@param fov Field of view of the camera (horizontal, vertical).\n@param image BGR or Gray-Scale image that is going to be displayed on the far plane of the frustum.\n@param scale Scale of the frustum and image.\n@param color Color of the frustum.\n\nCreates viewing frustum of the camera based on its intrinsic matrix K, and displays image on\nthe far end plane.\n\n[Camera viewing frustum with image](images/cpw3.png)"]
    #[link_name = "\u{1}_ZN2cv3viz15WCameraPositionC1ERKNS_3VecIdLi2EEERKNS_11_InputArrayEdRKNS0_5ColorE"]
    pub fn cv_viz_WCameraPosition_WCameraPosition4(
        this: *mut cv_viz_WCameraPosition,
        fov: *const cv_Vec2d,
        image: cv_InputArray,
        scale: f64,
        color: *const cv_viz_Color,
    );
}
impl cv_viz_WCameraPosition {
    #[inline]
    pub unsafe fn new(scale: f64) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WCameraPosition_WCameraPosition(__bindgen_tmp.as_mut_ptr(), scale);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(K: *const cv_Matx33d, scale: f64, color: *const cv_viz_Color) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WCameraPosition_WCameraPosition1(__bindgen_tmp.as_mut_ptr(), K, scale, color);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(fov: *const cv_Vec2d, scale: f64, color: *const cv_viz_Color) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WCameraPosition_WCameraPosition2(__bindgen_tmp.as_mut_ptr(), fov, scale, color);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(
        K: *const cv_Matx33d,
        image: cv_InputArray,
        scale: f64,
        color: *const cv_viz_Color,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WCameraPosition_WCameraPosition3(__bindgen_tmp.as_mut_ptr(), K, image, scale, color);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(
        fov: *const cv_Vec2d,
        image: cv_InputArray,
        scale: f64,
        color: *const cv_viz_Color,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WCameraPosition_WCameraPosition4(
            __bindgen_tmp.as_mut_ptr(),
            fov,
            image,
            scale,
            color,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This 3D Widget represents a trajectory. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WTrajectory {
    pub _base: cv_viz_Widget3D,
}
pub const cv_viz_WTrajectory_FRAMES: cv_viz_WTrajectory__bindgen_ty_1 = 1;
pub const cv_viz_WTrajectory_PATH: cv_viz_WTrajectory__bindgen_ty_1 = 2;
pub const cv_viz_WTrajectory_BOTH: cv_viz_WTrajectory__bindgen_ty_1 = 3;
pub type cv_viz_WTrajectory__bindgen_ty_1 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WTrajectory"][::std::mem::size_of::<cv_viz_WTrajectory>() - 16usize];
    ["Alignment of cv_viz_WTrajectory"][::std::mem::align_of::<cv_viz_WTrajectory>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Constructs a WTrajectory.\n\n@param path List of poses on a trajectory. Takes std::vector\\<Affine\\<T\\>\\> with T == [float | double]\n@param display_mode Display mode. This can be PATH, FRAMES, and BOTH.\n@param scale Scale of the frames. Polyline is not affected.\n@param color Color of the polyline that represents path.\n\nFrames are not affected.\nDisplays trajectory of the given path as follows:\n-   PATH : Displays a poly line that represents the path.\n-   FRAMES : Displays coordinate frames at each pose.\n-   PATH & FRAMES : Displays both poly line and coordinate frames."]
    #[link_name = "\u{1}_ZN2cv3viz11WTrajectoryC1ERKNS_11_InputArrayEidRKNS0_5ColorE"]
    pub fn cv_viz_WTrajectory_WTrajectory(
        this: *mut cv_viz_WTrajectory,
        path: cv_InputArray,
        display_mode: ::std::os::raw::c_int,
        scale: f64,
        color: *const cv_viz_Color,
    );
}
impl cv_viz_WTrajectory {
    #[inline]
    pub unsafe fn new(
        path: cv_InputArray,
        display_mode: ::std::os::raw::c_int,
        scale: f64,
        color: *const cv_viz_Color,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WTrajectory_WTrajectory(
            __bindgen_tmp.as_mut_ptr(),
            path,
            display_mode,
            scale,
            color,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This 3D Widget represents a trajectory. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WTrajectoryFrustums {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WTrajectoryFrustums"]
        [::std::mem::size_of::<cv_viz_WTrajectoryFrustums>() - 16usize];
    ["Alignment of cv_viz_WTrajectoryFrustums"]
        [::std::mem::align_of::<cv_viz_WTrajectoryFrustums>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Constructs a WTrajectoryFrustums.\n\n@param path List of poses on a trajectory. Takes std::vector\\<Affine\\<T\\>\\> with T == [float | double]\n@param K Intrinsic matrix of the camera.\n@param scale Scale of the frustums.\n@param color Color of the frustums.\n\nDisplays frustums at each pose of the trajectory."]
    #[link_name = "\u{1}_ZN2cv3viz19WTrajectoryFrustumsC1ERKNS_11_InputArrayERKNS_4MatxIdLi3ELi3EEEdRKNS0_5ColorE"]
    pub fn cv_viz_WTrajectoryFrustums_WTrajectoryFrustums(
        this: *mut cv_viz_WTrajectoryFrustums,
        path: cv_InputArray,
        K: *const cv_Matx33d,
        scale: f64,
        color: *const cv_viz_Color,
    );
}
unsafe extern "C" {
    #[doc = " @brief Constructs a WTrajectoryFrustums.\n\n@param path List of poses on a trajectory. Takes std::vector\\<Affine\\<T\\>\\> with T == [float | double]\n@param fov Field of view of the camera (horizontal, vertical).\n@param scale Scale of the frustums.\n@param color Color of the frustums.\n\nDisplays frustums at each pose of the trajectory."]
    #[link_name = "\u{1}_ZN2cv3viz19WTrajectoryFrustumsC1ERKNS_11_InputArrayERKNS_3VecIdLi2EEEdRKNS0_5ColorE"]
    pub fn cv_viz_WTrajectoryFrustums_WTrajectoryFrustums1(
        this: *mut cv_viz_WTrajectoryFrustums,
        path: cv_InputArray,
        fov: *const cv_Vec2d,
        scale: f64,
        color: *const cv_viz_Color,
    );
}
impl cv_viz_WTrajectoryFrustums {
    #[inline]
    pub unsafe fn new(
        path: cv_InputArray,
        K: *const cv_Matx33d,
        scale: f64,
        color: *const cv_viz_Color,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WTrajectoryFrustums_WTrajectoryFrustums(
            __bindgen_tmp.as_mut_ptr(),
            path,
            K,
            scale,
            color,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        path: cv_InputArray,
        fov: *const cv_Vec2d,
        scale: f64,
        color: *const cv_viz_Color,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WTrajectoryFrustums_WTrajectoryFrustums1(
            __bindgen_tmp.as_mut_ptr(),
            path,
            fov,
            scale,
            color,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This 3D Widget represents a trajectory using spheres and lines\n\nwhere spheres represent the positions of the camera, and lines represent the direction from\nprevious position to the current. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WTrajectorySpheres {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WTrajectorySpheres"]
        [::std::mem::size_of::<cv_viz_WTrajectorySpheres>() - 16usize];
    ["Alignment of cv_viz_WTrajectorySpheres"]
        [::std::mem::align_of::<cv_viz_WTrajectorySpheres>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Constructs a WTrajectorySpheres.\n\n@param path List of poses on a trajectory. Takes std::vector\\<Affine\\<T\\>\\> with T == [float | double]\n@param line_length Max length of the lines which point to previous position\n@param radius Radius of the spheres.\n@param from Color for first sphere.\n@param to Color for last sphere. Intermediate spheres will have interpolated color."]
    #[link_name = "\u{1}_ZN2cv3viz18WTrajectorySpheresC1ERKNS_11_InputArrayEddRKNS0_5ColorES7_"]
    pub fn cv_viz_WTrajectorySpheres_WTrajectorySpheres(
        this: *mut cv_viz_WTrajectorySpheres,
        path: cv_InputArray,
        line_length: f64,
        radius: f64,
        from: *const cv_viz_Color,
        to: *const cv_viz_Color,
    );
}
impl cv_viz_WTrajectorySpheres {
    #[inline]
    pub unsafe fn new(
        path: cv_InputArray,
        line_length: f64,
        radius: f64,
        from: *const cv_viz_Color,
        to: *const cv_viz_Color,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WTrajectorySpheres_WTrajectorySpheres(
            __bindgen_tmp.as_mut_ptr(),
            path,
            line_length,
            radius,
            from,
            to,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This 3D Widget defines a point cloud. :\n\n@note In case there are four channels in the cloud, fourth channel is ignored."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WCloud {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WCloud"][::std::mem::size_of::<cv_viz_WCloud>() - 16usize];
    ["Alignment of cv_viz_WCloud"][::std::mem::align_of::<cv_viz_WCloud>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Constructs a WCloud.\n\n@param cloud Set of points which can be of type: CV_32FC3, CV_32FC4, CV_64FC3, CV_64FC4.\n@param colors Set of colors. It has to be of the same size with cloud.\n\nPoints in the cloud belong to mask when they are set to (NaN, NaN, NaN)."]
    #[link_name = "\u{1}_ZN2cv3viz6WCloudC1ERKNS_11_InputArrayES4_"]
    pub fn cv_viz_WCloud_WCloud(
        this: *mut cv_viz_WCloud,
        cloud: cv_InputArray,
        colors: cv_InputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Constructs a WCloud.\n@param cloud Set of points which can be of type: CV_32FC3, CV_32FC4, CV_64FC3, CV_64FC4.\n@param color A single Color for the whole cloud.\n\nPoints in the cloud belong to mask when they are set to (NaN, NaN, NaN)."]
    #[link_name = "\u{1}_ZN2cv3viz6WCloudC1ERKNS_11_InputArrayERKNS0_5ColorE"]
    pub fn cv_viz_WCloud_WCloud1(
        this: *mut cv_viz_WCloud,
        cloud: cv_InputArray,
        color: *const cv_viz_Color,
    );
}
unsafe extern "C" {
    #[doc = " @brief Constructs a WCloud.\n@param cloud Set of points which can be of type: CV_32FC3, CV_32FC4, CV_64FC3, CV_64FC4.\n@param colors Set of colors. It has to be of the same size with cloud.\n@param normals Normals for each point in cloud. Size and type should match with the cloud parameter.\n\nPoints in the cloud belong to mask when they are set to (NaN, NaN, NaN)."]
    #[link_name = "\u{1}_ZN2cv3viz6WCloudC1ERKNS_11_InputArrayES4_S4_"]
    pub fn cv_viz_WCloud_WCloud2(
        this: *mut cv_viz_WCloud,
        cloud: cv_InputArray,
        colors: cv_InputArray,
        normals: cv_InputArray,
    );
}
unsafe extern "C" {
    #[doc = " @brief Constructs a WCloud.\n@param cloud Set of points which can be of type: CV_32FC3, CV_32FC4, CV_64FC3, CV_64FC4.\n@param color A single Color for the whole cloud.\n@param normals Normals for each point in cloud.\n\nSize and type should match with the cloud parameter.\nPoints in the cloud belong to mask when they are set to (NaN, NaN, NaN)."]
    #[link_name = "\u{1}_ZN2cv3viz6WCloudC1ERKNS_11_InputArrayERKNS0_5ColorES4_"]
    pub fn cv_viz_WCloud_WCloud3(
        this: *mut cv_viz_WCloud,
        cloud: cv_InputArray,
        color: *const cv_viz_Color,
        normals: cv_InputArray,
    );
}
impl cv_viz_WCloud {
    #[inline]
    pub unsafe fn new(cloud: cv_InputArray, colors: cv_InputArray) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WCloud_WCloud(__bindgen_tmp.as_mut_ptr(), cloud, colors);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(cloud: cv_InputArray, color: *const cv_viz_Color) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WCloud_WCloud1(__bindgen_tmp.as_mut_ptr(), cloud, color);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(
        cloud: cv_InputArray,
        colors: cv_InputArray,
        normals: cv_InputArray,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WCloud_WCloud2(__bindgen_tmp.as_mut_ptr(), cloud, colors, normals);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(
        cloud: cv_InputArray,
        color: *const cv_viz_Color,
        normals: cv_InputArray,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WCloud_WCloud3(__bindgen_tmp.as_mut_ptr(), cloud, color, normals);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WPaintedCloud {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WPaintedCloud"][::std::mem::size_of::<cv_viz_WPaintedCloud>() - 16usize];
    ["Alignment of cv_viz_WPaintedCloud"][::std::mem::align_of::<cv_viz_WPaintedCloud>() - 8usize];
};
unsafe extern "C" {
    #[doc = "! Paint cloud with default gradient between cloud bounds points"]
    #[link_name = "\u{1}_ZN2cv3viz13WPaintedCloudC1ERKNS_11_InputArrayE"]
    pub fn cv_viz_WPaintedCloud_WPaintedCloud(
        this: *mut cv_viz_WPaintedCloud,
        cloud: cv_InputArray,
    );
}
unsafe extern "C" {
    #[doc = "! Paint cloud with default gradient between given points"]
    #[link_name = "\u{1}_ZN2cv3viz13WPaintedCloudC1ERKNS_11_InputArrayERKNS_7Point3_IdEES8_"]
    pub fn cv_viz_WPaintedCloud_WPaintedCloud1(
        this: *mut cv_viz_WPaintedCloud,
        cloud: cv_InputArray,
        p1: *const cv_Point3d,
        p2: *const cv_Point3d,
    );
}
unsafe extern "C" {
    #[doc = "! Paint cloud with gradient specified by given colors between given points"]
    #[link_name = "\u{1}_ZN2cv3viz13WPaintedCloudC1ERKNS_11_InputArrayERKNS_7Point3_IdEES8_RKNS0_5ColorES9_"]
    pub fn cv_viz_WPaintedCloud_WPaintedCloud2(
        this: *mut cv_viz_WPaintedCloud,
        cloud: cv_InputArray,
        p1: *const cv_Point3d,
        p2: *const cv_Point3d,
        c1: *const cv_viz_Color,
        c2: cv_viz_Color,
    );
}
impl cv_viz_WPaintedCloud {
    #[inline]
    pub unsafe fn new(cloud: cv_InputArray) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WPaintedCloud_WPaintedCloud(__bindgen_tmp.as_mut_ptr(), cloud);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(cloud: cv_InputArray, p1: *const cv_Point3d, p2: *const cv_Point3d) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WPaintedCloud_WPaintedCloud1(__bindgen_tmp.as_mut_ptr(), cloud, p1, p2);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(
        cloud: cv_InputArray,
        p1: *const cv_Point3d,
        p2: *const cv_Point3d,
        c1: *const cv_viz_Color,
        c2: cv_viz_Color,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WPaintedCloud_WPaintedCloud2(__bindgen_tmp.as_mut_ptr(), cloud, p1, p2, c1, c2);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This 3D Widget defines a collection of clouds. :\n@note In case there are four channels in the cloud, fourth channel is ignored."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WCloudCollection {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WCloudCollection"][::std::mem::size_of::<cv_viz_WCloudCollection>() - 16usize];
    ["Alignment of cv_viz_WCloudCollection"]
        [::std::mem::align_of::<cv_viz_WCloudCollection>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Adds a cloud to the collection.\n\n@param cloud Point set which can be of type: CV_32FC3, CV_32FC4, CV_64FC3, CV_64FC4.\n@param colors Set of colors. It has to be of the same size with cloud.\n@param pose Pose of the cloud. Points in the cloud belong to mask when they are set to (NaN, NaN, NaN)."]
    #[link_name = "\u{1}_ZN2cv3viz16WCloudCollection8addCloudERKNS_11_InputArrayES4_RKNS_7Affine3IdEE"]
    pub fn cv_viz_WCloudCollection_addCloud(
        this: *mut cv_viz_WCloudCollection,
        cloud: cv_InputArray,
        colors: cv_InputArray,
        pose: *const cv_Affine3d,
    );
}
unsafe extern "C" {
    #[doc = " @brief Adds a cloud to the collection.\n\n@param cloud Point set which can be of type: CV_32FC3, CV_32FC4, CV_64FC3, CV_64FC4.\n@param color A single Color for the whole cloud.\n@param pose Pose of the cloud. Points in the cloud belong to mask when they are set to (NaN, NaN, NaN)."]
    #[link_name = "\u{1}_ZN2cv3viz16WCloudCollection8addCloudERKNS_11_InputArrayERKNS0_5ColorERKNS_7Affine3IdEE"]
    pub fn cv_viz_WCloudCollection_addCloud1(
        this: *mut cv_viz_WCloudCollection,
        cloud: cv_InputArray,
        color: *const cv_viz_Color,
        pose: *const cv_Affine3d,
    );
}
unsafe extern "C" {
    #[doc = " @brief Finalizes cloud data by repacking to single cloud.\n\nUseful for large cloud collections to reduce memory usage"]
    #[link_name = "\u{1}_ZN2cv3viz16WCloudCollection8finalizeEv"]
    pub fn cv_viz_WCloudCollection_finalize(this: *mut cv_viz_WCloudCollection);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3viz16WCloudCollectionC1Ev"]
    pub fn cv_viz_WCloudCollection_WCloudCollection(this: *mut cv_viz_WCloudCollection);
}
impl cv_viz_WCloudCollection {
    #[inline]
    pub unsafe fn addCloud(
        &mut self,
        cloud: cv_InputArray,
        colors: cv_InputArray,
        pose: *const cv_Affine3d,
    ) {
        cv_viz_WCloudCollection_addCloud(self, cloud, colors, pose)
    }
    #[inline]
    pub unsafe fn addCloud1(
        &mut self,
        cloud: cv_InputArray,
        color: *const cv_viz_Color,
        pose: *const cv_Affine3d,
    ) {
        cv_viz_WCloudCollection_addCloud1(self, cloud, color, pose)
    }
    #[inline]
    pub unsafe fn finalize(&mut self) {
        cv_viz_WCloudCollection_finalize(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WCloudCollection_WCloudCollection(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This 3D Widget represents normals of a point cloud. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WCloudNormals {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WCloudNormals"][::std::mem::size_of::<cv_viz_WCloudNormals>() - 16usize];
    ["Alignment of cv_viz_WCloudNormals"][::std::mem::align_of::<cv_viz_WCloudNormals>() - 8usize];
};
unsafe extern "C" {
    #[doc = " @brief Constructs a WCloudNormals.\n\n@param cloud Point set which can be of type: CV_32FC3, CV_32FC4, CV_64FC3, CV_64FC4.\n@param normals A set of normals that has to be of same type with cloud.\n@param level Display only every level th normal.\n@param scale Scale of the arrows that represent normals.\n@param color Color of the arrows that represent normals.\n\n@note In case there are four channels in the cloud, fourth channel is ignored."]
    #[link_name = "\u{1}_ZN2cv3viz13WCloudNormalsC1ERKNS_11_InputArrayES4_idRKNS0_5ColorE"]
    pub fn cv_viz_WCloudNormals_WCloudNormals(
        this: *mut cv_viz_WCloudNormals,
        cloud: cv_InputArray,
        normals: cv_InputArray,
        level: ::std::os::raw::c_int,
        scale: f64,
        color: *const cv_viz_Color,
    );
}
impl cv_viz_WCloudNormals {
    #[inline]
    pub unsafe fn new(
        cloud: cv_InputArray,
        normals: cv_InputArray,
        level: ::std::os::raw::c_int,
        scale: f64,
        color: *const cv_viz_Color,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WCloudNormals_WCloudNormals(
            __bindgen_tmp.as_mut_ptr(),
            cloud,
            normals,
            level,
            scale,
            color,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief Constructs a WMesh.\n\n@param mesh Mesh object that will be displayed.\n@param cloud Points of the mesh object.\n@param polygons Points of the mesh object.\n@param colors Point colors.\n@param normals Point normals."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WMesh {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WMesh"][::std::mem::size_of::<cv_viz_WMesh>() - 16usize];
    ["Alignment of cv_viz_WMesh"][::std::mem::align_of::<cv_viz_WMesh>() - 8usize];
};
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3viz5WMeshC1ERKNS0_4MeshE"]
    pub fn cv_viz_WMesh_WMesh(this: *mut cv_viz_WMesh, mesh: *const cv_viz_Mesh);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3viz5WMeshC1ERKNS_11_InputArrayES4_S4_S4_"]
    pub fn cv_viz_WMesh_WMesh1(
        this: *mut cv_viz_WMesh,
        cloud: cv_InputArray,
        polygons: cv_InputArray,
        colors: cv_InputArray,
        normals: cv_InputArray,
    );
}
impl cv_viz_WMesh {
    #[inline]
    pub unsafe fn new(mesh: *const cv_viz_Mesh) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WMesh_WMesh(__bindgen_tmp.as_mut_ptr(), mesh);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        cloud: cv_InputArray,
        polygons: cv_InputArray,
        colors: cv_InputArray,
        normals: cv_InputArray,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WMesh_WMesh1(__bindgen_tmp.as_mut_ptr(), cloud, polygons, colors, normals);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief This class allows to merge several widgets to single one.\n\nIt has quite limited functionality and can't merge widgets with different attributes. For\ninstance, if widgetA has color array and widgetB has only global color defined, then result\nof merge won't have color at all. The class is suitable for merging large amount of similar\nwidgets. :"]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_WWidgetMerger {
    pub _base: cv_viz_Widget3D,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_WWidgetMerger"][::std::mem::size_of::<cv_viz_WWidgetMerger>() - 16usize];
    ["Alignment of cv_viz_WWidgetMerger"][::std::mem::align_of::<cv_viz_WWidgetMerger>() - 8usize];
};
unsafe extern "C" {
    #[doc = "! Add widget to merge with optional position change"]
    #[link_name = "\u{1}_ZN2cv3viz13WWidgetMerger9addWidgetERKNS0_8Widget3DERKNS_7Affine3IdEE"]
    pub fn cv_viz_WWidgetMerger_addWidget(
        this: *mut cv_viz_WWidgetMerger,
        widget: *const cv_viz_Widget3D,
        pose: *const cv_Affine3d,
    );
}
unsafe extern "C" {
    #[doc = "! Repacks internal structure to single widget"]
    #[link_name = "\u{1}_ZN2cv3viz13WWidgetMerger8finalizeEv"]
    pub fn cv_viz_WWidgetMerger_finalize(this: *mut cv_viz_WWidgetMerger);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3viz13WWidgetMergerC1Ev"]
    pub fn cv_viz_WWidgetMerger_WWidgetMerger(this: *mut cv_viz_WWidgetMerger);
}
impl cv_viz_WWidgetMerger {
    #[inline]
    pub unsafe fn addWidget(&mut self, widget: *const cv_viz_Widget3D, pose: *const cv_Affine3d) {
        cv_viz_WWidgetMerger_addWidget(self, widget, pose)
    }
    #[inline]
    pub unsafe fn finalize(&mut self) {
        cv_viz_WWidgetMerger_finalize(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_WWidgetMerger_WWidgetMerger(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief The Viz3d class represents a 3D visualizer window. This class is implicitly shared."]
#[repr(C)]
#[derive(Debug)]
pub struct cv_viz_Viz3d {
    pub impl_: *mut cv_viz_Viz3d_VizImpl,
}
#[doc = " @brief This class represents color in BGR order."]
pub type cv_viz_Viz3d_Color = cv_viz_Color;
pub type cv_viz_Viz3d_KeyboardCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const cv_viz_KeyboardEvent, arg2: *mut ::std::os::raw::c_void),
>;
pub type cv_viz_Viz3d_MouseCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const cv_viz_MouseEvent, arg2: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cv_viz_Viz3d_VizImpl {
    _unused: [u8; 0],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cv_viz_Viz3d"][::std::mem::size_of::<cv_viz_Viz3d>() - 8usize];
    ["Alignment of cv_viz_Viz3d"][::std::mem::align_of::<cv_viz_Viz3d>() - 8usize];
    ["Offset of field: cv_viz_Viz3d::impl_"][::std::mem::offset_of!(cv_viz_Viz3d, impl_) - 0usize];
};
unsafe extern "C" {
    #[doc = " @brief Shows a widget in the window.\n\n@param id A unique id for the widget. @param widget The widget to be displayed in the window.\n@param pose Pose of the widget."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d10showWidgetERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS0_6WidgetERKNS_7Affine3IdEE"]
    pub fn cv_viz_Viz3d_showWidget(
        this: *mut cv_viz_Viz3d,
        id: *const cv_String,
        widget: *const cv_viz_Widget,
        pose: *const cv_Affine3d,
    );
}
unsafe extern "C" {
    #[doc = " @brief Removes a widget from the window.\n\n@param id The id of the widget that will be removed."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d12removeWidgetERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_viz_Viz3d_removeWidget(this: *mut cv_viz_Viz3d, id: *const cv_String);
}
unsafe extern "C" {
    #[doc = " @brief Retrieves a widget from the window.\n\nA widget is implicitly shared; that is, if the returned widget is modified, the changes\nwill be immediately visible in the window.\n\n@param id The id of the widget that will be returned."]
    #[link_name = "\u{1}_ZNK2cv3viz5Viz3d9getWidgetERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_viz_Viz3d_getWidget(this: *const cv_viz_Viz3d, id: *const cv_String)
    -> cv_viz_Widget;
}
unsafe extern "C" {
    #[doc = " @brief Removes all widgets from the window."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d16removeAllWidgetsEv"]
    pub fn cv_viz_Viz3d_removeAllWidgets(this: *mut cv_viz_Viz3d);
}
unsafe extern "C" {
    #[doc = " @brief Removed all widgets and displays image scaled to whole window area.\n\n@param image Image to be displayed.\n@param window_size Size of Viz3d window. Default value means no change."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d9showImageERKNS_11_InputArrayERKNS_5Size_IiEE"]
    pub fn cv_viz_Viz3d_showImage(
        this: *mut cv_viz_Viz3d,
        image: cv_InputArray,
        window_size: *const cv_Size,
    );
}
unsafe extern "C" {
    #[doc = " @brief Sets pose of a widget in the window.\n\n@param id The id of the widget whose pose will be set. @param pose The new pose of the widget."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d13setWidgetPoseERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_7Affine3IdEE"]
    pub fn cv_viz_Viz3d_setWidgetPose(
        this: *mut cv_viz_Viz3d,
        id: *const cv_String,
        pose: *const cv_Affine3d,
    );
}
unsafe extern "C" {
    #[doc = " @brief Updates pose of a widget in the window by pre-multiplying its current pose.\n\n@param id The id of the widget whose pose will be updated. @param pose The pose that the current\npose of the widget will be pre-multiplied by."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d16updateWidgetPoseERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_7Affine3IdEE"]
    pub fn cv_viz_Viz3d_updateWidgetPose(
        this: *mut cv_viz_Viz3d,
        id: *const cv_String,
        pose: *const cv_Affine3d,
    );
}
unsafe extern "C" {
    #[doc = " @brief Returns the current pose of a widget in the window.\n\n@param id The id of the widget whose pose will be returned."]
    #[link_name = "\u{1}_ZNK2cv3viz5Viz3d13getWidgetPoseERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_viz_Viz3d_getWidgetPose(
        this: *const cv_viz_Viz3d,
        id: *const cv_String,
    ) -> cv_Affine3d;
}
unsafe extern "C" {
    #[doc = " @brief Sets the intrinsic parameters of the viewer using Camera.\n\n@param camera Camera object wrapping intrinsic parameters."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d9setCameraERKNS0_6CameraE"]
    pub fn cv_viz_Viz3d_setCamera(this: *mut cv_viz_Viz3d, camera: *const cv_viz_Camera);
}
unsafe extern "C" {
    #[doc = " @brief Returns a camera object that contains intrinsic parameters of the current viewer."]
    #[link_name = "\u{1}_ZNK2cv3viz5Viz3d9getCameraEv"]
    pub fn cv_viz_Viz3d_getCamera(this: *const cv_viz_Viz3d) -> cv_viz_Camera;
}
unsafe extern "C" {
    #[doc = " @brief Returns the current pose of the viewer."]
    #[link_name = "\u{1}_ZNK2cv3viz5Viz3d13getViewerPoseEv"]
    pub fn cv_viz_Viz3d_getViewerPose(this: *const cv_viz_Viz3d) -> cv_Affine3d;
}
unsafe extern "C" {
    #[doc = " @brief Sets pose of the viewer.\n\n@param pose The new pose of the viewer."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d13setViewerPoseERKNS_7Affine3IdEE"]
    pub fn cv_viz_Viz3d_setViewerPose(this: *mut cv_viz_Viz3d, pose: *const cv_Affine3d);
}
unsafe extern "C" {
    #[doc = " @brief Resets camera viewpoint to a 3D widget in the scene.\n\n@param id Id of a 3D widget."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d20resetCameraViewpointERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_viz_Viz3d_resetCameraViewpoint(this: *mut cv_viz_Viz3d, id: *const cv_String);
}
unsafe extern "C" {
    #[doc = " @brief Resets camera."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d11resetCameraEv"]
    pub fn cv_viz_Viz3d_resetCamera(this: *mut cv_viz_Viz3d);
}
unsafe extern "C" {
    #[doc = " @brief Transforms a point in world coordinate system to window coordinate system.\n\n@param pt Point in world coordinate system.\n@param window_coord Output point in window coordinate system."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d26convertToWindowCoordinatesERKNS_7Point3_IdEERS3_"]
    pub fn cv_viz_Viz3d_convertToWindowCoordinates(
        this: *mut cv_viz_Viz3d,
        pt: *const cv_Point3d,
        window_coord: *mut cv_Point3d,
    );
}
unsafe extern "C" {
    #[doc = " @brief Transforms a point in window coordinate system to a 3D ray in world coordinate system.\n\n@param window_coord Point in window coordinate system. @param origin Output origin of the ray.\n@param direction Output direction of the ray."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d13converTo3DRayERKNS_7Point3_IdEERS3_RNS_3VecIdLi3EEE"]
    pub fn cv_viz_Viz3d_converTo3DRay(
        this: *mut cv_viz_Viz3d,
        window_coord: *const cv_Point3d,
        origin: *mut cv_Point3d,
        direction: *mut cv_Vec3d,
    );
}
unsafe extern "C" {
    #[doc = " @brief Returns the current size of the window."]
    #[link_name = "\u{1}_ZNK2cv3viz5Viz3d13getWindowSizeEv"]
    pub fn cv_viz_Viz3d_getWindowSize(this: *const cv_viz_Viz3d) -> cv_Size;
}
unsafe extern "C" {
    #[doc = " @brief Sets the size of the window.\n\n@param window_size New size of the window."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d13setWindowSizeERKNS_5Size_IiEE"]
    pub fn cv_viz_Viz3d_setWindowSize(this: *mut cv_viz_Viz3d, window_size: *const cv_Size);
}
unsafe extern "C" {
    #[doc = " @brief Returns the name of the window which has been set in the constructor.\n  `Viz - ` is prepended to the name if necessary."]
    #[link_name = "\u{1}_ZNK2cv3viz5Viz3d13getWindowNameB5cxx11Ev"]
    pub fn cv_viz_Viz3d_getWindowName(this: *const cv_viz_Viz3d) -> cv_String;
}
unsafe extern "C" {
    #[doc = " @brief Returns the Mat screenshot of the current scene."]
    #[link_name = "\u{1}_ZNK2cv3viz5Viz3d13getScreenshotEv"]
    pub fn cv_viz_Viz3d_getScreenshot(this: *const cv_viz_Viz3d) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = " @brief Saves screenshot of the current scene.\n\n@param file Name of the file."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d14saveScreenshotERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_viz_Viz3d_saveScreenshot(this: *mut cv_viz_Viz3d, file: *const cv_String);
}
unsafe extern "C" {
    #[doc = " @brief Sets the position of the window in the screen.\n\n@param window_position coordinates of the window"]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d17setWindowPositionERKNS_6Point_IiEE"]
    pub fn cv_viz_Viz3d_setWindowPosition(
        this: *mut cv_viz_Viz3d,
        window_position: *const cv_Point,
    );
}
unsafe extern "C" {
    #[doc = " @brief Sets or unsets full-screen rendering mode.\n\n@param mode If true, window will use full-screen mode."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d13setFullScreenEb"]
    pub fn cv_viz_Viz3d_setFullScreen(this: *mut cv_viz_Viz3d, mode: bool);
}
unsafe extern "C" {
    #[doc = " @brief Sets background color."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d18setBackgroundColorERKNS0_5ColorES4_"]
    pub fn cv_viz_Viz3d_setBackgroundColor(
        this: *mut cv_viz_Viz3d,
        color: *const cv_viz_Viz3d_Color,
        color2: *const cv_viz_Viz3d_Color,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d20setBackgroundTextureERKNS_11_InputArrayE"]
    pub fn cv_viz_Viz3d_setBackgroundTexture(this: *mut cv_viz_Viz3d, image: cv_InputArray);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d20setBackgroundMeshLabEv"]
    pub fn cv_viz_Viz3d_setBackgroundMeshLab(this: *mut cv_viz_Viz3d);
}
unsafe extern "C" {
    #[doc = " @brief The window renders and starts the event loop."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d4spinEv"]
    pub fn cv_viz_Viz3d_spin(this: *mut cv_viz_Viz3d);
}
unsafe extern "C" {
    #[doc = " @brief Starts the event loop for a given time.\n\n@param time Amount of time in milliseconds for the event loop to keep running.\n@param force_redraw If true, window renders."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d8spinOnceEib"]
    pub fn cv_viz_Viz3d_spinOnce(
        this: *mut cv_viz_Viz3d,
        time: ::std::os::raw::c_int,
        force_redraw: bool,
    );
}
unsafe extern "C" {
    #[doc = " @brief Create a window in memory instead of on the screen."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d21setOffScreenRenderingEv"]
    pub fn cv_viz_Viz3d_setOffScreenRendering(this: *mut cv_viz_Viz3d);
}
unsafe extern "C" {
    #[doc = " @brief Remove all lights from the current scene."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d15removeAllLightsEv"]
    pub fn cv_viz_Viz3d_removeAllLights(this: *mut cv_viz_Viz3d);
}
unsafe extern "C" {
    #[doc = " @brief Add a light in the scene.\n\n@param position The position of the light.\n@param focalPoint The point at which the light is shining\n@param color The color of the light\n@param diffuseColor The diffuse color of the light\n@param ambientColor The ambient color of the light\n@param specularColor The specular color of the light"]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d8addLightERKNS_3VecIdLi3EEES5_RKNS0_5ColorES8_S8_S8_"]
    pub fn cv_viz_Viz3d_addLight(
        this: *mut cv_viz_Viz3d,
        position: *const cv_Vec3d,
        focalPoint: *const cv_Vec3d,
        color: *const cv_viz_Viz3d_Color,
        diffuseColor: *const cv_viz_Viz3d_Color,
        ambientColor: *const cv_viz_Viz3d_Color,
        specularColor: *const cv_viz_Viz3d_Color,
    );
}
unsafe extern "C" {
    #[doc = " @brief Returns whether the event loop has been stopped."]
    #[link_name = "\u{1}_ZNK2cv3viz5Viz3d10wasStoppedEv"]
    pub fn cv_viz_Viz3d_wasStopped(this: *const cv_viz_Viz3d) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d5closeEv"]
    pub fn cv_viz_Viz3d_close(this: *mut cv_viz_Viz3d);
}
unsafe extern "C" {
    #[doc = " @brief Sets keyboard handler.\n\n@param callback Keyboard callback (void (\\*KeyboardCallbackFunction(const\nKeyboardEvent&, void\\*)).\n@param cookie The optional parameter passed to the callback."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d24registerKeyboardCallbackEPFvRKNS0_13KeyboardEventEPvES5_"]
    pub fn cv_viz_Viz3d_registerKeyboardCallback(
        this: *mut cv_viz_Viz3d,
        callback: cv_viz_Viz3d_KeyboardCallback,
        cookie: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " @brief Sets mouse handler.\n\n@param callback Mouse callback (void (\\*MouseCallback)(const MouseEvent&, void\\*)).\n@param cookie The optional parameter passed to the callback."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d21registerMouseCallbackEPFvRKNS0_10MouseEventEPvES5_"]
    pub fn cv_viz_Viz3d_registerMouseCallback(
        this: *mut cv_viz_Viz3d,
        callback: cv_viz_Viz3d_MouseCallback,
        cookie: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " @brief Sets rendering property of a widget.\n\n@param id Id of the widget.\n@param property Property that will be modified.\n@param value The new value of the property.\n\nRendering property can be one of the following:\n-   **POINT_SIZE**\n-   **OPACITY**\n-   **LINE_WIDTH**\n-   **FONT_SIZE**\n\nREPRESENTATION: Expected values are\n-   **REPRESENTATION_POINTS**\n-   **REPRESENTATION_WIREFRAME**\n-   **REPRESENTATION_SURFACE**\n\nIMMEDIATE_RENDERING:\n-   Turn on immediate rendering by setting the value to 1.\n-   Turn off immediate rendering by setting the value to 0.\n\nSHADING: Expected values are\n-   **SHADING_FLAT**\n-   **SHADING_GOURAUD**\n-   **SHADING_PHONG**"]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d20setRenderingPropertyERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEid"]
    pub fn cv_viz_Viz3d_setRenderingProperty(
        this: *mut cv_viz_Viz3d,
        id: *const cv_String,
        property: ::std::os::raw::c_int,
        value: f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Returns rendering property of a widget.\n\n@param id Id of the widget.\n@param property Property.\n\nRendering property can be one of the following:\n-   **POINT_SIZE**\n-   **OPACITY**\n-   **LINE_WIDTH**\n-   **FONT_SIZE**\n\nREPRESENTATION: Expected values are\n-   **REPRESENTATION_POINTS**\n-   **REPRESENTATION_WIREFRAME**\n-   **REPRESENTATION_SURFACE**\n\nIMMEDIATE_RENDERING:\n-   Turn on immediate rendering by setting the value to 1.\n-   Turn off immediate rendering by setting the value to 0.\n\nSHADING: Expected values are\n-   **SHADING_FLAT**\n-   **SHADING_GOURAUD**\n-   **SHADING_PHONG**"]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d20getRenderingPropertyERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
    pub fn cv_viz_Viz3d_getRenderingProperty(
        this: *mut cv_viz_Viz3d,
        id: *const cv_String,
        property: ::std::os::raw::c_int,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Sets geometry representation of the widgets to surface, wireframe or points.\n\n@param representation Geometry representation which can be one of the following:\n-   **REPRESENTATION_POINTS**\n-   **REPRESENTATION_WIREFRAME**\n-   **REPRESENTATION_SURFACE**"]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d17setRepresentationEi"]
    pub fn cv_viz_Viz3d_setRepresentation(
        this: *mut cv_viz_Viz3d,
        representation: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3viz5Viz3d17setGlobalWarningsEb"]
    pub fn cv_viz_Viz3d_setGlobalWarnings(this: *mut cv_viz_Viz3d, enabled: bool);
}
unsafe extern "C" {
    #[doc = " @brief The constructors.\n\n@param window_name Name of the window."]
    #[link_name = "\u{1}_ZN2cv3viz5Viz3dC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_viz_Viz3d_Viz3d(this: *mut cv_viz_Viz3d, window_name: *const cv_String);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3viz5Viz3dC1ERKS1_"]
    pub fn cv_viz_Viz3d_Viz3d1(this: *mut cv_viz_Viz3d, arg1: *const cv_viz_Viz3d);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN2cv3viz5Viz3dD1Ev"]
    pub fn cv_viz_Viz3d_Viz3d_destructor(this: *mut cv_viz_Viz3d);
}
impl cv_viz_Viz3d {
    #[inline]
    pub unsafe fn showWidget(
        &mut self,
        id: *const cv_String,
        widget: *const cv_viz_Widget,
        pose: *const cv_Affine3d,
    ) {
        cv_viz_Viz3d_showWidget(self, id, widget, pose)
    }
    #[inline]
    pub unsafe fn removeWidget(&mut self, id: *const cv_String) {
        cv_viz_Viz3d_removeWidget(self, id)
    }
    #[inline]
    pub unsafe fn getWidget(&self, id: *const cv_String) -> cv_viz_Widget {
        cv_viz_Viz3d_getWidget(self, id)
    }
    #[inline]
    pub unsafe fn removeAllWidgets(&mut self) {
        cv_viz_Viz3d_removeAllWidgets(self)
    }
    #[inline]
    pub unsafe fn showImage(&mut self, image: cv_InputArray, window_size: *const cv_Size) {
        cv_viz_Viz3d_showImage(self, image, window_size)
    }
    #[inline]
    pub unsafe fn setWidgetPose(&mut self, id: *const cv_String, pose: *const cv_Affine3d) {
        cv_viz_Viz3d_setWidgetPose(self, id, pose)
    }
    #[inline]
    pub unsafe fn updateWidgetPose(&mut self, id: *const cv_String, pose: *const cv_Affine3d) {
        cv_viz_Viz3d_updateWidgetPose(self, id, pose)
    }
    #[inline]
    pub unsafe fn getWidgetPose(&self, id: *const cv_String) -> cv_Affine3d {
        cv_viz_Viz3d_getWidgetPose(self, id)
    }
    #[inline]
    pub unsafe fn setCamera(&mut self, camera: *const cv_viz_Camera) {
        cv_viz_Viz3d_setCamera(self, camera)
    }
    #[inline]
    pub unsafe fn getCamera(&self) -> cv_viz_Camera {
        cv_viz_Viz3d_getCamera(self)
    }
    #[inline]
    pub unsafe fn getViewerPose(&self) -> cv_Affine3d {
        cv_viz_Viz3d_getViewerPose(self)
    }
    #[inline]
    pub unsafe fn setViewerPose(&mut self, pose: *const cv_Affine3d) {
        cv_viz_Viz3d_setViewerPose(self, pose)
    }
    #[inline]
    pub unsafe fn resetCameraViewpoint(&mut self, id: *const cv_String) {
        cv_viz_Viz3d_resetCameraViewpoint(self, id)
    }
    #[inline]
    pub unsafe fn resetCamera(&mut self) {
        cv_viz_Viz3d_resetCamera(self)
    }
    #[inline]
    pub unsafe fn convertToWindowCoordinates(
        &mut self,
        pt: *const cv_Point3d,
        window_coord: *mut cv_Point3d,
    ) {
        cv_viz_Viz3d_convertToWindowCoordinates(self, pt, window_coord)
    }
    #[inline]
    pub unsafe fn converTo3DRay(
        &mut self,
        window_coord: *const cv_Point3d,
        origin: *mut cv_Point3d,
        direction: *mut cv_Vec3d,
    ) {
        cv_viz_Viz3d_converTo3DRay(self, window_coord, origin, direction)
    }
    #[inline]
    pub unsafe fn getWindowSize(&self) -> cv_Size {
        cv_viz_Viz3d_getWindowSize(self)
    }
    #[inline]
    pub unsafe fn setWindowSize(&mut self, window_size: *const cv_Size) {
        cv_viz_Viz3d_setWindowSize(self, window_size)
    }
    #[inline]
    pub unsafe fn getWindowName(&self) -> cv_String {
        cv_viz_Viz3d_getWindowName(self)
    }
    #[inline]
    pub unsafe fn getScreenshot(&self) -> cv_Mat {
        cv_viz_Viz3d_getScreenshot(self)
    }
    #[inline]
    pub unsafe fn saveScreenshot(&mut self, file: *const cv_String) {
        cv_viz_Viz3d_saveScreenshot(self, file)
    }
    #[inline]
    pub unsafe fn setWindowPosition(&mut self, window_position: *const cv_Point) {
        cv_viz_Viz3d_setWindowPosition(self, window_position)
    }
    #[inline]
    pub unsafe fn setFullScreen(&mut self, mode: bool) {
        cv_viz_Viz3d_setFullScreen(self, mode)
    }
    #[inline]
    pub unsafe fn setBackgroundColor(
        &mut self,
        color: *const cv_viz_Viz3d_Color,
        color2: *const cv_viz_Viz3d_Color,
    ) {
        cv_viz_Viz3d_setBackgroundColor(self, color, color2)
    }
    #[inline]
    pub unsafe fn setBackgroundTexture(&mut self, image: cv_InputArray) {
        cv_viz_Viz3d_setBackgroundTexture(self, image)
    }
    #[inline]
    pub unsafe fn setBackgroundMeshLab(&mut self) {
        cv_viz_Viz3d_setBackgroundMeshLab(self)
    }
    #[inline]
    pub unsafe fn spin(&mut self) {
        cv_viz_Viz3d_spin(self)
    }
    #[inline]
    pub unsafe fn spinOnce(&mut self, time: ::std::os::raw::c_int, force_redraw: bool) {
        cv_viz_Viz3d_spinOnce(self, time, force_redraw)
    }
    #[inline]
    pub unsafe fn setOffScreenRendering(&mut self) {
        cv_viz_Viz3d_setOffScreenRendering(self)
    }
    #[inline]
    pub unsafe fn removeAllLights(&mut self) {
        cv_viz_Viz3d_removeAllLights(self)
    }
    #[inline]
    pub unsafe fn addLight(
        &mut self,
        position: *const cv_Vec3d,
        focalPoint: *const cv_Vec3d,
        color: *const cv_viz_Viz3d_Color,
        diffuseColor: *const cv_viz_Viz3d_Color,
        ambientColor: *const cv_viz_Viz3d_Color,
        specularColor: *const cv_viz_Viz3d_Color,
    ) {
        cv_viz_Viz3d_addLight(
            self,
            position,
            focalPoint,
            color,
            diffuseColor,
            ambientColor,
            specularColor,
        )
    }
    #[inline]
    pub unsafe fn wasStopped(&self) -> bool {
        cv_viz_Viz3d_wasStopped(self)
    }
    #[inline]
    pub unsafe fn close(&mut self) {
        cv_viz_Viz3d_close(self)
    }
    #[inline]
    pub unsafe fn registerKeyboardCallback(
        &mut self,
        callback: cv_viz_Viz3d_KeyboardCallback,
        cookie: *mut ::std::os::raw::c_void,
    ) {
        cv_viz_Viz3d_registerKeyboardCallback(self, callback, cookie)
    }
    #[inline]
    pub unsafe fn registerMouseCallback(
        &mut self,
        callback: cv_viz_Viz3d_MouseCallback,
        cookie: *mut ::std::os::raw::c_void,
    ) {
        cv_viz_Viz3d_registerMouseCallback(self, callback, cookie)
    }
    #[inline]
    pub unsafe fn setRenderingProperty(
        &mut self,
        id: *const cv_String,
        property: ::std::os::raw::c_int,
        value: f64,
    ) {
        cv_viz_Viz3d_setRenderingProperty(self, id, property, value)
    }
    #[inline]
    pub unsafe fn getRenderingProperty(
        &mut self,
        id: *const cv_String,
        property: ::std::os::raw::c_int,
    ) -> f64 {
        cv_viz_Viz3d_getRenderingProperty(self, id, property)
    }
    #[inline]
    pub unsafe fn setRepresentation(&mut self, representation: ::std::os::raw::c_int) {
        cv_viz_Viz3d_setRepresentation(self, representation)
    }
    #[inline]
    pub unsafe fn setGlobalWarnings(&mut self, enabled: bool) {
        cv_viz_Viz3d_setGlobalWarnings(self, enabled)
    }
    #[inline]
    pub unsafe fn new(window_name: *const cv_String) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_Viz3d_Viz3d(__bindgen_tmp.as_mut_ptr(), window_name);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const cv_viz_Viz3d) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cv_viz_Viz3d_Viz3d1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cv_viz_Viz3d_Viz3d_destructor(self)
    }
}
unsafe extern "C" {
    #[doc = " @brief Takes coordinate frame data and builds transform to global coordinate frame.\n\n@param axis_x X axis vector in global coordinate frame.\n@param axis_y Y axis vector in global coordinate frame.\n@param axis_z Z axis vector in global coordinate frame.\n@param origin Origin of the coordinate frame in global coordinate frame.\n\n@return An affine transform that describes transformation between global coordinate frame\nand a given coordinate frame.\nThe returned transforms can transform a point in the given coordinate frame to the global\ncoordinate frame."]
    #[link_name = "\u{1}_ZN2cv3viz21makeTransformToGlobalERKNS_3VecIdLi3EEES4_S4_S4_"]
    pub fn cv_viz_makeTransformToGlobal(
        axis_x: *const cv_Vec3d,
        axis_y: *const cv_Vec3d,
        axis_z: *const cv_Vec3d,
        origin: *const cv_Vec3d,
    ) -> cv_Affine3d;
}
unsafe extern "C" {
    #[doc = " @brief Constructs camera pose from position, focal_point and up_vector (see gluLookAt() for more\ninformation).\n\n@param position Position of the camera in global coordinate frame.\n@param focal_point Focal point of the camera in global coordinate frame.\n@param y_dir Up vector of the camera in global coordinate frame.\n\nThis function returns pose of the camera in global coordinate frame."]
    #[link_name = "\u{1}_ZN2cv3viz14makeCameraPoseERKNS_3VecIdLi3EEES4_S4_"]
    pub fn cv_viz_makeCameraPose(
        position: *const cv_Vec3d,
        focal_point: *const cv_Vec3d,
        y_dir: *const cv_Vec3d,
    ) -> cv_Affine3d;
}
unsafe extern "C" {
    #[doc = " @brief Retrieves a window by its name.\n\n@param window_name Name of the window that is to be retrieved.\n\nThis function returns a Viz3d object with the given name.\n\n@note If the window with that name already exists, that window is returned. Otherwise, new window is\ncreated with the given name, and it is returned.\n\n@note Window names are automatically prefixed by \"Viz - \" if it is not done by the user.\n@code\n/// window and window_2 are the same windows.\nviz::Viz3d window   = viz::getWindowByName(\"myWindow\");\nviz::Viz3d window_2 = viz::getWindowByName(\"Viz - myWindow\");\n@endcode"]
    #[link_name = "\u{1}_ZN2cv3viz15getWindowByNameERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_viz_getWindowByName(window_name: *const cv_String) -> cv_viz_Viz3d;
}
unsafe extern "C" {
    #[doc = "! Unregisters all Viz windows from internal database. After it 'getWindowByName()' will create new windows instead of getting existing from the database."]
    #[link_name = "\u{1}_ZN2cv3viz20unregisterAllWindowsEv"]
    pub fn cv_viz_unregisterAllWindows();
}
unsafe extern "C" {
    #[doc = "! Displays image in specified window"]
    #[link_name = "\u{1}_ZN2cv3viz6imshowERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_11_InputArrayERKNS_5Size_IiEE"]
    pub fn cv_viz_imshow(
        window_name: *const cv_String,
        image: cv_InputArray,
        window_size: *const cv_Size,
    ) -> cv_viz_Viz3d;
}
unsafe extern "C" {
    #[doc = " @param file Filename with extension. Supported formats: PLY, XYZ and OBJ.\n @param cloud  Supported depths: CV_32F and CV_64F. Supported channels: 3 and 4.\n @param colors Used by PLY format only. Supported depth: CV_8U. Supported channels: 1, 3 and 4.\n @param normals Used by PLY and OBJ format only. Supported depths: CV_32F and CV_64F.\n                Supported channels: 3 and 4.\n @param binary Used only for PLY format."]
    #[link_name = "\u{1}_ZN2cv3viz10writeCloudERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_11_InputArrayESB_SB_b"]
    pub fn cv_viz_writeCloud(
        file: *const cv_String,
        cloud: cv_InputArray,
        colors: cv_InputArray,
        normals: cv_InputArray,
        binary: bool,
    );
}
unsafe extern "C" {
    #[doc = " @param file Filename with extension. Supported formats: PLY, XYZ, OBJ and STL.\n @param colors Used by PLY and STL formats only.\n @param normals Used by PLY, OBJ and STL formats only.\n @return A mat containing the point coordinates with depth CV_32F or CV_64F and number of\n         channels 3 or 4 with only 1 row."]
    #[link_name = "\u{1}_ZN2cv3viz9readCloudERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_12_OutputArrayESB_"]
    pub fn cv_viz_readCloud(
        file: *const cv_String,
        colors: cv_OutputArray,
        normals: cv_OutputArray,
    ) -> cv_Mat;
}
unsafe extern "C" {
    #[doc = "\n Reads mesh. Only ply format is supported now and no texture load support"]
    #[link_name = "\u{1}_ZN2cv3viz8readMeshERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn cv_viz_readMesh(file: *const cv_String) -> cv_viz_Mesh;
}
unsafe extern "C" {
    #[doc = " @param file Filename of type supported by cv::FileStorage.\n @param pose Output matrix.\n @param tag Name of the pose in the file."]
    #[link_name = "\u{1}_ZN2cv3viz8readPoseERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERNS_7Affine3IdEES8_"]
    pub fn cv_viz_readPose(
        file: *const cv_String,
        pose: *mut cv_Affine3d,
        tag: *const cv_String,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @param file Filename.\n @param pose Input matrix.\n @param tag Name of the pose to be saved into the given file."]
    #[link_name = "\u{1}_ZN2cv3viz9writePoseERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_7Affine3IdEES8_"]
    pub fn cv_viz_writePose(
        file: *const cv_String,
        pose: *const cv_Affine3d,
        tag: *const cv_String,
    );
}
unsafe extern "C" {
    #[doc = " takes vector<Affine3<T>> with T = float/dobule and writes to a sequence of files with given filename format\n @param traj Trajectory containing a list of poses. It can be\n          - std::vector<cv::Mat>, each cv::Mat is of type CV_32F16 or CV_64FC16\n          - std::vector<cv::Affine3f>, std::vector<cv::Affine3d>\n          - cv::Mat of type CV_32FC16 OR CV_64F16\n @param files_format Format specifier string for constructing filenames.\n                     The only placeholder in the string should support `int`.\n @param start The initial counter for files_format.\n @param tag Name of the matrix in the file."]
    #[link_name = "\u{1}_ZN2cv3viz15writeTrajectoryERKNS_11_InputArrayERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiSB_"]
    pub fn cv_viz_writeTrajectory(
        traj: cv_InputArray,
        files_format: *const cv_String,
        start: ::std::os::raw::c_int,
        tag: *const cv_String,
    );
}
unsafe extern "C" {
    #[doc = " takes vector<Affine3<T>> with T = float/dobule and loads poses from sequence of files\n\n @param traj Output array containing a lists of poses. It can be\n             - std::vector<cv::Affine3f>, std::vector<cv::Affine3d>\n             - cv::Mat\n @param files_format Format specifier string for constructing filenames.\n                     The only placeholder in the string should support `int`.\n @param start The initial counter for files_format. It must be greater than or equal to 0.\n @param end The final  counter for files_format.\n @param tag Name of the matrix in the file."]
    #[link_name = "\u{1}_ZN2cv3viz14readTrajectoryERKNS_12_OutputArrayERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiiSB_"]
    pub fn cv_viz_readTrajectory(
        traj: cv_OutputArray,
        files_format: *const cv_String,
        start: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
        tag: *const cv_String,
    );
}
unsafe extern "C" {
    #[doc = "\n** Computing normals for mesh\n* @param mesh Input mesh.\n* @param normals Normals at very point in the mesh of type CV_64FC3.\n*/"]
    #[link_name = "\u{1}_ZN2cv3viz14computeNormalsERKNS0_4MeshERKNS_12_OutputArrayE"]
    pub fn cv_viz_computeNormals(mesh: *const cv_viz_Mesh, normals: cv_OutputArray);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cxxabiv1___cxa_refcounted_exception {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[link_name = "\u{1}__cxa_allocate_exception"]
    pub fn __cxxabiv1___cxa_allocate_exception(arg1: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[link_name = "\u{1}__cxa_free_exception"]
    pub fn __cxxabiv1___cxa_free_exception(arg1: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[link_name = "\u{1}__cxa_init_primary_exception"]
    pub fn __cxxabiv1___cxa_init_primary_exception(
        object: *mut ::std::os::raw::c_void,
        tinfo: *mut std_type_info,
        dest: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> *mut __cxxabiv1___cxa_refcounted_exception;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cxxabiv1___class_type_info {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct __cxxabiv1___forced_unwind__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct __cxxabiv1___forced_unwind {
    pub vtable_: *const __cxxabiv1___forced_unwind__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __cxxabiv1___forced_unwind"]
        [::std::mem::size_of::<__cxxabiv1___forced_unwind>() - 8usize];
    ["Alignment of __cxxabiv1___forced_unwind"]
        [::std::mem::align_of::<__cxxabiv1___forced_unwind>() - 8usize];
};
unsafe extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memchr(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn rawmemchr(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memrchr(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        __s: *mut ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        __s: *mut ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchrnul(
        __s: *mut ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strpbrk(
        __s: *mut ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strstr(
        __haystack: *mut ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcasestr(
        __haystack: *mut ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystacklen: usize,
        __needle: *const ::std::os::raw::c_void,
        __needlelen: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> usize;
}
unsafe extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
unsafe extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
unsafe extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strverscmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfry(__string: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn memfrob(__s: *mut ::std::os::raw::c_void, __n: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn basename(__filename: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
pub const _ISupper: _bindgen_ty_36 = 256;
pub const _ISlower: _bindgen_ty_36 = 512;
pub const _ISalpha: _bindgen_ty_36 = 1024;
pub const _ISdigit: _bindgen_ty_36 = 2048;
pub const _ISxdigit: _bindgen_ty_36 = 4096;
pub const _ISspace: _bindgen_ty_36 = 8192;
pub const _ISprint: _bindgen_ty_36 = 16384;
pub const _ISgraph: _bindgen_ty_36 = 32768;
pub const _ISblank: _bindgen_ty_36 = 1;
pub const _IScntrl: _bindgen_ty_36 = 2;
pub const _ISpunct: _bindgen_ty_36 = 4;
pub const _ISalnum: _bindgen_ty_36 = 8;
pub type _bindgen_ty_36 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
unsafe extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
unsafe extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isctype(
        __c: ::std::os::raw::c_int,
        __mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wint_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t__bindgen_ty_1"]
        [::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Alignment of __mbstate_t__bindgen_ty_1"]
        [::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wch"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wch) - 0usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wchb"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wchb) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 8usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 4usize];
    ["Offset of field: __mbstate_t::__count"]
        [::std::mem::offset_of!(__mbstate_t, __count) - 0usize];
    ["Offset of field: __mbstate_t::__value"]
        [::std::mem::offset_of!(__mbstate_t, __value) - 4usize];
};
pub type mbstate_t = __mbstate_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
unsafe extern "C" {
    pub fn wcscpy(__dest: *mut u32, __src: *const u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcsncpy(__dest: *mut u32, __src: *const u32, __n: usize) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcscat(__dest: *mut u32, __src: *const u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcsncat(__dest: *mut u32, __src: *const u32, __n: usize) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcscmp(__s1: *const u32, __s2: *const u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcsncmp(__s1: *const u32, __s2: *const u32, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcscasecmp(__s1: *const u32, __s2: *const u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcsncasecmp(__s1: *const u32, __s2: *const u32, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcscasecmp_l(
        __s1: *const u32,
        __s2: *const u32,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcsncasecmp_l(
        __s1: *const u32,
        __s2: *const u32,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcscoll(__s1: *const u32, __s2: *const u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcsxfrm(__s1: *mut u32, __s2: *const u32, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcscoll_l(__s1: *const u32, __s2: *const u32, __loc: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcsxfrm_l(__s1: *mut u32, __s2: *const u32, __n: usize, __loc: locale_t) -> usize;
}
unsafe extern "C" {
    pub fn wcsdup(__s: *const u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcschr(__wcs: *const u32, __wc: u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcsrchr(__wcs: *const u32, __wc: u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcschrnul(__s: *const u32, __wc: u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcscspn(__wcs: *const u32, __reject: *const u32) -> usize;
}
unsafe extern "C" {
    pub fn wcsspn(__wcs: *const u32, __accept: *const u32) -> usize;
}
unsafe extern "C" {
    pub fn wcspbrk(__wcs: *const u32, __accept: *const u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcsstr(__haystack: *const u32, __needle: *const u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcstok(__s: *mut u32, __delim: *const u32, __ptr: *mut *mut u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcslen(__s: *const u32) -> usize;
}
unsafe extern "C" {
    pub fn wcswcs(__haystack: *const u32, __needle: *const u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcsnlen(__s: *const u32, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn wmemchr(__s: *const u32, __c: u32, __n: usize) -> *mut u32;
}
unsafe extern "C" {
    pub fn wmemcmp(__s1: *const u32, __s2: *const u32, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wmemcpy(__s1: *mut u32, __s2: *const u32, __n: usize) -> *mut u32;
}
unsafe extern "C" {
    pub fn wmemmove(__s1: *mut u32, __s2: *const u32, __n: usize) -> *mut u32;
}
unsafe extern "C" {
    pub fn wmemset(__s: *mut u32, __c: u32, __n: usize) -> *mut u32;
}
unsafe extern "C" {
    pub fn wmempcpy(__s1: *mut u32, __s2: *const u32, __n: usize) -> *mut u32;
}
unsafe extern "C" {
    pub fn btowc(__c: ::std::os::raw::c_int) -> wint_t;
}
unsafe extern "C" {
    pub fn wctob(__c: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbsinit(__ps: *const mbstate_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbrtowc(
        __pwc: *mut u32,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
        __p: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcrtomb(__s: *mut ::std::os::raw::c_char, __wc: u32, __ps: *mut mbstate_t) -> usize;
}
unsafe extern "C" {
    pub fn __mbrlen(__s: *const ::std::os::raw::c_char, __n: usize, __ps: *mut mbstate_t) -> usize;
}
unsafe extern "C" {
    pub fn mbrlen(__s: *const ::std::os::raw::c_char, __n: usize, __ps: *mut mbstate_t) -> usize;
}
unsafe extern "C" {
    pub fn mbsrtowcs(
        __dst: *mut u32,
        __src: *mut *const ::std::os::raw::c_char,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcsrtombs(
        __dst: *mut ::std::os::raw::c_char,
        __src: *mut *const u32,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn mbsnrtowcs(
        __dst: *mut u32,
        __src: *mut *const ::std::os::raw::c_char,
        __nmc: usize,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcsnrtombs(
        __dst: *mut ::std::os::raw::c_char,
        __src: *mut *const u32,
        __nwc: usize,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcwidth(__c: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcswidth(__s: *const u32, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcstod(__nptr: *const u32, __endptr: *mut *mut u32) -> f64;
}
unsafe extern "C" {
    pub fn wcstof(__nptr: *const u32, __endptr: *mut *mut u32) -> f32;
}
unsafe extern "C" {
    pub fn wcstold(__nptr: *const u32, __endptr: *mut *mut u32) -> u128;
}
unsafe extern "C" {
    pub fn wcstof32(__nptr: *const u32, __endptr: *mut *mut u32) -> _Float32;
}
unsafe extern "C" {
    pub fn wcstof64(__nptr: *const u32, __endptr: *mut *mut u32) -> _Float64;
}
unsafe extern "C" {
    pub fn wcstof32x(__nptr: *const u32, __endptr: *mut *mut u32) -> _Float32x;
}
unsafe extern "C" {
    pub fn wcstof64x(__nptr: *const u32, __endptr: *mut *mut u32) -> _Float64x;
}
unsafe extern "C" {
    pub fn wcstol(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn wcstoul(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn wcstoll(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn wcstoull(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn wcstoq(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn wcstouq(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn wcstol_l(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn wcstoul_l(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn wcstoll_l(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn wcstoull_l(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn wcstod_l(__nptr: *const u32, __endptr: *mut *mut u32, __loc: locale_t) -> f64;
}
unsafe extern "C" {
    pub fn wcstof_l(__nptr: *const u32, __endptr: *mut *mut u32, __loc: locale_t) -> f32;
}
unsafe extern "C" {
    pub fn wcstold_l(__nptr: *const u32, __endptr: *mut *mut u32, __loc: locale_t) -> u128;
}
unsafe extern "C" {
    pub fn wcstof32_l(__nptr: *const u32, __endptr: *mut *mut u32, __loc: locale_t) -> _Float32;
}
unsafe extern "C" {
    pub fn wcstof64_l(__nptr: *const u32, __endptr: *mut *mut u32, __loc: locale_t) -> _Float64;
}
unsafe extern "C" {
    pub fn wcstof32x_l(__nptr: *const u32, __endptr: *mut *mut u32, __loc: locale_t) -> _Float32x;
}
unsafe extern "C" {
    pub fn wcstof64x_l(__nptr: *const u32, __endptr: *mut *mut u32, __loc: locale_t) -> _Float64x;
}
unsafe extern "C" {
    pub fn wcpcpy(__dest: *mut u32, __src: *const u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcpncpy(__dest: *mut u32, __src: *const u32, __n: usize) -> *mut u32;
}
unsafe extern "C" {
    pub fn open_wmemstream(__bufloc: *mut *mut u32, __sizeloc: *mut usize) -> *mut __FILE;
}
unsafe extern "C" {
    pub fn fwide(__fp: *mut __FILE, __mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fwprintf(__stream: *mut __FILE, __format: *const u32, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wprintf(__format: *const u32, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn swprintf(__s: *mut u32, __n: usize, __format: *const u32, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfwprintf(
        __s: *mut __FILE,
        __format: *const u32,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vwprintf(__format: *const u32, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vswprintf(
        __s: *mut u32,
        __n: usize,
        __format: *const u32,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fwscanf(__stream: *mut __FILE, __format: *const u32, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wscanf(__format: *const u32, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn swscanf(__s: *const u32, __format: *const u32, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_fwscanf"]
    pub fn fwscanf1(__stream: *mut __FILE, __format: *const u32, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_wscanf"]
    pub fn wscanf1(__format: *const u32, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_swscanf"]
    pub fn swscanf1(__s: *const u32, __format: *const u32, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfwscanf(
        __s: *mut __FILE,
        __format: *const u32,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vwscanf(__format: *const u32, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vswscanf(
        __s: *const u32,
        __format: *const u32,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vfwscanf"]
    pub fn vfwscanf1(
        __s: *mut __FILE,
        __format: *const u32,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vwscanf"]
    pub fn vwscanf1(__format: *const u32, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vswscanf"]
    pub fn vswscanf1(
        __s: *const u32,
        __format: *const u32,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetwc(__stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn getwc(__stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn getwchar() -> wint_t;
}
unsafe extern "C" {
    pub fn fputwc(__wc: u32, __stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn putwc(__wc: u32, __stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn putwchar(__wc: u32) -> wint_t;
}
unsafe extern "C" {
    pub fn fgetws(__ws: *mut u32, __n: ::std::os::raw::c_int, __stream: *mut __FILE) -> *mut u32;
}
unsafe extern "C" {
    pub fn fputws(__ws: *const u32, __stream: *mut __FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ungetwc(__wc: wint_t, __stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn getwc_unlocked(__stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn getwchar_unlocked() -> wint_t;
}
unsafe extern "C" {
    pub fn fgetwc_unlocked(__stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn fputwc_unlocked(__wc: u32, __stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn putwc_unlocked(__wc: u32, __stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn putwchar_unlocked(__wc: u32) -> wint_t;
}
unsafe extern "C" {
    pub fn fgetws_unlocked(
        __ws: *mut u32,
        __n: ::std::os::raw::c_int,
        __stream: *mut __FILE,
    ) -> *mut u32;
}
unsafe extern "C" {
    pub fn fputws_unlocked(__ws: *const u32, __stream: *mut __FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcsftime(
        __s: *mut u32,
        __maxsize: usize,
        __format: *const u32,
        __tp: *const tm,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcsftime_l(
        __s: *mut u32,
        __maxsize: usize,
        __format: *const u32,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub int_p_cs_precedes: ::std::os::raw::c_char,
    pub int_p_sep_by_space: ::std::os::raw::c_char,
    pub int_n_cs_precedes: ::std::os::raw::c_char,
    pub int_n_sep_by_space: ::std::os::raw::c_char,
    pub int_p_sign_posn: ::std::os::raw::c_char,
    pub int_n_sign_posn: ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lconv"][::std::mem::size_of::<lconv>() - 96usize];
    ["Alignment of lconv"][::std::mem::align_of::<lconv>() - 8usize];
    ["Offset of field: lconv::decimal_point"]
        [::std::mem::offset_of!(lconv, decimal_point) - 0usize];
    ["Offset of field: lconv::thousands_sep"]
        [::std::mem::offset_of!(lconv, thousands_sep) - 8usize];
    ["Offset of field: lconv::grouping"][::std::mem::offset_of!(lconv, grouping) - 16usize];
    ["Offset of field: lconv::int_curr_symbol"]
        [::std::mem::offset_of!(lconv, int_curr_symbol) - 24usize];
    ["Offset of field: lconv::currency_symbol"]
        [::std::mem::offset_of!(lconv, currency_symbol) - 32usize];
    ["Offset of field: lconv::mon_decimal_point"]
        [::std::mem::offset_of!(lconv, mon_decimal_point) - 40usize];
    ["Offset of field: lconv::mon_thousands_sep"]
        [::std::mem::offset_of!(lconv, mon_thousands_sep) - 48usize];
    ["Offset of field: lconv::mon_grouping"][::std::mem::offset_of!(lconv, mon_grouping) - 56usize];
    ["Offset of field: lconv::positive_sign"]
        [::std::mem::offset_of!(lconv, positive_sign) - 64usize];
    ["Offset of field: lconv::negative_sign"]
        [::std::mem::offset_of!(lconv, negative_sign) - 72usize];
    ["Offset of field: lconv::int_frac_digits"]
        [::std::mem::offset_of!(lconv, int_frac_digits) - 80usize];
    ["Offset of field: lconv::frac_digits"][::std::mem::offset_of!(lconv, frac_digits) - 81usize];
    ["Offset of field: lconv::p_cs_precedes"]
        [::std::mem::offset_of!(lconv, p_cs_precedes) - 82usize];
    ["Offset of field: lconv::p_sep_by_space"]
        [::std::mem::offset_of!(lconv, p_sep_by_space) - 83usize];
    ["Offset of field: lconv::n_cs_precedes"]
        [::std::mem::offset_of!(lconv, n_cs_precedes) - 84usize];
    ["Offset of field: lconv::n_sep_by_space"]
        [::std::mem::offset_of!(lconv, n_sep_by_space) - 85usize];
    ["Offset of field: lconv::p_sign_posn"][::std::mem::offset_of!(lconv, p_sign_posn) - 86usize];
    ["Offset of field: lconv::n_sign_posn"][::std::mem::offset_of!(lconv, n_sign_posn) - 87usize];
    ["Offset of field: lconv::int_p_cs_precedes"]
        [::std::mem::offset_of!(lconv, int_p_cs_precedes) - 88usize];
    ["Offset of field: lconv::int_p_sep_by_space"]
        [::std::mem::offset_of!(lconv, int_p_sep_by_space) - 89usize];
    ["Offset of field: lconv::int_n_cs_precedes"]
        [::std::mem::offset_of!(lconv, int_n_cs_precedes) - 90usize];
    ["Offset of field: lconv::int_n_sep_by_space"]
        [::std::mem::offset_of!(lconv, int_n_sep_by_space) - 91usize];
    ["Offset of field: lconv::int_p_sign_posn"]
        [::std::mem::offset_of!(lconv, int_p_sign_posn) - 92usize];
    ["Offset of field: lconv::int_n_sign_posn"]
        [::std::mem::offset_of!(lconv, int_n_sign_posn) - 93usize];
};
unsafe extern "C" {
    pub fn setlocale(
        __category: ::std::os::raw::c_int,
        __locale: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn localeconv() -> *mut lconv;
}
unsafe extern "C" {
    pub fn newlocale(
        __category_mask: ::std::os::raw::c_int,
        __locale: *const ::std::os::raw::c_char,
        __base: locale_t,
    ) -> locale_t;
}
unsafe extern "C" {
    pub fn duplocale(__dataset: locale_t) -> locale_t;
}
unsafe extern "C" {
    pub fn freelocale(__dataset: locale_t);
}
unsafe extern "C" {
    pub fn uselocale(__dataset: locale_t) -> locale_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sched_param"][::std::mem::size_of::<sched_param>() - 4usize];
    ["Alignment of sched_param"][::std::mem::align_of::<sched_param>() - 4usize];
    ["Offset of field: sched_param::sched_priority"]
        [::std::mem::offset_of!(sched_param, sched_priority) - 0usize];
};
unsafe extern "C" {
    pub fn clone(
        __fn: ::std::option::Option<
            unsafe extern "C" fn(__arg: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        __child_stack: *mut ::std::os::raw::c_void,
        __flags: ::std::os::raw::c_int,
        __arg: *mut ::std::os::raw::c_void,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unshare(__flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getcpu() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getcpu(
        arg1: *mut ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setns(
        __fd: ::std::os::raw::c_int,
        __nstype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cpu_set_t"][::std::mem::size_of::<cpu_set_t>() - 128usize];
    ["Alignment of cpu_set_t"][::std::mem::align_of::<cpu_set_t>() - 8usize];
    ["Offset of field: cpu_set_t::__bits"][::std::mem::offset_of!(cpu_set_t, __bits) - 0usize];
};
unsafe extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
unsafe extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
unsafe extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_setaffinity(
        __pid: __pid_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getaffinity(
        __pid: __pid_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timex {
    pub modes: ::std::os::raw::c_uint,
    pub offset: __syscall_slong_t,
    pub freq: __syscall_slong_t,
    pub maxerror: __syscall_slong_t,
    pub esterror: __syscall_slong_t,
    pub status: ::std::os::raw::c_int,
    pub constant: __syscall_slong_t,
    pub precision: __syscall_slong_t,
    pub tolerance: __syscall_slong_t,
    pub time: timeval,
    pub tick: __syscall_slong_t,
    pub ppsfreq: __syscall_slong_t,
    pub jitter: __syscall_slong_t,
    pub shift: ::std::os::raw::c_int,
    pub stabil: __syscall_slong_t,
    pub jitcnt: __syscall_slong_t,
    pub calcnt: __syscall_slong_t,
    pub errcnt: __syscall_slong_t,
    pub stbcnt: __syscall_slong_t,
    pub tai: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 44usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timex"][::std::mem::size_of::<timex>() - 208usize];
    ["Alignment of timex"][::std::mem::align_of::<timex>() - 8usize];
    ["Offset of field: timex::modes"][::std::mem::offset_of!(timex, modes) - 0usize];
    ["Offset of field: timex::offset"][::std::mem::offset_of!(timex, offset) - 8usize];
    ["Offset of field: timex::freq"][::std::mem::offset_of!(timex, freq) - 16usize];
    ["Offset of field: timex::maxerror"][::std::mem::offset_of!(timex, maxerror) - 24usize];
    ["Offset of field: timex::esterror"][::std::mem::offset_of!(timex, esterror) - 32usize];
    ["Offset of field: timex::status"][::std::mem::offset_of!(timex, status) - 40usize];
    ["Offset of field: timex::constant"][::std::mem::offset_of!(timex, constant) - 48usize];
    ["Offset of field: timex::precision"][::std::mem::offset_of!(timex, precision) - 56usize];
    ["Offset of field: timex::tolerance"][::std::mem::offset_of!(timex, tolerance) - 64usize];
    ["Offset of field: timex::time"][::std::mem::offset_of!(timex, time) - 72usize];
    ["Offset of field: timex::tick"][::std::mem::offset_of!(timex, tick) - 88usize];
    ["Offset of field: timex::ppsfreq"][::std::mem::offset_of!(timex, ppsfreq) - 96usize];
    ["Offset of field: timex::jitter"][::std::mem::offset_of!(timex, jitter) - 104usize];
    ["Offset of field: timex::shift"][::std::mem::offset_of!(timex, shift) - 112usize];
    ["Offset of field: timex::stabil"][::std::mem::offset_of!(timex, stabil) - 120usize];
    ["Offset of field: timex::jitcnt"][::std::mem::offset_of!(timex, jitcnt) - 128usize];
    ["Offset of field: timex::calcnt"][::std::mem::offset_of!(timex, calcnt) - 136usize];
    ["Offset of field: timex::errcnt"][::std::mem::offset_of!(timex, errcnt) - 144usize];
    ["Offset of field: timex::stbcnt"][::std::mem::offset_of!(timex, stbcnt) - 152usize];
    ["Offset of field: timex::tai"][::std::mem::offset_of!(timex, tai) - 160usize];
};
unsafe extern "C" {
    pub fn clock_adjtime(__clock_id: __clockid_t, __utx: *mut timex) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tm"][::std::mem::size_of::<tm>() - 56usize];
    ["Alignment of tm"][::std::mem::align_of::<tm>() - 8usize];
    ["Offset of field: tm::tm_sec"][::std::mem::offset_of!(tm, tm_sec) - 0usize];
    ["Offset of field: tm::tm_min"][::std::mem::offset_of!(tm, tm_min) - 4usize];
    ["Offset of field: tm::tm_hour"][::std::mem::offset_of!(tm, tm_hour) - 8usize];
    ["Offset of field: tm::tm_mday"][::std::mem::offset_of!(tm, tm_mday) - 12usize];
    ["Offset of field: tm::tm_mon"][::std::mem::offset_of!(tm, tm_mon) - 16usize];
    ["Offset of field: tm::tm_year"][::std::mem::offset_of!(tm, tm_year) - 20usize];
    ["Offset of field: tm::tm_wday"][::std::mem::offset_of!(tm, tm_wday) - 24usize];
    ["Offset of field: tm::tm_yday"][::std::mem::offset_of!(tm, tm_yday) - 28usize];
    ["Offset of field: tm::tm_isdst"][::std::mem::offset_of!(tm, tm_isdst) - 32usize];
    ["Offset of field: tm::tm_gmtoff"][::std::mem::offset_of!(tm, tm_gmtoff) - 40usize];
    ["Offset of field: tm::tm_zone"][::std::mem::offset_of!(tm, tm_zone) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of itimerspec"][::std::mem::size_of::<itimerspec>() - 32usize];
    ["Alignment of itimerspec"][::std::mem::align_of::<itimerspec>() - 8usize];
    ["Offset of field: itimerspec::it_interval"]
        [::std::mem::offset_of!(itimerspec, it_interval) - 0usize];
    ["Offset of field: itimerspec::it_value"]
        [::std::mem::offset_of!(itimerspec, it_value) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn clock() -> clock_t;
}
unsafe extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
unsafe extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
unsafe extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strptime(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __tp: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strptime_l(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __tp: *mut tm,
        __loc: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
unsafe extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
unsafe extern "C" {
    pub fn tzset();
}
unsafe extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdate(__string: *const ::std::os::raw::c_char) -> *mut tm;
}
unsafe extern "C" {
    pub fn getdate_r(
        __string: *const ::std::os::raw::c_char,
        __resbufp: *mut tm,
    ) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_37 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_37 = 1;
pub type _bindgen_ty_37 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_38 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_38 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_38 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_38 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_38 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_38 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_38 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_38 = 0;
pub const PTHREAD_MUTEX_FAST_NP: _bindgen_ty_38 = 0;
pub type _bindgen_ty_38 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_39 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_39 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_39 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_39 = 1;
pub type _bindgen_ty_39 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_40 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_40 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_40 = 2;
pub type _bindgen_ty_40 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_41 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_41 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_41 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_41 = 0;
pub type _bindgen_ty_41 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_42 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_42 = 1;
pub type _bindgen_ty_42 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_43 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_43 = 1;
pub type _bindgen_ty_43 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_44 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_44 = 1;
pub type _bindgen_ty_44 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _pthread_cleanup_buffer"][::std::mem::size_of::<_pthread_cleanup_buffer>() - 32usize];
    ["Alignment of _pthread_cleanup_buffer"]
        [::std::mem::align_of::<_pthread_cleanup_buffer>() - 8usize];
    ["Offset of field: _pthread_cleanup_buffer::__routine"]
        [::std::mem::offset_of!(_pthread_cleanup_buffer, __routine) - 0usize];
    ["Offset of field: _pthread_cleanup_buffer::__arg"]
        [::std::mem::offset_of!(_pthread_cleanup_buffer, __arg) - 8usize];
    ["Offset of field: _pthread_cleanup_buffer::__canceltype"]
        [::std::mem::offset_of!(_pthread_cleanup_buffer, __canceltype) - 16usize];
    ["Offset of field: _pthread_cleanup_buffer::__prev"]
        [::std::mem::offset_of!(_pthread_cleanup_buffer, __prev) - 24usize];
};
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_45 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_45 = 1;
pub type _bindgen_ty_45 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_46 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_46 = 1;
pub type _bindgen_ty_46 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void) -> !;
}
unsafe extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_tryjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_timedjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_clockjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_self() -> pthread_t;
}
unsafe extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setaffinity_np(
        __attr: *mut pthread_attr_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getaffinity_np(
        __attr: *const pthread_attr_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getattr_default_np(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setattr_default_np(__attr: *const pthread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getattr_np(
        __th: pthread_t,
        __attr: *mut pthread_attr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getname_np(
        __target_thread: pthread_t,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setname_np(
        __target_thread: pthread_t,
        __name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getconcurrency() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setconcurrency(__level: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_yield() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setaffinity_np(
        __th: pthread_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getaffinity_np(
        __th: pthread_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_unwind_buf_t__bindgen_ty_1"]
        [::std::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>() - 72usize];
    ["Alignment of __pthread_unwind_buf_t__bindgen_ty_1"]
        [::std::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: __pthread_unwind_buf_t__bindgen_ty_1::__cancel_jmp_buf"]
        [::std::mem::offset_of!(__pthread_unwind_buf_t__bindgen_ty_1, __cancel_jmp_buf) - 0usize];
    ["Offset of field: __pthread_unwind_buf_t__bindgen_ty_1::__mask_was_saved"]
        [::std::mem::offset_of!(__pthread_unwind_buf_t__bindgen_ty_1, __mask_was_saved) - 64usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_unwind_buf_t"][::std::mem::size_of::<__pthread_unwind_buf_t>() - 104usize];
    ["Alignment of __pthread_unwind_buf_t"]
        [::std::mem::align_of::<__pthread_unwind_buf_t>() - 8usize];
    ["Offset of field: __pthread_unwind_buf_t::__cancel_jmp_buf"]
        [::std::mem::offset_of!(__pthread_unwind_buf_t, __cancel_jmp_buf) - 0usize];
    ["Offset of field: __pthread_unwind_buf_t::__pad"]
        [::std::mem::offset_of!(__pthread_unwind_buf_t, __pad) - 72usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cleanup_frame"][::std::mem::size_of::<__pthread_cleanup_frame>() - 24usize];
    ["Alignment of __pthread_cleanup_frame"]
        [::std::mem::align_of::<__pthread_cleanup_frame>() - 8usize];
    ["Offset of field: __pthread_cleanup_frame::__cancel_routine"]
        [::std::mem::offset_of!(__pthread_cleanup_frame, __cancel_routine) - 0usize];
    ["Offset of field: __pthread_cleanup_frame::__cancel_arg"]
        [::std::mem::offset_of!(__pthread_cleanup_frame, __cancel_arg) - 8usize];
    ["Offset of field: __pthread_cleanup_frame::__do_it"]
        [::std::mem::offset_of!(__pthread_cleanup_frame, __do_it) - 16usize];
    ["Offset of field: __pthread_cleanup_frame::__cancel_type"]
        [::std::mem::offset_of!(__pthread_cleanup_frame, __cancel_type) - 20usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct __pthread_cleanup_class {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cleanup_class"][::std::mem::size_of::<__pthread_cleanup_class>() - 24usize];
    ["Alignment of __pthread_cleanup_class"]
        [::std::mem::align_of::<__pthread_cleanup_class>() - 8usize];
    ["Offset of field: __pthread_cleanup_class::__cancel_routine"]
        [::std::mem::offset_of!(__pthread_cleanup_class, __cancel_routine) - 0usize];
    ["Offset of field: __pthread_cleanup_class::__cancel_arg"]
        [::std::mem::offset_of!(__pthread_cleanup_class, __cancel_arg) - 8usize];
    ["Offset of field: __pthread_cleanup_class::__do_it"]
        [::std::mem::offset_of!(__pthread_cleanup_class, __do_it) - 16usize];
    ["Offset of field: __pthread_cleanup_class::__cancel_type"]
        [::std::mem::offset_of!(__pthread_cleanup_class, __cancel_type) - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_clocklock(
        __mutex: *mut pthread_mutex_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_consistent_np(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getrobust_np(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setrobust_np(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_clockrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_clockwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_clockwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __clock_id: __clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type __gthread_t = pthread_t;
pub type __gthread_key_t = pthread_key_t;
pub type __gthread_once_t = pthread_once_t;
pub type __gthread_mutex_t = pthread_mutex_t;
pub type __gthread_recursive_mutex_t = pthread_mutex_t;
pub type __gthread_cond_t = pthread_cond_t;
pub type __gthread_time_t = timespec;
pub type _Atomic_word = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos_t"][::std::mem::size_of::<_G_fpos_t>() - 16usize];
    ["Alignment of _G_fpos_t"][::std::mem::align_of::<_G_fpos_t>() - 8usize];
    ["Offset of field: _G_fpos_t::__pos"][::std::mem::offset_of!(_G_fpos_t, __pos) - 0usize];
    ["Offset of field: _G_fpos_t::__state"][::std::mem::offset_of!(_G_fpos_t, __state) - 8usize];
};
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos64_t"][::std::mem::size_of::<_G_fpos64_t>() - 16usize];
    ["Alignment of _G_fpos64_t"][::std::mem::align_of::<_G_fpos64_t>() - 8usize];
    ["Offset of field: _G_fpos64_t::__pos"][::std::mem::offset_of!(_G_fpos64_t, __pos) - 0usize];
    ["Offset of field: _G_fpos64_t::__state"]
        [::std::mem::offset_of!(_G_fpos64_t, __state) - 8usize];
};
pub type __fpos64_t = _G_fpos64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_FILE"][::std::mem::size_of::<_IO_FILE>() - 216usize];
    ["Alignment of _IO_FILE"][::std::mem::align_of::<_IO_FILE>() - 8usize];
    ["Offset of field: _IO_FILE::_flags"][::std::mem::offset_of!(_IO_FILE, _flags) - 0usize];
    ["Offset of field: _IO_FILE::_IO_read_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 8usize];
    ["Offset of field: _IO_FILE::_IO_read_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_end) - 16usize];
    ["Offset of field: _IO_FILE::_IO_read_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_base) - 24usize];
    ["Offset of field: _IO_FILE::_IO_write_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_base) - 32usize];
    ["Offset of field: _IO_FILE::_IO_write_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 40usize];
    ["Offset of field: _IO_FILE::_IO_write_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_end) - 48usize];
    ["Offset of field: _IO_FILE::_IO_buf_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_base) - 56usize];
    ["Offset of field: _IO_FILE::_IO_buf_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_end) - 64usize];
    ["Offset of field: _IO_FILE::_IO_save_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_base) - 72usize];
    ["Offset of field: _IO_FILE::_IO_backup_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_backup_base) - 80usize];
    ["Offset of field: _IO_FILE::_IO_save_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_end) - 88usize];
    ["Offset of field: _IO_FILE::_markers"][::std::mem::offset_of!(_IO_FILE, _markers) - 96usize];
    ["Offset of field: _IO_FILE::_chain"][::std::mem::offset_of!(_IO_FILE, _chain) - 104usize];
    ["Offset of field: _IO_FILE::_fileno"][::std::mem::offset_of!(_IO_FILE, _fileno) - 112usize];
    ["Offset of field: _IO_FILE::_flags2"][::std::mem::offset_of!(_IO_FILE, _flags2) - 116usize];
    ["Offset of field: _IO_FILE::_old_offset"]
        [::std::mem::offset_of!(_IO_FILE, _old_offset) - 120usize];
    ["Offset of field: _IO_FILE::_cur_column"]
        [::std::mem::offset_of!(_IO_FILE, _cur_column) - 128usize];
    ["Offset of field: _IO_FILE::_vtable_offset"]
        [::std::mem::offset_of!(_IO_FILE, _vtable_offset) - 130usize];
    ["Offset of field: _IO_FILE::_shortbuf"]
        [::std::mem::offset_of!(_IO_FILE, _shortbuf) - 131usize];
    ["Offset of field: _IO_FILE::_lock"][::std::mem::offset_of!(_IO_FILE, _lock) - 136usize];
    ["Offset of field: _IO_FILE::_offset"][::std::mem::offset_of!(_IO_FILE, _offset) - 144usize];
    ["Offset of field: _IO_FILE::_codecvt"][::std::mem::offset_of!(_IO_FILE, _codecvt) - 152usize];
    ["Offset of field: _IO_FILE::_wide_data"]
        [::std::mem::offset_of!(_IO_FILE, _wide_data) - 160usize];
    ["Offset of field: _IO_FILE::_freeres_list"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_list) - 168usize];
    ["Offset of field: _IO_FILE::_freeres_buf"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_buf) - 176usize];
    ["Offset of field: _IO_FILE::__pad5"][::std::mem::offset_of!(_IO_FILE, __pad5) - 184usize];
    ["Offset of field: _IO_FILE::_mode"][::std::mem::offset_of!(_IO_FILE, _mode) - 192usize];
    ["Offset of field: _IO_FILE::_unused2"][::std::mem::offset_of!(_IO_FILE, _unused2) - 196usize];
};
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_cookie_io_functions_t"]
        [::std::mem::size_of::<_IO_cookie_io_functions_t>() - 32usize];
    ["Alignment of _IO_cookie_io_functions_t"]
        [::std::mem::align_of::<_IO_cookie_io_functions_t>() - 8usize];
    ["Offset of field: _IO_cookie_io_functions_t::read"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, read) - 0usize];
    ["Offset of field: _IO_cookie_io_functions_t::write"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, write) - 8usize];
    ["Offset of field: _IO_cookie_io_functions_t::seek"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, seek) - 16usize];
    ["Offset of field: _IO_cookie_io_functions_t::close"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, close) - 24usize];
};
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type fpos_t = __fpos_t;
pub type fpos64_t = __fpos64_t;
unsafe extern "C" {
    pub static mut stdin: *mut FILE;
}
unsafe extern "C" {
    pub static mut stdout: *mut FILE;
}
unsafe extern "C" {
    pub static mut stderr: *mut FILE;
}
unsafe extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renameat2(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpfile64() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fopen64(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn freopen64(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
    -> *mut FILE;
}
unsafe extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
unsafe extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gets(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fgets_unlocked(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __s: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fputs_unlocked(
        __s: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
unsafe extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fseeko64(
        __stream: *mut FILE,
        __off: __off64_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftello64(__stream: *mut FILE) -> __off64_t;
}
unsafe extern "C" {
    pub fn fgetpos64(__stream: *mut FILE, __pos: *mut fpos64_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsetpos64(__stream: *mut FILE, __pos: *const fpos64_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
unsafe extern "C" {
    pub static mut _sys_nerr: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static _sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
unsafe extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn cuserid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obstack {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn obstack_printf(
        __obstack: *mut obstack,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn obstack_vprintf(
        __obstack: *mut obstack,
        __format: *const ::std::os::raw::c_char,
        __args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut program_invocation_name: *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut program_invocation_short_name: *mut ::std::os::raw::c_char;
}
pub type error_t = ::std::os::raw::c_int;
pub type float_t = f32;
pub type double_t = f64;
pub const FP_INT_UPWARD: _bindgen_ty_47 = 0;
pub const FP_INT_DOWNWARD: _bindgen_ty_47 = 1;
pub const FP_INT_TOWARDZERO: _bindgen_ty_47 = 2;
pub const FP_INT_TONEARESTFROMZERO: _bindgen_ty_47 = 3;
pub const FP_INT_TONEAREST: _bindgen_ty_47 = 4;
pub type _bindgen_ty_47 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn asin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
unsafe extern "C" {
    pub fn cos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn sin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn tan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn sincos(__x: f64, __sinx: *mut f64, __cosx: *mut f64);
}
unsafe extern "C" {
    pub fn __sincos(__x: f64, __sinx: *mut f64, __cosx: *mut f64);
}
unsafe extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn log(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn log10(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn exp10(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __exp10(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn logb(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn log2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn floor(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn significand(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn rint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn nextdown(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __nextdown(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn nextup(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __nextup(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn llogb(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __llogb(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
unsafe extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
unsafe extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn round(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __round(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
unsafe extern "C" {
    pub fn roundeven(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __roundeven(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn fromfp(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfp(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfp(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfp(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fromfpx(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpx(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpx(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpx(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fmaxmag(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmaxmag(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fminmag(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fminmag(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn canonicalize(__cx: *mut f64, __x: *const f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalorder(__x: *const f64, __y: *const f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalordermag(__x: *const f64, __y: *const f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpayload(__x: *const f64) -> f64;
}
unsafe extern "C" {
    pub fn __getpayload(__x: *const f64) -> f64;
}
unsafe extern "C" {
    pub fn setpayload(__x: *mut f64, __payload: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpayloadsig(__x: *mut f64, __payload: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
unsafe extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
unsafe extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn sincosf(__x: f32, __sinx: *mut f32, __cosx: *mut f32);
}
unsafe extern "C" {
    pub fn __sincosf(__x: f32, __sinx: *mut f32, __cosx: *mut f32);
}
unsafe extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn expf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn logf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
unsafe extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
unsafe extern "C" {
    pub fn exp10f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __exp10f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
unsafe extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
unsafe extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn nextdownf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __nextdownf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn nextupf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __nextupf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn llogbf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __llogbf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
unsafe extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
unsafe extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
unsafe extern "C" {
    pub fn roundevenf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __roundevenf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn fromfpf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fromfpxf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpxf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpxf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpxf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fmaxmagf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaxmagf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fminmagf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fminmagf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn canonicalizef(__cx: *mut f32, __x: *const f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalorderf(__x: *const f32, __y: *const f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalordermagf(__x: *const f32, __y: *const f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpayloadf(__x: *const f32) -> f32;
}
unsafe extern "C" {
    pub fn __getpayloadf(__x: *const f32) -> f32;
}
unsafe extern "C" {
    pub fn setpayloadf(__x: *mut f32, __payload: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpayloadsigf(__x: *mut f32, __payload: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
unsafe extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
unsafe extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn sincosl(__x: u128, __sinx: *mut u128, __cosx: *mut u128);
}
unsafe extern "C" {
    pub fn __sincosl(__x: u128, __sinx: *mut u128, __cosx: *mut u128);
}
unsafe extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn expl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn logl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
unsafe extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
unsafe extern "C" {
    pub fn exp10l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __exp10l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
unsafe extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
unsafe extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn nextdownl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nextdownl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn nextupl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nextupl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn llogbl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __llogbl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
unsafe extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
unsafe extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
unsafe extern "C" {
    pub fn roundevenl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __roundevenl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn fromfpl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fromfpxl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpxl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpxl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpxl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fmaxmagl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmaxmagl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fminmagl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fminmagl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn canonicalizel(__cx: *mut u128, __x: *const u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalorderl(__x: *const u128, __y: *const u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalordermagl(__x: *const u128, __y: *const u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpayloadl(__x: *const u128) -> u128;
}
unsafe extern "C" {
    pub fn __getpayloadl(__x: *const u128) -> u128;
}
unsafe extern "C" {
    pub fn setpayloadl(__x: *mut u128, __payload: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpayloadsigl(__x: *mut u128, __payload: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
unsafe extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
unsafe extern "C" {
    pub fn acosf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __acosf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn asinf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __asinf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn atanf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __atanf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn atan2f32(__y: _Float32, __x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __atan2f32(__y: _Float32, __x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn cosf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __cosf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn sinf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __sinf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn tanf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __tanf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn coshf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __coshf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn sinhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __sinhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn tanhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __tanhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn sincosf32(__x: _Float32, __sinx: *mut _Float32, __cosx: *mut _Float32);
}
unsafe extern "C" {
    pub fn __sincosf32(__x: _Float32, __sinx: *mut _Float32, __cosx: *mut _Float32);
}
unsafe extern "C" {
    pub fn acoshf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __acoshf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn asinhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __asinhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn atanhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __atanhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn expf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __expf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn frexpf32(__x: _Float32, __exponent: *mut ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn __frexpf32(__x: _Float32, __exponent: *mut ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn ldexpf32(__x: _Float32, __exponent: ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn __ldexpf32(__x: _Float32, __exponent: ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn logf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __logf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn log10f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __log10f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn modff32(__x: _Float32, __iptr: *mut _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __modff32(__x: _Float32, __iptr: *mut _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn exp10f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __exp10f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn expm1f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __expm1f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn log1pf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __log1pf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn logbf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __logbf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn exp2f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __exp2f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn log2f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __log2f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn powf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __powf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn sqrtf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __sqrtf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn hypotf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __hypotf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn cbrtf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __cbrtf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn ceilf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __ceilf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fabsf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fabsf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn floorf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __floorf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fmodf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fmodf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn copysignf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __copysignf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn nanf32(__tagb: *const ::std::os::raw::c_char) -> _Float32;
}
unsafe extern "C" {
    pub fn __nanf32(__tagb: *const ::std::os::raw::c_char) -> _Float32;
}
unsafe extern "C" {
    pub fn j0f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __j0f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn j1f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __j1f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn jnf32(arg1: ::std::os::raw::c_int, arg2: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __jnf32(arg1: ::std::os::raw::c_int, arg2: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn y0f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __y0f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn y1f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __y1f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn ynf32(arg1: ::std::os::raw::c_int, arg2: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __ynf32(arg1: ::std::os::raw::c_int, arg2: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn erff32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __erff32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn erfcf32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __erfcf32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn lgammaf32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __lgammaf32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn tgammaf32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __tgammaf32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn lgammaf32_r(arg1: _Float32, __signgamp: *mut ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn __lgammaf32_r(arg1: _Float32, __signgamp: *mut ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn rintf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __rintf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn nextafterf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __nextafterf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn nextdownf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __nextdownf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn nextupf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __nextupf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn remainderf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __remainderf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn scalbnf32(__x: _Float32, __n: ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn __scalbnf32(__x: _Float32, __n: ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn ilogbf32(__x: _Float32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbf32(__x: _Float32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn llogbf32(__x: _Float32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __llogbf32(__x: _Float32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn scalblnf32(__x: _Float32, __n: ::std::os::raw::c_long) -> _Float32;
}
unsafe extern "C" {
    pub fn __scalblnf32(__x: _Float32, __n: ::std::os::raw::c_long) -> _Float32;
}
unsafe extern "C" {
    pub fn nearbyintf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __nearbyintf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn roundf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __roundf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn truncf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __truncf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn remquof32(__x: _Float32, __y: _Float32, __quo: *mut ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn __remquof32(__x: _Float32, __y: _Float32, __quo: *mut ::std::os::raw::c_int)
    -> _Float32;
}
unsafe extern "C" {
    pub fn lrintf32(__x: _Float32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintf32(__x: _Float32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintf32(__x: _Float32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintf32(__x: _Float32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundf32(__x: _Float32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundf32(__x: _Float32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundf32(__x: _Float32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundf32(__x: _Float32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdimf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fdimf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fmaxf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fmaxf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fminf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fminf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fmaf32(__x: _Float32, __y: _Float32, __z: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fmaf32(__x: _Float32, __y: _Float32, __z: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn roundevenf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __roundevenf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fromfpf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fromfpxf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpxf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpxf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpxf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fmaxmagf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fmaxmagf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fminmagf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fminmagf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn canonicalizef32(__cx: *mut _Float32, __x: *const _Float32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalorderf32(__x: *const _Float32, __y: *const _Float32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalordermagf32(__x: *const _Float32, __y: *const _Float32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpayloadf32(__x: *const _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __getpayloadf32(__x: *const _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn setpayloadf32(__x: *mut _Float32, __payload: _Float32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpayloadsigf32(__x: *mut _Float32, __payload: _Float32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __acosf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn asinf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __asinf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn atanf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __atanf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn atan2f64(__y: _Float64, __x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __atan2f64(__y: _Float64, __x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn cosf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __cosf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn sinf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __sinf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn tanf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __tanf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn coshf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __coshf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn sinhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __sinhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn tanhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __tanhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn sincosf64(__x: _Float64, __sinx: *mut _Float64, __cosx: *mut _Float64);
}
unsafe extern "C" {
    pub fn __sincosf64(__x: _Float64, __sinx: *mut _Float64, __cosx: *mut _Float64);
}
unsafe extern "C" {
    pub fn acoshf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __acoshf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn asinhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __asinhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn atanhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __atanhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn expf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __expf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn frexpf64(__x: _Float64, __exponent: *mut ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn __frexpf64(__x: _Float64, __exponent: *mut ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn ldexpf64(__x: _Float64, __exponent: ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn __ldexpf64(__x: _Float64, __exponent: ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn logf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __logf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn log10f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __log10f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn modff64(__x: _Float64, __iptr: *mut _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __modff64(__x: _Float64, __iptr: *mut _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn exp10f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __exp10f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn expm1f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __expm1f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn log1pf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __log1pf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn logbf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __logbf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn exp2f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __exp2f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn log2f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __log2f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn powf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __powf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn sqrtf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __sqrtf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn hypotf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __hypotf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn cbrtf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __cbrtf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn ceilf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __ceilf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fabsf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fabsf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn floorf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __floorf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fmodf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fmodf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn copysignf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __copysignf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn nanf64(__tagb: *const ::std::os::raw::c_char) -> _Float64;
}
unsafe extern "C" {
    pub fn __nanf64(__tagb: *const ::std::os::raw::c_char) -> _Float64;
}
unsafe extern "C" {
    pub fn j0f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __j0f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn j1f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __j1f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn jnf64(arg1: ::std::os::raw::c_int, arg2: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __jnf64(arg1: ::std::os::raw::c_int, arg2: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn y0f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __y0f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn y1f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __y1f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn ynf64(arg1: ::std::os::raw::c_int, arg2: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __ynf64(arg1: ::std::os::raw::c_int, arg2: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn erff64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __erff64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn erfcf64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __erfcf64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn lgammaf64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __lgammaf64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn tgammaf64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __tgammaf64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn lgammaf64_r(arg1: _Float64, __signgamp: *mut ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn __lgammaf64_r(arg1: _Float64, __signgamp: *mut ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn rintf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __rintf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn nextafterf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __nextafterf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn nextdownf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __nextdownf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn nextupf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __nextupf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn remainderf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __remainderf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn scalbnf64(__x: _Float64, __n: ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn __scalbnf64(__x: _Float64, __n: ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn ilogbf64(__x: _Float64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbf64(__x: _Float64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn llogbf64(__x: _Float64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __llogbf64(__x: _Float64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn scalblnf64(__x: _Float64, __n: ::std::os::raw::c_long) -> _Float64;
}
unsafe extern "C" {
    pub fn __scalblnf64(__x: _Float64, __n: ::std::os::raw::c_long) -> _Float64;
}
unsafe extern "C" {
    pub fn nearbyintf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __nearbyintf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn roundf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __roundf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn truncf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __truncf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn remquof64(__x: _Float64, __y: _Float64, __quo: *mut ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn __remquof64(__x: _Float64, __y: _Float64, __quo: *mut ::std::os::raw::c_int)
    -> _Float64;
}
unsafe extern "C" {
    pub fn lrintf64(__x: _Float64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintf64(__x: _Float64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintf64(__x: _Float64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintf64(__x: _Float64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundf64(__x: _Float64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundf64(__x: _Float64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundf64(__x: _Float64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundf64(__x: _Float64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdimf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fdimf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fmaxf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fmaxf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fminf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fminf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fmaf64(__x: _Float64, __y: _Float64, __z: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fmaf64(__x: _Float64, __y: _Float64, __z: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn roundevenf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __roundevenf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fromfpf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fromfpxf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpxf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpxf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpxf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fmaxmagf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fmaxmagf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fminmagf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fminmagf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn canonicalizef64(__cx: *mut _Float64, __x: *const _Float64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalorderf64(__x: *const _Float64, __y: *const _Float64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalordermagf64(__x: *const _Float64, __y: *const _Float64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpayloadf64(__x: *const _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __getpayloadf64(__x: *const _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn setpayloadf64(__x: *mut _Float64, __payload: _Float64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpayloadsigf64(__x: *mut _Float64, __payload: _Float64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __acosf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn asinf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __asinf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn atanf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __atanf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn atan2f32x(__y: _Float32x, __x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __atan2f32x(__y: _Float32x, __x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn cosf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __cosf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn sinf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __sinf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn tanf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __tanf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn coshf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __coshf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn sinhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __sinhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn tanhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __tanhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn sincosf32x(__x: _Float32x, __sinx: *mut _Float32x, __cosx: *mut _Float32x);
}
unsafe extern "C" {
    pub fn __sincosf32x(__x: _Float32x, __sinx: *mut _Float32x, __cosx: *mut _Float32x);
}
unsafe extern "C" {
    pub fn acoshf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __acoshf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn asinhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __asinhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn atanhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __atanhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn expf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __expf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn frexpf32x(__x: _Float32x, __exponent: *mut ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn __frexpf32x(__x: _Float32x, __exponent: *mut ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn ldexpf32x(__x: _Float32x, __exponent: ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn __ldexpf32x(__x: _Float32x, __exponent: ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn logf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __logf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn log10f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __log10f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn modff32x(__x: _Float32x, __iptr: *mut _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __modff32x(__x: _Float32x, __iptr: *mut _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn exp10f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __exp10f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn expm1f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __expm1f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn log1pf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __log1pf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn logbf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __logbf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn exp2f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __exp2f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn log2f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __log2f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn powf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __powf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn sqrtf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __sqrtf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn hypotf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __hypotf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn cbrtf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __cbrtf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn ceilf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __ceilf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fabsf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fabsf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn floorf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __floorf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fmodf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fmodf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn copysignf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __copysignf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn nanf32x(__tagb: *const ::std::os::raw::c_char) -> _Float32x;
}
unsafe extern "C" {
    pub fn __nanf32x(__tagb: *const ::std::os::raw::c_char) -> _Float32x;
}
unsafe extern "C" {
    pub fn j0f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __j0f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn j1f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __j1f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn jnf32x(arg1: ::std::os::raw::c_int, arg2: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __jnf32x(arg1: ::std::os::raw::c_int, arg2: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn y0f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __y0f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn y1f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __y1f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn ynf32x(arg1: ::std::os::raw::c_int, arg2: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __ynf32x(arg1: ::std::os::raw::c_int, arg2: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn erff32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __erff32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn erfcf32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __erfcf32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn lgammaf32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __lgammaf32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn tgammaf32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __tgammaf32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn lgammaf32x_r(arg1: _Float32x, __signgamp: *mut ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn __lgammaf32x_r(arg1: _Float32x, __signgamp: *mut ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn rintf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __rintf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn nextafterf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __nextafterf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn nextdownf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __nextdownf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn nextupf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __nextupf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn remainderf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __remainderf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn scalbnf32x(__x: _Float32x, __n: ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn __scalbnf32x(__x: _Float32x, __n: ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn ilogbf32x(__x: _Float32x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbf32x(__x: _Float32x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn llogbf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __llogbf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn scalblnf32x(__x: _Float32x, __n: ::std::os::raw::c_long) -> _Float32x;
}
unsafe extern "C" {
    pub fn __scalblnf32x(__x: _Float32x, __n: ::std::os::raw::c_long) -> _Float32x;
}
unsafe extern "C" {
    pub fn nearbyintf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __nearbyintf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn roundf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __roundf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn truncf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __truncf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn remquof32x(
        __x: _Float32x,
        __y: _Float32x,
        __quo: *mut ::std::os::raw::c_int,
    ) -> _Float32x;
}
unsafe extern "C" {
    pub fn __remquof32x(
        __x: _Float32x,
        __y: _Float32x,
        __quo: *mut ::std::os::raw::c_int,
    ) -> _Float32x;
}
unsafe extern "C" {
    pub fn lrintf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintf32x(__x: _Float32x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintf32x(__x: _Float32x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundf32x(__x: _Float32x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundf32x(__x: _Float32x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdimf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fdimf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fmaxf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fmaxf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fminf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fminf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fmaf32x(__x: _Float32x, __y: _Float32x, __z: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fmaf32x(__x: _Float32x, __y: _Float32x, __z: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn roundevenf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __roundevenf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fromfpf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fromfpxf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpxf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpxf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpxf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fmaxmagf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fmaxmagf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fminmagf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fminmagf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn canonicalizef32x(__cx: *mut _Float32x, __x: *const _Float32x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalorderf32x(__x: *const _Float32x, __y: *const _Float32x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalordermagf32x(__x: *const _Float32x, __y: *const _Float32x)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpayloadf32x(__x: *const _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __getpayloadf32x(__x: *const _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn setpayloadf32x(__x: *mut _Float32x, __payload: _Float32x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpayloadsigf32x(__x: *mut _Float32x, __payload: _Float32x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __acosf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn asinf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __asinf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn atanf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __atanf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn atan2f64x(__y: _Float64x, __x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __atan2f64x(__y: _Float64x, __x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn cosf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __cosf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn sinf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __sinf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn tanf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __tanf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn coshf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __coshf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn sinhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __sinhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn tanhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __tanhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn sincosf64x(__x: _Float64x, __sinx: *mut _Float64x, __cosx: *mut _Float64x);
}
unsafe extern "C" {
    pub fn __sincosf64x(__x: _Float64x, __sinx: *mut _Float64x, __cosx: *mut _Float64x);
}
unsafe extern "C" {
    pub fn acoshf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __acoshf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn asinhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __asinhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn atanhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __atanhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn expf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __expf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn frexpf64x(__x: _Float64x, __exponent: *mut ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn __frexpf64x(__x: _Float64x, __exponent: *mut ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn ldexpf64x(__x: _Float64x, __exponent: ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn __ldexpf64x(__x: _Float64x, __exponent: ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn logf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __logf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn log10f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __log10f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn modff64x(__x: _Float64x, __iptr: *mut _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __modff64x(__x: _Float64x, __iptr: *mut _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn exp10f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __exp10f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn expm1f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __expm1f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn log1pf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __log1pf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn logbf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __logbf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn exp2f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __exp2f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn log2f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __log2f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn powf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __powf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn sqrtf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __sqrtf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn hypotf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __hypotf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn cbrtf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __cbrtf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn ceilf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __ceilf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fabsf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fabsf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn floorf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __floorf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fmodf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fmodf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn copysignf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __copysignf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn nanf64x(__tagb: *const ::std::os::raw::c_char) -> _Float64x;
}
unsafe extern "C" {
    pub fn __nanf64x(__tagb: *const ::std::os::raw::c_char) -> _Float64x;
}
unsafe extern "C" {
    pub fn j0f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __j0f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn j1f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __j1f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn jnf64x(arg1: ::std::os::raw::c_int, arg2: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __jnf64x(arg1: ::std::os::raw::c_int, arg2: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn y0f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __y0f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn y1f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __y1f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn ynf64x(arg1: ::std::os::raw::c_int, arg2: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __ynf64x(arg1: ::std::os::raw::c_int, arg2: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn erff64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __erff64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn erfcf64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __erfcf64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn lgammaf64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __lgammaf64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn tgammaf64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __tgammaf64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn lgammaf64x_r(arg1: _Float64x, __signgamp: *mut ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn __lgammaf64x_r(arg1: _Float64x, __signgamp: *mut ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn rintf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __rintf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn nextafterf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __nextafterf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn nextdownf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __nextdownf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn nextupf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __nextupf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn remainderf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __remainderf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn scalbnf64x(__x: _Float64x, __n: ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn __scalbnf64x(__x: _Float64x, __n: ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn ilogbf64x(__x: _Float64x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbf64x(__x: _Float64x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn llogbf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __llogbf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn scalblnf64x(__x: _Float64x, __n: ::std::os::raw::c_long) -> _Float64x;
}
unsafe extern "C" {
    pub fn __scalblnf64x(__x: _Float64x, __n: ::std::os::raw::c_long) -> _Float64x;
}
unsafe extern "C" {
    pub fn nearbyintf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __nearbyintf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn roundf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __roundf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn truncf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __truncf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn remquof64x(
        __x: _Float64x,
        __y: _Float64x,
        __quo: *mut ::std::os::raw::c_int,
    ) -> _Float64x;
}
unsafe extern "C" {
    pub fn __remquof64x(
        __x: _Float64x,
        __y: _Float64x,
        __quo: *mut ::std::os::raw::c_int,
    ) -> _Float64x;
}
unsafe extern "C" {
    pub fn lrintf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintf64x(__x: _Float64x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintf64x(__x: _Float64x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundf64x(__x: _Float64x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundf64x(__x: _Float64x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdimf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fdimf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fmaxf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fmaxf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fminf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fminf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fmaf64x(__x: _Float64x, __y: _Float64x, __z: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fmaf64x(__x: _Float64x, __y: _Float64x, __z: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn roundevenf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __roundevenf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fromfpf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fromfpxf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpxf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpxf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpxf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fmaxmagf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fmaxmagf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fminmagf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fminmagf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn canonicalizef64x(__cx: *mut _Float64x, __x: *const _Float64x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalorderf64x(__x: *const _Float64x, __y: *const _Float64x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalordermagf64x(__x: *const _Float64x, __y: *const _Float64x)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpayloadf64x(__x: *const _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __getpayloadf64x(__x: *const _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn setpayloadf64x(__x: *mut _Float64x, __payload: _Float64x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpayloadsigf64x(__x: *mut _Float64x, __payload: _Float64x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fadd(__x: f64, __y: f64) -> f32;
}
unsafe extern "C" {
    pub fn fdiv(__x: f64, __y: f64) -> f32;
}
unsafe extern "C" {
    pub fn fmul(__x: f64, __y: f64) -> f32;
}
unsafe extern "C" {
    pub fn fsub(__x: f64, __y: f64) -> f32;
}
unsafe extern "C" {
    pub fn faddl(__x: u128, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn fdivl(__x: u128, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn fmull(__x: u128, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn fsubl(__x: u128, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn daddl(__x: u128, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn ddivl(__x: u128, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn dmull(__x: u128, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn dsubl(__x: u128, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn f32addf32x(__x: _Float32x, __y: _Float32x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32divf32x(__x: _Float32x, __y: _Float32x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32mulf32x(__x: _Float32x, __y: _Float32x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32subf32x(__x: _Float32x, __y: _Float32x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32addf64(__x: _Float64, __y: _Float64) -> _Float32;
}
unsafe extern "C" {
    pub fn f32divf64(__x: _Float64, __y: _Float64) -> _Float32;
}
unsafe extern "C" {
    pub fn f32mulf64(__x: _Float64, __y: _Float64) -> _Float32;
}
unsafe extern "C" {
    pub fn f32subf64(__x: _Float64, __y: _Float64) -> _Float32;
}
unsafe extern "C" {
    pub fn f32addf64x(__x: _Float64x, __y: _Float64x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32divf64x(__x: _Float64x, __y: _Float64x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32mulf64x(__x: _Float64x, __y: _Float64x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32subf64x(__x: _Float64x, __y: _Float64x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32xaddf64(__x: _Float64, __y: _Float64) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xdivf64(__x: _Float64, __y: _Float64) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xmulf64(__x: _Float64, __y: _Float64) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xsubf64(__x: _Float64, __y: _Float64) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xaddf64x(__x: _Float64x, __y: _Float64x) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xdivf64x(__x: _Float64x, __y: _Float64x) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xmulf64x(__x: _Float64x, __y: _Float64x) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xsubf64x(__x: _Float64x, __y: _Float64x) -> _Float32x;
}
unsafe extern "C" {
    pub fn f64addf64x(__x: _Float64x, __y: _Float64x) -> _Float64;
}
unsafe extern "C" {
    pub fn f64divf64x(__x: _Float64x, __y: _Float64x) -> _Float64;
}
unsafe extern "C" {
    pub fn f64mulf64x(__x: _Float64x, __y: _Float64x) -> _Float64;
}
unsafe extern "C" {
    pub fn f64subf64x(__x: _Float64x, __y: _Float64x) -> _Float64;
}
unsafe extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: _bindgen_ty_48 = 0;
pub const FP_INFINITE: _bindgen_ty_48 = 1;
pub const FP_ZERO: _bindgen_ty_48 = 2;
pub const FP_SUBNORMAL: _bindgen_ty_48 = 3;
pub const FP_NORMAL: _bindgen_ty_48 = 4;
pub type _bindgen_ty_48 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn __iscanonicall(__x: u128) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __iseqsig_type {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: __iseqsig_type_open0_float_close0"]
        [::std::mem::size_of::<__iseqsig_type>() - 1usize];
    ["Align of template specialization: __iseqsig_type_open0_float_close0"]
        [::std::mem::align_of::<__iseqsig_type>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: __iseqsig_type_open0_double_close0"]
        [::std::mem::size_of::<__iseqsig_type>() - 1usize];
    ["Align of template specialization: __iseqsig_type_open0_double_close0"]
        [::std::mem::align_of::<__iseqsig_type>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: __iseqsig_type_open0_long_double_close0"]
        [::std::mem::size_of::<__iseqsig_type>() - 1usize];
    ["Align of template specialization: __iseqsig_type_open0_long_double_close0"]
        [::std::mem::align_of::<__iseqsig_type>() - 1usize];
};
unsafe extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    ) -> !;
}
pub type wctype_t = ::std::os::raw::c_ulong;
pub const __ISwupper: _bindgen_ty_52 = 0;
pub const __ISwlower: _bindgen_ty_52 = 1;
pub const __ISwalpha: _bindgen_ty_52 = 2;
pub const __ISwdigit: _bindgen_ty_52 = 3;
pub const __ISwxdigit: _bindgen_ty_52 = 4;
pub const __ISwspace: _bindgen_ty_52 = 5;
pub const __ISwprint: _bindgen_ty_52 = 6;
pub const __ISwgraph: _bindgen_ty_52 = 7;
pub const __ISwblank: _bindgen_ty_52 = 8;
pub const __ISwcntrl: _bindgen_ty_52 = 9;
pub const __ISwpunct: _bindgen_ty_52 = 10;
pub const __ISwalnum: _bindgen_ty_52 = 11;
pub const _ISwupper: _bindgen_ty_52 = 16777216;
pub const _ISwlower: _bindgen_ty_52 = 33554432;
pub const _ISwalpha: _bindgen_ty_52 = 67108864;
pub const _ISwdigit: _bindgen_ty_52 = 134217728;
pub const _ISwxdigit: _bindgen_ty_52 = 268435456;
pub const _ISwspace: _bindgen_ty_52 = 536870912;
pub const _ISwprint: _bindgen_ty_52 = 1073741824;
pub const _ISwgraph: _bindgen_ty_52 = -2147483648;
pub const _ISwblank: _bindgen_ty_52 = 65536;
pub const _ISwcntrl: _bindgen_ty_52 = 131072;
pub const _ISwpunct: _bindgen_ty_52 = 262144;
pub const _ISwalnum: _bindgen_ty_52 = 524288;
pub type _bindgen_ty_52 = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn iswalnum(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswalpha(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswcntrl(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswdigit(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswgraph(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswlower(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswprint(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswpunct(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswspace(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswupper(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswxdigit(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswblank(__wc: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctype(__property: *const ::std::os::raw::c_char) -> wctype_t;
}
unsafe extern "C" {
    pub fn iswctype(__wc: wint_t, __desc: wctype_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn towlower(__wc: wint_t) -> wint_t;
}
unsafe extern "C" {
    pub fn towupper(__wc: wint_t) -> wint_t;
}
pub type wctrans_t = *const __int32_t;
unsafe extern "C" {
    pub fn wctrans(__property: *const ::std::os::raw::c_char) -> wctrans_t;
}
unsafe extern "C" {
    pub fn towctrans(__wc: wint_t, __desc: wctrans_t) -> wint_t;
}
unsafe extern "C" {
    pub fn iswalnum_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswalpha_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswcntrl_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswdigit_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswgraph_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswlower_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswprint_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswpunct_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswspace_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswupper_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswxdigit_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iswblank_l(__wc: wint_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctype_l(__property: *const ::std::os::raw::c_char, __locale: locale_t) -> wctype_t;
}
unsafe extern "C" {
    pub fn iswctype_l(__wc: wint_t, __desc: wctype_t, __locale: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn towlower_l(__wc: wint_t, __locale: locale_t) -> wint_t;
}
unsafe extern "C" {
    pub fn towupper_l(__wc: wint_t, __locale: locale_t) -> wint_t;
}
unsafe extern "C" {
    pub fn wctrans_l(__property: *const ::std::os::raw::c_char, __locale: locale_t) -> wctrans_t;
}
unsafe extern "C" {
    pub fn towctrans_l(__wc: wint_t, __desc: wctrans_t, __locale: locale_t) -> wint_t;
}
pub const cvflann_flann_algorithm_t_FLANN_INDEX_LINEAR: cvflann_flann_algorithm_t = 0;
pub const cvflann_flann_algorithm_t_FLANN_INDEX_KDTREE: cvflann_flann_algorithm_t = 1;
pub const cvflann_flann_algorithm_t_FLANN_INDEX_KMEANS: cvflann_flann_algorithm_t = 2;
pub const cvflann_flann_algorithm_t_FLANN_INDEX_COMPOSITE: cvflann_flann_algorithm_t = 3;
pub const cvflann_flann_algorithm_t_FLANN_INDEX_KDTREE_SINGLE: cvflann_flann_algorithm_t = 4;
pub const cvflann_flann_algorithm_t_FLANN_INDEX_HIERARCHICAL: cvflann_flann_algorithm_t = 5;
pub const cvflann_flann_algorithm_t_FLANN_INDEX_LSH: cvflann_flann_algorithm_t = 6;
pub const cvflann_flann_algorithm_t_FLANN_INDEX_SAVED: cvflann_flann_algorithm_t = 254;
pub const cvflann_flann_algorithm_t_FLANN_INDEX_AUTOTUNED: cvflann_flann_algorithm_t = 255;
pub const cvflann_flann_algorithm_t_LINEAR: cvflann_flann_algorithm_t = 0;
pub const cvflann_flann_algorithm_t_KDTREE: cvflann_flann_algorithm_t = 1;
pub const cvflann_flann_algorithm_t_KMEANS: cvflann_flann_algorithm_t = 2;
pub const cvflann_flann_algorithm_t_COMPOSITE: cvflann_flann_algorithm_t = 3;
pub const cvflann_flann_algorithm_t_KDTREE_SINGLE: cvflann_flann_algorithm_t = 4;
pub const cvflann_flann_algorithm_t_SAVED: cvflann_flann_algorithm_t = 254;
pub const cvflann_flann_algorithm_t_AUTOTUNED: cvflann_flann_algorithm_t = 255;
pub type cvflann_flann_algorithm_t = ::std::os::raw::c_uint;
pub const cvflann_flann_centers_init_t_FLANN_CENTERS_RANDOM: cvflann_flann_centers_init_t = 0;
pub const cvflann_flann_centers_init_t_FLANN_CENTERS_GONZALES: cvflann_flann_centers_init_t = 1;
pub const cvflann_flann_centers_init_t_FLANN_CENTERS_KMEANSPP: cvflann_flann_centers_init_t = 2;
pub const cvflann_flann_centers_init_t_FLANN_CENTERS_GROUPWISE: cvflann_flann_centers_init_t = 3;
pub const cvflann_flann_centers_init_t_CENTERS_RANDOM: cvflann_flann_centers_init_t = 0;
pub const cvflann_flann_centers_init_t_CENTERS_GONZALES: cvflann_flann_centers_init_t = 1;
pub const cvflann_flann_centers_init_t_CENTERS_KMEANSPP: cvflann_flann_centers_init_t = 2;
pub type cvflann_flann_centers_init_t = ::std::os::raw::c_uint;
pub const cvflann_flann_log_level_t_FLANN_LOG_NONE: cvflann_flann_log_level_t = 0;
pub const cvflann_flann_log_level_t_FLANN_LOG_FATAL: cvflann_flann_log_level_t = 1;
pub const cvflann_flann_log_level_t_FLANN_LOG_ERROR: cvflann_flann_log_level_t = 2;
pub const cvflann_flann_log_level_t_FLANN_LOG_WARN: cvflann_flann_log_level_t = 3;
pub const cvflann_flann_log_level_t_FLANN_LOG_INFO: cvflann_flann_log_level_t = 4;
pub type cvflann_flann_log_level_t = ::std::os::raw::c_uint;
pub const cvflann_flann_distance_t_FLANN_DIST_EUCLIDEAN: cvflann_flann_distance_t = 1;
pub const cvflann_flann_distance_t_FLANN_DIST_L2: cvflann_flann_distance_t = 1;
pub const cvflann_flann_distance_t_FLANN_DIST_MANHATTAN: cvflann_flann_distance_t = 2;
pub const cvflann_flann_distance_t_FLANN_DIST_L1: cvflann_flann_distance_t = 2;
pub const cvflann_flann_distance_t_FLANN_DIST_MINKOWSKI: cvflann_flann_distance_t = 3;
pub const cvflann_flann_distance_t_FLANN_DIST_MAX: cvflann_flann_distance_t = 4;
pub const cvflann_flann_distance_t_FLANN_DIST_HIST_INTERSECT: cvflann_flann_distance_t = 5;
pub const cvflann_flann_distance_t_FLANN_DIST_HELLINGER: cvflann_flann_distance_t = 6;
pub const cvflann_flann_distance_t_FLANN_DIST_CHI_SQUARE: cvflann_flann_distance_t = 7;
pub const cvflann_flann_distance_t_FLANN_DIST_CS: cvflann_flann_distance_t = 7;
pub const cvflann_flann_distance_t_FLANN_DIST_KULLBACK_LEIBLER: cvflann_flann_distance_t = 8;
pub const cvflann_flann_distance_t_FLANN_DIST_KL: cvflann_flann_distance_t = 8;
pub const cvflann_flann_distance_t_FLANN_DIST_HAMMING: cvflann_flann_distance_t = 9;
pub const cvflann_flann_distance_t_EUCLIDEAN: cvflann_flann_distance_t = 1;
pub const cvflann_flann_distance_t_MANHATTAN: cvflann_flann_distance_t = 2;
pub const cvflann_flann_distance_t_MINKOWSKI: cvflann_flann_distance_t = 3;
pub const cvflann_flann_distance_t_MAX_DIST: cvflann_flann_distance_t = 4;
pub const cvflann_flann_distance_t_HIST_INTERSECT: cvflann_flann_distance_t = 5;
pub const cvflann_flann_distance_t_HELLINGER: cvflann_flann_distance_t = 6;
pub const cvflann_flann_distance_t_CS: cvflann_flann_distance_t = 7;
pub const cvflann_flann_distance_t_KL: cvflann_flann_distance_t = 8;
pub const cvflann_flann_distance_t_KULLBACK_LEIBLER: cvflann_flann_distance_t = 8;
pub type cvflann_flann_distance_t = ::std::os::raw::c_uint;
pub const cvflann_flann_datatype_t_FLANN_INT8: cvflann_flann_datatype_t = 0;
pub const cvflann_flann_datatype_t_FLANN_INT16: cvflann_flann_datatype_t = 1;
pub const cvflann_flann_datatype_t_FLANN_INT32: cvflann_flann_datatype_t = 2;
pub const cvflann_flann_datatype_t_FLANN_INT64: cvflann_flann_datatype_t = 3;
pub const cvflann_flann_datatype_t_FLANN_UINT8: cvflann_flann_datatype_t = 4;
pub const cvflann_flann_datatype_t_FLANN_UINT16: cvflann_flann_datatype_t = 5;
pub const cvflann_flann_datatype_t_FLANN_UINT32: cvflann_flann_datatype_t = 6;
pub const cvflann_flann_datatype_t_FLANN_UINT64: cvflann_flann_datatype_t = 7;
pub const cvflann_flann_datatype_t_FLANN_FLOAT32: cvflann_flann_datatype_t = 8;
pub const cvflann_flann_datatype_t_FLANN_FLOAT64: cvflann_flann_datatype_t = 9;
pub type cvflann_flann_datatype_t = ::std::os::raw::c_uint;
pub const FLANN_CHECKS_UNLIMITED: cvflann__bindgen_ty_1 = -1;
pub const FLANN_CHECKS_AUTOTUNED: cvflann__bindgen_ty_1 = -2;
pub type cvflann__bindgen_ty_1 = ::std::os::raw::c_int;
#[repr(C)]
pub struct cvflann_FLANNException {
    pub _base: cv_Exception,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_FLANNException"][::std::mem::size_of::<cvflann_FLANNException>() - 152usize];
    ["Alignment of cvflann_FLANNException"]
        [::std::mem::align_of::<cvflann_FLANNException>() - 8usize];
};
#[doc = " Class that implements a simple rectangular matrix stored in a memory buffer and\n provides convenient matrix-like access using the [] operators."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_Matrix<T> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    pub rows: usize,
    pub cols: usize,
    pub stride: usize,
    pub data: *mut T,
}
pub type cvflann_Matrix_type<T> = T;
#[repr(C)]
#[derive(Debug)]
pub struct cvflann_UntypedMatrix {
    pub rows: usize,
    pub cols: usize,
    pub data: *mut ::std::os::raw::c_void,
    pub type_: cvflann_flann_datatype_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_UntypedMatrix"][::std::mem::size_of::<cvflann_UntypedMatrix>() - 32usize];
    ["Alignment of cvflann_UntypedMatrix"]
        [::std::mem::align_of::<cvflann_UntypedMatrix>() - 8usize];
    ["Offset of field: cvflann_UntypedMatrix::rows"]
        [::std::mem::offset_of!(cvflann_UntypedMatrix, rows) - 0usize];
    ["Offset of field: cvflann_UntypedMatrix::cols"]
        [::std::mem::offset_of!(cvflann_UntypedMatrix, cols) - 8usize];
    ["Offset of field: cvflann_UntypedMatrix::data"]
        [::std::mem::offset_of!(cvflann_UntypedMatrix, data) - 16usize];
    ["Offset of field: cvflann_UntypedMatrix::type_"]
        [::std::mem::offset_of!(cvflann_UntypedMatrix, type_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_anyimpl_bad_any_cast {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_anyimpl_bad_any_cast"]
        [::std::mem::size_of::<cvflann_anyimpl_bad_any_cast>() - 1usize];
    ["Alignment of cvflann_anyimpl_bad_any_cast"]
        [::std::mem::align_of::<cvflann_anyimpl_bad_any_cast>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_anyimpl_empty_any {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_anyimpl_empty_any"]
        [::std::mem::size_of::<cvflann_anyimpl_empty_any>() - 1usize];
    ["Alignment of cvflann_anyimpl_empty_any"]
        [::std::mem::align_of::<cvflann_anyimpl_empty_any>() - 1usize];
};
#[repr(C)]
pub struct cvflann_anyimpl_base_any_policy__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct cvflann_anyimpl_base_any_policy {
    pub vtable_: *const cvflann_anyimpl_base_any_policy__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_anyimpl_base_any_policy"]
        [::std::mem::size_of::<cvflann_anyimpl_base_any_policy>() - 8usize];
    ["Alignment of cvflann_anyimpl_base_any_policy"]
        [::std::mem::align_of::<cvflann_anyimpl_base_any_policy>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cvflann_anyimpl_typed_base_any_policy {
    pub _base: cvflann_anyimpl_base_any_policy,
}
#[repr(C)]
#[derive(Debug)]
pub struct cvflann_anyimpl_small_any_policy {
    pub _base: cvflann_anyimpl_typed_base_any_policy,
}
#[repr(C)]
#[derive(Debug)]
pub struct cvflann_anyimpl_big_any_policy {
    pub _base: cvflann_anyimpl_typed_base_any_policy,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_anyimpl_choose_policy {
    pub _address: u8,
}
pub type cvflann_anyimpl_choose_policy_type = cvflann_anyimpl_big_any_policy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_anyimpl_any {
    _unused: [u8; 0],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cvflann_anyimpl_choose_policy_open0_cvflann_anyimpl_any_close0",
    ][::std::mem::size_of::<cvflann_anyimpl_choose_policy>() - 1usize];
    [
        "Align of template specialization: cvflann_anyimpl_choose_policy_open0_cvflann_anyimpl_any_close0",
    ][::std::mem::align_of::<cvflann_anyimpl_choose_policy>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_anyimpl_choose_policy_open0_signed_char_close0"]
        [::std::mem::size_of::<cvflann_anyimpl_choose_policy>() - 1usize];
    ["Align of template specialization: cvflann_anyimpl_choose_policy_open0_signed_char_close0"]
        [::std::mem::align_of::<cvflann_anyimpl_choose_policy>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_anyimpl_choose_policy_open0_unsigned_char_close0"]
        [::std::mem::size_of::<cvflann_anyimpl_choose_policy>() - 1usize];
    ["Align of template specialization: cvflann_anyimpl_choose_policy_open0_unsigned_char_close0"]
        [::std::mem::align_of::<cvflann_anyimpl_choose_policy>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_anyimpl_choose_policy_open0_short_close0"]
        [::std::mem::size_of::<cvflann_anyimpl_choose_policy>() - 1usize];
    ["Align of template specialization: cvflann_anyimpl_choose_policy_open0_short_close0"]
        [::std::mem::align_of::<cvflann_anyimpl_choose_policy>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_anyimpl_choose_policy_open0_unsigned_short_close0"]
        [::std::mem::size_of::<cvflann_anyimpl_choose_policy>() - 1usize];
    ["Align of template specialization: cvflann_anyimpl_choose_policy_open0_unsigned_short_close0"]
        [::std::mem::align_of::<cvflann_anyimpl_choose_policy>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_anyimpl_choose_policy_open0_int_close0"]
        [::std::mem::size_of::<cvflann_anyimpl_choose_policy>() - 1usize];
    ["Align of template specialization: cvflann_anyimpl_choose_policy_open0_int_close0"]
        [::std::mem::align_of::<cvflann_anyimpl_choose_policy>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_anyimpl_choose_policy_open0_unsigned_int_close0"]
        [::std::mem::size_of::<cvflann_anyimpl_choose_policy>() - 1usize];
    ["Align of template specialization: cvflann_anyimpl_choose_policy_open0_unsigned_int_close0"]
        [::std::mem::align_of::<cvflann_anyimpl_choose_policy>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_anyimpl_choose_policy_open0_long_close0"]
        [::std::mem::size_of::<cvflann_anyimpl_choose_policy>() - 1usize];
    ["Align of template specialization: cvflann_anyimpl_choose_policy_open0_long_close0"]
        [::std::mem::align_of::<cvflann_anyimpl_choose_policy>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_anyimpl_choose_policy_open0_unsigned_long_close0"]
        [::std::mem::size_of::<cvflann_anyimpl_choose_policy>() - 1usize];
    ["Align of template specialization: cvflann_anyimpl_choose_policy_open0_unsigned_long_close0"]
        [::std::mem::align_of::<cvflann_anyimpl_choose_policy>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_anyimpl_choose_policy_open0_float_close0"]
        [::std::mem::size_of::<cvflann_anyimpl_choose_policy>() - 1usize];
    ["Align of template specialization: cvflann_anyimpl_choose_policy_open0_float_close0"]
        [::std::mem::align_of::<cvflann_anyimpl_choose_policy>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_anyimpl_choose_policy_open0_bool__close0"]
        [::std::mem::size_of::<cvflann_anyimpl_choose_policy>() - 1usize];
    ["Align of template specialization: cvflann_anyimpl_choose_policy_open0_bool__close0"]
        [::std::mem::align_of::<cvflann_anyimpl_choose_policy>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_anyimpl_SinglePolicy {
    pub _address: u8,
}
unsafe extern "C" {
    #[link_name = "\u{1}policy"]
    pub static mut cvflann_anyimpl_policy: T;
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cvflann_anyimpl_big_any_policy_open0_cvflann_anyimpl_empty_any_close0",
    ][::std::mem::size_of::<cvflann_anyimpl_big_any_policy>() - 8usize];
    [
        "Align of template specialization: cvflann_anyimpl_big_any_policy_open0_cvflann_anyimpl_empty_any_close0",
    ][::std::mem::align_of::<cvflann_anyimpl_big_any_policy>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cvflann_anyimpl_small_any_policy_open0_ptr_const_char_close0",
    ][::std::mem::size_of::<cvflann_anyimpl_small_any_policy>() - 8usize];
    [
        "Align of template specialization: cvflann_anyimpl_small_any_policy_open0_ptr_const_char_close0",
    ][::std::mem::align_of::<cvflann_anyimpl_small_any_policy>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_anyimpl_small_any_policy_open0_int_close0"]
        [::std::mem::size_of::<cvflann_anyimpl_small_any_policy>() - 8usize];
    ["Align of template specialization: cvflann_anyimpl_small_any_policy_open0_int_close0"]
        [::std::mem::align_of::<cvflann_anyimpl_small_any_policy>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_anyimpl_small_any_policy_open0_float_close0"]
        [::std::mem::size_of::<cvflann_anyimpl_small_any_policy>() - 8usize];
    ["Align of template specialization: cvflann_anyimpl_small_any_policy_open0_float_close0"]
        [::std::mem::align_of::<cvflann_anyimpl_small_any_policy>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_anyimpl_small_any_policy_open0_bool__close0"]
        [::std::mem::size_of::<cvflann_anyimpl_small_any_policy>() - 8usize];
    ["Align of template specialization: cvflann_anyimpl_small_any_policy_open0_bool__close0"]
        [::std::mem::align_of::<cvflann_anyimpl_small_any_policy>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cvflann_anyimpl_big_any_policy_open0_cvflann_flann_algorithm_t_close0",
    ][::std::mem::size_of::<cvflann_anyimpl_big_any_policy>() - 8usize];
    [
        "Align of template specialization: cvflann_anyimpl_big_any_policy_open0_cvflann_flann_algorithm_t_close0",
    ][::std::mem::align_of::<cvflann_anyimpl_big_any_policy>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cvflann_anyimpl_big_any_policy_open0_cvflann_flann_centers_init_t_close0",
    ][::std::mem::size_of::<cvflann_anyimpl_big_any_policy>() - 8usize];
    [
        "Align of template specialization: cvflann_anyimpl_big_any_policy_open0_cvflann_flann_centers_init_t_close0",
    ][::std::mem::align_of::<cvflann_anyimpl_big_any_policy>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_anyimpl_small_any_policy_open0_unsigned_int_close0"]
        [::std::mem::size_of::<cvflann_anyimpl_small_any_policy>() - 8usize];
    [
        "Align of template specialization: cvflann_anyimpl_small_any_policy_open0_unsigned_int_close0",
    ][::std::mem::align_of::<cvflann_anyimpl_small_any_policy>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cvflann_anyimpl_big_any_policy_open0__bindgen_ty_id_130332_close0",
    ][::std::mem::size_of::<cvflann_anyimpl_big_any_policy>() - 8usize];
    [
        "Align of template specialization: cvflann_anyimpl_big_any_policy_open0__bindgen_ty_id_130332_close0",
    ][::std::mem::align_of::<cvflann_anyimpl_big_any_policy>() - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cvflann_any {
    pub policy: *mut cvflann_anyimpl_base_any_policy,
    pub object: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_any"][::std::mem::size_of::<cvflann_any>() - 16usize];
    ["Alignment of cvflann_any"][::std::mem::align_of::<cvflann_any>() - 8usize];
    ["Offset of field: cvflann_any::policy"][::std::mem::offset_of!(cvflann_any, policy) - 0usize];
    ["Offset of field: cvflann_any::object"][::std::mem::offset_of!(cvflann_any, object) - 8usize];
};
pub type cvflann_IndexParams = std_map;
#[repr(C)]
pub struct cvflann_SearchParams {
    pub _base: cvflann_IndexParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_SearchParams"][::std::mem::size_of::<cvflann_SearchParams>() - 48usize];
    ["Alignment of cvflann_SearchParams"][::std::mem::align_of::<cvflann_SearchParams>() - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_BranchStruct<T, DistanceType> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<DistanceType>>,
    pub node: T,
    pub mindist: DistanceType,
}
#[repr(C)]
pub struct cvflann_ResultSet__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct cvflann_ResultSet {
    pub vtable_: *const cvflann_ResultSet__bindgen_vtable,
}
#[doc = " KNNSimpleResultSet does not ensure that the element it holds are unique.\n Is used in those cases where the nearest neighbour algorithm used does not\n attempt to insert the same element multiple times."]
#[repr(C)]
#[derive(Debug)]
pub struct cvflann_KNNSimpleResultSet<DistanceType> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<DistanceType>>,
    pub _base: cvflann_ResultSet,
    pub indices: *mut ::std::os::raw::c_int,
    pub dists: *mut DistanceType,
    pub capacity: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
    pub worst_distance_: DistanceType,
}
#[doc = " K-Nearest neighbour result set. Ensures that the elements inserted are unique"]
#[repr(C)]
#[derive(Debug)]
pub struct cvflann_KNNResultSet<DistanceType> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<DistanceType>>,
    pub _base: cvflann_ResultSet,
    pub indices: *mut ::std::os::raw::c_int,
    pub dists: *mut DistanceType,
    pub capacity: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
    pub worst_distance_: DistanceType,
}
#[doc = " A result-set class used when performing a radius based search."]
#[repr(C)]
#[derive(Debug)]
pub struct cvflann_RadiusResultSet<DistanceType> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<DistanceType>>,
    pub _base: cvflann_ResultSet,
    pub radius: DistanceType,
    pub indices: *mut ::std::os::raw::c_int,
    pub dists: *mut DistanceType,
    pub capacity: usize,
    pub count: usize,
}
#[doc = " Class that holds the k NN neighbors\n Faster than KNNResultSet as it uses a binary heap and does not maintain two arrays"]
#[repr(C)]
pub struct cvflann_UniqueResultSet<DistanceType> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<DistanceType>>,
    pub _base: cvflann_ResultSet,
    #[doc = " Flag to say if the set is full"]
    pub is_full_: bool,
    #[doc = " The worst distance found so far"]
    pub worst_distance_: DistanceType,
    #[doc = " The best candidates so far"]
    pub dist_indices_: std_set,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_UniqueResultSet_DistIndex<DistanceType> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<DistanceType>>,
    pub dist_: DistanceType,
    pub index_: ::std::os::raw::c_uint,
}
#[doc = " Class that holds the k NN neighbors\n Faster than KNNResultSet as it uses a binary heap and does not maintain two arrays"]
#[repr(C)]
pub struct cvflann_KNNUniqueResultSet<DistanceType> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<DistanceType>>,
    pub _base: cvflann_UniqueResultSet<DistanceType>,
    #[doc = " The number of neighbors to keep"]
    pub capacity_: ::std::os::raw::c_uint,
}
pub type cvflann_KNNUniqueResultSet_DistIndex = cvflann_UniqueResultSet<DistanceType>;
#[doc = " Class that holds the radius nearest neighbors\n It is more accurate than RadiusResult as it is not limited in the number of neighbors"]
#[repr(C)]
pub struct cvflann_RadiusUniqueResultSet<DistanceType> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<DistanceType>>,
    pub _base: cvflann_UniqueResultSet<DistanceType>,
    #[doc = " The furthest distance a neighbor can be"]
    pub radius_: DistanceType,
}
pub type cvflann_RadiusUniqueResultSet_DistIndex = cvflann_UniqueResultSet<DistanceType>;
#[doc = " Class that holds the k NN neighbors within a radius distance"]
#[repr(C)]
pub struct cvflann_KNNRadiusUniqueResultSet<DistanceType> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<DistanceType>>,
    pub _base: cvflann_KNNUniqueResultSet<DistanceType>,
    #[doc = " The maximum number of neighbors to consider"]
    pub capacity_: ::std::os::raw::c_uint,
    #[doc = " The maximum distance of a neighbor"]
    pub radius_: DistanceType,
}
#[repr(C)]
pub struct cvflann_NNIndex__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Nearest-neighbour index base class"]
#[repr(C)]
#[derive(Debug)]
pub struct cvflann_NNIndex {
    pub vtable_: *const cvflann_NNIndex__bindgen_vtable,
}
pub type cvflann_NNIndex_ElementType = __BindgenOpaqueArray<u8, 0usize>;
pub type cvflann_NNIndex_DistanceType = __BindgenOpaqueArray<u8, 0usize>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_Datatype {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_Datatype_open0_char_close0"]
        [::std::mem::size_of::<cvflann_Datatype>() - 1usize];
    ["Align of template specialization: cvflann_Datatype_open0_char_close0"]
        [::std::mem::align_of::<cvflann_Datatype>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_Datatype_open0_short_close0"]
        [::std::mem::size_of::<cvflann_Datatype>() - 1usize];
    ["Align of template specialization: cvflann_Datatype_open0_short_close0"]
        [::std::mem::align_of::<cvflann_Datatype>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_Datatype_open0_int_close0"]
        [::std::mem::size_of::<cvflann_Datatype>() - 1usize];
    ["Align of template specialization: cvflann_Datatype_open0_int_close0"]
        [::std::mem::align_of::<cvflann_Datatype>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_Datatype_open0_unsigned_char_close0"]
        [::std::mem::size_of::<cvflann_Datatype>() - 1usize];
    ["Align of template specialization: cvflann_Datatype_open0_unsigned_char_close0"]
        [::std::mem::align_of::<cvflann_Datatype>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_Datatype_open0_unsigned_short_close0"]
        [::std::mem::size_of::<cvflann_Datatype>() - 1usize];
    ["Align of template specialization: cvflann_Datatype_open0_unsigned_short_close0"]
        [::std::mem::align_of::<cvflann_Datatype>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_Datatype_open0_unsigned_int_close0"]
        [::std::mem::size_of::<cvflann_Datatype>() - 1usize];
    ["Align of template specialization: cvflann_Datatype_open0_unsigned_int_close0"]
        [::std::mem::align_of::<cvflann_Datatype>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_Datatype_open0_float_close0"]
        [::std::mem::size_of::<cvflann_Datatype>() - 1usize];
    ["Align of template specialization: cvflann_Datatype_open0_float_close0"]
        [::std::mem::align_of::<cvflann_Datatype>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_Datatype_open0_double_close0"]
        [::std::mem::size_of::<cvflann_Datatype>() - 1usize];
    ["Align of template specialization: cvflann_Datatype_open0_double_close0"]
        [::std::mem::align_of::<cvflann_Datatype>() - 1usize];
};
#[doc = " Structure representing the index header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_IndexHeader {
    pub signature: [::std::os::raw::c_char; 16usize],
    pub version: [::std::os::raw::c_char; 16usize],
    pub data_type: cvflann_flann_datatype_t,
    pub index_type: cvflann_flann_algorithm_t,
    pub rows: usize,
    pub cols: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_IndexHeader"][::std::mem::size_of::<cvflann_IndexHeader>() - 56usize];
    ["Alignment of cvflann_IndexHeader"][::std::mem::align_of::<cvflann_IndexHeader>() - 8usize];
    ["Offset of field: cvflann_IndexHeader::signature"]
        [::std::mem::offset_of!(cvflann_IndexHeader, signature) - 0usize];
    ["Offset of field: cvflann_IndexHeader::version"]
        [::std::mem::offset_of!(cvflann_IndexHeader, version) - 16usize];
    ["Offset of field: cvflann_IndexHeader::data_type"]
        [::std::mem::offset_of!(cvflann_IndexHeader, data_type) - 32usize];
    ["Offset of field: cvflann_IndexHeader::index_type"]
        [::std::mem::offset_of!(cvflann_IndexHeader, index_type) - 36usize];
    ["Offset of field: cvflann_IndexHeader::rows"]
        [::std::mem::offset_of!(cvflann_IndexHeader, rows) - 40usize];
    ["Offset of field: cvflann_IndexHeader::cols"]
        [::std::mem::offset_of!(cvflann_IndexHeader, cols) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_Accumulator {
    pub _address: u8,
}
pub type cvflann_Accumulator_Type<T> = T;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_Accumulator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<cvflann_Accumulator>() - 1usize];
    ["Align of template specialization: cvflann_Accumulator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<cvflann_Accumulator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_Accumulator_open0_unsigned_short_close0"]
        [::std::mem::size_of::<cvflann_Accumulator>() - 1usize];
    ["Align of template specialization: cvflann_Accumulator_open0_unsigned_short_close0"]
        [::std::mem::align_of::<cvflann_Accumulator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_Accumulator_open0_unsigned_int_close0"]
        [::std::mem::size_of::<cvflann_Accumulator>() - 1usize];
    ["Align of template specialization: cvflann_Accumulator_open0_unsigned_int_close0"]
        [::std::mem::align_of::<cvflann_Accumulator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_Accumulator_open0_char_close0"]
        [::std::mem::size_of::<cvflann_Accumulator>() - 1usize];
    ["Align of template specialization: cvflann_Accumulator_open0_char_close0"]
        [::std::mem::align_of::<cvflann_Accumulator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_Accumulator_open0_short_close0"]
        [::std::mem::size_of::<cvflann_Accumulator>() - 1usize];
    ["Align of template specialization: cvflann_Accumulator_open0_short_close0"]
        [::std::mem::align_of::<cvflann_Accumulator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_Accumulator_open0_int_close0"]
        [::std::mem::size_of::<cvflann_Accumulator>() - 1usize];
    ["Align of template specialization: cvflann_Accumulator_open0_int_close0"]
        [::std::mem::align_of::<cvflann_Accumulator>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_True {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_True"][::std::mem::size_of::<cvflann_True>() - 1usize];
    ["Alignment of cvflann_True"][::std::mem::align_of::<cvflann_True>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_False {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_False"][::std::mem::size_of::<cvflann_False>() - 1usize];
    ["Alignment of cvflann_False"][::std::mem::align_of::<cvflann_False>() - 1usize];
};
#[doc = " Squared Euclidean distance functor.\n\n This is the simpler, unrolled version. This is preferable for\n very low dimensionality data (eg 3D points)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_L2_Simple {
    pub _address: u8,
}
pub type cvflann_L2_Simple_is_kdtree_distance = cvflann_True;
pub type cvflann_L2_Simple_is_vector_space_distance = cvflann_True;
pub type cvflann_L2_Simple_ElementType<T> = T;
pub type cvflann_L2_Simple_ResultType = cvflann_Accumulator;
#[doc = " Squared Euclidean distance functor, optimized version"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_L2 {
    pub _address: u8,
}
pub type cvflann_L2_is_kdtree_distance = cvflann_True;
pub type cvflann_L2_is_vector_space_distance = cvflann_True;
pub type cvflann_L2_ElementType<T> = T;
pub type cvflann_L2_ResultType = cvflann_Accumulator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_L1 {
    pub _address: u8,
}
pub type cvflann_L1_is_kdtree_distance = cvflann_True;
pub type cvflann_L1_is_vector_space_distance = cvflann_True;
pub type cvflann_L1_ElementType<T> = T;
pub type cvflann_L1_ResultType = cvflann_Accumulator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_MinkowskiDistance {
    pub order: ::std::os::raw::c_int,
}
pub type cvflann_MinkowskiDistance_is_kdtree_distance = cvflann_True;
pub type cvflann_MinkowskiDistance_is_vector_space_distance = cvflann_True;
pub type cvflann_MinkowskiDistance_ElementType<T> = T;
pub type cvflann_MinkowskiDistance_ResultType = cvflann_Accumulator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_MaxDistance {
    pub _address: u8,
}
pub type cvflann_MaxDistance_is_kdtree_distance = cvflann_False;
pub type cvflann_MaxDistance_is_vector_space_distance = cvflann_True;
pub type cvflann_MaxDistance_ElementType<T> = T;
pub type cvflann_MaxDistance_ResultType = cvflann_Accumulator;
#[doc = " Hamming distance functor - counts the bit differences between two strings - useful for the Brief descriptor\n bit count of A exclusive XOR'ed with B"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_HammingLUT {
    pub _address: u8,
}
pub type cvflann_HammingLUT_is_kdtree_distance = cvflann_False;
pub type cvflann_HammingLUT_is_vector_space_distance = cvflann_False;
pub type cvflann_HammingLUT_ElementType = ::std::os::raw::c_uchar;
pub type cvflann_HammingLUT_ResultType = ::std::os::raw::c_int;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_HammingLUT"][::std::mem::size_of::<cvflann_HammingLUT>() - 1usize];
    ["Alignment of cvflann_HammingLUT"][::std::mem::align_of::<cvflann_HammingLUT>() - 1usize];
};
#[doc = " Hamming distance functor (pop count between two binary vectors, i.e. xor them and count the number of bits set)\n That code was taken from brief.cpp in OpenCV"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_Hamming {
    pub _address: u8,
}
pub type cvflann_Hamming_is_kdtree_distance = cvflann_False;
pub type cvflann_Hamming_is_vector_space_distance = cvflann_False;
pub type cvflann_Hamming_ElementType<T> = T;
pub type cvflann_Hamming_ResultType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_Hamming2 {
    pub _address: u8,
}
pub type cvflann_Hamming2_is_kdtree_distance = cvflann_False;
pub type cvflann_Hamming2_is_vector_space_distance = cvflann_False;
pub type cvflann_Hamming2_ElementType<T> = T;
pub type cvflann_Hamming2_ResultType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_HistIntersectionDistance {
    pub _address: u8,
}
pub type cvflann_HistIntersectionDistance_is_kdtree_distance = cvflann_True;
pub type cvflann_HistIntersectionDistance_is_vector_space_distance = cvflann_True;
pub type cvflann_HistIntersectionDistance_ElementType<T> = T;
pub type cvflann_HistIntersectionDistance_ResultType = cvflann_Accumulator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_HellingerDistance {
    pub _address: u8,
}
pub type cvflann_HellingerDistance_is_kdtree_distance = cvflann_True;
pub type cvflann_HellingerDistance_is_vector_space_distance = cvflann_True;
pub type cvflann_HellingerDistance_ElementType<T> = T;
pub type cvflann_HellingerDistance_ResultType = cvflann_Accumulator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_ChiSquareDistance {
    pub _address: u8,
}
pub type cvflann_ChiSquareDistance_is_kdtree_distance = cvflann_True;
pub type cvflann_ChiSquareDistance_is_vector_space_distance = cvflann_True;
pub type cvflann_ChiSquareDistance_ElementType<T> = T;
pub type cvflann_ChiSquareDistance_ResultType = cvflann_Accumulator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_KL_Divergence {
    pub _address: u8,
}
pub type cvflann_KL_Divergence_is_kdtree_distance = cvflann_True;
pub type cvflann_KL_Divergence_is_vector_space_distance = cvflann_True;
pub type cvflann_KL_Divergence_ElementType<T> = T;
pub type cvflann_KL_Divergence_ResultType = cvflann_Accumulator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_ZeroIterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_squareDistance {
    pub _address: u8,
}
pub type cvflann_squareDistance_ResultType = __BindgenOpaqueArray<u8, 0usize>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_simpleDistance {
    pub _address: u8,
}
pub type cvflann_simpleDistance_ResultType = __BindgenOpaqueArray<u8, 0usize>;
#[doc = " Class re-implementing the boost version of it\n This helps not depending on boost, it also does not do the bound checks\n and has a way to reset a block for speed"]
#[repr(C)]
pub struct cvflann_DynamicBitset {
    pub bitset_: std_vector,
    pub size_: usize,
}
pub const cvflann_DynamicBitset_cell_bit_size_: ::std::os::raw::c_uint = 64;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_DynamicBitset"][::std::mem::size_of::<cvflann_DynamicBitset>() - 32usize];
    ["Alignment of cvflann_DynamicBitset"]
        [::std::mem::align_of::<cvflann_DynamicBitset>() - 8usize];
    ["Offset of field: cvflann_DynamicBitset::bitset_"]
        [::std::mem::offset_of!(cvflann_DynamicBitset, bitset_) - 0usize];
    ["Offset of field: cvflann_DynamicBitset::size_"]
        [::std::mem::offset_of!(cvflann_DynamicBitset, size_) - 24usize];
};
#[doc = " Priority Queue Implementation\n\n The priority queue is implemented with a heap.  A heap is a complete\n (full) binary tree in which each parent is less than both of its\n children, but the order of the children is unspecified."]
#[repr(C)]
pub struct cvflann_Heap {
    #[doc = " Storage array for the heap.\n Type T must be comparable."]
    pub heap: std_vector,
    pub length: ::std::os::raw::c_int,
    #[doc = " Number of element in the heap"]
    pub count: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_Heap_CompareT {
    pub _address: u8,
}
#[doc = " Pooled storage allocator\n\n The following routines allow for the efficient allocation of storage in\n small chunks from a specified pool.  Rather than allowing each structure\n to be freed individually, an entire pool of storage is freed at once.\n This method has two advantages over just using malloc() and free().  First,\n it is far more efficient for allocating small objects, as there is\n no overhead for remembering all the information needed to free each\n object or consolidating fragmented memory.  Second, the decision about\n how long to keep an object is made at the time of allocation, and there\n is no need to track down all the objects to free them.\n"]
pub const cvflann_WORDSIZE: usize = 16;
pub const cvflann_BLOCKSIZE: usize = 8192;
#[repr(C)]
#[derive(Debug)]
pub struct cvflann_PooledAllocator {
    pub remaining: ::std::os::raw::c_int,
    pub base: *mut ::std::os::raw::c_void,
    pub loc: *mut ::std::os::raw::c_void,
    pub blocksize: ::std::os::raw::c_int,
    pub usedMemory: ::std::os::raw::c_int,
    pub wastedMemory: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_PooledAllocator"][::std::mem::size_of::<cvflann_PooledAllocator>() - 40usize];
    ["Alignment of cvflann_PooledAllocator"]
        [::std::mem::align_of::<cvflann_PooledAllocator>() - 8usize];
    ["Offset of field: cvflann_PooledAllocator::remaining"]
        [::std::mem::offset_of!(cvflann_PooledAllocator, remaining) - 0usize];
    ["Offset of field: cvflann_PooledAllocator::base"]
        [::std::mem::offset_of!(cvflann_PooledAllocator, base) - 8usize];
    ["Offset of field: cvflann_PooledAllocator::loc"]
        [::std::mem::offset_of!(cvflann_PooledAllocator, loc) - 16usize];
    ["Offset of field: cvflann_PooledAllocator::blocksize"]
        [::std::mem::offset_of!(cvflann_PooledAllocator, blocksize) - 24usize];
    ["Offset of field: cvflann_PooledAllocator::usedMemory"]
        [::std::mem::offset_of!(cvflann_PooledAllocator, usedMemory) - 28usize];
    ["Offset of field: cvflann_PooledAllocator::wastedMemory"]
        [::std::mem::offset_of!(cvflann_PooledAllocator, wastedMemory) - 32usize];
};
#[doc = " Random number generator that returns a distinct number from\n the [0,n) interval each time."]
#[repr(C)]
pub struct cvflann_UniqueRandom {
    pub vals_: std_vector,
    pub size_: ::std::os::raw::c_int,
    pub counter_: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_UniqueRandom"][::std::mem::size_of::<cvflann_UniqueRandom>() - 32usize];
    ["Alignment of cvflann_UniqueRandom"][::std::mem::align_of::<cvflann_UniqueRandom>() - 8usize];
    ["Offset of field: cvflann_UniqueRandom::vals_"]
        [::std::mem::offset_of!(cvflann_UniqueRandom, vals_) - 0usize];
    ["Offset of field: cvflann_UniqueRandom::size_"]
        [::std::mem::offset_of!(cvflann_UniqueRandom, size_) - 24usize];
    ["Offset of field: cvflann_UniqueRandom::counter_"]
        [::std::mem::offset_of!(cvflann_UniqueRandom, counter_) - 28usize];
};
#[repr(C)]
pub struct cvflann_KDTreeIndexParams {
    pub _base: cvflann_IndexParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_KDTreeIndexParams"]
        [::std::mem::size_of::<cvflann_KDTreeIndexParams>() - 48usize];
    ["Alignment of cvflann_KDTreeIndexParams"]
        [::std::mem::align_of::<cvflann_KDTreeIndexParams>() - 8usize];
};
#[doc = " Randomized kd-tree index\n\n Contains the k-d trees and other information for indexing a set of points\n for nearest-neighbor matching."]
#[repr(C)]
pub struct cvflann_KDTreeIndex<Distance> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Distance>>,
    pub _base: cvflann_NNIndex,
    #[doc = " Number of randomized trees that are used"]
    pub trees_: ::std::os::raw::c_int,
    #[doc = "  Array of indices to vectors in the dataset."]
    pub vind_: std_vector,
    #[doc = " The dataset used by this index"]
    pub dataset_: cvflann_Matrix<cvflann_KDTreeIndex_ElementType>,
    pub index_params_: cvflann_IndexParams,
    pub size_: usize,
    pub veclen_: usize,
    pub mean_: *mut cvflann_KDTreeIndex_DistanceType,
    pub var_: *mut cvflann_KDTreeIndex_DistanceType,
    #[doc = " Array of k-d trees used to find neighbours."]
    pub tree_roots_: *mut cvflann_KDTreeIndex_NodePtr,
    #[doc = " Pooled memory allocator.\n\n Using a pooled memory allocator is more efficient\n than allocating memory directly when there is a large\n number small of memory allocations."]
    pub pool_: cvflann_PooledAllocator,
    pub distance_: Distance,
}
pub type cvflann_KDTreeIndex_ElementType = __BindgenOpaqueArray<u8, 0usize>;
pub type cvflann_KDTreeIndex_DistanceType = __BindgenOpaqueArray<u8, 0usize>;
#[repr(C)]
pub struct cvflann_KDTreeIndex_Node {
    #[doc = " Dimension used for subdivision."]
    pub divfeat: ::std::os::raw::c_int,
    #[doc = " The values used for subdivision."]
    pub divval: cvflann_KDTreeIndex_DistanceType,
    #[doc = " The child nodes."]
    pub child1: *mut cvflann_KDTreeIndex_Node,
    #[doc = " The child nodes."]
    pub child2: *mut cvflann_KDTreeIndex_Node,
}
pub type cvflann_KDTreeIndex_NodePtr = *mut cvflann_KDTreeIndex_Node;
pub type cvflann_KDTreeIndex_BranchSt =
    cvflann_BranchStruct<cvflann_KDTreeIndex_NodePtr, cvflann_KDTreeIndex_DistanceType>;
pub type cvflann_KDTreeIndex_Branch = *mut cvflann_KDTreeIndex_BranchSt;
#[doc = " To improve efficiency, only SAMPLE_MEAN random values are used to\n compute the mean and variance at each level when building a tree.\n A value of 100 seems to perform as well as using all values."]
pub const cvflann_KDTreeIndex_SAMPLE_MEAN: cvflann_KDTreeIndex__bindgen_ty_1 = 0;
#[doc = " Top random dimensions to consider\n\n When creating random trees, the dimension on which to subdivide is\n selected at random from among the top RAND_DIM dimensions with the\n highest variance.  A value of 5 works well."]
pub const cvflann_KDTreeIndex_RAND_DIM: cvflann_KDTreeIndex__bindgen_ty_1 = 0;
pub type cvflann_KDTreeIndex__bindgen_ty_1 = i32;
#[repr(C)]
pub struct cvflann_KDTreeSingleIndexParams {
    pub _base: cvflann_IndexParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_KDTreeSingleIndexParams"]
        [::std::mem::size_of::<cvflann_KDTreeSingleIndexParams>() - 48usize];
    ["Alignment of cvflann_KDTreeSingleIndexParams"]
        [::std::mem::align_of::<cvflann_KDTreeSingleIndexParams>() - 8usize];
};
#[doc = " Randomized kd-tree index\n\n Contains the k-d trees and other information for indexing a set of points\n for nearest-neighbor matching."]
#[repr(C)]
pub struct cvflann_KDTreeSingleIndex<Distance> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Distance>>,
    pub _base: cvflann_NNIndex,
    #[doc = " The dataset used by this index"]
    pub dataset_: cvflann_Matrix<cvflann_KDTreeSingleIndex_ElementType>,
    pub index_params_: cvflann_IndexParams,
    pub leaf_max_size_: ::std::os::raw::c_int,
    pub reorder_: bool,
    #[doc = "  Array of indices to vectors in the dataset."]
    pub vind_: std_vector,
    pub data_: cvflann_Matrix<cvflann_KDTreeSingleIndex_ElementType>,
    pub size_: usize,
    pub dim_: usize,
    #[doc = " Array of k-d trees used to find neighbours."]
    pub root_node_: cvflann_KDTreeSingleIndex_NodePtr,
    pub root_bbox_: cvflann_KDTreeSingleIndex_BoundingBox,
    #[doc = " Pooled memory allocator.\n\n Using a pooled memory allocator is more efficient\n than allocating memory directly when there is a large\n number small of memory allocations."]
    pub pool_: cvflann_PooledAllocator,
    pub distance_: Distance,
}
pub type cvflann_KDTreeSingleIndex_ElementType = __BindgenOpaqueArray<u8, 0usize>;
pub type cvflann_KDTreeSingleIndex_DistanceType = __BindgenOpaqueArray<u8, 0usize>;
#[repr(C)]
pub struct cvflann_KDTreeSingleIndex_Node {
    #[doc = " Indices of points in leaf node"]
    pub left: ::std::os::raw::c_int,
    #[doc = " Indices of points in leaf node"]
    pub right: ::std::os::raw::c_int,
    #[doc = " Dimension used for subdivision."]
    pub divfeat: ::std::os::raw::c_int,
    #[doc = " The values used for subdivision."]
    pub divlow: cvflann_KDTreeSingleIndex_DistanceType,
    #[doc = " The values used for subdivision."]
    pub divhigh: cvflann_KDTreeSingleIndex_DistanceType,
    #[doc = " The child nodes."]
    pub child1: *mut cvflann_KDTreeSingleIndex_Node,
    #[doc = " The child nodes."]
    pub child2: *mut cvflann_KDTreeSingleIndex_Node,
}
pub type cvflann_KDTreeSingleIndex_NodePtr = *mut cvflann_KDTreeSingleIndex_Node;
#[repr(C)]
pub struct cvflann_KDTreeSingleIndex_Interval {
    pub low: cvflann_KDTreeSingleIndex_DistanceType,
    pub high: cvflann_KDTreeSingleIndex_DistanceType,
}
pub type cvflann_KDTreeSingleIndex_BoundingBox = std_vector;
pub type cvflann_KDTreeSingleIndex_BranchSt =
    cvflann_BranchStruct<cvflann_KDTreeSingleIndex_NodePtr, cvflann_KDTreeSingleIndex_DistanceType>;
pub type cvflann_KDTreeSingleIndex_Branch = *mut cvflann_KDTreeSingleIndex_BranchSt;
#[repr(C)]
#[derive(Debug)]
pub struct cvflann_Logger {
    pub stream: *mut FILE,
    pub logLevel: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_Logger"][::std::mem::size_of::<cvflann_Logger>() - 16usize];
    ["Alignment of cvflann_Logger"][::std::mem::align_of::<cvflann_Logger>() - 8usize];
    ["Offset of field: cvflann_Logger::stream"]
        [::std::mem::offset_of!(cvflann_Logger, stream) - 0usize];
    ["Offset of field: cvflann_Logger::logLevel"]
        [::std::mem::offset_of!(cvflann_Logger, logLevel) - 8usize];
};
#[repr(C)]
pub struct cvflann_KMeansIndexParams {
    pub _base: cvflann_IndexParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_KMeansIndexParams"]
        [::std::mem::size_of::<cvflann_KMeansIndexParams>() - 48usize];
    ["Alignment of cvflann_KMeansIndexParams"]
        [::std::mem::align_of::<cvflann_KMeansIndexParams>() - 8usize];
};
#[doc = " Hierarchical kmeans index\n\n Contains a tree constructed through a hierarchical kmeans clustering\n and other information for indexing a set of points for nearest-neighbour matching."]
#[repr(C)]
pub struct cvflann_KMeansIndex<Distance> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Distance>>,
    pub _base: cvflann_NNIndex,
    #[doc = " The function used for choosing the cluster centers."]
    pub chooseCenters: cvflann_KMeansIndex_centersAlgFunction,
    #[doc = " The branching factor used in the hierarchical k-means clustering"]
    pub branching_: ::std::os::raw::c_int,
    #[doc = " Maximum number of iterations to use when performing k-means clustering"]
    pub iterations_: ::std::os::raw::c_int,
    #[doc = " Algorithm for choosing the cluster centers"]
    pub centers_init_: cvflann_flann_centers_init_t,
    #[doc = " Cluster border index. This is used in the tree search phase when determining\n the closest cluster to explore next. A zero value takes into account only\n the cluster centres, a value greater then zero also take into account the size\n of the cluster."]
    pub cb_index_: f32,
    #[doc = " The dataset used by this index"]
    pub dataset_: cvflann_Matrix<cvflann_KMeansIndex_ElementType>,
    #[doc = " Index parameters"]
    pub index_params_: cvflann_IndexParams,
    #[doc = " Number of features in the dataset."]
    pub size_: usize,
    #[doc = " Length of each feature."]
    pub veclen_: usize,
    #[doc = " The root node in the tree."]
    pub root_: cvflann_KMeansIndex_KMeansNodePtr,
    #[doc = "  Array of indices to vectors in the dataset."]
    pub indices_: *mut ::std::os::raw::c_int,
    #[doc = " The distance"]
    pub distance_: Distance,
    #[doc = " Pooled memory allocator."]
    pub pool_: cvflann_PooledAllocator,
    #[doc = " Memory occupied by the index."]
    pub memoryCounter_: ::std::os::raw::c_int,
}
pub type cvflann_KMeansIndex_ElementType = __BindgenOpaqueArray<u8, 0usize>;
pub type cvflann_KMeansIndex_DistanceType = __BindgenOpaqueArray<u8, 0usize>;
pub type cvflann_KMeansIndex_centersAlgFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug)]
pub struct cvflann_KMeansIndex_KMeansDistanceComputer<Distance> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Distance>>,
    pub _base: cv_ParallelLoopBody,
    pub distance: Distance,
    pub dataset: *const __BindgenOpaqueArray<u8, 0usize>,
    pub branching: ::std::os::raw::c_int,
    pub indices: *const ::std::os::raw::c_int,
    pub dcenters: *const cvflann_Matrix<f64>,
    pub veclen: usize,
    pub new_centroids: *mut std_vector,
    pub sq_dists: *mut std_vector,
}
#[doc = " Structure representing a node in the hierarchical k-means tree."]
#[repr(C)]
pub struct cvflann_KMeansIndex_KMeansNode {
    #[doc = " The cluster center."]
    pub pivot: *mut cvflann_KMeansIndex_DistanceType,
    #[doc = " The cluster radius."]
    pub radius: cvflann_KMeansIndex_DistanceType,
    #[doc = " The cluster mean radius."]
    pub mean_radius: cvflann_KMeansIndex_DistanceType,
    #[doc = " The cluster variance."]
    pub variance: cvflann_KMeansIndex_DistanceType,
    #[doc = " The cluster size (number of points in the cluster)"]
    pub size: ::std::os::raw::c_int,
    #[doc = " Child nodes (only for non-terminal nodes)"]
    pub childs: *mut *mut cvflann_KMeansIndex_KMeansNode,
    #[doc = " Node points (only for terminal nodes)"]
    pub indices: *mut ::std::os::raw::c_int,
    #[doc = " Level"]
    pub level: ::std::os::raw::c_int,
}
pub type cvflann_KMeansIndex_KMeansNodePtr = *mut cvflann_KMeansIndex_KMeansNode;
#[doc = " Alias definition for a nicer syntax."]
pub type cvflann_KMeansIndex_BranchSt =
    cvflann_BranchStruct<cvflann_KMeansIndex_KMeansNodePtr, cvflann_KMeansIndex_DistanceType>;
#[doc = " Index parameters for the CompositeIndex."]
#[repr(C)]
pub struct cvflann_CompositeIndexParams {
    pub _base: cvflann_IndexParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_CompositeIndexParams"]
        [::std::mem::size_of::<cvflann_CompositeIndexParams>() - 48usize];
    ["Alignment of cvflann_CompositeIndexParams"]
        [::std::mem::align_of::<cvflann_CompositeIndexParams>() - 8usize];
};
#[doc = " This index builds a kd-tree index and a k-means index and performs nearest\n neighbour search both indexes. This gives a slight boost in search performance\n as some of the neighbours that are missed by one index are found by the other."]
#[repr(C)]
pub struct cvflann_CompositeIndex<Distance> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Distance>>,
    pub _base: cvflann_NNIndex,
    #[doc = " The k-means index"]
    pub kmeans_index_: *mut cvflann_KMeansIndex<Distance>,
    #[doc = " The kd-tree index"]
    pub kdtree_index_: *mut cvflann_KDTreeIndex<Distance>,
    #[doc = " The index parameters"]
    pub index_params_: cvflann_IndexParams,
}
pub type cvflann_CompositeIndex_ElementType = __BindgenOpaqueArray<u8, 0usize>;
pub type cvflann_CompositeIndex_DistanceType = __BindgenOpaqueArray<u8, 0usize>;
#[repr(C)]
pub struct cvflann_LinearIndexParams {
    pub _base: cvflann_IndexParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_LinearIndexParams"]
        [::std::mem::size_of::<cvflann_LinearIndexParams>() - 48usize];
    ["Alignment of cvflann_LinearIndexParams"]
        [::std::mem::align_of::<cvflann_LinearIndexParams>() - 8usize];
};
#[repr(C)]
pub struct cvflann_LinearIndex<Distance> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Distance>>,
    pub _base: cvflann_NNIndex,
    #[doc = " The dataset"]
    pub dataset_: cvflann_Matrix<cvflann_LinearIndex_ElementType>,
    #[doc = " Index parameters"]
    pub index_params_: cvflann_IndexParams,
    #[doc = " Index distance"]
    pub distance_: Distance,
}
pub type cvflann_LinearIndex_ElementType = __BindgenOpaqueArray<u8, 0usize>;
pub type cvflann_LinearIndex_DistanceType = __BindgenOpaqueArray<u8, 0usize>;
#[repr(C)]
pub struct cvflann_HierarchicalClusteringIndexParams {
    pub _base: cvflann_IndexParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_HierarchicalClusteringIndexParams"]
        [::std::mem::size_of::<cvflann_HierarchicalClusteringIndexParams>() - 48usize];
    ["Alignment of cvflann_HierarchicalClusteringIndexParams"]
        [::std::mem::align_of::<cvflann_HierarchicalClusteringIndexParams>() - 8usize];
};
#[doc = " Hierarchical index\n\n Contains a tree constructed through a hierarchical clustering\n and other information for indexing a set of points for nearest-neighbour matching."]
#[repr(C)]
pub struct cvflann_HierarchicalClusteringIndex<Distance> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Distance>>,
    pub _base: cvflann_NNIndex,
    #[doc = " The function used for choosing the cluster centers."]
    pub chooseCenters: cvflann_HierarchicalClusteringIndex_centersAlgFunction,
    #[doc = " The dataset used by this index"]
    pub dataset: cvflann_Matrix<cvflann_HierarchicalClusteringIndex_ElementType>,
    #[doc = " Parameters used by this index"]
    pub params: cvflann_IndexParams,
    #[doc = " Number of features in the dataset."]
    pub size_: usize,
    #[doc = " Length of each feature."]
    pub veclen_: usize,
    #[doc = " The root node in the tree."]
    pub root: *mut cvflann_HierarchicalClusteringIndex_NodePtr,
    #[doc = "  Array of indices to vectors in the dataset."]
    pub indices: *mut *mut ::std::os::raw::c_int,
    #[doc = " The distance"]
    pub distance: Distance,
    #[doc = " Pooled memory allocator.\n\n Using a pooled memory allocator is more efficient\n than allocating memory directly when there is a large\n number small of memory allocations."]
    pub pool: cvflann_PooledAllocator,
    #[doc = " Memory occupied by the index."]
    pub memoryCounter: ::std::os::raw::c_int,
    #[doc = " index parameters"]
    pub branching_: ::std::os::raw::c_int,
    pub trees_: ::std::os::raw::c_int,
    pub centers_init_: cvflann_flann_centers_init_t,
    pub leaf_size_: ::std::os::raw::c_int,
}
pub type cvflann_HierarchicalClusteringIndex_ElementType = __BindgenOpaqueArray<u8, 0usize>;
pub type cvflann_HierarchicalClusteringIndex_DistanceType = __BindgenOpaqueArray<u8, 0usize>;
pub type cvflann_HierarchicalClusteringIndex_centersAlgFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
    ),
>;
#[doc = " Structure representing a node in the hierarchical k-means tree."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_HierarchicalClusteringIndex_Node {
    #[doc = " The cluster center index"]
    pub pivot: ::std::os::raw::c_int,
    #[doc = " The cluster size (number of points in the cluster)"]
    pub size: ::std::os::raw::c_int,
    #[doc = " Child nodes (only for non-terminal nodes)"]
    pub childs: *mut *mut cvflann_HierarchicalClusteringIndex_Node,
    #[doc = " Node points (only for terminal nodes)"]
    pub indices: *mut ::std::os::raw::c_int,
    #[doc = " Level"]
    pub level: ::std::os::raw::c_int,
}
pub type cvflann_HierarchicalClusteringIndex_NodePtr =
    *mut cvflann_HierarchicalClusteringIndex_Node;
#[doc = " Alias definition for a nicer syntax."]
pub type cvflann_HierarchicalClusteringIndex_BranchSt = cvflann_BranchStruct<
    cvflann_HierarchicalClusteringIndex_NodePtr,
    cvflann_HierarchicalClusteringIndex_DistanceType,
>;
#[doc = " What is stored in an LSH bucket"]
pub type cvflann_lsh_FeatureIndex = u32;
#[doc = " The id from which we can get a bucket back in an LSH table"]
pub type cvflann_lsh_BucketKey = ::std::os::raw::c_uint;
#[doc = " A bucket in an LSH table"]
pub type cvflann_lsh_Bucket = std_vector;
#[doc = " POD for stats about an LSH table"]
#[repr(C)]
pub struct cvflann_lsh_LshStats {
    pub bucket_sizes_: std_vector,
    pub n_buckets_: usize,
    pub bucket_size_mean_: usize,
    pub bucket_size_median_: usize,
    pub bucket_size_min_: usize,
    pub bucket_size_max_: usize,
    pub bucket_size_std_dev: usize,
    #[doc = " Each contained vector contains three value: beginning/end for interval, number of elements in the bin"]
    pub size_histogram_: std_vector,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_lsh_LshStats"][::std::mem::size_of::<cvflann_lsh_LshStats>() - 96usize];
    ["Alignment of cvflann_lsh_LshStats"][::std::mem::align_of::<cvflann_lsh_LshStats>() - 8usize];
    ["Offset of field: cvflann_lsh_LshStats::bucket_sizes_"]
        [::std::mem::offset_of!(cvflann_lsh_LshStats, bucket_sizes_) - 0usize];
    ["Offset of field: cvflann_lsh_LshStats::n_buckets_"]
        [::std::mem::offset_of!(cvflann_lsh_LshStats, n_buckets_) - 24usize];
    ["Offset of field: cvflann_lsh_LshStats::bucket_size_mean_"]
        [::std::mem::offset_of!(cvflann_lsh_LshStats, bucket_size_mean_) - 32usize];
    ["Offset of field: cvflann_lsh_LshStats::bucket_size_median_"]
        [::std::mem::offset_of!(cvflann_lsh_LshStats, bucket_size_median_) - 40usize];
    ["Offset of field: cvflann_lsh_LshStats::bucket_size_min_"]
        [::std::mem::offset_of!(cvflann_lsh_LshStats, bucket_size_min_) - 48usize];
    ["Offset of field: cvflann_lsh_LshStats::bucket_size_max_"]
        [::std::mem::offset_of!(cvflann_lsh_LshStats, bucket_size_max_) - 56usize];
    ["Offset of field: cvflann_lsh_LshStats::bucket_size_std_dev"]
        [::std::mem::offset_of!(cvflann_lsh_LshStats, bucket_size_std_dev) - 64usize];
    ["Offset of field: cvflann_lsh_LshStats::size_histogram_"]
        [::std::mem::offset_of!(cvflann_lsh_LshStats, size_histogram_) - 72usize];
};
#[doc = " Lsh hash table. As its key is a sub-feature, and as usually\n the size of it is pretty small, we keep it as a continuous memory array.\n The value is an index in the corpus of features (we keep it as an unsigned\n int for pure memory reasons, it could be a size_t)"]
#[repr(C)]
pub struct cvflann_lsh_LshTable {
    #[doc = " The vector of all the buckets if they are held for speed"]
    pub buckets_speed_: cvflann_lsh_LshTable_BucketsSpeed,
    #[doc = " The hash table of all the buckets in case we cannot use the speed version"]
    pub buckets_space_: cvflann_lsh_LshTable_BucketsSpace,
    #[doc = " What is used to store the data"]
    pub speed_level_: cvflann_lsh_LshTable_SpeedLevel,
    #[doc = " If the subkey is small enough, it will keep track of which subkeys are set through that bitset\n That is just a speedup so that we don't look in the hash table (which can be mush slower that checking a bitset)"]
    pub key_bitset_: cvflann_DynamicBitset,
    #[doc = " The size of the sub-signature in bits"]
    pub key_size_: ::std::os::raw::c_uint,
    pub feature_size_: ::std::os::raw::c_uint,
    #[doc = " The mask to apply to a feature to get the hash key\n Only used in the unsigned char case"]
    pub mask_: std_vector,
}
pub type cvflann_lsh_LshTable_BucketsSpace = std_unordered_map;
#[doc = " A container of all the feature indices. Optimized for speed"]
pub type cvflann_lsh_LshTable_BucketsSpeed = std_vector;
pub const cvflann_lsh_LshTable_SpeedLevel_kArray: cvflann_lsh_LshTable_SpeedLevel = 0;
pub const cvflann_lsh_LshTable_SpeedLevel_kBitsetHash: cvflann_lsh_LshTable_SpeedLevel = 0;
pub const cvflann_lsh_LshTable_SpeedLevel_kHash: cvflann_lsh_LshTable_SpeedLevel = 0;
#[doc = " defines the speed fo the implementation\n kArray uses a vector for storing data\n kBitsetHash uses a hash map but checks for the validity of a key with a bitset\n kHash uses a hash map only"]
pub type cvflann_lsh_LshTable_SpeedLevel = i32;
#[repr(C)]
pub struct cvflann_LshIndexParams {
    pub _base: cvflann_IndexParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_LshIndexParams"][::std::mem::size_of::<cvflann_LshIndexParams>() - 48usize];
    ["Alignment of cvflann_LshIndexParams"]
        [::std::mem::align_of::<cvflann_LshIndexParams>() - 8usize];
};
#[doc = " Randomized kd-tree index\n\n Contains the k-d trees and other information for indexing a set of points\n for nearest-neighbor matching."]
#[repr(C)]
pub struct cvflann_LshIndex<Distance> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Distance>>,
    pub _base: cvflann_NNIndex,
    #[doc = " The different hash tables"]
    pub tables_: std_vector,
    #[doc = " The data the LSH tables where built from"]
    pub dataset_: cvflann_Matrix<cvflann_LshIndex_ElementType>,
    #[doc = " The size of the features (as ElementType[])"]
    pub feature_size_: ::std::os::raw::c_uint,
    pub index_params_: cvflann_IndexParams,
    #[doc = " table number"]
    pub table_number_: ::std::os::raw::c_uint,
    #[doc = " key size"]
    pub key_size_: ::std::os::raw::c_uint,
    #[doc = " How far should we look for neighbors in multi-probe LSH"]
    pub multi_probe_level_: ::std::os::raw::c_uint,
    #[doc = " The XOR masks to apply to a key to get the neighboring buckets"]
    pub xor_masks_: std_vector,
    pub distance_: Distance,
}
pub type cvflann_LshIndex_ElementType = __BindgenOpaqueArray<u8, 0usize>;
pub type cvflann_LshIndex_DistanceType = __BindgenOpaqueArray<u8, 0usize>;
#[doc = " Defines the comparator on score and index"]
pub type cvflann_LshIndex_ScoreIndexPair = std_pair<f32, ::std::os::raw::c_uint>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_LshIndex_SortScoreIndexPairOnSecond {
    pub _address: u8,
}
#[doc = " A start-stop timer class.\n\n Can be used to time portions of code."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_StartStopTimer {
    pub startTime: int64,
    #[doc = " Value of the timer."]
    pub value: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_StartStopTimer"][::std::mem::size_of::<cvflann_StartStopTimer>() - 16usize];
    ["Alignment of cvflann_StartStopTimer"]
        [::std::mem::align_of::<cvflann_StartStopTimer>() - 8usize];
    ["Offset of field: cvflann_StartStopTimer::startTime"]
        [::std::mem::offset_of!(cvflann_StartStopTimer, startTime) - 0usize];
    ["Offset of field: cvflann_StartStopTimer::value"]
        [::std::mem::offset_of!(cvflann_StartStopTimer, value) - 8usize];
};
#[repr(C)]
pub struct cvflann_AutotunedIndexParams {
    pub _base: cvflann_IndexParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_AutotunedIndexParams"]
        [::std::mem::size_of::<cvflann_AutotunedIndexParams>() - 48usize];
    ["Alignment of cvflann_AutotunedIndexParams"]
        [::std::mem::align_of::<cvflann_AutotunedIndexParams>() - 8usize];
};
#[repr(C)]
pub struct cvflann_AutotunedIndex<Distance> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Distance>>,
    pub _base: cvflann_NNIndex,
    pub bestIndex_: *mut cvflann_NNIndex,
    pub bestParams_: cvflann_IndexParams,
    pub bestSearchParams_: cvflann_SearchParams,
    pub sampledDataset_: cvflann_Matrix<cvflann_AutotunedIndex_ElementType>,
    pub testDataset_: cvflann_Matrix<cvflann_AutotunedIndex_ElementType>,
    pub gt_matches_: cvflann_Matrix<::std::os::raw::c_int>,
    pub speedup_: f32,
    #[doc = " The dataset used by this index"]
    pub dataset_: cvflann_Matrix<cvflann_AutotunedIndex_ElementType>,
    #[doc = " Index parameters"]
    pub target_precision_: f32,
    pub build_weight_: f32,
    pub memory_weight_: f32,
    pub sample_fraction_: f32,
    pub distance_: Distance,
}
pub type cvflann_AutotunedIndex_ElementType = __BindgenOpaqueArray<u8, 0usize>;
pub type cvflann_AutotunedIndex_DistanceType = __BindgenOpaqueArray<u8, 0usize>;
#[repr(C)]
pub struct cvflann_AutotunedIndex_CostData {
    pub searchTimeCost: f32,
    pub buildTimeCost: f32,
    pub memoryCost: f32,
    pub totalCost: f32,
    pub params: cvflann_IndexParams,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvflann_index_creator {
    pub _address: u8,
}
#[doc = " (Deprecated) Index parameters for creating a saved index."]
#[repr(C)]
pub struct cvflann_SavedIndexParams {
    pub _base: cvflann_IndexParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvflann_SavedIndexParams"]
        [::std::mem::size_of::<cvflann_SavedIndexParams>() - 48usize];
    ["Alignment of cvflann_SavedIndexParams"]
        [::std::mem::align_of::<cvflann_SavedIndexParams>() - 8usize];
};
#[repr(C)]
pub struct cvflann_Index {
    pub _base: cvflann_NNIndex,
    #[doc = " Pointer to actual index class"]
    pub nnIndex_: *mut cvflann_NNIndex,
    #[doc = " Indices if the index was loaded from a file"]
    pub loaded_: bool,
    #[doc = " Parameters passed to the index"]
    pub index_params_: cvflann_IndexParams,
}
pub type cvflann_Index_ElementType = __BindgenOpaqueArray<u8, 0usize>;
pub type cvflann_Index_DistanceType = __BindgenOpaqueArray<u8, 0usize>;
unsafe extern "C" {
    #[link_name = "\u{1}_ZN7cvflann19flann_distance_typeEv"]
    pub fn cvflann_flann_distance_type() -> cvflann_flann_distance_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN7cvflann17set_distance_typeENS_16flann_distance_tEi"]
    pub fn cvflann_set_distance_type(
        distance_type: cvflann_flann_distance_t,
        order: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn gettext(__msgid: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn dgettext(
        __domainname: *const ::std::os::raw::c_char,
        __msgid: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __dgettext(
        __domainname: *const ::std::os::raw::c_char,
        __msgid: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn dcgettext(
        __domainname: *const ::std::os::raw::c_char,
        __msgid: *const ::std::os::raw::c_char,
        __category: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __dcgettext(
        __domainname: *const ::std::os::raw::c_char,
        __msgid: *const ::std::os::raw::c_char,
        __category: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ngettext(
        __msgid1: *const ::std::os::raw::c_char,
        __msgid2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn dngettext(
        __domainname: *const ::std::os::raw::c_char,
        __msgid1: *const ::std::os::raw::c_char,
        __msgid2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn dcngettext(
        __domainname: *const ::std::os::raw::c_char,
        __msgid1: *const ::std::os::raw::c_char,
        __msgid2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
        __category: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn textdomain(__domainname: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bindtextdomain(
        __domainname: *const ::std::os::raw::c_char,
        __dirname: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bind_textdomain_codeset(
        __domainname: *const ::std::os::raw::c_char,
        __codeset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvCapture {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvVideoWriter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvHaarClassifierCascade {
    _unused: [u8; 0],
}
pub type rknn_context = u64;
pub const _rknn_query_cmd_RKNN_QUERY_IN_OUT_NUM: _rknn_query_cmd = 0;
pub const _rknn_query_cmd_RKNN_QUERY_INPUT_ATTR: _rknn_query_cmd = 1;
pub const _rknn_query_cmd_RKNN_QUERY_OUTPUT_ATTR: _rknn_query_cmd = 2;
pub const _rknn_query_cmd_RKNN_QUERY_PERF_DETAIL: _rknn_query_cmd = 3;
pub const _rknn_query_cmd_RKNN_QUERY_PERF_RUN: _rknn_query_cmd = 4;
pub const _rknn_query_cmd_RKNN_QUERY_SDK_VERSION: _rknn_query_cmd = 5;
pub const _rknn_query_cmd_RKNN_QUERY_MEM_SIZE: _rknn_query_cmd = 6;
pub const _rknn_query_cmd_RKNN_QUERY_CUSTOM_STRING: _rknn_query_cmd = 7;
pub const _rknn_query_cmd_RKNN_QUERY_NATIVE_INPUT_ATTR: _rknn_query_cmd = 8;
pub const _rknn_query_cmd_RKNN_QUERY_NATIVE_OUTPUT_ATTR: _rknn_query_cmd = 9;
pub const _rknn_query_cmd_RKNN_QUERY_NATIVE_NC1HWC2_INPUT_ATTR: _rknn_query_cmd = 8;
pub const _rknn_query_cmd_RKNN_QUERY_NATIVE_NC1HWC2_OUTPUT_ATTR: _rknn_query_cmd = 9;
pub const _rknn_query_cmd_RKNN_QUERY_NATIVE_NHWC_INPUT_ATTR: _rknn_query_cmd = 10;
pub const _rknn_query_cmd_RKNN_QUERY_NATIVE_NHWC_OUTPUT_ATTR: _rknn_query_cmd = 11;
pub const _rknn_query_cmd_RKNN_QUERY_DEVICE_MEM_INFO: _rknn_query_cmd = 12;
pub const _rknn_query_cmd_RKNN_QUERY_INPUT_DYNAMIC_RANGE: _rknn_query_cmd = 13;
pub const _rknn_query_cmd_RKNN_QUERY_CURRENT_INPUT_ATTR: _rknn_query_cmd = 14;
pub const _rknn_query_cmd_RKNN_QUERY_CURRENT_OUTPUT_ATTR: _rknn_query_cmd = 15;
pub const _rknn_query_cmd_RKNN_QUERY_CURRENT_NATIVE_INPUT_ATTR: _rknn_query_cmd = 16;
pub const _rknn_query_cmd_RKNN_QUERY_CURRENT_NATIVE_OUTPUT_ATTR: _rknn_query_cmd = 17;
pub const _rknn_query_cmd_RKNN_QUERY_CMD_MAX: _rknn_query_cmd = 18;
pub type _rknn_query_cmd = ::std::os::raw::c_uint;
pub use self::_rknn_query_cmd as rknn_query_cmd;
pub const _rknn_tensor_type_RKNN_TENSOR_FLOAT32: _rknn_tensor_type = 0;
pub const _rknn_tensor_type_RKNN_TENSOR_FLOAT16: _rknn_tensor_type = 1;
pub const _rknn_tensor_type_RKNN_TENSOR_INT8: _rknn_tensor_type = 2;
pub const _rknn_tensor_type_RKNN_TENSOR_UINT8: _rknn_tensor_type = 3;
pub const _rknn_tensor_type_RKNN_TENSOR_INT16: _rknn_tensor_type = 4;
pub const _rknn_tensor_type_RKNN_TENSOR_UINT16: _rknn_tensor_type = 5;
pub const _rknn_tensor_type_RKNN_TENSOR_INT32: _rknn_tensor_type = 6;
pub const _rknn_tensor_type_RKNN_TENSOR_UINT32: _rknn_tensor_type = 7;
pub const _rknn_tensor_type_RKNN_TENSOR_INT64: _rknn_tensor_type = 8;
pub const _rknn_tensor_type_RKNN_TENSOR_BOOL: _rknn_tensor_type = 9;
pub const _rknn_tensor_type_RKNN_TENSOR_INT4: _rknn_tensor_type = 10;
pub const _rknn_tensor_type_RKNN_TENSOR_BFLOAT16: _rknn_tensor_type = 11;
pub const _rknn_tensor_type_RKNN_TENSOR_TYPE_MAX: _rknn_tensor_type = 12;
pub type _rknn_tensor_type = ::std::os::raw::c_uint;
pub use self::_rknn_tensor_type as rknn_tensor_type;
pub const _rknn_tensor_qnt_type_RKNN_TENSOR_QNT_NONE: _rknn_tensor_qnt_type = 0;
pub const _rknn_tensor_qnt_type_RKNN_TENSOR_QNT_DFP: _rknn_tensor_qnt_type = 1;
pub const _rknn_tensor_qnt_type_RKNN_TENSOR_QNT_AFFINE_ASYMMETRIC: _rknn_tensor_qnt_type = 2;
pub const _rknn_tensor_qnt_type_RKNN_TENSOR_QNT_MAX: _rknn_tensor_qnt_type = 3;
pub type _rknn_tensor_qnt_type = ::std::os::raw::c_uint;
pub use self::_rknn_tensor_qnt_type as rknn_tensor_qnt_type;
pub const _rknn_tensor_format_RKNN_TENSOR_NCHW: _rknn_tensor_format = 0;
pub const _rknn_tensor_format_RKNN_TENSOR_NHWC: _rknn_tensor_format = 1;
pub const _rknn_tensor_format_RKNN_TENSOR_NC1HWC2: _rknn_tensor_format = 2;
pub const _rknn_tensor_format_RKNN_TENSOR_UNDEFINED: _rknn_tensor_format = 3;
pub const _rknn_tensor_format_RKNN_TENSOR_FORMAT_MAX: _rknn_tensor_format = 4;
pub type _rknn_tensor_format = ::std::os::raw::c_uint;
pub use self::_rknn_tensor_format as rknn_tensor_format;
pub const _rknn_core_mask_RKNN_NPU_CORE_AUTO: _rknn_core_mask = 0;
pub const _rknn_core_mask_RKNN_NPU_CORE_0: _rknn_core_mask = 1;
pub const _rknn_core_mask_RKNN_NPU_CORE_1: _rknn_core_mask = 2;
pub const _rknn_core_mask_RKNN_NPU_CORE_2: _rknn_core_mask = 4;
pub const _rknn_core_mask_RKNN_NPU_CORE_0_1: _rknn_core_mask = 3;
pub const _rknn_core_mask_RKNN_NPU_CORE_0_1_2: _rknn_core_mask = 7;
pub const _rknn_core_mask_RKNN_NPU_CORE_ALL: _rknn_core_mask = 65535;
pub const _rknn_core_mask_RKNN_NPU_CORE_UNDEFINED: _rknn_core_mask = 65536;
pub type _rknn_core_mask = ::std::os::raw::c_uint;
pub use self::_rknn_core_mask as rknn_core_mask;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rknn_input_output_num {
    pub n_input: u32,
    pub n_output: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _rknn_input_output_num"][::std::mem::size_of::<_rknn_input_output_num>() - 8usize];
    ["Alignment of _rknn_input_output_num"]
        [::std::mem::align_of::<_rknn_input_output_num>() - 4usize];
    ["Offset of field: _rknn_input_output_num::n_input"]
        [::std::mem::offset_of!(_rknn_input_output_num, n_input) - 0usize];
    ["Offset of field: _rknn_input_output_num::n_output"]
        [::std::mem::offset_of!(_rknn_input_output_num, n_output) - 4usize];
};
pub type rknn_input_output_num = _rknn_input_output_num;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rknn_tensor_attr {
    pub index: u32,
    pub n_dims: u32,
    pub dims: [u32; 16usize],
    pub name: [::std::os::raw::c_char; 256usize],
    pub n_elems: u32,
    pub size: u32,
    pub fmt: rknn_tensor_format,
    pub type_: rknn_tensor_type,
    pub qnt_type: rknn_tensor_qnt_type,
    pub fl: i8,
    pub zp: i32,
    pub scale: f32,
    pub w_stride: u32,
    pub size_with_stride: u32,
    pub pass_through: u8,
    pub h_stride: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _rknn_tensor_attr"][::std::mem::size_of::<_rknn_tensor_attr>() - 376usize];
    ["Alignment of _rknn_tensor_attr"][::std::mem::align_of::<_rknn_tensor_attr>() - 4usize];
    ["Offset of field: _rknn_tensor_attr::index"]
        [::std::mem::offset_of!(_rknn_tensor_attr, index) - 0usize];
    ["Offset of field: _rknn_tensor_attr::n_dims"]
        [::std::mem::offset_of!(_rknn_tensor_attr, n_dims) - 4usize];
    ["Offset of field: _rknn_tensor_attr::dims"]
        [::std::mem::offset_of!(_rknn_tensor_attr, dims) - 8usize];
    ["Offset of field: _rknn_tensor_attr::name"]
        [::std::mem::offset_of!(_rknn_tensor_attr, name) - 72usize];
    ["Offset of field: _rknn_tensor_attr::n_elems"]
        [::std::mem::offset_of!(_rknn_tensor_attr, n_elems) - 328usize];
    ["Offset of field: _rknn_tensor_attr::size"]
        [::std::mem::offset_of!(_rknn_tensor_attr, size) - 332usize];
    ["Offset of field: _rknn_tensor_attr::fmt"]
        [::std::mem::offset_of!(_rknn_tensor_attr, fmt) - 336usize];
    ["Offset of field: _rknn_tensor_attr::type_"]
        [::std::mem::offset_of!(_rknn_tensor_attr, type_) - 340usize];
    ["Offset of field: _rknn_tensor_attr::qnt_type"]
        [::std::mem::offset_of!(_rknn_tensor_attr, qnt_type) - 344usize];
    ["Offset of field: _rknn_tensor_attr::fl"]
        [::std::mem::offset_of!(_rknn_tensor_attr, fl) - 348usize];
    ["Offset of field: _rknn_tensor_attr::zp"]
        [::std::mem::offset_of!(_rknn_tensor_attr, zp) - 352usize];
    ["Offset of field: _rknn_tensor_attr::scale"]
        [::std::mem::offset_of!(_rknn_tensor_attr, scale) - 356usize];
    ["Offset of field: _rknn_tensor_attr::w_stride"]
        [::std::mem::offset_of!(_rknn_tensor_attr, w_stride) - 360usize];
    ["Offset of field: _rknn_tensor_attr::size_with_stride"]
        [::std::mem::offset_of!(_rknn_tensor_attr, size_with_stride) - 364usize];
    ["Offset of field: _rknn_tensor_attr::pass_through"]
        [::std::mem::offset_of!(_rknn_tensor_attr, pass_through) - 368usize];
    ["Offset of field: _rknn_tensor_attr::h_stride"]
        [::std::mem::offset_of!(_rknn_tensor_attr, h_stride) - 372usize];
};
pub type rknn_tensor_attr = _rknn_tensor_attr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rknn_input_range {
    pub index: u32,
    pub shape_number: u32,
    pub fmt: rknn_tensor_format,
    pub name: [::std::os::raw::c_char; 256usize],
    pub dyn_range: [[u32; 16usize]; 512usize],
    pub n_dims: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _rknn_input_range"][::std::mem::size_of::<_rknn_input_range>() - 33040usize];
    ["Alignment of _rknn_input_range"][::std::mem::align_of::<_rknn_input_range>() - 4usize];
    ["Offset of field: _rknn_input_range::index"]
        [::std::mem::offset_of!(_rknn_input_range, index) - 0usize];
    ["Offset of field: _rknn_input_range::shape_number"]
        [::std::mem::offset_of!(_rknn_input_range, shape_number) - 4usize];
    ["Offset of field: _rknn_input_range::fmt"]
        [::std::mem::offset_of!(_rknn_input_range, fmt) - 8usize];
    ["Offset of field: _rknn_input_range::name"]
        [::std::mem::offset_of!(_rknn_input_range, name) - 12usize];
    ["Offset of field: _rknn_input_range::dyn_range"]
        [::std::mem::offset_of!(_rknn_input_range, dyn_range) - 268usize];
    ["Offset of field: _rknn_input_range::n_dims"]
        [::std::mem::offset_of!(_rknn_input_range, n_dims) - 33036usize];
};
pub type rknn_input_range = _rknn_input_range;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rknn_perf_detail {
    pub perf_data: *mut ::std::os::raw::c_char,
    pub data_len: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _rknn_perf_detail"][::std::mem::size_of::<_rknn_perf_detail>() - 16usize];
    ["Alignment of _rknn_perf_detail"][::std::mem::align_of::<_rknn_perf_detail>() - 8usize];
    ["Offset of field: _rknn_perf_detail::perf_data"]
        [::std::mem::offset_of!(_rknn_perf_detail, perf_data) - 0usize];
    ["Offset of field: _rknn_perf_detail::data_len"]
        [::std::mem::offset_of!(_rknn_perf_detail, data_len) - 8usize];
};
pub type rknn_perf_detail = _rknn_perf_detail;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rknn_perf_run {
    pub run_duration: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _rknn_perf_run"][::std::mem::size_of::<_rknn_perf_run>() - 8usize];
    ["Alignment of _rknn_perf_run"][::std::mem::align_of::<_rknn_perf_run>() - 8usize];
    ["Offset of field: _rknn_perf_run::run_duration"]
        [::std::mem::offset_of!(_rknn_perf_run, run_duration) - 0usize];
};
pub type rknn_perf_run = _rknn_perf_run;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rknn_sdk_version {
    pub api_version: [::std::os::raw::c_char; 256usize],
    pub drv_version: [::std::os::raw::c_char; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _rknn_sdk_version"][::std::mem::size_of::<_rknn_sdk_version>() - 512usize];
    ["Alignment of _rknn_sdk_version"][::std::mem::align_of::<_rknn_sdk_version>() - 1usize];
    ["Offset of field: _rknn_sdk_version::api_version"]
        [::std::mem::offset_of!(_rknn_sdk_version, api_version) - 0usize];
    ["Offset of field: _rknn_sdk_version::drv_version"]
        [::std::mem::offset_of!(_rknn_sdk_version, drv_version) - 256usize];
};
pub type rknn_sdk_version = _rknn_sdk_version;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rknn_mem_size {
    pub total_weight_size: u32,
    pub total_internal_size: u32,
    pub total_dma_allocated_size: u64,
    pub total_sram_size: u32,
    pub free_sram_size: u32,
    pub reserved: [u32; 10usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _rknn_mem_size"][::std::mem::size_of::<_rknn_mem_size>() - 64usize];
    ["Alignment of _rknn_mem_size"][::std::mem::align_of::<_rknn_mem_size>() - 8usize];
    ["Offset of field: _rknn_mem_size::total_weight_size"]
        [::std::mem::offset_of!(_rknn_mem_size, total_weight_size) - 0usize];
    ["Offset of field: _rknn_mem_size::total_internal_size"]
        [::std::mem::offset_of!(_rknn_mem_size, total_internal_size) - 4usize];
    ["Offset of field: _rknn_mem_size::total_dma_allocated_size"]
        [::std::mem::offset_of!(_rknn_mem_size, total_dma_allocated_size) - 8usize];
    ["Offset of field: _rknn_mem_size::total_sram_size"]
        [::std::mem::offset_of!(_rknn_mem_size, total_sram_size) - 16usize];
    ["Offset of field: _rknn_mem_size::free_sram_size"]
        [::std::mem::offset_of!(_rknn_mem_size, free_sram_size) - 20usize];
    ["Offset of field: _rknn_mem_size::reserved"]
        [::std::mem::offset_of!(_rknn_mem_size, reserved) - 24usize];
};
pub type rknn_mem_size = _rknn_mem_size;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rknn_custom_string {
    pub string: [::std::os::raw::c_char; 1024usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _rknn_custom_string"][::std::mem::size_of::<_rknn_custom_string>() - 1024usize];
    ["Alignment of _rknn_custom_string"][::std::mem::align_of::<_rknn_custom_string>() - 1usize];
    ["Offset of field: _rknn_custom_string::string"]
        [::std::mem::offset_of!(_rknn_custom_string, string) - 0usize];
};
pub type rknn_custom_string = _rknn_custom_string;
pub const _rknn_tensor_mem_flags_RKNN_TENSOR_MEMORY_FLAGS_ALLOC_INSIDE: _rknn_tensor_mem_flags = 1;
pub const _rknn_tensor_mem_flags_RKNN_TENSOR_MEMORY_FLAGS_FROM_FD: _rknn_tensor_mem_flags = 2;
pub const _rknn_tensor_mem_flags_RKNN_TENSOR_MEMORY_FLAGS_FROM_PHYS: _rknn_tensor_mem_flags = 3;
pub const _rknn_tensor_mem_flags_RKNN_TENSOR_MEMORY_FLAGS_UNKNOWN: _rknn_tensor_mem_flags = 4;
pub type _rknn_tensor_mem_flags = ::std::os::raw::c_uint;
pub use self::_rknn_tensor_mem_flags as rknn_tensor_mem_flags;
pub const _rknn_mem_alloc_flags_RKNN_FLAG_MEMORY_FLAGS_DEFAULT: _rknn_mem_alloc_flags = 0;
pub const _rknn_mem_alloc_flags_RKNN_FLAG_MEMORY_CACHEABLE: _rknn_mem_alloc_flags = 1;
pub const _rknn_mem_alloc_flags_RKNN_FLAG_MEMORY_NON_CACHEABLE: _rknn_mem_alloc_flags = 2;
pub type _rknn_mem_alloc_flags = ::std::os::raw::c_uint;
pub use self::_rknn_mem_alloc_flags as rknn_mem_alloc_flags;
pub const _rknn_mem_sync_mode_RKNN_MEMORY_SYNC_TO_DEVICE: _rknn_mem_sync_mode = 1;
pub const _rknn_mem_sync_mode_RKNN_MEMORY_SYNC_FROM_DEVICE: _rknn_mem_sync_mode = 2;
pub const _rknn_mem_sync_mode_RKNN_MEMORY_SYNC_BIDIRECTIONAL: _rknn_mem_sync_mode = 3;
pub type _rknn_mem_sync_mode = ::std::os::raw::c_uint;
pub use self::_rknn_mem_sync_mode as rknn_mem_sync_mode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rknn_tensor_memory {
    pub virt_addr: *mut ::std::os::raw::c_void,
    pub phys_addr: u64,
    pub fd: i32,
    pub offset: i32,
    pub size: u32,
    pub flags: u32,
    pub priv_data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _rknn_tensor_memory"][::std::mem::size_of::<_rknn_tensor_memory>() - 40usize];
    ["Alignment of _rknn_tensor_memory"][::std::mem::align_of::<_rknn_tensor_memory>() - 8usize];
    ["Offset of field: _rknn_tensor_memory::virt_addr"]
        [::std::mem::offset_of!(_rknn_tensor_memory, virt_addr) - 0usize];
    ["Offset of field: _rknn_tensor_memory::phys_addr"]
        [::std::mem::offset_of!(_rknn_tensor_memory, phys_addr) - 8usize];
    ["Offset of field: _rknn_tensor_memory::fd"]
        [::std::mem::offset_of!(_rknn_tensor_memory, fd) - 16usize];
    ["Offset of field: _rknn_tensor_memory::offset"]
        [::std::mem::offset_of!(_rknn_tensor_memory, offset) - 20usize];
    ["Offset of field: _rknn_tensor_memory::size"]
        [::std::mem::offset_of!(_rknn_tensor_memory, size) - 24usize];
    ["Offset of field: _rknn_tensor_memory::flags"]
        [::std::mem::offset_of!(_rknn_tensor_memory, flags) - 28usize];
    ["Offset of field: _rknn_tensor_memory::priv_data"]
        [::std::mem::offset_of!(_rknn_tensor_memory, priv_data) - 32usize];
};
pub type rknn_tensor_mem = _rknn_tensor_memory;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rknn_input {
    pub index: u32,
    pub buf: *mut ::std::os::raw::c_void,
    pub size: u32,
    pub pass_through: u8,
    pub type_: rknn_tensor_type,
    pub fmt: rknn_tensor_format,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _rknn_input"][::std::mem::size_of::<_rknn_input>() - 32usize];
    ["Alignment of _rknn_input"][::std::mem::align_of::<_rknn_input>() - 8usize];
    ["Offset of field: _rknn_input::index"][::std::mem::offset_of!(_rknn_input, index) - 0usize];
    ["Offset of field: _rknn_input::buf"][::std::mem::offset_of!(_rknn_input, buf) - 8usize];
    ["Offset of field: _rknn_input::size"][::std::mem::offset_of!(_rknn_input, size) - 16usize];
    ["Offset of field: _rknn_input::pass_through"]
        [::std::mem::offset_of!(_rknn_input, pass_through) - 20usize];
    ["Offset of field: _rknn_input::type_"][::std::mem::offset_of!(_rknn_input, type_) - 24usize];
    ["Offset of field: _rknn_input::fmt"][::std::mem::offset_of!(_rknn_input, fmt) - 28usize];
};
pub type rknn_input = _rknn_input;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rknn_output {
    pub want_float: u8,
    pub is_prealloc: u8,
    pub index: u32,
    pub buf: *mut ::std::os::raw::c_void,
    pub size: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _rknn_output"][::std::mem::size_of::<_rknn_output>() - 24usize];
    ["Alignment of _rknn_output"][::std::mem::align_of::<_rknn_output>() - 8usize];
    ["Offset of field: _rknn_output::want_float"]
        [::std::mem::offset_of!(_rknn_output, want_float) - 0usize];
    ["Offset of field: _rknn_output::is_prealloc"]
        [::std::mem::offset_of!(_rknn_output, is_prealloc) - 1usize];
    ["Offset of field: _rknn_output::index"][::std::mem::offset_of!(_rknn_output, index) - 4usize];
    ["Offset of field: _rknn_output::buf"][::std::mem::offset_of!(_rknn_output, buf) - 8usize];
    ["Offset of field: _rknn_output::size"][::std::mem::offset_of!(_rknn_output, size) - 16usize];
};
pub type rknn_output = _rknn_output;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rknn_init_extend {
    pub ctx: rknn_context,
    pub real_model_offset: i32,
    pub real_model_size: u32,
    pub model_buffer_fd: i32,
    pub model_buffer_flags: u32,
    pub reserved: [u8; 112usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _rknn_init_extend"][::std::mem::size_of::<_rknn_init_extend>() - 136usize];
    ["Alignment of _rknn_init_extend"][::std::mem::align_of::<_rknn_init_extend>() - 8usize];
    ["Offset of field: _rknn_init_extend::ctx"]
        [::std::mem::offset_of!(_rknn_init_extend, ctx) - 0usize];
    ["Offset of field: _rknn_init_extend::real_model_offset"]
        [::std::mem::offset_of!(_rknn_init_extend, real_model_offset) - 8usize];
    ["Offset of field: _rknn_init_extend::real_model_size"]
        [::std::mem::offset_of!(_rknn_init_extend, real_model_size) - 12usize];
    ["Offset of field: _rknn_init_extend::model_buffer_fd"]
        [::std::mem::offset_of!(_rknn_init_extend, model_buffer_fd) - 16usize];
    ["Offset of field: _rknn_init_extend::model_buffer_flags"]
        [::std::mem::offset_of!(_rknn_init_extend, model_buffer_flags) - 20usize];
    ["Offset of field: _rknn_init_extend::reserved"]
        [::std::mem::offset_of!(_rknn_init_extend, reserved) - 24usize];
};
pub type rknn_init_extend = _rknn_init_extend;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rknn_run_extend {
    pub frame_id: u64,
    pub non_block: i32,
    pub timeout_ms: i32,
    pub fence_fd: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _rknn_run_extend"][::std::mem::size_of::<_rknn_run_extend>() - 24usize];
    ["Alignment of _rknn_run_extend"][::std::mem::align_of::<_rknn_run_extend>() - 8usize];
    ["Offset of field: _rknn_run_extend::frame_id"]
        [::std::mem::offset_of!(_rknn_run_extend, frame_id) - 0usize];
    ["Offset of field: _rknn_run_extend::non_block"]
        [::std::mem::offset_of!(_rknn_run_extend, non_block) - 8usize];
    ["Offset of field: _rknn_run_extend::timeout_ms"]
        [::std::mem::offset_of!(_rknn_run_extend, timeout_ms) - 12usize];
    ["Offset of field: _rknn_run_extend::fence_fd"]
        [::std::mem::offset_of!(_rknn_run_extend, fence_fd) - 16usize];
};
pub type rknn_run_extend = _rknn_run_extend;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rknn_output_extend {
    pub frame_id: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _rknn_output_extend"][::std::mem::size_of::<_rknn_output_extend>() - 8usize];
    ["Alignment of _rknn_output_extend"][::std::mem::align_of::<_rknn_output_extend>() - 8usize];
    ["Offset of field: _rknn_output_extend::frame_id"]
        [::std::mem::offset_of!(_rknn_output_extend, frame_id) - 0usize];
};
pub type rknn_output_extend = _rknn_output_extend;
unsafe extern "C" {
    pub fn rknn_init(
        context: *mut rknn_context,
        model: *mut ::std::os::raw::c_void,
        size: u32,
        flag: u32,
        extend: *mut rknn_init_extend,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rknn_dup_context(
        context_in: *mut rknn_context,
        context_out: *mut rknn_context,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rknn_destroy(context: rknn_context) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rknn_query(
        context: rknn_context,
        cmd: rknn_query_cmd,
        info: *mut ::std::os::raw::c_void,
        size: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rknn_inputs_set(
        context: rknn_context,
        n_inputs: u32,
        inputs: *mut rknn_input,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rknn_set_batch_core_num(
        context: rknn_context,
        core_num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rknn_set_core_mask(
        context: rknn_context,
        core_mask: rknn_core_mask,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rknn_run(context: rknn_context, extend: *mut rknn_run_extend) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rknn_wait(context: rknn_context, extend: *mut rknn_run_extend) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rknn_outputs_get(
        context: rknn_context,
        n_outputs: u32,
        outputs: *mut rknn_output,
        extend: *mut rknn_output_extend,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rknn_outputs_release(
        context: rknn_context,
        n_ouputs: u32,
        outputs: *mut rknn_output,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rknn_create_mem_from_phys(
        ctx: rknn_context,
        phys_addr: u64,
        virt_addr: *mut ::std::os::raw::c_void,
        size: u32,
    ) -> *mut rknn_tensor_mem;
}
unsafe extern "C" {
    pub fn rknn_create_mem_from_fd(
        ctx: rknn_context,
        fd: i32,
        virt_addr: *mut ::std::os::raw::c_void,
        size: u32,
        offset: i32,
    ) -> *mut rknn_tensor_mem;
}
unsafe extern "C" {
    pub fn rknn_create_mem_from_mb_blk(
        ctx: rknn_context,
        mb_blk: *mut ::std::os::raw::c_void,
        offset: i32,
    ) -> *mut rknn_tensor_mem;
}
unsafe extern "C" {
    pub fn rknn_create_mem(ctx: rknn_context, size: u32) -> *mut rknn_tensor_mem;
}
unsafe extern "C" {
    pub fn rknn_create_mem2(ctx: rknn_context, size: u64, alloc_flags: u64)
    -> *mut rknn_tensor_mem;
}
unsafe extern "C" {
    pub fn rknn_destroy_mem(ctx: rknn_context, mem: *mut rknn_tensor_mem) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rknn_set_weight_mem(
        ctx: rknn_context,
        mem: *mut rknn_tensor_mem,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rknn_set_internal_mem(
        ctx: rknn_context,
        mem: *mut rknn_tensor_mem,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rknn_set_io_mem(
        ctx: rknn_context,
        mem: *mut rknn_tensor_mem,
        attr: *mut rknn_tensor_attr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rknn_set_input_shape(
        ctx: rknn_context,
        attr: *mut rknn_tensor_attr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rknn_set_input_shapes(
        ctx: rknn_context,
        n_inputs: u32,
        attr: *mut rknn_tensor_attr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rknn_mem_sync(
        context: rknn_context,
        mem: *mut rknn_tensor_mem,
        mode: rknn_mem_sync_mode,
    ) -> ::std::os::raw::c_int;
}
pub const image_format_t_IMAGE_FORMAT_GRAY8: image_format_t = 0;
pub const image_format_t_IMAGE_FORMAT_RGB888: image_format_t = 1;
pub const image_format_t_IMAGE_FORMAT_RGBA8888: image_format_t = 2;
pub const image_format_t_IMAGE_FORMAT_YUV420SP_NV21: image_format_t = 3;
pub const image_format_t_IMAGE_FORMAT_YUV420SP_NV12: image_format_t = 4;
pub const image_format_t_IMAGE_FORMAT_BGR_888: image_format_t = 5;
#[doc = " @brief Image pixel format\n"]
pub type image_format_t = ::std::os::raw::c_uint;
#[doc = " @brief Image buffer\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_buffer_t {
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub width_stride: ::std::os::raw::c_int,
    pub height_stride: ::std::os::raw::c_int,
    pub format: image_format_t,
    pub virt_addr: *mut ::std::os::raw::c_uchar,
    pub size: ::std::os::raw::c_int,
    pub fd: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of image_buffer_t"][::std::mem::size_of::<image_buffer_t>() - 40usize];
    ["Alignment of image_buffer_t"][::std::mem::align_of::<image_buffer_t>() - 8usize];
    ["Offset of field: image_buffer_t::width"]
        [::std::mem::offset_of!(image_buffer_t, width) - 0usize];
    ["Offset of field: image_buffer_t::height"]
        [::std::mem::offset_of!(image_buffer_t, height) - 4usize];
    ["Offset of field: image_buffer_t::width_stride"]
        [::std::mem::offset_of!(image_buffer_t, width_stride) - 8usize];
    ["Offset of field: image_buffer_t::height_stride"]
        [::std::mem::offset_of!(image_buffer_t, height_stride) - 12usize];
    ["Offset of field: image_buffer_t::format"]
        [::std::mem::offset_of!(image_buffer_t, format) - 16usize];
    ["Offset of field: image_buffer_t::virt_addr"]
        [::std::mem::offset_of!(image_buffer_t, virt_addr) - 24usize];
    ["Offset of field: image_buffer_t::size"]
        [::std::mem::offset_of!(image_buffer_t, size) - 32usize];
    ["Offset of field: image_buffer_t::fd"][::std::mem::offset_of!(image_buffer_t, fd) - 36usize];
};
#[doc = " @brief Image rectangle\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_rect_t {
    pub left: ::std::os::raw::c_int,
    pub top: ::std::os::raw::c_int,
    pub right: ::std::os::raw::c_int,
    pub bottom: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of image_rect_t"][::std::mem::size_of::<image_rect_t>() - 16usize];
    ["Alignment of image_rect_t"][::std::mem::align_of::<image_rect_t>() - 4usize];
    ["Offset of field: image_rect_t::left"][::std::mem::offset_of!(image_rect_t, left) - 0usize];
    ["Offset of field: image_rect_t::top"][::std::mem::offset_of!(image_rect_t, top) - 4usize];
    ["Offset of field: image_rect_t::right"][::std::mem::offset_of!(image_rect_t, right) - 8usize];
    ["Offset of field: image_rect_t::bottom"]
        [::std::mem::offset_of!(image_rect_t, bottom) - 12usize];
};
#[doc = " @brief Image obb rectangle\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_obb_box_t {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
    pub h: ::std::os::raw::c_int,
    pub angle: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of image_obb_box_t"][::std::mem::size_of::<image_obb_box_t>() - 20usize];
    ["Alignment of image_obb_box_t"][::std::mem::align_of::<image_obb_box_t>() - 4usize];
    ["Offset of field: image_obb_box_t::x"][::std::mem::offset_of!(image_obb_box_t, x) - 0usize];
    ["Offset of field: image_obb_box_t::y"][::std::mem::offset_of!(image_obb_box_t, y) - 4usize];
    ["Offset of field: image_obb_box_t::w"][::std::mem::offset_of!(image_obb_box_t, w) - 8usize];
    ["Offset of field: image_obb_box_t::h"][::std::mem::offset_of!(image_obb_box_t, h) - 12usize];
    ["Offset of field: image_obb_box_t::angle"]
        [::std::mem::offset_of!(image_obb_box_t, angle) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rknn_context_t {
    pub rknn_ctx: rknn_context,
    pub io_num: rknn_input_output_num,
    pub input_attrs: *mut rknn_tensor_attr,
    pub output_attrs: *mut rknn_tensor_attr,
    pub model_channel: ::std::os::raw::c_int,
    pub model_width: ::std::os::raw::c_int,
    pub model_height: ::std::os::raw::c_int,
    pub is_quant: bool,
    pub NMS_THRESH: f32,
    pub BOX_THRESH: f32,
    pub OBJ_CLASS_NUM: ::std::os::raw::c_int,
    pub yoloType: ::std::os::raw::c_int,
    pub anchor: [[::std::os::raw::c_int; 6usize]; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rknn_context_t"][::std::mem::size_of::<rknn_context_t>() - 136usize];
    ["Alignment of rknn_context_t"][::std::mem::align_of::<rknn_context_t>() - 8usize];
    ["Offset of field: rknn_context_t::rknn_ctx"]
        [::std::mem::offset_of!(rknn_context_t, rknn_ctx) - 0usize];
    ["Offset of field: rknn_context_t::io_num"]
        [::std::mem::offset_of!(rknn_context_t, io_num) - 8usize];
    ["Offset of field: rknn_context_t::input_attrs"]
        [::std::mem::offset_of!(rknn_context_t, input_attrs) - 16usize];
    ["Offset of field: rknn_context_t::output_attrs"]
        [::std::mem::offset_of!(rknn_context_t, output_attrs) - 24usize];
    ["Offset of field: rknn_context_t::model_channel"]
        [::std::mem::offset_of!(rknn_context_t, model_channel) - 32usize];
    ["Offset of field: rknn_context_t::model_width"]
        [::std::mem::offset_of!(rknn_context_t, model_width) - 36usize];
    ["Offset of field: rknn_context_t::model_height"]
        [::std::mem::offset_of!(rknn_context_t, model_height) - 40usize];
    ["Offset of field: rknn_context_t::is_quant"]
        [::std::mem::offset_of!(rknn_context_t, is_quant) - 44usize];
    ["Offset of field: rknn_context_t::NMS_THRESH"]
        [::std::mem::offset_of!(rknn_context_t, NMS_THRESH) - 48usize];
    ["Offset of field: rknn_context_t::BOX_THRESH"]
        [::std::mem::offset_of!(rknn_context_t, BOX_THRESH) - 52usize];
    ["Offset of field: rknn_context_t::OBJ_CLASS_NUM"]
        [::std::mem::offset_of!(rknn_context_t, OBJ_CLASS_NUM) - 56usize];
    ["Offset of field: rknn_context_t::yoloType"]
        [::std::mem::offset_of!(rknn_context_t, yoloType) - 60usize];
    ["Offset of field: rknn_context_t::anchor"]
        [::std::mem::offset_of!(rknn_context_t, anchor) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct object_detect_result {
    pub box_: image_rect_t,
    pub prop: f32,
    pub cls_id: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of object_detect_result"][::std::mem::size_of::<object_detect_result>() - 24usize];
    ["Alignment of object_detect_result"][::std::mem::align_of::<object_detect_result>() - 4usize];
    ["Offset of field: object_detect_result::box_"]
        [::std::mem::offset_of!(object_detect_result, box_) - 0usize];
    ["Offset of field: object_detect_result::prop"]
        [::std::mem::offset_of!(object_detect_result, prop) - 16usize];
    ["Offset of field: object_detect_result::cls_id"]
        [::std::mem::offset_of!(object_detect_result, cls_id) - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct object_detected_list {
    pub id: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
    pub results: [object_detect_result; 128usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of object_detected_list"][::std::mem::size_of::<object_detected_list>() - 3080usize];
    ["Alignment of object_detected_list"][::std::mem::align_of::<object_detected_list>() - 4usize];
    ["Offset of field: object_detected_list::id"]
        [::std::mem::offset_of!(object_detected_list, id) - 0usize];
    ["Offset of field: object_detected_list::count"]
        [::std::mem::offset_of!(object_detected_list, count) - 4usize];
    ["Offset of field: object_detected_list::results"]
        [::std::mem::offset_of!(object_detected_list, results) - 8usize];
};
unsafe extern "C" {
    pub fn kmAI_Init() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_Run() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_kmEnable(enable: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_Version() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_mouse_move(
        x: ::std::os::raw::c_short,
        y: ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_mouse_left(isdown: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_mouse_right(isdown: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_mouse_middle(isdown: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_mouse_wheel(wheel: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_mouse_side1(isdown: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_mouse_side2(isdown: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_mouse_all(
        button: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        wheel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_keydown(vkey: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_keyup(vkey: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_keyinit() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_monitor_mouse_left() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_monitor_mouse_middle() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_monitor_mouse_right() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_monitor_mouse_side1() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_monitor_mouse_side2() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_monitor_mouse_xy(
        x: *mut ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_monitor_mouse_wheel(wheel: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_monitor_keyboard(vk_key: ::std::os::raw::c_short) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_mask_mouse_left(enable: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_mask_mouse_right(enable: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_mask_mouse_middle(enable: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_mask_mouse_side1(enable: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_mask_mouse_side2(enable: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_mask_mouse_x(enable: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_mask_mouse_y(enable: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_mask_mouse_xy(enable: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_mask_mouse_wheel(enable: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_mask_keyboard(vkey: ::std::os::raw::c_short) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_unmask_keyboard(vkey: ::std::os::raw::c_short) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_unmask_all() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_MiniUI_Enable(MODE: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_MiniUI_UserLock() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_MiniUI_UserUnLock() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_MiniUI_LCDdisplay(img: cv_Mat) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_YOLO_Loadmodel(
        ctx: *mut rknn_context_t,
        model_path: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_YOLO_InterfaceModel(
        ctx: *mut rknn_context_t,
        img: cv_Mat,
        out: *mut object_detected_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_YOLO_DrawRectangle(
        img: cv_Mat,
        rx: ::std::os::raw::c_int,
        ry: ::std::os::raw::c_int,
        rw: ::std::os::raw::c_int,
        rh: ::std::os::raw::c_int,
        color: ::std::os::raw::c_uint,
        thickness: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn kmAI_YOLO_DrawText(
        img: cv_Mat,
        text: *const ::std::os::raw::c_char,
        rx: ::std::os::raw::c_int,
        ry: ::std::os::raw::c_int,
        color: ::std::os::raw::c_uint,
        fontsize: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn kmAI_YOLO_Release(ctx: *mut rknn_context_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kmAI_reboot() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_3 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_4 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_5 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_6 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_7 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_8 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_9 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_10 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_11 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_12 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_13 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_14 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_15 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_16 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_17 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_18 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_19 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_20 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_21 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_22 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_23 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_24 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_25 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_26 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_27 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_28 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_29 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_30 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_31 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_32 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_33 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_34 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_35 {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0",
    ][::std::mem::size_of::<std_iterator>() - 1usize];
    [
        "Align of template specialization: std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0",
    ][::std::mem::align_of::<std_iterator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0",
    ][::std::mem::size_of::<std_iterator>() - 1usize];
    [
        "Align of template specialization: std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0",
    ][::std::mem::align_of::<std_iterator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0",
    ][::std::mem::size_of::<std_iterator>() - 1usize];
    [
        "Align of template specialization: std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0",
    ][::std::mem::align_of::<std_iterator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_string<u32>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_string<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char16_t_std_char_traits_open1_char16_t_close1_std_allocator_open1_char16_t_close1_close0",
    ][::std::mem::size_of::<std_basic_string<u16>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char16_t_std_char_traits_open1_char16_t_close1_std_allocator_open1_char16_t_close1_close0",
    ][::std::mem::align_of::<std_basic_string<u16>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char16_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char16_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char16_t_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char16_t_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char32_t_std_char_traits_open1_char32_t_close1_std_allocator_open1_char32_t_close1_close0",
    ][::std::mem::size_of::<std_basic_string<u32>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char32_t_std_char_traits_open1_char32_t_close1_std_allocator_open1_char32_t_close1_close0",
    ][::std::mem::align_of::<std_basic_string<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char32_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char32_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char32_t_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char32_t_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_ios_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_ios<::std::os::raw::c_char>>() - 264usize];
    [
        "Align of template specialization: std_basic_ios_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_ios<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_streambuf_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_streambuf<::std::os::raw::c_char>>() - 64usize];
    [
        "Align of template specialization: std_basic_streambuf_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_streambuf<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_istream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_istream<::std::os::raw::c_char>>() - 280usize];
    [
        "Align of template specialization: std_basic_istream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_istream<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_ostream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_ostream<::std::os::raw::c_char>>() - 272usize];
    [
        "Align of template specialization: std_basic_ostream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_ostream<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_iostream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_iostream<::std::os::raw::c_char>>() - 288usize];
    [
        "Align of template specialization: std_basic_iostream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_iostream<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_stringbuf_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_stringbuf<::std::os::raw::c_char>>() - 104usize];
    [
        "Align of template specialization: std_basic_stringbuf_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_stringbuf<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_istringstream_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_istringstream<::std::os::raw::c_char>>() - 384usize];
    [
        "Align of template specialization: std_basic_istringstream_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_istringstream<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_ostringstream_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_ostringstream<::std::os::raw::c_char>>() - 376usize];
    [
        "Align of template specialization: std_basic_ostringstream_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_ostringstream<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_stringstream_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_stringstream<::std::os::raw::c_char>>() - 392usize];
    [
        "Align of template specialization: std_basic_stringstream_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_stringstream<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_filebuf_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_filebuf<::std::os::raw::c_char>>() - 240usize];
    [
        "Align of template specialization: std_basic_filebuf_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_filebuf<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_ifstream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_ifstream<::std::os::raw::c_char>>() - 520usize];
    [
        "Align of template specialization: std_basic_ifstream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_ifstream<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_ofstream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_ofstream<::std::os::raw::c_char>>() - 512usize];
    [
        "Align of template specialization: std_basic_ofstream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_ofstream<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_fstream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_fstream<::std::os::raw::c_char>>() - 528usize];
    [
        "Align of template specialization: std_basic_fstream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_fstream<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_ios_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_ios<u32>>() - 264usize];
    [
        "Align of template specialization: std_basic_ios_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_ios<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_streambuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_streambuf<u32>>() - 64usize];
    [
        "Align of template specialization: std_basic_streambuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_streambuf<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_istream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_istream<u32>>() - 280usize];
    [
        "Align of template specialization: std_basic_istream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_istream<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_ostream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_ostream<u32>>() - 272usize];
    [
        "Align of template specialization: std_basic_ostream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_ostream<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_iostream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_iostream<u32>>() - 288usize];
    [
        "Align of template specialization: std_basic_iostream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_iostream<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_stringbuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_stringbuf<u32>>() - 104usize];
    [
        "Align of template specialization: std_basic_stringbuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_stringbuf<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_istringstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_istringstream<u32>>() - 384usize];
    [
        "Align of template specialization: std_basic_istringstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_istringstream<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_ostringstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_ostringstream<u32>>() - 376usize];
    [
        "Align of template specialization: std_basic_ostringstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_ostringstream<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_stringstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_stringstream<u32>>() - 392usize];
    [
        "Align of template specialization: std_basic_stringstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_stringstream<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_filebuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_filebuf<u32>>() - 240usize];
    [
        "Align of template specialization: std_basic_filebuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_filebuf<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_ifstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_ifstream<u32>>() - 520usize];
    [
        "Align of template specialization: std_basic_ifstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_ifstream<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_ofstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_ofstream<u32>>() - 512usize];
    [
        "Align of template specialization: std_basic_ofstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_ofstream<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_fstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_fstream<u32>>() - 528usize];
    [
        "Align of template specialization: std_basic_fstream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_fstream<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_void_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_void_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_istream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_istream<::std::os::raw::c_char>>() - 280usize];
    [
        "Align of template specialization: std_basic_istream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_istream<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_istream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_istream<::std::os::raw::c_char>>() - 280usize];
    [
        "Align of template specialization: std_basic_istream_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_istream<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_istream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_istream<u32>>() - 280usize];
    [
        "Align of template specialization: std_basic_istream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_istream<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_string<u32>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_string<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_istream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_istream<u32>>() - 280usize];
    [
        "Align of template specialization: std_basic_istream_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_istream<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_hash_open0_long_double_close0"]
        [::std::mem::size_of::<std_hash>() - 1usize];
    ["Align of template specialization: std_hash_open0_long_double_close0"]
        [::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_hash_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_hash>() - 1usize];
    [
        "Align of template specialization: std_hash_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_string<u32>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_string<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_hash_open0_std_basic_string_open1_wchar_t_std_char_traits_open2_wchar_t_close2_std_allocator_open2_wchar_t_close2_close1_close0",
    ][::std::mem::size_of::<std_hash>() - 1usize];
    [
        "Align of template specialization: std_hash_open0_std_basic_string_open1_wchar_t_std_char_traits_open2_wchar_t_close2_std_allocator_open2_wchar_t_close2_close1_close0",
    ][::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_string<u32>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_wchar_t_std_char_traits_open1_wchar_t_close1_std_allocator_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_string<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char16_t_std_char_traits_open1_char16_t_close1_std_allocator_open1_char16_t_close1_close0",
    ][::std::mem::size_of::<std_basic_string<u16>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char16_t_std_char_traits_open1_char16_t_close1_std_allocator_open1_char16_t_close1_close0",
    ][::std::mem::align_of::<std_basic_string<u16>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char16_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char16_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char16_t_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char16_t_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_hash_open0_std_basic_string_open1_char16_t_std_char_traits_open2_char16_t_close2_std_allocator_open2_char16_t_close2_close1_close0",
    ][::std::mem::size_of::<std_hash>() - 1usize];
    [
        "Align of template specialization: std_hash_open0_std_basic_string_open1_char16_t_std_char_traits_open2_char16_t_close2_std_allocator_open2_char16_t_close2_close1_close0",
    ][::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char16_t_std_char_traits_open1_char16_t_close1_std_allocator_open1_char16_t_close1_close0",
    ][::std::mem::size_of::<std_basic_string<u16>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char16_t_std_char_traits_open1_char16_t_close1_std_allocator_open1_char16_t_close1_close0",
    ][::std::mem::align_of::<std_basic_string<u16>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char16_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char16_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char16_t_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char16_t_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char32_t_std_char_traits_open1_char32_t_close1_std_allocator_open1_char32_t_close1_close0",
    ][::std::mem::size_of::<std_basic_string<u32>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char32_t_std_char_traits_open1_char32_t_close1_std_allocator_open1_char32_t_close1_close0",
    ][::std::mem::align_of::<std_basic_string<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char32_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char32_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char32_t_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char32_t_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_hash_open0_std_basic_string_open1_char32_t_std_char_traits_open2_char32_t_close2_std_allocator_open2_char32_t_close2_close1_close0",
    ][::std::mem::size_of::<std_hash>() - 1usize];
    [
        "Align of template specialization: std_hash_open0_std_basic_string_open1_char32_t_std_char_traits_open2_char32_t_close2_std_allocator_open2_char32_t_close2_close1_close0",
    ][::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char32_t_std_char_traits_open1_char32_t_close1_std_allocator_open1_char32_t_close1_close0",
    ][::std::mem::size_of::<std_basic_string<u32>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char32_t_std_char_traits_open1_char32_t_close1_std_allocator_open1_char32_t_close1_close0",
    ][::std::mem::align_of::<std_basic_string<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char32_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char32_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char32_t_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char32_t_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
pub type size_type = size_type;
pub type size_type = usize;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0",
    ][::std::mem::size_of::<std_iterator>() - 1usize];
    [
        "Align of template specialization: std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0",
    ][::std::mem::align_of::<std_iterator>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_49 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_50 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_51 {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Size__open0_int_close0"]
        [::std::mem::size_of::<cv_Size_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Size__open0_int_close0"]
        [::std::mem::align_of::<cv_Size_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Size__open0_int_close0"]
        [::std::mem::size_of::<cv_Size_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Size__open0_int_close0"]
        [::std::mem::align_of::<cv_Size_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Size__open0_int_close0"]
        [::std::mem::size_of::<cv_Size_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Size__open0_int_close0"]
        [::std::mem::align_of::<cv_Size_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_iterator_open0_std_random_access_iterator_tag_bool__long_ptr_bool_ref_bool_close0",
    ][::std::mem::size_of::<std_iterator>() - 1usize];
    [
        "Align of template specialization: std_iterator_open0_std_random_access_iterator_tag_bool__long_ptr_bool_ref_bool_close0",
    ][::std::mem::align_of::<std_iterator>() - 1usize];
};
pub type iterator = std__Bit_iterator;
pub type size_type = usize;
pub type iterator = std__Bit_iterator;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int64_close0"]
        [::std::mem::size_of::<cv_Point_<int64>>() - 16usize];
    ["Align of template specialization: cv_Point__open0_int64_close0"]
        [::std::mem::align_of::<cv_Point_<int64>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::size_of::<cv_Point_<f32>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::align_of::<cv_Point_<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_double_close0"]
        [::std::mem::size_of::<cv_Point_<f64>>() - 16usize];
    ["Align of template specialization: cv_Point__open0_double_close0"]
        [::std::mem::align_of::<cv_Point_<f64>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point3__open0_float_close0"]
        [::std::mem::size_of::<cv_Point3_<f32>>() - 12usize];
    ["Align of template specialization: cv_Point3__open0_float_close0"]
        [::std::mem::align_of::<cv_Point3_<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point3__open0_double_close0"]
        [::std::mem::size_of::<cv_Point3_<f64>>() - 24usize];
    ["Align of template specialization: cv_Point3__open0_double_close0"]
        [::std::mem::align_of::<cv_Point3_<f64>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Size__open0_int_close0"]
        [::std::mem::size_of::<cv_Size_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Size__open0_int_close0"]
        [::std::mem::align_of::<cv_Size_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Size__open0_float_close0"]
        [::std::mem::size_of::<cv_Size_<f32>>() - 8usize];
    ["Align of template specialization: cv_Size__open0_float_close0"]
        [::std::mem::align_of::<cv_Size_<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Size__open0_double_close0"]
        [::std::mem::size_of::<cv_Size_<f64>>() - 16usize];
    ["Align of template specialization: cv_Size__open0_double_close0"]
        [::std::mem::align_of::<cv_Size_<f64>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Scalar__open0_double_close0"]
        [::std::mem::size_of::<cv_Scalar_>() - 32usize];
    ["Align of template specialization: cv_Scalar__open0_double_close0"]
        [::std::mem::align_of::<cv_Scalar_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::size_of::<cv_Point_<f32>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::align_of::<cv_Point_<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::size_of::<cv_Point_<f32>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::align_of::<cv_Point_<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int64_close0"]
        [::std::mem::size_of::<cv_Point_<int64>>() - 16usize];
    ["Align of template specialization: cv_Point__open0_int64_close0"]
        [::std::mem::align_of::<cv_Point_<int64>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::size_of::<cv_Point_<f32>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::align_of::<cv_Point_<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::size_of::<cv_Point_<f32>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::align_of::<cv_Point_<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_double_close0"]
        [::std::mem::size_of::<cv_Point_<f64>>() - 16usize];
    ["Align of template specialization: cv_Point__open0_double_close0"]
        [::std::mem::align_of::<cv_Point_<f64>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_bool__close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_bool__close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0__bindgen_ty_id_122035_open1_bool__std_allocator_open2_bool__close2_close1_std_allocator_open1__bindgen_ty_id_122044_open2_bool__std_allocator_open3_bool__close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0__bindgen_ty_id_122035_open1_bool__std_allocator_open2_bool__close2_close1_std_allocator_open1__bindgen_ty_id_122044_open2_bool__std_allocator_open3_bool__close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_bool__close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_bool__close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0__bindgen_ty_id_122044_open1_bool__std_allocator_open2_bool__close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0__bindgen_ty_id_122044_open1_bool__std_allocator_open2_bool__close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_bool__close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_bool__close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_cuda_GpuMat_std_allocator_open1_cv_cuda_GpuMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_cuda_GpuMat_std_allocator_open1_cv_cuda_GpuMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_cuda_GpuMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_cuda_GpuMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_cuda_GpuMat_std_allocator_open1_cv_cuda_GpuMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_cuda_GpuMat_std_allocator_open1_cv_cuda_GpuMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_cuda_GpuMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_cuda_GpuMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_cuda_GpuMat_std_allocator_open1_cv_cuda_GpuMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_cuda_GpuMat_std_allocator_open1_cv_cuda_GpuMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_cuda_GpuMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_cuda_GpuMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_bool__close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_bool__close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0__bindgen_ty_id_122329_open1_bool__std_allocator_open2_bool__close2_close1_std_allocator_open1__bindgen_ty_id_122338_open2_bool__std_allocator_open3_bool__close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0__bindgen_ty_id_122329_open1_bool__std_allocator_open2_bool__close2_close1_std_allocator_open1__bindgen_ty_id_122338_open2_bool__std_allocator_open3_bool__close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_bool__close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_bool__close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0__bindgen_ty_id_122338_open1_bool__std_allocator_open2_bool__close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0__bindgen_ty_id_122338_open1_bool__std_allocator_open2_bool__close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_bool__close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_bool__close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_cuda_GpuMat_std_allocator_open1_cv_cuda_GpuMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_cuda_GpuMat_std_allocator_open1_cv_cuda_GpuMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_cuda_GpuMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_cuda_GpuMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_cuda_GpuMat_std_allocator_open1_cv_cuda_GpuMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_cuda_GpuMat_std_allocator_open1_cv_cuda_GpuMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_cuda_GpuMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_cuda_GpuMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_bool__close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_bool__close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_cuda_GpuMat_std_allocator_open1_cv_cuda_GpuMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_cuda_GpuMat_std_allocator_open1_cv_cuda_GpuMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_cuda_GpuMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_cuda_GpuMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Range_std_allocator_open1_cv_Range_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Range_std_allocator_open1_cv_Range_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Range_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Range_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_int_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_int_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_double_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_double_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Range_std_allocator_open1_cv_Range_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Range_std_allocator_open1_cv_Range_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Range_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Range_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_size_t_std_allocator_open1_unsigned_long_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_size_t_std_allocator_open1_unsigned_long_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_long_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_long_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_bool__close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_bool__close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_cuda_GpuMat_std_allocator_open1_cv_cuda_GpuMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_cuda_GpuMat_std_allocator_open1_cv_cuda_GpuMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_cuda_GpuMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_cuda_GpuMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_cuda_GpuMat_std_allocator_open1_cv_cuda_GpuMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_cuda_GpuMat_std_allocator_open1_cv_cuda_GpuMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_cuda_GpuMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_cuda_GpuMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_cuda_GpuMat_std_allocator_open1_cv_cuda_GpuMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_cuda_GpuMat_std_allocator_open1_cv_cuda_GpuMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_cuda_GpuMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_cuda_GpuMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_cuda_GpuMat_std_allocator_open1_cv_cuda_GpuMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_cuda_GpuMat_std_allocator_open1_cv_cuda_GpuMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_cuda_GpuMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_cuda_GpuMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_FileStorage_Impl_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_FileStorage_Impl_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_Formatted_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_Formatted_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_Formatter_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_Formatter_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_FileStorage_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_FileStorage_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Scalar__open0_double_close0"]
        [::std::mem::size_of::<cv_Scalar_>() - 32usize];
    ["Align of template specialization: cv_Scalar__open0_double_close0"]
        [::std::mem::align_of::<cv_Scalar_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_Formatted_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_Formatted_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_Formatted_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_Formatted_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_streambuf_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_streambuf<::std::os::raw::c_char>>() - 64usize];
    [
        "Align of template specialization: std_basic_streambuf_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_streambuf<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_streambuf_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_streambuf<::std::os::raw::c_char>>() - 64usize];
    [
        "Align of template specialization: std_basic_streambuf_open0_char_std_char_traits_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_streambuf<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_streambuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_streambuf<u32>>() - 64usize];
    [
        "Align of template specialization: std_basic_streambuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_streambuf<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_streambuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::size_of::<std_basic_streambuf<u32>>() - 64usize];
    [
        "Align of template specialization: std_basic_streambuf_open0_wchar_t_std_char_traits_open1_wchar_t_close1_close0",
    ][::std::mem::align_of::<std_basic_streambuf<u32>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0",
    ][::std::mem::size_of::<std_iterator>() - 1usize];
    [
        "Align of template specialization: std_iterator_open0_std_output_iterator_tag_void_void_void_void_close0",
    ][::std::mem::align_of::<std_iterator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
pub type char_type = ::std::os::raw::c_char;
pub type int_type = int_type;
pub type int_type = ::std::os::raw::c_int;
pub type char_type = u32;
pub type int_type = int_type;
pub type int_type = wint_t;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_complex_open0_double_close0"]
        [::std::mem::size_of::<std_complex<f64>>() - 16usize];
    ["Align of template specialization: std_complex_open0_double_close0"]
        [::std::mem::align_of::<std_complex<f64>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_complex_open0_long_double_close0"]
        [::std::mem::size_of::<std_complex<u128>>() - 32usize];
    ["Align of template specialization: std_complex_open0_long_double_close0"]
        [::std::mem::align_of::<std_complex<u128>>() - 16usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_complex_open0_long_double_close0"]
        [::std::mem::size_of::<std_complex<u128>>() - 32usize];
    ["Align of template specialization: std_complex_open0_long_double_close0"]
        [::std::mem::align_of::<std_complex<u128>>() - 16usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_complex_open0_float_close0"]
        [::std::mem::size_of::<std_complex<f32>>() - 8usize];
    ["Align of template specialization: std_complex_open0_float_close0"]
        [::std::mem::align_of::<std_complex<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_complex_open0_float_close0"]
        [::std::mem::size_of::<std_complex<f32>>() - 8usize];
    ["Align of template specialization: std_complex_open0_float_close0"]
        [::std::mem::align_of::<std_complex<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_complex_open0_double_close0"]
        [::std::mem::size_of::<std_complex<f64>>() - 16usize];
    ["Align of template specialization: std_complex_open0_double_close0"]
        [::std::mem::align_of::<std_complex<f64>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_complex_open0_double_close0"]
        [::std::mem::size_of::<std_complex<f64>>() - 16usize];
    ["Align of template specialization: std_complex_open0_double_close0"]
        [::std::mem::align_of::<std_complex<f64>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_complex_open0_long_double_close0"]
        [::std::mem::size_of::<std_complex<u128>>() - 32usize];
    ["Align of template specialization: std_complex_open0_long_double_close0"]
        [::std::mem::align_of::<std_complex<u128>>() - 16usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_complex_open0_long_double_close0"]
        [::std::mem::size_of::<std_complex<u128>>() - 32usize];
    ["Align of template specialization: std_complex_open0_long_double_close0"]
        [::std::mem::align_of::<std_complex<u128>>() - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_53 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_54 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_55 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_56 {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_chrono_duration_open0_int64_t_std_nano_close0"]
        [::std::mem::size_of::<std_chrono_duration<i64>>() - 8usize];
    ["Align of template specialization: std_chrono_duration_open0_int64_t_std_nano_close0"]
        [::std::mem::align_of::<std_chrono_duration<i64>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_chrono_duration_open0_int64_t_std_ratio_open1_close1_close0",
    ][::std::mem::size_of::<std_chrono_duration<i64>>() - 8usize];
    [
        "Align of template specialization: std_chrono_duration_open0_int64_t_std_ratio_open1_close1_close0",
    ][::std::mem::align_of::<std_chrono_duration<i64>>() - 8usize];
};
pub type rep = ::std::os::raw::c_long;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_chrono_time_point_open0_std_chrono_system_clock_std_chrono_system_clock_duration_close0",
    ][::std::mem::size_of::<std_chrono_time_point<std_chrono_system_clock_duration>>() - 8usize];
    [
        "Align of template specialization: std_chrono_time_point_open0_std_chrono_system_clock_std_chrono_system_clock_duration_close0",
    ][::std::mem::align_of::<std_chrono_time_point<std_chrono_system_clock_duration>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_chrono_time_point_open0_std_chrono_steady_clock_std_chrono_steady_clock_duration_close0",
    ][::std::mem::size_of::<std_chrono_time_point<std_chrono_steady_clock_duration>>() - 8usize];
    [
        "Align of template specialization: std_chrono_time_point_open0_std_chrono_steady_clock_std_chrono_steady_clock_duration_close0",
    ][::std::mem::align_of::<std_chrono_time_point<std_chrono_steady_clock_duration>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___timed_mutex_impl_open0_std_timed_mutex_close0"]
        [::std::mem::size_of::<std___timed_mutex_impl>() - 1usize];
    ["Align of template specialization: std___timed_mutex_impl_open0_std_timed_mutex_close0"]
        [::std::mem::align_of::<std___timed_mutex_impl>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std___timed_mutex_impl_open0_std_recursive_timed_mutex_close0",
    ][::std::mem::size_of::<std___timed_mutex_impl>() - 1usize];
    [
        "Align of template specialization: std___timed_mutex_impl_open0_std_recursive_timed_mutex_close0",
    ][::std::mem::align_of::<std___timed_mutex_impl>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_MinProblemSolver_Function_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_MinProblemSolver_Function_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_MinProblemSolver_Function_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_MinProblemSolver_Function_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_MinProblemSolver_Function_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_MinProblemSolver_Function_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_MinProblemSolver_Function_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_MinProblemSolver_Function_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_FileStorage_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_FileStorage_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_std_vector_open1_cv_Point_std_allocator_open2_cv_Point__open3_int_close3_close2_close1_std_allocator_open1_std_vector_open2_cv_Point__open3_int_close3_std_allocator_open3_cv_Point__open4_int_close4_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_std_vector_open1_cv_Point_std_allocator_open2_cv_Point__open3_int_close3_close2_close1_std_allocator_open1_std_vector_open2_cv_Point__open3_int_close3_std_allocator_open3_cv_Point__open4_int_close4_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_cv_Point__open2_int_close2_std_allocator_open2_cv_Point__open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_cv_Point__open2_int_close2_std_allocator_open2_cv_Point__open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point__open1_int_close1_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point__open1_int_close1_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_SimpleBlobDetector_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_SimpleBlobDetector_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_DescriptorMatcher_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_DescriptorMatcher_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_DescriptorMatcher_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_DescriptorMatcher_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_DescriptorMatcher_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_DescriptorMatcher_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_FileStorage_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_FileStorage_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_DescriptorMatcher_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_DescriptorMatcher_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_flann_IndexParams_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_flann_IndexParams_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_flann_SearchParams_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_flann_SearchParams_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_DescriptorMatcher_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_DescriptorMatcher_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_flann_IndexParams_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_flann_IndexParams_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_flann_SearchParams_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_flann_SearchParams_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_flann_Index_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_flann_Index_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_char_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_char_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_std_vector_open1_char_std_allocator_open2_char_close2_close1_std_allocator_open1_std_vector_open2_char_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_std_vector_open1_char_std_allocator_open2_char_close2_close1_std_allocator_open1_std_vector_open2_char_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_char_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_char_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_char_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_char_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_char_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_char_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_FeatureDetector_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_FeatureDetector_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_unsigned_char_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_unsigned_char_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::size_of::<cv_Point_<f32>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::align_of::<cv_Point_<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::size_of::<cv_Point_<f32>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::align_of::<cv_Point_<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::size_of::<cv_Point_<f32>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::align_of::<cv_Point_<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_DescriptorExtractor_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_DescriptorExtractor_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_DescriptorMatcher_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_DescriptorMatcher_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_DescriptorMatcher_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_DescriptorMatcher_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_DescriptorExtractor_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_DescriptorExtractor_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_DescriptorMatcher_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_DescriptorMatcher_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Affine3_open0_float_close0"]
        [::std::mem::size_of::<cv_Affine3>() - 64usize];
    ["Align of template specialization: cv_Affine3_open0_float_close0"]
        [::std::mem::align_of::<cv_Affine3>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Affine3_open0_double_close0"]
        [::std::mem::size_of::<cv_Affine3>() - 128usize];
    ["Align of template specialization: cv_Affine3_open0_double_close0"]
        [::std::mem::align_of::<cv_Affine3>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_FeatureDetector_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_FeatureDetector_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_FeatureDetector_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_FeatureDetector_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_map_open0_cv_String_cv_dnn_dnn4_v20191202_DictValue_std_less_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_std_allocator_open1_std_pair_open2_std_basic_string_open3_char_std_char_traits_open4_char_close4_std_allocator_open4_char_close4_close3_cv_dnn_dnn4_v20191202_DictValue_close2_close1_close0",
    ][::std::mem::size_of::<std_map>() - 48usize];
    [
        "Align of template specialization: std_map_open0_cv_String_cv_dnn_dnn4_v20191202_DictValue_std_less_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_std_allocator_open1_std_pair_open2_std_basic_string_open3_char_std_char_traits_open4_char_close4_std_allocator_open4_char_close4_close3_cv_dnn_dnn4_v20191202_DictValue_close2_close1_close0",
    ][::std::mem::align_of::<std_map>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_less_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_less>() - 1usize];
    [
        "Align of template specialization: std_less_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_less>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_pair_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_cv_dnn_dnn4_v20191202_DictValue_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_pair_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_cv_dnn_dnn4_v20191202_DictValue_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_pair_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_cv_dnn_dnn4_v20191202_DictValue_close0",
    ][::std::mem::size_of::<
        std_pair<std_basic_string<::std::os::raw::c_char>, cv_dnn_dnn4_v20191202_DictValue>,
    >() - 48usize];
    [
        "Align of template specialization: std_pair_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_cv_dnn_dnn4_v20191202_DictValue_close0",
    ][::std::mem::align_of::<
        std_pair<std_basic_string<::std::os::raw::c_char>, cv_dnn_dnn4_v20191202_DictValue>,
    >() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_dnn_dnn4_v20191202_MatShape_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_size_t_std_allocator_open1_unsigned_long_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_size_t_std_allocator_open1_unsigned_long_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_long_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_long_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_size_t_std_allocator_open1_unsigned_long_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_size_t_std_allocator_open1_unsigned_long_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_long_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_long_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_size_t_std_allocator_open1_unsigned_long_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_size_t_std_allocator_open1_unsigned_long_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_long_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_long_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_size_t_std_allocator_open1_unsigned_long_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_size_t_std_allocator_open1_unsigned_long_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_long_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_long_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_dnn_dnn4_v20191202_Net_Impl_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_dnn_dnn4_v20191202_Net_Impl_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_dnn_dnn4_v20191202_Model_Impl_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_dnn_dnn4_v20191202_Model_Impl_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::size_of::<cv_Point_<f32>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::align_of::<cv_Point_<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_map_open0_cv_String_cvflann_any_std_less_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_std_allocator_open1_std_pair_open2_std_basic_string_open3_char_std_char_traits_open4_char_close4_std_allocator_open4_char_close4_close3_cvflann_any_close2_close1_close0",
    ][::std::mem::size_of::<std_map>() - 48usize];
    [
        "Align of template specialization: std_map_open0_cv_String_cvflann_any_std_less_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_std_allocator_open1_std_pair_open2_std_basic_string_open3_char_std_char_traits_open4_char_close4_std_allocator_open4_char_close4_close3_cvflann_any_close2_close1_close0",
    ][::std::mem::align_of::<std_map>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_less_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_less>() - 1usize];
    [
        "Align of template specialization: std_less_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_less>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_pair_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_cvflann_any_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_pair_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_cvflann_any_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_pair_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_cvflann_any_close0",
    ][::std::mem::size_of::<std_pair<std_basic_string<::std::os::raw::c_char>, cvflann_any>>()
        - 48usize];
    [
        "Align of template specialization: std_pair_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_cvflann_any_close0",
    ][::std::mem::align_of::<std_pair<std_basic_string<::std::os::raw::c_char>, cvflann_any>>()
        - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_size_t_std_allocator_open1_unsigned_long_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_size_t_std_allocator_open1_unsigned_long_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_long_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_long_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_Matrix_open0_double_close0"]
        [::std::mem::size_of::<cvflann_Matrix<f64>>() - 32usize];
    ["Align of template specialization: cvflann_Matrix_open0_double_close0"]
        [::std::mem::align_of::<cvflann_Matrix<f64>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_Matrix_open0_double_close0"]
        [::std::mem::size_of::<cvflann_Matrix<f64>>() - 32usize];
    ["Align of template specialization: cvflann_Matrix_open0_double_close0"]
        [::std::mem::align_of::<cvflann_Matrix<f64>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_pair_open0_bool__std_size_t_close0"]
        [::std::mem::size_of::<std_pair<bool, usize>>() - 16usize];
    ["Align of template specialization: std_pair_open0_bool__std_size_t_close0"]
        [::std::mem::align_of::<std_pair<bool, usize>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_pair_open0_bool__std_size_t_close0"]
        [::std::mem::size_of::<std_pair<bool, usize>>() - 16usize];
    ["Align of template specialization: std_pair_open0_bool__std_size_t_close0"]
        [::std::mem::align_of::<std_pair<bool, usize>>() - 8usize];
};
pub type __hashtable = std__Hashtable<_RehashPolicy>;
pub type __hashtable = std__Hashtable<_RehashPolicy>;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cvflann_lsh_FeatureIndex_std_allocator_open1_unsigned_int_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cvflann_lsh_FeatureIndex_std_allocator_open1_unsigned_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_unsigned_int_std_allocator_open1_unsigned_int_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_unsigned_int_std_allocator_open1_unsigned_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_std_vector_open1_unsigned_int_std_allocator_open2_unsigned_int_close2_close1_std_allocator_open1_std_vector_open2_unsigned_int_std_allocator_open3_unsigned_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_std_vector_open1_unsigned_int_std_allocator_open2_unsigned_int_close2_close1_std_allocator_open1_std_vector_open2_unsigned_int_std_allocator_open3_unsigned_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_unsigned_int_std_allocator_open1_unsigned_int_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_unsigned_int_std_allocator_open1_unsigned_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_unsigned_int_std_allocator_open2_unsigned_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_unsigned_int_std_allocator_open2_unsigned_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_unsigned_int_std_allocator_open1_unsigned_int_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_unsigned_int_std_allocator_open1_unsigned_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_unordered_map_open0_cvflann_lsh_BucketKey_cvflann_lsh_Bucket_std_hash_open1_unsigned_int_close1_std_equal_to_open1_unsigned_int_close1_std_allocator_open1_std_pair_open2_const_unsigned_int_std_vector_open3_unsigned_int_std_allocator_open4_unsigned_int_close4_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_unordered_map>() - 56usize];
    [
        "Align of template specialization: std_unordered_map_open0_cvflann_lsh_BucketKey_cvflann_lsh_Bucket_std_hash_open1_unsigned_int_close1_std_equal_to_open1_unsigned_int_close1_std_allocator_open1_std_pair_open2_const_unsigned_int_std_vector_open3_unsigned_int_std_allocator_open4_unsigned_int_close4_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_unordered_map>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_hash_open0_unsigned_int_close0"]
        [::std::mem::size_of::<std_hash>() - 1usize];
    ["Align of template specialization: std_hash_open0_unsigned_int_close0"]
        [::std::mem::align_of::<std_hash>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_equal_to_open0_unsigned_int_close0"]
        [::std::mem::size_of::<std_equal_to>() - 1usize];
    ["Align of template specialization: std_equal_to_open0_unsigned_int_close0"]
        [::std::mem::align_of::<std_equal_to>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_pair_open1_const_unsigned_int_std_vector_open2_unsigned_int_std_allocator_open3_unsigned_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_pair_open1_const_unsigned_int_std_vector_open2_unsigned_int_std_allocator_open3_unsigned_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_pair_open0_const_unsigned_int_std_vector_open1_unsigned_int_std_allocator_open2_unsigned_int_close2_close1_close0",
    ][::std::mem::size_of::<std_pair<::std::os::raw::c_uint, std_vector>>() - 32usize];
    [
        "Align of template specialization: std_pair_open0_const_unsigned_int_std_vector_open1_unsigned_int_std_allocator_open2_unsigned_int_close2_close1_close0",
    ][::std::mem::align_of::<std_pair<::std::os::raw::c_uint, std_vector>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_unsigned_int_std_allocator_open1_unsigned_int_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_unsigned_int_std_allocator_open1_unsigned_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cvflann_lsh_Bucket_std_allocator_open1_std_vector_open2_unsigned_int_std_allocator_open3_unsigned_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cvflann_lsh_Bucket_std_allocator_open1_std_vector_open2_unsigned_int_std_allocator_open3_unsigned_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_unsigned_int_std_allocator_open2_unsigned_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_unsigned_int_std_allocator_open2_unsigned_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_unsigned_int_std_allocator_open1_unsigned_int_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_unsigned_int_std_allocator_open1_unsigned_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_size_t_std_allocator_open1_unsigned_long_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_size_t_std_allocator_open1_unsigned_long_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_long_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_long_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_pair_open0_float_unsigned_int_close0"]
        [::std::mem::size_of::<std_pair<f32, ::std::os::raw::c_uint>>() - 8usize];
    ["Align of template specialization: std_pair_open0_float_unsigned_int_close0"]
        [::std::mem::align_of::<std_pair<f32, ::std::os::raw::c_uint>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cvflann_lsh_BucketKey_std_allocator_open1_unsigned_int_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cvflann_lsh_BucketKey_std_allocator_open1_unsigned_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cvflann_Matrix_open0_int_close0"]
        [::std::mem::size_of::<cvflann_Matrix<::std::os::raw::c_int>>() - 32usize];
    ["Align of template specialization: cvflann_Matrix_open0_int_close0"]
        [::std::mem::align_of::<cvflann_Matrix<::std::os::raw::c_int>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_CvCapture_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_CvCapture_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_IVideoCapture_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_IVideoCapture_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_CvVideoWriter_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_CvVideoWriter_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_IVideoWriter_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_IVideoWriter_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_IVideoWriter_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_IVideoWriter_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::size_of::<cv_Point_<f32>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::align_of::<cv_Point_<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::size_of::<cv_Point_<f32>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::align_of::<cv_Point_<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point__open1_float_close1_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point__open1_float_close1_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::size_of::<cv_Point_<f32>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::align_of::<cv_Point_<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::size_of::<cv_Point_<f32>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::align_of::<cv_Point_<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::size_of::<cv_Point_<f32>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::align_of::<cv_Point_<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Subdiv2D_Vertex_std_allocator_open1_cv_Subdiv2D_Vertex_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Subdiv2D_Vertex_std_allocator_open1_cv_Subdiv2D_Vertex_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Subdiv2D_Vertex_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Subdiv2D_Vertex_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Subdiv2D_QuadEdge_std_allocator_open1_cv_Subdiv2D_QuadEdge_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Subdiv2D_QuadEdge_std_allocator_open1_cv_Subdiv2D_QuadEdge_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Subdiv2D_QuadEdge_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Subdiv2D_QuadEdge_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_float_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_float_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_double_close0"]
        [::std::mem::size_of::<cv_Point_<f64>>() - 16usize];
    ["Align of template specialization: cv_Point__open0_double_close0"]
        [::std::mem::align_of::<cv_Point_<f64>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_ml_ParamGrid_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_ml_ParamGrid_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_ml_ParamGrid_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_ml_ParamGrid_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_ml_ParamGrid_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_ml_ParamGrid_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_ml_ParamGrid_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_ml_ParamGrid_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_ml_ParamGrid_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_ml_ParamGrid_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_ml_ParamGrid_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_ml_ParamGrid_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_ml_ParamGrid_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_ml_ParamGrid_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_ml_ParamGrid_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_ml_ParamGrid_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_BaseCascadeClassifier_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_BaseCascadeClassifier_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_QRCodeDetector_Impl_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_QRCodeDetector_Impl_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_DetectionBasedTracker_IDetector_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_DetectionBasedTracker_IDetector_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_DetectionBasedTracker_IDetector_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_DetectionBasedTracker_IDetector_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cv_Ptr_open0_cv_DetectionBasedTracker_SeparateDetectionWork_close0",
    ][::std::mem::size_of::<cv_Ptr>() - 16usize];
    [
        "Align of template specialization: cv_Ptr_open0_cv_DetectionBasedTracker_SeparateDetectionWork_close0",
    ][::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DetectionBasedTracker_TrackedObject_std_allocator_open1_cv_DetectionBasedTracker_TrackedObject_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DetectionBasedTracker_TrackedObject_std_allocator_open1_cv_DetectionBasedTracker_TrackedObject_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_cv_DetectionBasedTracker_TrackedObject_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_cv_DetectionBasedTracker_TrackedObject_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_DetectionBasedTracker_IDetector_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_DetectionBasedTracker_IDetector_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Rect_std_allocator_open1_cv_Rect__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Rect__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::size_of::<cv_Rect_<::std::os::raw::c_int>>() - 16usize];
    ["Align of template specialization: cv_Rect__open0_int_close0"]
        [::std::mem::align_of::<cv_Rect_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_ThinPlateSplineShapeTransformer_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_ThinPlateSplineShapeTransformer_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_HistogramCostExtractor_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_HistogramCostExtractor_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_HistogramCostExtractor_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_HistogramCostExtractor_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_HistogramCostExtractor_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_HistogramCostExtractor_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_HistogramCostExtractor_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_HistogramCostExtractor_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_HistogramCostExtractor_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_HistogramCostExtractor_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_HistogramCostExtractor_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_HistogramCostExtractor_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_ShapeTransformer_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_ShapeTransformer_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_ShapeTransformer_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_ShapeTransformer_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_HistogramCostExtractor_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_HistogramCostExtractor_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_ShapeTransformer_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_ShapeTransformer_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_cuda_GpuMat_Allocator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_cuda_GpuMat_Allocator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_cuda_GpuMat_Allocator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_cuda_GpuMat_Allocator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_cuda_GpuMat_Allocator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_cuda_GpuMat_Allocator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_cuda_Stream_Impl_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_cuda_Stream_Impl_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_cuda_Stream_Impl_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_cuda_Stream_Impl_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_cuda_Event_Impl_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_cuda_Event_Impl_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_cuda_Event_Impl_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_cuda_Event_Impl_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_cuda_Stream_Impl_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_cuda_Stream_Impl_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_cuda_Event_Impl_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_cuda_Event_Impl_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_PlaneProjector_close0",
    ][::std::mem::size_of::<cv_detail_RotationWarperBase<cv_detail_PlaneProjector>>() - 168usize];
    [
        "Align of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_PlaneProjector_close0",
    ][::std::mem::align_of::<cv_detail_RotationWarperBase<cv_detail_PlaneProjector>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_SphericalProjector_close0",
    ][::std::mem::size_of::<cv_detail_RotationWarperBase<cv_detail_SphericalProjector>>()
        - 168usize];
    [
        "Align of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_SphericalProjector_close0",
    ][::std::mem::align_of::<cv_detail_RotationWarperBase<cv_detail_SphericalProjector>>()
        - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_CylindricalProjector_close0",
    ][::std::mem::size_of::<cv_detail_RotationWarperBase<cv_detail_CylindricalProjector>>()
        - 168usize];
    [
        "Align of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_CylindricalProjector_close0",
    ][::std::mem::align_of::<cv_detail_RotationWarperBase<cv_detail_CylindricalProjector>>()
        - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_FisheyeProjector_close0",
    ][::std::mem::size_of::<cv_detail_RotationWarperBase<cv_detail_FisheyeProjector>>() - 168usize];
    [
        "Align of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_FisheyeProjector_close0",
    ][::std::mem::align_of::<cv_detail_RotationWarperBase<cv_detail_FisheyeProjector>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_StereographicProjector_close0",
    ][::std::mem::size_of::<cv_detail_RotationWarperBase<cv_detail_StereographicProjector>>()
        - 168usize];
    [
        "Align of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_StereographicProjector_close0",
    ][::std::mem::align_of::<cv_detail_RotationWarperBase<cv_detail_StereographicProjector>>()
        - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_CompressedRectilinearProjector_close0",
    ][::std::mem::size_of::<cv_detail_RotationWarperBase<cv_detail_CompressedRectilinearProjector>>(
    ) - 176usize];
    [
        "Align of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_CompressedRectilinearProjector_close0",
    ][::std::mem::align_of::<cv_detail_RotationWarperBase<cv_detail_CompressedRectilinearProjector>>(
    ) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_CompressedRectilinearPortraitProjector_close0",
    ][::std::mem::size_of::<
        cv_detail_RotationWarperBase<cv_detail_CompressedRectilinearPortraitProjector>,
    >() - 176usize];
    [
        "Align of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_CompressedRectilinearPortraitProjector_close0",
    ][::std::mem::align_of::<
        cv_detail_RotationWarperBase<cv_detail_CompressedRectilinearPortraitProjector>,
    >() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_PaniniProjector_close0",
    ][::std::mem::size_of::<cv_detail_RotationWarperBase<cv_detail_PaniniProjector>>() - 176usize];
    [
        "Align of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_PaniniProjector_close0",
    ][::std::mem::align_of::<cv_detail_RotationWarperBase<cv_detail_PaniniProjector>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_PaniniPortraitProjector_close0",
    ][::std::mem::size_of::<cv_detail_RotationWarperBase<cv_detail_PaniniPortraitProjector>>()
        - 176usize];
    [
        "Align of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_PaniniPortraitProjector_close0",
    ][::std::mem::align_of::<cv_detail_RotationWarperBase<cv_detail_PaniniPortraitProjector>>()
        - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_MercatorProjector_close0",
    ][::std::mem::size_of::<cv_detail_RotationWarperBase<cv_detail_MercatorProjector>>()
        - 168usize];
    [
        "Align of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_MercatorProjector_close0",
    ][::std::mem::align_of::<cv_detail_RotationWarperBase<cv_detail_MercatorProjector>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_TransverseMercatorProjector_close0",
    ][::std::mem::size_of::<cv_detail_RotationWarperBase<cv_detail_TransverseMercatorProjector>>()
        - 168usize];
    [
        "Align of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_TransverseMercatorProjector_close0",
    ][::std::mem::align_of::<cv_detail_RotationWarperBase<cv_detail_TransverseMercatorProjector>>(
    ) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_SphericalPortraitProjector_close0",
    ][::std::mem::size_of::<cv_detail_RotationWarperBase<cv_detail_SphericalPortraitProjector>>()
        - 168usize];
    [
        "Align of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_SphericalPortraitProjector_close0",
    ][::std::mem::align_of::<cv_detail_RotationWarperBase<cv_detail_SphericalPortraitProjector>>()
        - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_CylindricalPortraitProjector_close0",
    ][::std::mem::size_of::<cv_detail_RotationWarperBase<cv_detail_CylindricalPortraitProjector>>(
    ) - 168usize];
    [
        "Align of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_CylindricalPortraitProjector_close0",
    ][::std::mem::align_of::<cv_detail_RotationWarperBase<cv_detail_CylindricalPortraitProjector>>(
    ) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_PlanePortraitProjector_close0",
    ][::std::mem::size_of::<cv_detail_RotationWarperBase<cv_detail_PlanePortraitProjector>>()
        - 168usize];
    [
        "Align of template specialization: cv_detail_RotationWarperBase_open0_cv_detail_PlanePortraitProjector_close0",
    ][::std::mem::align_of::<cv_detail_RotationWarperBase<cv_detail_PlanePortraitProjector>>()
        - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_RotationWarper_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_Feature2D_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_Feature2D_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_ImageFeatures_std_allocator_open1_cv_detail_ImageFeatures_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_ImageFeatures_std_allocator_open1_cv_detail_ImageFeatures_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_ImageFeatures_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_ImageFeatures_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_Feature2D_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_Feature2D_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_DMatch_std_allocator_open1_cv_DMatch_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_DMatch_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_FeaturesMatcher_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_FeaturesMatcher_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_std_list_open1_cv_detail_GraphEdge_std_allocator_open2_cv_detail_GraphEdge_close2_close1_std_allocator_open1_std_list_open2_cv_detail_GraphEdge_std_allocator_open3_cv_detail_GraphEdge_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_std_list_open1_cv_detail_GraphEdge_std_allocator_open2_cv_detail_GraphEdge_close2_close1_std_allocator_open1_std_list_open2_cv_detail_GraphEdge_std_allocator_open3_cv_detail_GraphEdge_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_list_open0_cv_detail_GraphEdge_std_allocator_open1_cv_detail_GraphEdge_close1_close0",
    ][::std::mem::size_of::<std_list>() - 24usize];
    [
        "Align of template specialization: std_list_open0_cv_detail_GraphEdge_std_allocator_open1_cv_detail_GraphEdge_close1_close0",
    ][::std::mem::align_of::<std_list>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_GraphEdge_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_GraphEdge_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_list_open1_cv_detail_GraphEdge_std_allocator_open2_cv_detail_GraphEdge_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_list_open1_cv_detail_GraphEdge_std_allocator_open2_cv_detail_GraphEdge_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_list_open0_cv_detail_GraphEdge_std_allocator_open1_cv_detail_GraphEdge_close1_close0",
    ][::std::mem::size_of::<std_list>() - 24usize];
    [
        "Align of template specialization: std_list_open0_cv_detail_GraphEdge_std_allocator_open1_cv_detail_GraphEdge_close1_close0",
    ][::std::mem::align_of::<std_list>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_GraphEdge_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_GraphEdge_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Size_std_allocator_open1_cv_Size__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Size_std_allocator_open1_cv_Size__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Size__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Size__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Size__open0_int_close0"]
        [::std::mem::size_of::<cv_Size_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Size__open0_int_close0"]
        [::std::mem::align_of::<cv_Size_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Size_std_allocator_open1_cv_Size__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Size_std_allocator_open1_cv_Size__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Size__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Size__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Size__open0_int_close0"]
        [::std::mem::size_of::<cv_Size_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Size__open0_int_close0"]
        [::std::mem::align_of::<cv_Size_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_ImageFeatures_std_allocator_open1_cv_detail_ImageFeatures_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_ImageFeatures_std_allocator_open1_cv_detail_ImageFeatures_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_ImageFeatures_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_ImageFeatures_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_MatchesInfo_std_allocator_open1_cv_detail_MatchesInfo_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_MatchesInfo_std_allocator_open1_cv_detail_MatchesInfo_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_MatchesInfo_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_MatchesInfo_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_ImageFeatures_std_allocator_open1_cv_detail_ImageFeatures_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_ImageFeatures_std_allocator_open1_cv_detail_ImageFeatures_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_ImageFeatures_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_ImageFeatures_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_MatchesInfo_std_allocator_open1_cv_detail_MatchesInfo_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_MatchesInfo_std_allocator_open1_cv_detail_MatchesInfo_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_MatchesInfo_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_MatchesInfo_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_ImageFeatures_std_allocator_open1_cv_detail_ImageFeatures_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_ImageFeatures_std_allocator_open1_cv_detail_ImageFeatures_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_ImageFeatures_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_ImageFeatures_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_MatchesInfo_std_allocator_open1_cv_detail_MatchesInfo_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_MatchesInfo_std_allocator_open1_cv_detail_MatchesInfo_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_MatchesInfo_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_MatchesInfo_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_ImageFeatures_std_allocator_open1_cv_detail_ImageFeatures_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_ImageFeatures_std_allocator_open1_cv_detail_ImageFeatures_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_ImageFeatures_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_ImageFeatures_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_MatchesInfo_std_allocator_open1_cv_detail_MatchesInfo_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_MatchesInfo_std_allocator_open1_cv_detail_MatchesInfo_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_MatchesInfo_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_MatchesInfo_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_std_pair_open1_int_int_close1_std_allocator_open1_std_pair_open2_int_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_std_pair_open1_int_int_close1_std_allocator_open1_std_pair_open2_int_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::size_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::align_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_std_pair_open1_int_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_std_pair_open1_int_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::size_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::align_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_ImageFeatures_std_allocator_open1_cv_detail_ImageFeatures_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_ImageFeatures_std_allocator_open1_cv_detail_ImageFeatures_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_ImageFeatures_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_ImageFeatures_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_MatchesInfo_std_allocator_open1_cv_detail_MatchesInfo_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_MatchesInfo_std_allocator_open1_cv_detail_MatchesInfo_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_MatchesInfo_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_MatchesInfo_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_String_std_allocator_open1_std_basic_string_open2_char_std_char_traits_open3_char_close3_std_allocator_open3_char_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_basic_string_open1_char_std_char_traits_open2_char_close2_std_allocator_open2_char_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>() - 32usize];
    [
        "Align of template specialization: std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0",
    ][::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_MatchesInfo_std_allocator_open1_cv_detail_MatchesInfo_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_MatchesInfo_std_allocator_open1_cv_detail_MatchesInfo_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_MatchesInfo_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_MatchesInfo_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_ImageFeatures_std_allocator_open1_cv_detail_ImageFeatures_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_ImageFeatures_std_allocator_open1_cv_detail_ImageFeatures_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_ImageFeatures_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_ImageFeatures_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_MatchesInfo_std_allocator_open1_cv_detail_MatchesInfo_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_MatchesInfo_std_allocator_open1_cv_detail_MatchesInfo_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_MatchesInfo_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_MatchesInfo_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_MatchesInfo_std_allocator_open1_cv_detail_MatchesInfo_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_MatchesInfo_std_allocator_open1_cv_detail_MatchesInfo_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_MatchesInfo_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_MatchesInfo_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_ExposureCompensator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_ExposureCompensator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_double_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_double_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Scalar_std_allocator_open1_cv_Scalar__open2_double_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Scalar_std_allocator_open1_cv_Scalar__open2_double_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Scalar__open1_double_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Scalar__open1_double_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Scalar__open0_double_close0"]
        [::std::mem::size_of::<cv_Scalar_>() - 32usize];
    ["Align of template specialization: cv_Scalar__open0_double_close0"]
        [::std::mem::align_of::<cv_Scalar_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Scalar_std_allocator_open1_cv_Scalar__open2_double_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Scalar_std_allocator_open1_cv_Scalar__open2_double_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Scalar__open1_double_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Scalar__open1_double_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Scalar__open0_double_close0"]
        [::std::mem::size_of::<cv_Scalar_>() - 32usize];
    ["Align of template specialization: cv_Scalar__open0_double_close0"]
        [::std::mem::align_of::<cv_Scalar_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_SeamFinder_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_SeamFinder_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Size_std_allocator_open1_cv_Size__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Size_std_allocator_open1_cv_Size__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Size__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Size__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Size__open0_int_close0"]
        [::std::mem::size_of::<cv_Size_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Size__open0_int_close0"]
        [::std::mem::align_of::<cv_Size_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Size_std_allocator_open1_cv_Size__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Size_std_allocator_open1_cv_Size__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Size__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Size__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Size__open0_int_close0"]
        [::std::mem::size_of::<cv_Size_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Size__open0_int_close0"]
        [::std::mem::align_of::<cv_Size_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_int_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_int_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_DpSeamFinder_ComponentState_std_allocator_open1_cv_detail_DpSeamFinder_ComponentState_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_DpSeamFinder_ComponentState_std_allocator_open1_cv_detail_DpSeamFinder_ComponentState_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_cv_detail_DpSeamFinder_ComponentState_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_cv_detail_DpSeamFinder_ComponentState_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_std_vector_open1_cv_Point_std_allocator_open2_cv_Point__open3_int_close3_close2_close1_std_allocator_open1_std_vector_open2_cv_Point__open3_int_close3_std_allocator_open3_cv_Point__open4_int_close4_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_std_vector_open1_cv_Point_std_allocator_open2_cv_Point__open3_int_close3_close2_close1_std_allocator_open1_std_vector_open2_cv_Point__open3_int_close3_std_allocator_open3_cv_Point__open4_int_close4_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_cv_Point__open2_int_close2_std_allocator_open2_cv_Point__open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_cv_Point__open2_int_close2_std_allocator_open2_cv_Point__open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point__open1_int_close1_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point__open1_int_close1_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_set_open0_std_pair_open1_int_int_close1_std_less_open1_std_pair_open2_int_int_close2_close1_std_allocator_open1_std_pair_open2_int_int_close2_close1_close0",
    ][::std::mem::size_of::<std_set>() - 48usize];
    [
        "Align of template specialization: std_set_open0_std_pair_open1_int_int_close1_std_less_open1_std_pair_open2_int_int_close2_close1_std_allocator_open1_std_pair_open2_int_int_close2_close1_close0",
    ][::std::mem::align_of::<std_set>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::size_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::align_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_less_open0_std_pair_open1_int_int_close1_close0"]
        [::std::mem::size_of::<std_less>() - 1usize];
    ["Align of template specialization: std_less_open0_std_pair_open1_int_int_close1_close0"]
        [::std::mem::align_of::<std_less>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::size_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::align_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_std_pair_open1_int_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_std_pair_open1_int_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::size_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::align_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_PairwiseSeamFinder_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_PairwiseSeamFinder_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_Blender_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_Blender_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Size_std_allocator_open1_cv_Size__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Size_std_allocator_open1_cv_Size__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Size__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Size__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Size__open0_int_close0"]
        [::std::mem::size_of::<cv_Size_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Size__open0_int_close0"]
        [::std::mem::align_of::<cv_Size_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point_std_allocator_open1_cv_Point__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::size_of::<cv_Point_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_int_close0"]
        [::std::mem::align_of::<cv_Point_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_Feature2D_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_Feature2D_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_Feature2D_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_Feature2D_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_Feature2D_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_Feature2D_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_FeaturesMatcher_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_FeaturesMatcher_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_FeaturesMatcher_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_FeaturesMatcher_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_FeaturesMatcher_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_FeaturesMatcher_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_BundleAdjusterBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_BundleAdjusterBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_BundleAdjusterBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_BundleAdjusterBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_BundleAdjusterBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_BundleAdjusterBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_Estimator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_Estimator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_Estimator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_Estimator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_Estimator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_Estimator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_WarperCreator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_WarperCreator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_WarperCreator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_WarperCreator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_WarperCreator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_WarperCreator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_ExposureCompensator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_ExposureCompensator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_ExposureCompensator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_ExposureCompensator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_ExposureCompensator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_ExposureCompensator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_SeamFinder_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_SeamFinder_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_SeamFinder_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_SeamFinder_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_SeamFinder_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_SeamFinder_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_Blender_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_Blender_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_Blender_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_Blender_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_Blender_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_Blender_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_Feature2D_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_Feature2D_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_FeaturesMatcher_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_FeaturesMatcher_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_BundleAdjusterBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_BundleAdjusterBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_Estimator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_Estimator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_WarperCreator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_WarperCreator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_ExposureCompensator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_ExposureCompensator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_SeamFinder_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_SeamFinder_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_detail_Blender_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_detail_Blender_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Size_std_allocator_open1_cv_Size__open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Size_std_allocator_open1_cv_Size__open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Size__open1_int_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Size__open1_int_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Size__open0_int_close0"]
        [::std::mem::size_of::<cv_Size_<::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: cv_Size__open0_int_close0"]
        [::std::mem::align_of::<cv_Size_<::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_ImageFeatures_std_allocator_open1_cv_detail_ImageFeatures_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_ImageFeatures_std_allocator_open1_cv_detail_ImageFeatures_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_ImageFeatures_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_ImageFeatures_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_MatchesInfo_std_allocator_open1_cv_detail_MatchesInfo_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_MatchesInfo_std_allocator_open1_cv_detail_MatchesInfo_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_MatchesInfo_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_MatchesInfo_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_UMat_std_allocator_open1_cv_UMat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_UMat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_detail_CameraParams_std_allocator_open1_cv_detail_CameraParams_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_detail_CameraParams_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_superres_FrameSource_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_superres_FrameSource_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_superres_FrameSource_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_superres_FrameSource_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_superres_FrameSource_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_superres_FrameSource_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_superres_FrameSource_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_superres_FrameSource_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_superres_FrameSource_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_superres_FrameSource_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_superres_FrameSource_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_superres_FrameSource_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_superres_FrameSource_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_superres_FrameSource_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_superres_FrameSource_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_superres_FrameSource_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___basic_file_open0_char_close0"]
        [::std::mem::size_of::<std___basic_file>() - 16usize];
    ["Align of template specialization: std___basic_file_open0_char_close0"]
        [::std::mem::align_of::<std___basic_file>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_char_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::size_of::<std_char_traits>() - 1usize];
    ["Align of template specialization: std_char_traits_open0_wchar_t_close0"]
        [::std::mem::align_of::<std_char_traits>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_videostab_TranslationBasedLocalOutlierRejector_Cell_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_videostab_TranslationBasedLocalOutlierRejector_Cell_std_allocator_open1_std_vector_open2_int_std_allocator_open3_int_close3_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_std_vector_open1_int_std_allocator_open2_int_close2_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_ImageMotionEstimatorBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_ImageMotionEstimatorBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_ImageMotionEstimatorBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_ImageMotionEstimatorBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_MotionEstimatorBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_MotionEstimatorBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_FeatureDetector_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_FeatureDetector_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_FeatureDetector_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_FeatureDetector_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_ISparseOptFlowEstimator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_ISparseOptFlowEstimator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_ISparseOptFlowEstimator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_ISparseOptFlowEstimator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_IOutlierRejector_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_IOutlierRejector_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_IOutlierRejector_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_IOutlierRejector_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_MotionEstimatorBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_MotionEstimatorBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_FeatureDetector_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_FeatureDetector_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_ISparseOptFlowEstimator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_ISparseOptFlowEstimator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_IOutlierRejector_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_IOutlierRejector_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_uchar_std_allocator_open1_unsigned_char_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_unsigned_char_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_KeyPoint_std_allocator_open1_cv_KeyPoint_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_KeyPoint_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::size_of::<cv_Point_<f32>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::align_of::<cv_Point_<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::size_of::<cv_Point_<f32>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::align_of::<cv_Point_<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::size_of::<cv_Point_<f32>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::align_of::<cv_Point_<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Point2f_std_allocator_open1_cv_Point__open2_float_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Point__open1_float_close1_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::size_of::<cv_Point_<f32>>() - 8usize];
    ["Align of template specialization: cv_Point__open0_float_close0"]
        [::std::mem::align_of::<cv_Point_<f32>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::size_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::align_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_IMotionStabilizer_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_IMotionStabilizer_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::size_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::align_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Ptr_open1_cv_videostab_IMotionStabilizer_close1_std_allocator_open1_cv_Ptr_open2_cv_videostab_IMotionStabilizer_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Ptr_open1_cv_videostab_IMotionStabilizer_close1_std_allocator_open1_cv_Ptr_open2_cv_videostab_IMotionStabilizer_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_IMotionStabilizer_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_IMotionStabilizer_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_cv_Ptr_open1_cv_videostab_IMotionStabilizer_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_cv_Ptr_open1_cv_videostab_IMotionStabilizer_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_IMotionStabilizer_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_IMotionStabilizer_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::size_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::align_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::size_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::align_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::size_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::align_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::size_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 8usize];
    ["Align of template specialization: std_pair_open0_int_int_close0"]
        [::std::mem::align_of::<std_pair<::std::os::raw::c_int, ::std::os::raw::c_int>>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0"]
        [::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_int_std_allocator_open1_int_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_int_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_double_std_allocator_open1_double_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_double_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_IFrameSource_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_IFrameSource_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_IFrameSource_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_IFrameSource_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_IFrameSource_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_IFrameSource_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_int_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_int_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_videostab_FastMarchingMethod_DXY_std_allocator_open1_cv_videostab_FastMarchingMethod_DXY_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_videostab_FastMarchingMethod_DXY_std_allocator_open1_cv_videostab_FastMarchingMethod_DXY_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_cv_videostab_FastMarchingMethod_DXY_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_cv_videostab_FastMarchingMethod_DXY_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_InpainterBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_InpainterBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Ptr_open1_cv_videostab_InpainterBase_close1_std_allocator_open1_cv_Ptr_open2_cv_videostab_InpainterBase_close2_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Ptr_open1_cv_videostab_InpainterBase_close1_std_allocator_open1_cv_Ptr_open2_cv_videostab_InpainterBase_close2_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_InpainterBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_InpainterBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_allocator_open0_cv_Ptr_open1_cv_videostab_InpainterBase_close1_close0",
    ][::std::mem::size_of::<std_allocator>() - 1usize];
    [
        "Align of template specialization: std_allocator_open0_cv_Ptr_open1_cv_videostab_InpainterBase_close1_close0",
    ][::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_InpainterBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_InpainterBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_IDenseOptFlowEstimator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_IDenseOptFlowEstimator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_IDenseOptFlowEstimator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_IDenseOptFlowEstimator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_IDenseOptFlowEstimator_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_IDenseOptFlowEstimator_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_uchar_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_ImageMotionEstimatorBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_ImageMotionEstimatorBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_ImageMotionEstimatorBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_ImageMotionEstimatorBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_ImageMotionEstimatorBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_ImageMotionEstimatorBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::size_of::<cv_Mat_>() - 96usize];
    ["Align of template specialization: cv_Mat__open0_float_close0"]
        [::std::mem::align_of::<cv_Mat_>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_ILog_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_ILog_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_ILog_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_ILog_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_IFrameSource_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_IFrameSource_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_IFrameSource_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_IFrameSource_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_IFrameSource_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_IFrameSource_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_IFrameSource_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_IFrameSource_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_ImageMotionEstimatorBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_ImageMotionEstimatorBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_ImageMotionEstimatorBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_ImageMotionEstimatorBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_DeblurerBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_DeblurerBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_DeblurerBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_DeblurerBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_InpainterBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_InpainterBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_InpainterBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_InpainterBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_ILog_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_ILog_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_IFrameSource_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_IFrameSource_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_IFrameSource_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_IFrameSource_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_ImageMotionEstimatorBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_ImageMotionEstimatorBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_DeblurerBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_DeblurerBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_InpainterBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_InpainterBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_float_std_allocator_open1_float_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_float_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_MotionFilterBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_MotionFilterBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_MotionFilterBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_MotionFilterBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_MotionFilterBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_MotionFilterBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_IMotionStabilizer_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_IMotionStabilizer_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_IMotionStabilizer_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_IMotionStabilizer_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_WobbleSuppressorBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_WobbleSuppressorBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_WobbleSuppressorBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_WobbleSuppressorBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_IMotionStabilizer_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_IMotionStabilizer_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: cv_Ptr_open0_cv_videostab_WobbleSuppressorBase_close0"]
        [::std::mem::size_of::<cv_Ptr>() - 16usize];
    ["Align of template specialization: cv_Ptr_open0_cv_videostab_WobbleSuppressorBase_close0"]
        [::std::mem::align_of::<cv_Ptr>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::size_of::<std_vector>() - 24usize];
    [
        "Align of template specialization: std_vector_open0_cv_Mat_std_allocator_open1_cv_Mat_close1_close0",
    ][::std::mem::align_of::<std_vector>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::size_of::<std_allocator>() - 1usize];
    ["Align of template specialization: std_allocator_open0_cv_Mat_close0"]
        [::std::mem::align_of::<std_allocator>() - 1usize];
};
